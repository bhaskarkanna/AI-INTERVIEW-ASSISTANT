"use client";


import { __commonJS, __toESM } from "./chunk-DlTWrutj.js";
import { require_react } from "./react-DXSWNJ4X.js";
import { require_classnames, require_react_is } from "./react-is-BYdZOess.js";
import { require_react_dom } from "./react-dom-BSDLvsA1.js";

//#region node_modules/@babel/runtime/helpers/esm/extends.js
var import_classnames$279 = /* @__PURE__ */ __toESM(require_classnames());
var import_react = /* @__PURE__ */ __toESM(require_react());
function _extends() {
	return _extends = Object.assign ? Object.assign.bind() : function(n$1) {
		for (var e$2 = 1; e$2 < arguments.length; e$2++) {
			var t$1 = arguments[e$2];
			for (var r$1 in t$1) ({}).hasOwnProperty.call(t$1, r$1) && (n$1[r$1] = t$1[r$1]);
		}
		return n$1;
	}, _extends.apply(null, arguments);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o$2) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$3) {
		return typeof o$3;
	} : function(o$3) {
		return o$3 && "function" == typeof Symbol && o$3.constructor === Symbol && o$3 !== Symbol.prototype ? "symbol" : typeof o$3;
	}, _typeof(o$2);
}

//#endregion
//#region node_modules/rc-util/es/React/isFragment.js
var REACT_ELEMENT_TYPE_18 = Symbol.for("react.element");
var REACT_ELEMENT_TYPE_19 = Symbol.for("react.transitional.element");
var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
/**
* Compatible with React 18 or 19 to check if node is a Fragment.
*/
function isFragment$1(object$1) {
	return object$1 && _typeof(object$1) === "object" && (object$1.$$typeof === REACT_ELEMENT_TYPE_18 || object$1.$$typeof === REACT_ELEMENT_TYPE_19) && object$1.type === REACT_FRAGMENT_TYPE;
}

//#endregion
//#region node_modules/rc-util/es/Children/toArray.js
function toArray(children) {
	var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var ret = [];
	import_react.Children.forEach(children, function(child) {
		if ((child === void 0 || child === null) && !option.keepEmpty) return;
		if (Array.isArray(child)) ret = ret.concat(toArray(child));
		else if (isFragment$1(child) && child.props) ret = ret.concat(toArray(child.props.children, option));
		else ret.push(child);
	});
	return ret;
}

//#endregion
//#region node_modules/rc-util/es/warning.js
var warned = {};
var preWarningFns = [];
/**
* Pre warning enable you to parse content before console.error.
* Modify to null will prevent warning.
*/
var preMessage = function preMessage$1(fn) {
	preWarningFns.push(fn);
};
/**
* Warning if condition not match.
* @param valid Condition
* @param message Warning message
* @example
* ```js
* warning(false, 'some error'); // print some error
* warning(true, 'some error'); // print nothing
* warning(1 === 2, 'some error'); // print some error
* ```
*/
function warning(valid, message$1) {
	if (!valid && console !== void 0) {
		var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
			return preMessageFn(msg !== null && msg !== void 0 ? msg : "", "warning");
		}, message$1);
		if (finalMessage) console.error("Warning: ".concat(finalMessage));
	}
}
/** @see Similar to {@link warning} */
function note(valid, message$1) {
	if (!valid && console !== void 0) {
		var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
			return preMessageFn(msg !== null && msg !== void 0 ? msg : "", "note");
		}, message$1);
		if (finalMessage) console.warn("Note: ".concat(finalMessage));
	}
}
function resetWarned() {
	warned = {};
}
function call(method$1, valid, message$1) {
	if (!valid && !warned[message$1]) {
		method$1(false, message$1);
		warned[message$1] = true;
	}
}
/** @see Same as {@link warning}, but only warn once for the same message */
function warningOnce(valid, message$1) {
	call(warning, valid, message$1);
}
/** @see Same as {@link warning}, but only warn once for the same message */
function noteOnce(valid, message$1) {
	call(note, valid, message$1);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
var warning_default = warningOnce;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t$1, r$1) {
	if ("object" != _typeof(t$1) || !t$1) return t$1;
	var e$2 = t$1[Symbol.toPrimitive];
	if (void 0 !== e$2) {
		var i = e$2.call(t$1, r$1 || "default");
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t$1) {
	var i = toPrimitive(t$1, "string");
	return "symbol" == _typeof(i) ? i : i + "";
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e$2, r$1, t$1) {
	return (r$1 = toPropertyKey(r$1)) in e$2 ? Object.defineProperty(e$2, r$1, {
		value: t$1,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e$2[r$1] = t$1, e$2;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e$2, r$1) {
	var t$1 = Object.keys(e$2);
	if (Object.getOwnPropertySymbols) {
		var o$2 = Object.getOwnPropertySymbols(e$2);
		r$1 && (o$2 = o$2.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$2, r$2).enumerable;
		})), t$1.push.apply(t$1, o$2);
	}
	return t$1;
}
function _objectSpread2(e$2) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$1 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys(Object(t$1), !0).forEach(function(r$2) {
			_defineProperty(e$2, r$2, t$1[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$2, Object.getOwnPropertyDescriptors(t$1)) : ownKeys(Object(t$1)).forEach(function(r$2) {
			Object.defineProperty(e$2, r$2, Object.getOwnPropertyDescriptor(t$1, r$2));
		});
	}
	return e$2;
}

//#endregion
//#region node_modules/rc-util/es/Dom/findDOMNode.js
var import_react_dom$11 = /* @__PURE__ */ __toESM(require_react_dom());
function isDOM(node$1) {
	return node$1 instanceof HTMLElement || node$1 instanceof SVGElement;
}
/**
* Retrieves a DOM node via a ref, and does not invoke `findDOMNode`.
*/
function getDOM(node$1) {
	if (node$1 && _typeof(node$1) === "object" && isDOM(node$1.nativeElement)) return node$1.nativeElement;
	if (isDOM(node$1)) return node$1;
	return null;
}
/**
* Return if a node is a DOM node. Else will return by `findDOMNode`
*/
function findDOMNode(node$1) {
	var domNode = getDOM(node$1);
	if (domNode) return domNode;
	if (node$1 instanceof import_react.Component) {
		var _ReactDOM$findDOMNode;
		return (_ReactDOM$findDOMNode = import_react_dom$11.default.findDOMNode) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.call(import_react_dom$11.default, node$1);
	}
	return null;
}

//#endregion
//#region node_modules/rc-util/es/hooks/useMemo.js
var import_react_is = /* @__PURE__ */ __toESM(require_react_is());
function useMemo$1(getValue$2, condition, shouldUpdate) {
	var cacheRef = import_react.useRef({});
	if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
		cacheRef.current.value = getValue$2();
		cacheRef.current.condition = condition;
	}
	return cacheRef.current.value;
}

//#endregion
//#region node_modules/rc-util/es/ref.js
var ReactMajorVersion = Number(import_react.version.split(".")[0]);
var fillRef = function fillRef$1(ref, node$1) {
	if (typeof ref === "function") ref(node$1);
	else if (_typeof(ref) === "object" && ref && "current" in ref) ref.current = node$1;
};
/**
* Merge refs into one ref function to support ref passing.
*/
var composeRef = function composeRef$1() {
	for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
	var refList = refs.filter(Boolean);
	if (refList.length <= 1) return refList[0];
	return function(node$1) {
		refs.forEach(function(ref) {
			fillRef(ref, node$1);
		});
	};
};
var useComposeRef = function useComposeRef$1() {
	for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) refs[_key2] = arguments[_key2];
	return useMemo$1(function() {
		return composeRef.apply(void 0, refs);
	}, refs, function(prev$1, next$1) {
		return prev$1.length !== next$1.length || prev$1.every(function(ref, i) {
			return ref !== next$1[i];
		});
	});
};
var supportRef = function supportRef$1(nodeOrComponent) {
	var _type$prototype, _nodeOrComponent$prot;
	if (!nodeOrComponent) return false;
	if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) return true;
	var type$2 = (0, import_react_is.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
	if (typeof type$2 === "function" && !((_type$prototype = type$2.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type$2.$$typeof !== import_react_is.ForwardRef) return false;
	if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== import_react_is.ForwardRef) return false;
	return true;
};
function isReactElement(node$1) {
	return /* @__PURE__ */ (0, import_react.isValidElement)(node$1) && !isFragment$1(node$1);
}
var supportNodeRef = function supportNodeRef$1(node$1) {
	return isReactElement(node$1) && supportRef(node$1);
};
/**
* In React 19. `ref` is not a property from node.
* But a property from `props.ref`.
* To check if `props.ref` exist or fallback to `ref`.
*/
var getNodeRef = function getNodeRef$1(node$1) {
	if (node$1 && isReactElement(node$1)) {
		var ele = node$1;
		return ele.props.propertyIsEnumerable("ref") ? ele.props.ref : ele.ref;
	}
	return null;
};

//#endregion
//#region node_modules/rc-resize-observer/es/Collection.js
var CollectionContext = /* @__PURE__ */ import_react.createContext(null);
/**
* Collect all the resize event from children ResizeObserver
*/
function Collection(_ref) {
	var children = _ref.children, onBatchResize = _ref.onBatchResize;
	var resizeIdRef = import_react.useRef(0);
	var resizeInfosRef = import_react.useRef([]);
	var onCollectionResize = import_react.useContext(CollectionContext);
	var onResize$1 = import_react.useCallback(function(size, element, data) {
		resizeIdRef.current += 1;
		var currentId = resizeIdRef.current;
		resizeInfosRef.current.push({
			size,
			element,
			data
		});
		Promise.resolve().then(function() {
			if (currentId === resizeIdRef.current) {
				onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
				resizeInfosRef.current = [];
			}
		});
		onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
	}, [onBatchResize, onCollectionResize]);
	return /* @__PURE__ */ import_react.createElement(CollectionContext.Provider, { value: onResize$1 }, children);
}

//#endregion
//#region node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
/**
* A collection of shims that provide minimal functionality of the ES6 collections.
*
* These implementations are not meant to be used outside of the ResizeObserver
* modules as they cover only a limited range of use cases.
*/
var MapShim = (function() {
	if (typeof Map !== "undefined") return Map;
	/**
	* Returns index in provided array that matches the specified key.
	*
	* @param {Array<Array>} arr
	* @param {*} key
	* @returns {number}
	*/
	function getIndex$1(arr, key) {
		var result = -1;
		arr.some(function(entry, index$2) {
			if (entry[0] === key) {
				result = index$2;
				return true;
			}
			return false;
		});
		return result;
	}
	return function() {
		function class_1() {
			this.__entries__ = [];
		}
		Object.defineProperty(class_1.prototype, "size", {
			get: function() {
				return this.__entries__.length;
			},
			enumerable: true,
			configurable: true
		});
		/**
		* @param {*} key
		* @returns {*}
		*/
		class_1.prototype.get = function(key) {
			var index$2 = getIndex$1(this.__entries__, key);
			var entry = this.__entries__[index$2];
			return entry && entry[1];
		};
		/**
		* @param {*} key
		* @param {*} value
		* @returns {void}
		*/
		class_1.prototype.set = function(key, value) {
			var index$2 = getIndex$1(this.__entries__, key);
			if (~index$2) this.__entries__[index$2][1] = value;
			else this.__entries__.push([key, value]);
		};
		/**
		* @param {*} key
		* @returns {void}
		*/
		class_1.prototype.delete = function(key) {
			var entries = this.__entries__;
			var index$2 = getIndex$1(entries, key);
			if (~index$2) entries.splice(index$2, 1);
		};
		/**
		* @param {*} key
		* @returns {void}
		*/
		class_1.prototype.has = function(key) {
			return !!~getIndex$1(this.__entries__, key);
		};
		/**
		* @returns {void}
		*/
		class_1.prototype.clear = function() {
			this.__entries__.splice(0);
		};
		/**
		* @param {Function} callback
		* @param {*} [ctx=null]
		* @returns {void}
		*/
		class_1.prototype.forEach = function(callback, ctx) {
			if (ctx === void 0) ctx = null;
			for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
				var entry = _a[_i];
				callback.call(ctx, entry[1], entry[0]);
			}
		};
		return class_1;
	}();
})();
/**
* Detects whether window and document objects are available in current environment.
*/
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = (function() {
	if (typeof global !== "undefined" && global.Math === Math) return global;
	if (typeof self !== "undefined" && self.Math === Math) return self;
	if (typeof window !== "undefined" && window.Math === Math) return window;
	return Function("return this")();
})();
/**
* A shim for the requestAnimationFrame which falls back to the setTimeout if
* first one is not supported.
*
* @returns {number} Requests' identifier.
*/
var requestAnimationFrame$1 = (function() {
	if (typeof requestAnimationFrame === "function") return requestAnimationFrame.bind(global$1);
	return function(callback) {
		return setTimeout(function() {
			return callback(Date.now());
		}, 1e3 / 60);
	};
})();
var trailingTimeout = 2;
/**
* Creates a wrapper function which ensures that provided callback will be
* invoked only once during the specified delay period.
*
* @param {Function} callback - Function to be invoked after the delay period.
* @param {number} delay - Delay after which to invoke callback.
* @returns {Function}
*/
function throttle$1(callback, delay) {
	var leadingCall = false, trailingCall = false, lastCallTime = 0;
	/**
	* Invokes the original callback function and schedules new invocation if
	* the "proxy" was called during current request.
	*
	* @returns {void}
	*/
	function resolvePending() {
		if (leadingCall) {
			leadingCall = false;
			callback();
		}
		if (trailingCall) proxy();
	}
	/**
	* Callback invoked after the specified delay. It will further postpone
	* invocation of the original function delegating it to the
	* requestAnimationFrame.
	*
	* @returns {void}
	*/
	function timeoutCallback() {
		requestAnimationFrame$1(resolvePending);
	}
	/**
	* Schedules invocation of the original function.
	*
	* @returns {void}
	*/
	function proxy() {
		var timeStamp = Date.now();
		if (leadingCall) {
			if (timeStamp - lastCallTime < trailingTimeout) return;
			trailingCall = true;
		} else {
			leadingCall = true;
			trailingCall = false;
			setTimeout(timeoutCallback, delay);
		}
		lastCallTime = timeStamp;
	}
	return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = [
	"top",
	"right",
	"bottom",
	"left",
	"width",
	"height",
	"size",
	"weight"
];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
/**
* Singleton controller class which handles updates of ResizeObserver instances.
*/
var ResizeObserverController = function() {
	/**
	* Creates a new instance of ResizeObserverController.
	*
	* @private
	*/
	function ResizeObserverController$1() {
		/**
		* Indicates whether DOM listeners have been added.
		*
		* @private {boolean}
		*/
		this.connected_ = false;
		/**
		* Tells that controller has subscribed for Mutation Events.
		*
		* @private {boolean}
		*/
		this.mutationEventsAdded_ = false;
		/**
		* Keeps reference to the instance of MutationObserver.
		*
		* @private {MutationObserver}
		*/
		this.mutationsObserver_ = null;
		/**
		* A list of connected observers.
		*
		* @private {Array<ResizeObserverSPI>}
		*/
		this.observers_ = [];
		this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
		this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
	}
	/**
	* Adds observer to observers list.
	*
	* @param {ResizeObserverSPI} observer - Observer to be added.
	* @returns {void}
	*/
	ResizeObserverController$1.prototype.addObserver = function(observer) {
		if (!~this.observers_.indexOf(observer)) this.observers_.push(observer);
		if (!this.connected_) this.connect_();
	};
	/**
	* Removes observer from observers list.
	*
	* @param {ResizeObserverSPI} observer - Observer to be removed.
	* @returns {void}
	*/
	ResizeObserverController$1.prototype.removeObserver = function(observer) {
		var observers$1 = this.observers_;
		var index$2 = observers$1.indexOf(observer);
		if (~index$2) observers$1.splice(index$2, 1);
		if (!observers$1.length && this.connected_) this.disconnect_();
	};
	/**
	* Invokes the update of observers. It will continue running updates insofar
	* it detects changes.
	*
	* @returns {void}
	*/
	ResizeObserverController$1.prototype.refresh = function() {
		if (this.updateObservers_()) this.refresh();
	};
	/**
	* Updates every observer from observers list and notifies them of queued
	* entries.
	*
	* @private
	* @returns {boolean} Returns "true" if any observer has detected changes in
	*      dimensions of it's elements.
	*/
	ResizeObserverController$1.prototype.updateObservers_ = function() {
		var activeObservers = this.observers_.filter(function(observer) {
			return observer.gatherActive(), observer.hasActive();
		});
		activeObservers.forEach(function(observer) {
			return observer.broadcastActive();
		});
		return activeObservers.length > 0;
	};
	/**
	* Initializes DOM listeners.
	*
	* @private
	* @returns {void}
	*/
	ResizeObserverController$1.prototype.connect_ = function() {
		if (!isBrowser || this.connected_) return;
		document.addEventListener("transitionend", this.onTransitionEnd_);
		window.addEventListener("resize", this.refresh);
		if (mutationObserverSupported) {
			this.mutationsObserver_ = new MutationObserver(this.refresh);
			this.mutationsObserver_.observe(document, {
				attributes: true,
				childList: true,
				characterData: true,
				subtree: true
			});
		} else {
			document.addEventListener("DOMSubtreeModified", this.refresh);
			this.mutationEventsAdded_ = true;
		}
		this.connected_ = true;
	};
	/**
	* Removes DOM listeners.
	*
	* @private
	* @returns {void}
	*/
	ResizeObserverController$1.prototype.disconnect_ = function() {
		if (!isBrowser || !this.connected_) return;
		document.removeEventListener("transitionend", this.onTransitionEnd_);
		window.removeEventListener("resize", this.refresh);
		if (this.mutationsObserver_) this.mutationsObserver_.disconnect();
		if (this.mutationEventsAdded_) document.removeEventListener("DOMSubtreeModified", this.refresh);
		this.mutationsObserver_ = null;
		this.mutationEventsAdded_ = false;
		this.connected_ = false;
	};
	/**
	* "Transitionend" event handler.
	*
	* @private
	* @param {TransitionEvent} event
	* @returns {void}
	*/
	ResizeObserverController$1.prototype.onTransitionEnd_ = function(_a) {
		var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
		if (transitionKeys.some(function(key) {
			return !!~propertyName.indexOf(key);
		})) this.refresh();
	};
	/**
	* Returns instance of the ResizeObserverController.
	*
	* @returns {ResizeObserverController}
	*/
	ResizeObserverController$1.getInstance = function() {
		if (!this.instance_) this.instance_ = new ResizeObserverController$1();
		return this.instance_;
	};
	/**
	* Holds reference to the controller's instance.
	*
	* @private {ResizeObserverController}
	*/
	ResizeObserverController$1.instance_ = null;
	return ResizeObserverController$1;
}();
/**
* Defines non-writable/enumerable properties of the provided target object.
*
* @param {Object} target - Object for which to define properties.
* @param {Object} props - Properties to be defined.
* @returns {Object} Target object.
*/
var defineConfigurable = (function(target, props) {
	for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
		var key = _a[_i];
		Object.defineProperty(target, key, {
			value: props[key],
			enumerable: false,
			writable: false,
			configurable: true
		});
	}
	return target;
});
/**
* Returns the global object associated with provided element.
*
* @param {Object} target
* @returns {Object}
*/
var getWindowOf = (function(target) {
	return target && target.ownerDocument && target.ownerDocument.defaultView || global$1;
});
var emptyRect = createRectInit(0, 0, 0, 0);
/**
* Converts provided string to a number.
*
* @param {number|string} value
* @returns {number}
*/
function toFloat(value) {
	return parseFloat(value) || 0;
}
/**
* Extracts borders size from provided styles.
*
* @param {CSSStyleDeclaration} styles
* @param {...string} positions - Borders positions (top, right, ...)
* @returns {number}
*/
function getBordersSize(styles) {
	var positions = [];
	for (var _i = 1; _i < arguments.length; _i++) positions[_i - 1] = arguments[_i];
	return positions.reduce(function(size, position$2) {
		var value = styles["border-" + position$2 + "-width"];
		return size + toFloat(value);
	}, 0);
}
/**
* Extracts paddings sizes from provided styles.
*
* @param {CSSStyleDeclaration} styles
* @returns {Object} Paddings box.
*/
function getPaddings(styles) {
	var positions = [
		"top",
		"right",
		"bottom",
		"left"
	];
	var paddings = {};
	for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
		var position$2 = positions_1[_i];
		var value = styles["padding-" + position$2];
		paddings[position$2] = toFloat(value);
	}
	return paddings;
}
/**
* Calculates content rectangle of provided SVG element.
*
* @param {SVGGraphicsElement} target - Element content rectangle of which needs
*      to be calculated.
* @returns {DOMRectInit}
*/
function getSVGContentRect(target) {
	var bbox = target.getBBox();
	return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
* Calculates content rectangle of provided HTMLElement.
*
* @param {HTMLElement} target - Element for which to calculate the content rectangle.
* @returns {DOMRectInit}
*/
function getHTMLElementContentRect(target) {
	var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
	if (!clientWidth && !clientHeight) return emptyRect;
	var styles = getWindowOf(target).getComputedStyle(target);
	var paddings = getPaddings(styles);
	var horizPad = paddings.left + paddings.right;
	var vertPad = paddings.top + paddings.bottom;
	var width = toFloat(styles.width), height = toFloat(styles.height);
	if (styles.boxSizing === "border-box") {
		if (Math.round(width + horizPad) !== clientWidth) width -= getBordersSize(styles, "left", "right") + horizPad;
		if (Math.round(height + vertPad) !== clientHeight) height -= getBordersSize(styles, "top", "bottom") + vertPad;
	}
	if (!isDocumentElement(target)) {
		var vertScrollbar = Math.round(width + horizPad) - clientWidth;
		var horizScrollbar = Math.round(height + vertPad) - clientHeight;
		if (Math.abs(vertScrollbar) !== 1) width -= vertScrollbar;
		if (Math.abs(horizScrollbar) !== 1) height -= horizScrollbar;
	}
	return createRectInit(paddings.left, paddings.top, width, height);
}
/**
* Checks whether provided element is an instance of the SVGGraphicsElement.
*
* @param {Element} target - Element to be checked.
* @returns {boolean}
*/
var isSVGGraphicsElement = (function() {
	if (typeof SVGGraphicsElement !== "undefined") return function(target) {
		return target instanceof getWindowOf(target).SVGGraphicsElement;
	};
	return function(target) {
		return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
	};
})();
/**
* Checks whether provided element is a document element (<html>).
*
* @param {Element} target - Element to be checked.
* @returns {boolean}
*/
function isDocumentElement(target) {
	return target === getWindowOf(target).document.documentElement;
}
/**
* Calculates an appropriate content rectangle for provided html or svg element.
*
* @param {Element} target - Element content rectangle of which needs to be calculated.
* @returns {DOMRectInit}
*/
function getContentRect(target) {
	if (!isBrowser) return emptyRect;
	if (isSVGGraphicsElement(target)) return getSVGContentRect(target);
	return getHTMLElementContentRect(target);
}
/**
* Creates rectangle with an interface of the DOMRectReadOnly.
* Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
*
* @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
* @returns {DOMRectReadOnly}
*/
function createReadOnlyRect(_a) {
	var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
	var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
	var rect = Object.create(Constr.prototype);
	defineConfigurable(rect, {
		x,
		y,
		width,
		height,
		top: y,
		right: x + width,
		bottom: height + y,
		left: x
	});
	return rect;
}
/**
* Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
* Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
*
* @param {number} x - X coordinate.
* @param {number} y - Y coordinate.
* @param {number} width - Rectangle's width.
* @param {number} height - Rectangle's height.
* @returns {DOMRectInit}
*/
function createRectInit(x, y, width, height) {
	return {
		x,
		y,
		width,
		height
	};
}
/**
* Class that is responsible for computations of the content rectangle of
* provided DOM element and for keeping track of it's changes.
*/
var ResizeObservation = function() {
	/**
	* Creates an instance of ResizeObservation.
	*
	* @param {Element} target - Element to be observed.
	*/
	function ResizeObservation$1(target) {
		/**
		* Broadcasted width of content rectangle.
		*
		* @type {number}
		*/
		this.broadcastWidth = 0;
		/**
		* Broadcasted height of content rectangle.
		*
		* @type {number}
		*/
		this.broadcastHeight = 0;
		/**
		* Reference to the last observed content rectangle.
		*
		* @private {DOMRectInit}
		*/
		this.contentRect_ = createRectInit(0, 0, 0, 0);
		this.target = target;
	}
	/**
	* Updates content rectangle and tells whether it's width or height properties
	* have changed since the last broadcast.
	*
	* @returns {boolean}
	*/
	ResizeObservation$1.prototype.isActive = function() {
		var rect = getContentRect(this.target);
		this.contentRect_ = rect;
		return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
	};
	/**
	* Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
	* from the corresponding properties of the last observed content rectangle.
	*
	* @returns {DOMRectInit} Last observed content rectangle.
	*/
	ResizeObservation$1.prototype.broadcastRect = function() {
		var rect = this.contentRect_;
		this.broadcastWidth = rect.width;
		this.broadcastHeight = rect.height;
		return rect;
	};
	return ResizeObservation$1;
}();
var ResizeObserverEntry = function() {
	/**
	* Creates an instance of ResizeObserverEntry.
	*
	* @param {Element} target - Element that is being observed.
	* @param {DOMRectInit} rectInit - Data of the element's content rectangle.
	*/
	function ResizeObserverEntry$1(target, rectInit) {
		var contentRect = createReadOnlyRect(rectInit);
		defineConfigurable(this, {
			target,
			contentRect
		});
	}
	return ResizeObserverEntry$1;
}();
var ResizeObserverSPI = function() {
	/**
	* Creates a new instance of ResizeObserver.
	*
	* @param {ResizeObserverCallback} callback - Callback function that is invoked
	*      when one of the observed elements changes it's content dimensions.
	* @param {ResizeObserverController} controller - Controller instance which
	*      is responsible for the updates of observer.
	* @param {ResizeObserver} callbackCtx - Reference to the public
	*      ResizeObserver instance which will be passed to callback function.
	*/
	function ResizeObserverSPI$1(callback, controller, callbackCtx) {
		/**
		* Collection of resize observations that have detected changes in dimensions
		* of elements.
		*
		* @private {Array<ResizeObservation>}
		*/
		this.activeObservations_ = [];
		/**
		* Registry of the ResizeObservation instances.
		*
		* @private {Map<Element, ResizeObservation>}
		*/
		this.observations_ = new MapShim();
		if (typeof callback !== "function") throw new TypeError("The callback provided as parameter 1 is not a function.");
		this.callback_ = callback;
		this.controller_ = controller;
		this.callbackCtx_ = callbackCtx;
	}
	/**
	* Starts observing provided element.
	*
	* @param {Element} target - Element to be observed.
	* @returns {void}
	*/
	ResizeObserverSPI$1.prototype.observe = function(target) {
		if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
		if (typeof Element === "undefined" || !(Element instanceof Object)) return;
		if (!(target instanceof getWindowOf(target).Element)) throw new TypeError("parameter 1 is not of type \"Element\".");
		var observations = this.observations_;
		if (observations.has(target)) return;
		observations.set(target, new ResizeObservation(target));
		this.controller_.addObserver(this);
		this.controller_.refresh();
	};
	/**
	* Stops observing provided element.
	*
	* @param {Element} target - Element to stop observing.
	* @returns {void}
	*/
	ResizeObserverSPI$1.prototype.unobserve = function(target) {
		if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
		if (typeof Element === "undefined" || !(Element instanceof Object)) return;
		if (!(target instanceof getWindowOf(target).Element)) throw new TypeError("parameter 1 is not of type \"Element\".");
		var observations = this.observations_;
		if (!observations.has(target)) return;
		observations.delete(target);
		if (!observations.size) this.controller_.removeObserver(this);
	};
	/**
	* Stops observing all elements.
	*
	* @returns {void}
	*/
	ResizeObserverSPI$1.prototype.disconnect = function() {
		this.clearActive();
		this.observations_.clear();
		this.controller_.removeObserver(this);
	};
	/**
	* Collects observation instances the associated element of which has changed
	* it's content rectangle.
	*
	* @returns {void}
	*/
	ResizeObserverSPI$1.prototype.gatherActive = function() {
		var _this = this;
		this.clearActive();
		this.observations_.forEach(function(observation) {
			if (observation.isActive()) _this.activeObservations_.push(observation);
		});
	};
	/**
	* Invokes initial callback function with a list of ResizeObserverEntry
	* instances collected from active resize observations.
	*
	* @returns {void}
	*/
	ResizeObserverSPI$1.prototype.broadcastActive = function() {
		if (!this.hasActive()) return;
		var ctx = this.callbackCtx_;
		var entries = this.activeObservations_.map(function(observation) {
			return new ResizeObserverEntry(observation.target, observation.broadcastRect());
		});
		this.callback_.call(ctx, entries, ctx);
		this.clearActive();
	};
	/**
	* Clears the collection of active observations.
	*
	* @returns {void}
	*/
	ResizeObserverSPI$1.prototype.clearActive = function() {
		this.activeObservations_.splice(0);
	};
	/**
	* Tells whether observer has active observations.
	*
	* @returns {boolean}
	*/
	ResizeObserverSPI$1.prototype.hasActive = function() {
		return this.activeObservations_.length > 0;
	};
	return ResizeObserverSPI$1;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
/**
* ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
* exposing only those methods and properties that are defined in the spec.
*/
var ResizeObserver$2 = function() {
	/**
	* Creates a new instance of ResizeObserver.
	*
	* @param {ResizeObserverCallback} callback - Callback that is invoked when
	*      dimensions of the observed elements change.
	*/
	function ResizeObserver$3(callback) {
		if (!(this instanceof ResizeObserver$3)) throw new TypeError("Cannot call a class as a function.");
		if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
		var controller = ResizeObserverController.getInstance();
		var observer = new ResizeObserverSPI(callback, controller, this);
		observers.set(this, observer);
	}
	return ResizeObserver$3;
}();
[
	"observe",
	"unobserve",
	"disconnect"
].forEach(function(method$1) {
	ResizeObserver$2.prototype[method$1] = function() {
		var _a;
		return (_a = observers.get(this))[method$1].apply(_a, arguments);
	};
});
var index$1 = (function() {
	if (typeof global$1.ResizeObserver !== "undefined") return global$1.ResizeObserver;
	return ResizeObserver$2;
})();
var ResizeObserver_es_default = index$1;

//#endregion
//#region node_modules/rc-resize-observer/es/utils/observerUtil.js
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
	entities.forEach(function(entity) {
		var _elementListeners$get;
		var target = entity.target;
		(_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function(listener) {
			return listener(target);
		});
	});
}
var resizeObserver = new ResizeObserver_es_default(onResize);
function observe(element, callback) {
	if (!elementListeners.has(element)) {
		elementListeners.set(element, /* @__PURE__ */ new Set());
		resizeObserver.observe(element);
	}
	elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
	if (elementListeners.has(element)) {
		elementListeners.get(element).delete(callback);
		if (!elementListeners.get(element).size) {
			resizeObserver.unobserve(element);
			elementListeners.delete(element);
		}
	}
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n$1) {
	if (!(a instanceof n$1)) throw new TypeError("Cannot call a class as a function");
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e$2, r$1) {
	for (var t$1 = 0; t$1 < r$1.length; t$1++) {
		var o$2 = r$1[t$1];
		o$2.enumerable = o$2.enumerable || !1, o$2.configurable = !0, "value" in o$2 && (o$2.writable = !0), Object.defineProperty(e$2, toPropertyKey(o$2.key), o$2);
	}
}
function _createClass(e$2, r$1, t$1) {
	return r$1 && _defineProperties(e$2.prototype, r$1), t$1 && _defineProperties(e$2, t$1), Object.defineProperty(e$2, "prototype", { writable: !1 }), e$2;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t$1, e$2) {
	return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t$2, e$3) {
		return t$2.__proto__ = e$3, t$2;
	}, _setPrototypeOf(t$1, e$2);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t$1, e$2) {
	if ("function" != typeof e$2 && null !== e$2) throw new TypeError("Super expression must either be null or a function");
	t$1.prototype = Object.create(e$2 && e$2.prototype, { constructor: {
		value: t$1,
		writable: !0,
		configurable: !0
	} }), Object.defineProperty(t$1, "prototype", { writable: !1 }), e$2 && _setPrototypeOf(t$1, e$2);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t$1) {
	return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t$2) {
		return t$2.__proto__ || Object.getPrototypeOf(t$2);
	}, _getPrototypeOf(t$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$2) {}
	return (_isNativeReflectConstruct = function _isNativeReflectConstruct$1() {
		return !!t$1;
	})();
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e$2) {
	if (void 0 === e$2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return e$2;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t$1, e$2) {
	if (e$2 && ("object" == _typeof(e$2) || "function" == typeof e$2)) return e$2;
	if (void 0 !== e$2) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized(t$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(t$1) {
	var r$1 = _isNativeReflectConstruct();
	return function() {
		var e$2, o$2 = _getPrototypeOf(t$1);
		if (r$1) {
			var s = _getPrototypeOf(this).constructor;
			e$2 = Reflect.construct(o$2, arguments, s);
		} else e$2 = o$2.apply(this, arguments);
		return _possibleConstructorReturn(this, e$2);
	};
}

//#endregion
//#region node_modules/rc-resize-observer/es/SingleObserver/DomWrapper.js
/**
* Fallback to findDOMNode if origin ref do not provide any dom element
*/
var DomWrapper$2 = /* @__PURE__ */ function(_React$Component) {
	_inherits(DomWrapper$3, _React$Component);
	var _super = _createSuper(DomWrapper$3);
	function DomWrapper$3() {
		_classCallCheck(this, DomWrapper$3);
		return _super.apply(this, arguments);
	}
	_createClass(DomWrapper$3, [{
		key: "render",
		value: function render$1() {
			return this.props.children;
		}
	}]);
	return DomWrapper$3;
}(import_react.Component);

//#endregion
//#region node_modules/rc-resize-observer/es/SingleObserver/index.js
function SingleObserver(props, ref) {
	var children = props.children, disabled = props.disabled;
	var elementRef = import_react.useRef(null);
	var wrapperRef = import_react.useRef(null);
	var onCollectionResize = import_react.useContext(CollectionContext);
	var isRenderProps = typeof children === "function";
	var mergedChildren = isRenderProps ? children(elementRef) : children;
	var sizeRef = import_react.useRef({
		width: -1,
		height: -1,
		offsetWidth: -1,
		offsetHeight: -1
	});
	var canRef = !isRenderProps && /* @__PURE__ */ import_react.isValidElement(mergedChildren) && supportRef(mergedChildren);
	var originRef = canRef ? getNodeRef(mergedChildren) : null;
	var mergedRef = useComposeRef(originRef, elementRef);
	var getDom = function getDom$1() {
		var _elementRef$current;
		return findDOMNode(elementRef.current) || (elementRef.current && _typeof(elementRef.current) === "object" ? findDOMNode((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
	};
	import_react.useImperativeHandle(ref, function() {
		return getDom();
	});
	var propsRef = import_react.useRef(props);
	propsRef.current = props;
	var onInternalResize = import_react.useCallback(function(target) {
		var _propsRef$current = propsRef.current, onResize$1 = _propsRef$current.onResize, data = _propsRef$current.data;
		var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
		var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
		/**
		* Resize observer trigger when content size changed.
		* In most case we just care about element size,
		* let's use `boundary` instead of `contentRect` here to avoid shaking.
		*/
		var fixedWidth = Math.floor(width);
		var fixedHeight = Math.floor(height);
		if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
			var size = {
				width: fixedWidth,
				height: fixedHeight,
				offsetWidth,
				offsetHeight
			};
			sizeRef.current = size;
			var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
			var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
			var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
				offsetWidth: mergedOffsetWidth,
				offsetHeight: mergedOffsetHeight
			});
			onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
			if (onResize$1) Promise.resolve().then(function() {
				onResize$1(sizeInfo, target);
			});
		}
	}, []);
	import_react.useEffect(function() {
		var currentElement = getDom();
		if (currentElement && !disabled) observe(currentElement, onInternalResize);
		return function() {
			return unobserve(currentElement, onInternalResize);
		};
	}, [elementRef.current, disabled]);
	return /* @__PURE__ */ import_react.createElement(DomWrapper$2, { ref: wrapperRef }, canRef ? /* @__PURE__ */ import_react.cloneElement(mergedChildren, { ref: mergedRef }) : mergedChildren);
}
var RefSingleObserver = /* @__PURE__ */ import_react.forwardRef(SingleObserver);
RefSingleObserver.displayName = "SingleObserver";
var SingleObserver_default = RefSingleObserver;

//#endregion
//#region node_modules/rc-resize-observer/es/index.js
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver$1(props, ref) {
	var children = props.children;
	var childNodes = typeof children === "function" ? [children] : toArray(children);
	if (childNodes.length > 1) warning(false, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.");
	else if (childNodes.length === 0) warning(false, "`children` of ResizeObserver is empty. Nothing is in observe.");
	return childNodes.map(function(child, index$2) {
		var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index$2);
		return /* @__PURE__ */ import_react.createElement(SingleObserver_default, _extends({}, props, {
			key,
			ref: index$2 === 0 ? ref : void 0
		}), child);
	});
}
var RefResizeObserver = /* @__PURE__ */ import_react.forwardRef(ResizeObserver$1);
RefResizeObserver.displayName = "ResizeObserver";
RefResizeObserver.Collection = Collection;
var es_default = RefResizeObserver;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r$1, a) {
	(null == a || a > r$1.length) && (a = r$1.length);
	for (var e$2 = 0, n$1 = Array(a); e$2 < a; e$2++) n$1[e$2] = r$1[e$2];
	return n$1;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r$1) {
	if (Array.isArray(r$1)) return _arrayLikeToArray(r$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r$1) {
	if ("undefined" != typeof Symbol && null != r$1[Symbol.iterator] || null != r$1["@@iterator"]) return Array.from(r$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r$1, a) {
	if (r$1) {
		if ("string" == typeof r$1) return _arrayLikeToArray(r$1, a);
		var t$1 = {}.toString.call(r$1).slice(8, -1);
		return "Object" === t$1 && r$1.constructor && (t$1 = r$1.constructor.name), "Map" === t$1 || "Set" === t$1 ? Array.from(r$1) : "Arguments" === t$1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$1) ? _arrayLikeToArray(r$1, a) : void 0;
	}
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r$1) {
	return _arrayWithoutHoles(r$1) || _iterableToArray(r$1) || _unsupportedIterableToArray(r$1) || _nonIterableSpread();
}

//#endregion
//#region node_modules/rc-util/es/raf.js
var raf = function raf$1(callback) {
	return +setTimeout(callback, 16);
};
var caf = function caf$1(num) {
	return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
	raf = function raf$1(callback) {
		return window.requestAnimationFrame(callback);
	};
	caf = function caf$1(handle) {
		return window.cancelAnimationFrame(handle);
	};
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
	rafIds.delete(id);
}
var wrapperRaf = function wrapperRaf$1(callback) {
	var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
	rafUUID += 1;
	var id = rafUUID;
	function callRef(leftTimes) {
		if (leftTimes === 0) {
			cleanup(id);
			callback();
		} else {
			var realId = raf(function() {
				callRef(leftTimes - 1);
			});
			rafIds.set(id, realId);
		}
	}
	callRef(times);
	return id;
};
wrapperRaf.cancel = function(id) {
	var realId = rafIds.get(id);
	cleanup(id);
	return caf(realId);
};
wrapperRaf.ids = function() {
	return rafIds;
};
var raf_default = wrapperRaf;

//#endregion
//#region node_modules/antd/es/_util/throttleByAnimationFrame.js
function throttleByAnimationFrame(fn) {
	let requestId = null;
	const later = (args) => () => {
		requestId = null;
		fn.apply(void 0, _toConsumableArray(args));
	};
	const throttled = (...args) => {
		if (requestId === null) requestId = raf_default(later(args));
	};
	throttled.cancel = () => {
		raf_default.cancel(requestId);
		requestId = null;
	};
	return throttled;
}
var throttleByAnimationFrame_default = throttleByAnimationFrame;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r$1) {
	if (Array.isArray(r$1)) return r$1;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r$1, l$1) {
	var t$1 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$1) {
		var e$2, n$1, i, u, a = [], f = !0, o$2 = !1;
		try {
			if (i = (t$1 = t$1.call(r$1)).next, 0 === l$1) {
				if (Object(t$1) !== t$1) return;
				f = !1;
			} else for (; !(f = (e$2 = i.call(t$1)).done) && (a.push(e$2.value), a.length !== l$1); f = !0);
		} catch (r$2) {
			o$2 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f && null != t$1["return"] && (u = t$1["return"](), Object(u) !== u)) return;
			} finally {
				if (o$2) throw n$1;
			}
		}
		return a;
	}
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r$1, e$2) {
	return _arrayWithHoles(r$1) || _iterableToArrayLimit(r$1, e$2) || _unsupportedIterableToArray(r$1, e$2) || _nonIterableRest();
}

//#endregion
//#region node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
	var h = 0;
	var k, i = 0, len = str.length;
	for (; len >= 4; ++i, len -= 4) {
		k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
		k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
		k ^= k >>> 24;
		h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	}
	switch (len) {
		case 3: h ^= (str.charCodeAt(i + 2) & 255) << 16;
		case 2: h ^= (str.charCodeAt(i + 1) & 255) << 8;
		case 1:
			h ^= str.charCodeAt(i) & 255;
			h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	}
	h ^= h >>> 13;
	h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
	return ((h ^ h >>> 15) >>> 0).toString(36);
}
var hash_browser_esm_default = murmur2;

//#endregion
//#region node_modules/rc-util/es/Dom/canUseDom.js
function canUseDom() {
	return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}

//#endregion
//#region node_modules/rc-util/es/Dom/contains.js
function contains(root, n$1) {
	if (!root) return false;
	if (root.contains) return root.contains(n$1);
	var node$1 = n$1;
	while (node$1) {
		if (node$1 === root) return true;
		node$1 = node$1.parentNode;
	}
	return false;
}

//#endregion
//#region node_modules/rc-util/es/Dom/dynamicCSS.js
var APPEND_ORDER = "data-rc-order";
var APPEND_PRIORITY = "data-rc-priority";
var MARK_KEY = "rc-util-key";
var containerCache = /* @__PURE__ */ new Map();
function getMark() {
	var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
	if (mark) return mark.startsWith("data-") ? mark : "data-".concat(mark);
	return MARK_KEY;
}
function getContainer(option) {
	if (option.attachTo) return option.attachTo;
	return document.querySelector("head") || document.body;
}
function getOrder(prepend) {
	if (prepend === "queue") return "prependQueue";
	return prepend ? "prepend" : "append";
}
/**
* Find style which inject by rc-util
*/
function findStyles(container) {
	return Array.from((containerCache.get(container) || container).children).filter(function(node$1) {
		return node$1.tagName === "STYLE";
	});
}
function injectCSS(css) {
	var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	if (!canUseDom()) return null;
	var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority;
	var mergedOrder = getOrder(prepend);
	var isPrependQueue = mergedOrder === "prependQueue";
	var styleNode = document.createElement("style");
	styleNode.setAttribute(APPEND_ORDER, mergedOrder);
	if (isPrependQueue && priority) styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
	if (csp !== null && csp !== void 0 && csp.nonce) styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
	styleNode.innerHTML = css;
	var container = getContainer(option);
	var firstChild = container.firstChild;
	if (prepend) {
		if (isPrependQueue) {
			var existStyle = (option.styles || findStyles(container)).filter(function(node$1) {
				if (!["prepend", "prependQueue"].includes(node$1.getAttribute(APPEND_ORDER))) return false;
				var nodePriority = Number(node$1.getAttribute(APPEND_PRIORITY) || 0);
				return priority >= nodePriority;
			});
			if (existStyle.length) {
				container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
				return styleNode;
			}
		}
		container.insertBefore(styleNode, firstChild);
	} else container.appendChild(styleNode);
	return styleNode;
}
function findExistNode(key) {
	var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var container = getContainer(option);
	return (option.styles || findStyles(container)).find(function(node$1) {
		return node$1.getAttribute(getMark(option)) === key;
	});
}
function removeCSS(key) {
	var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var existNode = findExistNode(key, option);
	if (existNode) getContainer(option).removeChild(existNode);
}
/**
* qiankun will inject `appendChild` to insert into other
*/
function syncRealContainer(container, option) {
	var cachedRealContainer = containerCache.get(container);
	if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
		var placeholderStyle = injectCSS("", option);
		var parentNode = placeholderStyle.parentNode;
		containerCache.set(container, parentNode);
		container.removeChild(placeholderStyle);
	}
}
function updateCSS(css, key) {
	var originOption = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
	var container = getContainer(originOption);
	var styles = findStyles(container);
	var option = _objectSpread2(_objectSpread2({}, originOption), {}, { styles });
	syncRealContainer(container, option);
	var existNode = findExistNode(key, option);
	if (existNode) {
		var _option$csp, _option$csp2;
		if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
			var _option$csp3;
			existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
		}
		if (existNode.innerHTML !== css) existNode.innerHTML = css;
		return existNode;
	}
	var newNode = injectCSS(css, option);
	newNode.setAttribute(getMark(option), key);
	return newNode;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r$1, e$2) {
	if (null == r$1) return {};
	var t$1 = {};
	for (var n$1 in r$1) if ({}.hasOwnProperty.call(r$1, n$1)) {
		if (-1 !== e$2.indexOf(n$1)) continue;
		t$1[n$1] = r$1[n$1];
	}
	return t$1;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e$2, t$1) {
	if (null == e$2) return {};
	var o$2, r$1, i = _objectWithoutPropertiesLoose(e$2, t$1);
	if (Object.getOwnPropertySymbols) {
		var n$1 = Object.getOwnPropertySymbols(e$2);
		for (r$1 = 0; r$1 < n$1.length; r$1++) o$2 = n$1[r$1], -1 === t$1.indexOf(o$2) && {}.propertyIsEnumerable.call(e$2, o$2) && (i[o$2] = e$2[o$2]);
	}
	return i;
}

//#endregion
//#region node_modules/rc-util/es/isEqual.js
/**
* Deeply compares two object literals.
* @param obj1 object 1
* @param obj2 object 2
* @param shallow shallow compare
* @returns
*/
function isEqual(obj1, obj2) {
	var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
	var refSet = /* @__PURE__ */ new Set();
	function deepEqual(a, b) {
		var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
		var circular = refSet.has(a);
		warning_default(!circular, "Warning: There may be circular references");
		if (circular) return false;
		if (a === b) return true;
		if (shallow && level > 1) return false;
		refSet.add(a);
		var newLevel = level + 1;
		if (Array.isArray(a)) {
			if (!Array.isArray(b) || a.length !== b.length) return false;
			for (var i = 0; i < a.length; i++) if (!deepEqual(a[i], b[i], newLevel)) return false;
			return true;
		}
		if (a && b && _typeof(a) === "object" && _typeof(b) === "object") {
			var keys$1 = Object.keys(a);
			if (keys$1.length !== Object.keys(b).length) return false;
			return keys$1.every(function(key) {
				return deepEqual(a[key], b[key], newLevel);
			});
		}
		return false;
	}
	return deepEqual(obj1, obj2);
}
var isEqual_default = isEqual;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/Cache.js
var SPLIT$1 = "%";
/** Connect key with `SPLIT` */
function pathKey(keys$1) {
	return keys$1.join(SPLIT$1);
}
var Entity = /* @__PURE__ */ function() {
	function Entity$1(instanceId) {
		_classCallCheck(this, Entity$1);
		_defineProperty(this, "instanceId", void 0);
		/** @private Internal cache map. Do not access this directly */
		_defineProperty(this, "cache", /* @__PURE__ */ new Map());
		_defineProperty(this, "extracted", /* @__PURE__ */ new Set());
		this.instanceId = instanceId;
	}
	_createClass(Entity$1, [
		{
			key: "get",
			value: function get$1(keys$1) {
				return this.opGet(pathKey(keys$1));
			}
		},
		{
			key: "opGet",
			value: function opGet(keyPathStr) {
				return this.cache.get(keyPathStr) || null;
			}
		},
		{
			key: "update",
			value: function update(keys$1, valueFn) {
				return this.opUpdate(pathKey(keys$1), valueFn);
			}
		},
		{
			key: "opUpdate",
			value: function opUpdate(keyPathStr, valueFn) {
				var prevValue = this.cache.get(keyPathStr);
				var nextValue = valueFn(prevValue);
				if (nextValue === null) this.cache.delete(keyPathStr);
				else this.cache.set(keyPathStr, nextValue);
			}
		}
	]);
	return Entity$1;
}();
var Cache_default = Entity;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/StyleContext.js
var ATTR_TOKEN = "data-token-hash";
var ATTR_MARK = "data-css-hash";
var ATTR_CACHE_PATH = "data-cache-path";
var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
	var cssinjsInstanceId = Math.random().toString(12).slice(2);
	if (typeof document !== "undefined" && document.head && document.body) {
		var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
		var firstChild = document.head.firstChild;
		Array.from(styles).forEach(function(style$1) {
			style$1[CSS_IN_JS_INSTANCE] = style$1[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
			if (style$1[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) document.head.insertBefore(style$1, firstChild);
		});
		var styleHash = {};
		Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style$1) {
			var hash = style$1.getAttribute(ATTR_MARK);
			if (styleHash[hash]) {
				if (style$1[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
					var _style$parentNode;
					(_style$parentNode = style$1.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style$1);
				}
			} else styleHash[hash] = true;
		});
	}
	return new Cache_default(cssinjsInstanceId);
}
var StyleContext = /* @__PURE__ */ import_react.createContext({
	hashPriority: "low",
	cache: createCache(),
	defaultCache: true
});
var StyleContext_default = StyleContext;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/theme/calc/CSSCalculator.js
var CALC_UNIT$1 = "CALC_UNIT";
var regexp$2 = new RegExp(CALC_UNIT$1, "g");

//#endregion
//#region node_modules/@ant-design/cssinjs/es/theme/ThemeCache.js
function sameDerivativeOption(left, right) {
	if (left.length !== right.length) return false;
	for (var i = 0; i < left.length; i++) if (left[i] !== right[i]) return false;
	return true;
}
var ThemeCache = /* @__PURE__ */ function() {
	function ThemeCache$1() {
		_classCallCheck(this, ThemeCache$1);
		_defineProperty(this, "cache", void 0);
		_defineProperty(this, "keys", void 0);
		_defineProperty(this, "cacheCallTimes", void 0);
		this.cache = /* @__PURE__ */ new Map();
		this.keys = [];
		this.cacheCallTimes = 0;
	}
	_createClass(ThemeCache$1, [
		{
			key: "size",
			value: function size() {
				return this.keys.length;
			}
		},
		{
			key: "internalGet",
			value: function internalGet(derivativeOption) {
				var _cache2, _cache3;
				var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
				var cache = { map: this.cache };
				derivativeOption.forEach(function(derivative$3) {
					if (!cache) cache = void 0;
					else {
						var _cache;
						cache = (_cache = cache) === null || _cache === void 0 || (_cache = _cache.map) === null || _cache === void 0 ? void 0 : _cache.get(derivative$3);
					}
				});
				if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) cache.value[1] = this.cacheCallTimes++;
				return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
			}
		},
		{
			key: "get",
			value: function get$1(derivativeOption) {
				var _this$internalGet;
				return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
			}
		},
		{
			key: "has",
			value: function has(derivativeOption) {
				return !!this.internalGet(derivativeOption);
			}
		},
		{
			key: "set",
			value: function set$1(derivativeOption, value) {
				var _this = this;
				if (!this.has(derivativeOption)) {
					if (this.size() + 1 > ThemeCache$1.MAX_CACHE_SIZE + ThemeCache$1.MAX_CACHE_OFFSET) {
						var _this$keys$reduce = this.keys.reduce(function(result, key) {
							var _result = _slicedToArray(result, 2), callTimes = _result[1];
							if (_this.internalGet(key)[1] < callTimes) return [key, _this.internalGet(key)[1]];
							return result;
						}, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
						this.delete(targetKey);
					}
					this.keys.push(derivativeOption);
				}
				var cache = this.cache;
				derivativeOption.forEach(function(derivative$3, index$2) {
					if (index$2 === derivativeOption.length - 1) cache.set(derivative$3, { value: [value, _this.cacheCallTimes++] });
					else {
						var cacheValue = cache.get(derivative$3);
						if (!cacheValue) cache.set(derivative$3, { map: /* @__PURE__ */ new Map() });
						else if (!cacheValue.map) cacheValue.map = /* @__PURE__ */ new Map();
						cache = cache.get(derivative$3).map;
					}
				});
			}
		},
		{
			key: "deleteByPath",
			value: function deleteByPath(currentCache, derivatives) {
				var cache = currentCache.get(derivatives[0]);
				if (derivatives.length === 1) {
					var _cache$value;
					if (!cache.map) currentCache.delete(derivatives[0]);
					else currentCache.set(derivatives[0], { map: cache.map });
					return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
				}
				var result = this.deleteByPath(cache.map, derivatives.slice(1));
				if ((!cache.map || cache.map.size === 0) && !cache.value) currentCache.delete(derivatives[0]);
				return result;
			}
		},
		{
			key: "delete",
			value: function _delete(derivativeOption) {
				if (this.has(derivativeOption)) {
					this.keys = this.keys.filter(function(item) {
						return !sameDerivativeOption(item, derivativeOption);
					});
					return this.deleteByPath(this.cache, derivativeOption);
				}
			}
		}
	]);
	return ThemeCache$1;
}();
_defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20);
_defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);

//#endregion
//#region node_modules/@ant-design/cssinjs/es/theme/Theme.js
var uuid$6 = 0;
/**
* Theme with algorithms to derive tokens from design tokens.
* Use `createTheme` first which will help to manage the theme instance cache.
*/
var Theme = /* @__PURE__ */ function() {
	function Theme$1(derivatives) {
		_classCallCheck(this, Theme$1);
		_defineProperty(this, "derivatives", void 0);
		_defineProperty(this, "id", void 0);
		this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
		this.id = uuid$6;
		if (derivatives.length === 0) warning(derivatives.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function.");
		uuid$6 += 1;
	}
	_createClass(Theme$1, [{
		key: "getDerivativeToken",
		value: function getDerivativeToken(token$1) {
			return this.derivatives.reduce(function(result, derivative$3) {
				return derivative$3(token$1, result);
			}, void 0);
		}
	}]);
	return Theme$1;
}();

//#endregion
//#region node_modules/@ant-design/cssinjs/es/theme/createTheme.js
var cacheThemes = new ThemeCache();
/**
* Same as new Theme, but will always return same one if `derivative` not changed.
*/
function createTheme(derivatives) {
	var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
	if (!cacheThemes.has(derivativeArr)) cacheThemes.set(derivativeArr, new Theme(derivativeArr));
	return cacheThemes.get(derivativeArr);
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/util/index.js
var resultCache = /* @__PURE__ */ new WeakMap();
var RESULT_VALUE = {};
function memoResult(callback, deps) {
	var current = resultCache;
	for (var i = 0; i < deps.length; i += 1) {
		var dep = deps[i];
		if (!current.has(dep)) current.set(dep, /* @__PURE__ */ new WeakMap());
		current = current.get(dep);
	}
	if (!current.has(RESULT_VALUE)) current.set(RESULT_VALUE, callback());
	return current.get(RESULT_VALUE);
}
var flattenTokenCache = /* @__PURE__ */ new WeakMap();
/**
* Flatten token to string, this will auto cache the result when token not change
*/
function flattenToken(token$1) {
	var str = flattenTokenCache.get(token$1) || "";
	if (!str) {
		Object.keys(token$1).forEach(function(key) {
			var value = token$1[key];
			str += key;
			if (value instanceof Theme) str += value.id;
			else if (value && _typeof(value) === "object") str += flattenToken(value);
			else str += value;
		});
		str = hash_browser_esm_default(str);
		flattenTokenCache.set(token$1, str);
	}
	return str;
}
/**
* Convert derivative token to key string
*/
function token2key(token$1, salt) {
	return hash_browser_esm_default("".concat(salt, "_").concat(flattenToken(token$1)));
}
var randomSelectorKey = "random-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
var isClientSide = canUseDom();
function unit(num) {
	if (typeof num === "number") return "".concat(num, "px");
	return num;
}
function toStyleStr(style$1, tokenKey, styleId) {
	var customizeAttrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
	if (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false) return style$1;
	var attrs = _objectSpread2(_objectSpread2({}, customizeAttrs), {}, _defineProperty(_defineProperty({}, ATTR_TOKEN, tokenKey), ATTR_MARK, styleId));
	var attrStr = Object.keys(attrs).map(function(attr) {
		var val = attrs[attr];
		return val ? "".concat(attr, "=\"").concat(val, "\"") : null;
	}).filter(function(v) {
		return v;
	}).join(" ");
	return "<style ".concat(attrStr, ">").concat(style$1, "</style>");
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/util/css-variables.js
var token2CSSVar = function token2CSSVar$1(token$1) {
	var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
	return "--".concat(prefix ? "".concat(prefix, "-") : "").concat(token$1).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
};
var serializeCSSVar = function serializeCSSVar$1(cssVars, hashId, options) {
	if (!Object.keys(cssVars).length) return "";
	return ".".concat(hashId).concat(options !== null && options !== void 0 && options.scope ? ".".concat(options.scope) : "", "{").concat(Object.entries(cssVars).map(function(_ref) {
		var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
		return "".concat(key, ":").concat(value, ";");
	}).join(""), "}");
};
var transformToken = function transformToken$1(token$1, themeKey, config) {
	var cssVars = {};
	var result = {};
	Object.entries(token$1).forEach(function(_ref3) {
		var _config$preserve, _config$ignore;
		var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], value = _ref4[1];
		if (config !== null && config !== void 0 && (_config$preserve = config.preserve) !== null && _config$preserve !== void 0 && _config$preserve[key]) result[key] = value;
		else if ((typeof value === "string" || typeof value === "number") && !(config !== null && config !== void 0 && (_config$ignore = config.ignore) !== null && _config$ignore !== void 0 && _config$ignore[key])) {
			var _config$unitless;
			var cssVar = token2CSSVar(key, config === null || config === void 0 ? void 0 : config.prefix);
			cssVars[cssVar] = typeof value === "number" && !(config !== null && config !== void 0 && (_config$unitless = config.unitless) !== null && _config$unitless !== void 0 && _config$unitless[key]) ? "".concat(value, "px") : String(value);
			result[key] = "var(".concat(cssVar, ")");
		}
	});
	return [result, serializeCSSVar(cssVars, themeKey, { scope: config === null || config === void 0 ? void 0 : config.scope })];
};

//#endregion
//#region node_modules/rc-util/es/hooks/useLayoutEffect.js
/**
* Wrap `React.useLayoutEffect` which will not throw warning message in test env
*/
var useInternalLayoutEffect = canUseDom() ? import_react.useLayoutEffect : import_react.useEffect;
var useLayoutEffect$2 = function useLayoutEffect$3(callback, deps) {
	var firstMountRef = import_react.useRef(true);
	useInternalLayoutEffect(function() {
		return callback(firstMountRef.current);
	}, deps);
	useInternalLayoutEffect(function() {
		firstMountRef.current = false;
		return function() {
			firstMountRef.current = true;
		};
	}, []);
};
var useLayoutUpdateEffect = function useLayoutUpdateEffect$1(callback, deps) {
	useLayoutEffect$2(function(firstMount) {
		if (!firstMount) return callback();
	}, deps);
};
var useLayoutEffect_default = useLayoutEffect$2;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js
var useInsertionEffect = _objectSpread2({}, import_react).useInsertionEffect;
/**
* Compatible `useInsertionEffect`
* will use `useInsertionEffect` if React version >= 18,
* otherwise use `useInsertionEffectPolyfill`.
*/
var useCompatibleInsertionEffect = useInsertionEffect ? function(renderEffect, effect, deps) {
	return useInsertionEffect(function() {
		renderEffect();
		return effect();
	}, deps);
} : function useInsertionEffectPolyfill(renderEffect, effect, deps) {
	import_react.useMemo(renderEffect, deps);
	useLayoutEffect_default(function() {
		return effect(true);
	}, deps);
};
var useCompatibleInsertionEffect_default = useCompatibleInsertionEffect;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js
var useEffectCleanupRegister = typeof _objectSpread2({}, import_react).useInsertionEffect !== "undefined" ? function useCleanupRegister(deps) {
	var effectCleanups = [];
	var cleanupFlag = false;
	function register(fn) {
		if (cleanupFlag) {
			warning(false, "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect.");
			return;
		}
		effectCleanups.push(fn);
	}
	import_react.useEffect(function() {
		cleanupFlag = false;
		return function() {
			cleanupFlag = true;
			if (effectCleanups.length) effectCleanups.forEach(function(fn) {
				return fn();
			});
		};
	}, deps);
	return register;
} : function useRun() {
	return function(fn) {
		fn();
	};
};
var useEffectCleanupRegister_default = useEffectCleanupRegister;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useHMR.js
var webpackHMR = false;
function useDevHMR() {
	return webpackHMR;
}
var useHMR_default = useDevHMR;
if (typeof module !== "undefined" && module && module.hot && typeof window !== "undefined") {
	var win = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : null;
	if (win && typeof win.webpackHotUpdate === "function") {
		var originWebpackHotUpdate = win.webpackHotUpdate;
		win.webpackHotUpdate = function() {
			webpackHMR = true;
			setTimeout(function() {
				webpackHMR = false;
			}, 0);
			return originWebpackHotUpdate.apply(void 0, arguments);
		};
	}
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js
function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
	var _React$useContext = import_react.useContext(StyleContext_default), globalCache = _React$useContext.cache;
	var fullPath = [prefix].concat(_toConsumableArray(keyPath));
	var fullPathStr = pathKey(fullPath);
	var register = useEffectCleanupRegister_default([fullPathStr]);
	var HMRUpdate = useHMR_default();
	var buildCache = function buildCache$1(updater) {
		globalCache.opUpdate(fullPathStr, function(prevCache) {
			var _ref = prevCache || [void 0, void 0], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
			var tmpCache = cache;
			if (cache && HMRUpdate) {
				onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(tmpCache, HMRUpdate);
				tmpCache = null;
			}
			var mergedCache = tmpCache || cacheFn();
			var data = [times, mergedCache];
			return updater ? updater(data) : data;
		});
	};
	import_react.useMemo(function() {
		buildCache();
	}, [fullPathStr]);
	var cacheEntity = globalCache.opGet(fullPathStr);
	if (!cacheEntity) {
		buildCache();
		cacheEntity = globalCache.opGet(fullPathStr);
	}
	var cacheContent = cacheEntity[1];
	useCompatibleInsertionEffect_default(function() {
		onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
	}, function(polyfill) {
		buildCache(function(_ref3) {
			var _ref4 = _slicedToArray(_ref3, 2), times = _ref4[0], cache = _ref4[1];
			if (polyfill && times === 0) onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
			return [times + 1, cache];
		});
		return function() {
			globalCache.opUpdate(fullPathStr, function(prevCache) {
				var _ref5 = prevCache || [], _ref6 = _slicedToArray(_ref5, 2), _ref6$ = _ref6[0], times = _ref6$ === void 0 ? 0 : _ref6$, cache = _ref6[1];
				if (times - 1 === 0) {
					register(function() {
						if (polyfill || !globalCache.opGet(fullPathStr)) onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(cache, false);
					});
					return null;
				}
				return [times - 1, cache];
			});
		};
	}, [fullPathStr]);
	return cacheContent;
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js
var EMPTY_OVERRIDE = {};
var hashPrefix = "css-dev-only-do-not-override";
var tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
	tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key, instanceId) {
	if (typeof document !== "undefined") document.querySelectorAll("style[".concat(ATTR_TOKEN, "=\"").concat(key, "\"]")).forEach(function(style$1) {
		if (style$1[CSS_IN_JS_INSTANCE] === instanceId) {
			var _style$parentNode;
			(_style$parentNode = style$1.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style$1);
		}
	});
}
var TOKEN_THRESHOLD = 0;
function cleanTokenStyle(tokenKey, instanceId) {
	tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
	var cleanableKeyList = /* @__PURE__ */ new Set();
	tokenKeys.forEach(function(value, key) {
		if (value <= 0) cleanableKeyList.add(key);
	});
	if (tokenKeys.size - cleanableKeyList.size > TOKEN_THRESHOLD) cleanableKeyList.forEach(function(key) {
		removeStyleTags(key, instanceId);
		tokenKeys.delete(key);
	});
}
var getComputedToken = function getComputedToken$2(originToken, overrideToken, theme, format$2) {
	var derivativeToken = theme.getDerivativeToken(originToken);
	var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, derivativeToken), overrideToken);
	if (format$2) mergedDerivativeToken = format$2(mergedDerivativeToken);
	return mergedDerivativeToken;
};
var TOKEN_PREFIX = "token";
/**
* Cache theme derivative token as global shared one
* @param theme Theme entity
* @param tokens List of tokens, used for cache. Please do not dynamic generate object directly
* @param option Additional config
* @returns Call Theme.getDerivativeToken(tokenObject) to get token
*/
function useCacheToken(theme, tokens) {
	var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
	var _useContext = (0, import_react.useContext)(StyleContext_default), instanceId = _useContext.cache.instanceId, container = _useContext.container;
	var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken$1 = option.formatToken, compute = option.getComputedToken, cssVar = option.cssVar;
	var mergedToken = memoResult(function() {
		return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
	}, tokens);
	var tokenStr = flattenToken(mergedToken);
	var overrideTokenStr = flattenToken(override);
	var cssVarStr = cssVar ? flattenToken(cssVar) : "";
	return useGlobalCache(TOKEN_PREFIX, [
		salt,
		theme.id,
		tokenStr,
		overrideTokenStr,
		cssVarStr
	], function() {
		var _cssVar$key;
		var mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken(mergedToken, override, theme, formatToken$1);
		var actualToken = _objectSpread2({}, mergedDerivativeToken);
		var cssVarsStr = "";
		if (!!cssVar) {
			var _transformToken = transformToken(mergedDerivativeToken, cssVar.key, {
				prefix: cssVar.prefix,
				ignore: cssVar.ignore,
				unitless: cssVar.unitless,
				preserve: cssVar.preserve
			});
			var _transformToken2 = _slicedToArray(_transformToken, 2);
			mergedDerivativeToken = _transformToken2[0];
			cssVarsStr = _transformToken2[1];
		}
		var tokenKey = token2key(mergedDerivativeToken, salt);
		mergedDerivativeToken._tokenKey = tokenKey;
		actualToken._tokenKey = token2key(actualToken, salt);
		var themeKey = (_cssVar$key = cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) !== null && _cssVar$key !== void 0 ? _cssVar$key : tokenKey;
		mergedDerivativeToken._themeKey = themeKey;
		recordCleanToken(themeKey);
		var hashId = "".concat(hashPrefix, "-").concat(hash_browser_esm_default(tokenKey));
		mergedDerivativeToken._hashId = hashId;
		return [
			mergedDerivativeToken,
			hashId,
			actualToken,
			cssVarsStr,
			(cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) || ""
		];
	}, function(cache) {
		cleanTokenStyle(cache[0]._themeKey, instanceId);
	}, function(_ref) {
		var _ref2 = _slicedToArray(_ref, 4), token$1 = _ref2[0], cssVarsStr = _ref2[3];
		if (cssVar && cssVarsStr) {
			var style$1 = updateCSS(cssVarsStr, hash_browser_esm_default("css-variables-".concat(token$1._themeKey)), {
				mark: ATTR_MARK,
				prepend: "queue",
				attachTo: container,
				priority: -999
			});
			style$1[CSS_IN_JS_INSTANCE] = instanceId;
			style$1.setAttribute(ATTR_TOKEN, token$1._themeKey);
		}
	});
}
var extract = function extract$3(cache, effectStyles, options) {
	var _cache = _slicedToArray(cache, 5), realToken = _cache[2], styleStr = _cache[3], cssVarKey = _cache[4];
	var _ref3 = options || {}, plain = _ref3.plain;
	if (!styleStr) return null;
	var styleId = realToken._tokenKey;
	var order = -999;
	var sharedAttrs = {
		"data-rc-order": "prependQueue",
		"data-rc-priority": "".concat(order)
	};
	var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
	return [
		order,
		styleId,
		styleText
	];
};

//#endregion
//#region node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
	animationIterationCount: 1,
	borderImageOutset: 1,
	borderImageSlice: 1,
	borderImageWidth: 1,
	boxFlex: 1,
	boxFlexGroup: 1,
	boxOrdinalGroup: 1,
	columnCount: 1,
	columns: 1,
	flex: 1,
	flexGrow: 1,
	flexPositive: 1,
	flexShrink: 1,
	flexNegative: 1,
	flexOrder: 1,
	gridRow: 1,
	gridRowEnd: 1,
	gridRowSpan: 1,
	gridRowStart: 1,
	gridColumn: 1,
	gridColumnEnd: 1,
	gridColumnSpan: 1,
	gridColumnStart: 1,
	msGridRow: 1,
	msGridRowSpan: 1,
	msGridColumn: 1,
	msGridColumnSpan: 1,
	fontWeight: 1,
	lineHeight: 1,
	opacity: 1,
	order: 1,
	orphans: 1,
	tabSize: 1,
	widows: 1,
	zIndex: 1,
	zoom: 1,
	WebkitLineClamp: 1,
	fillOpacity: 1,
	floodOpacity: 1,
	stopOpacity: 1,
	strokeDasharray: 1,
	strokeDashoffset: 1,
	strokeMiterlimit: 1,
	strokeOpacity: 1,
	strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

//#endregion
//#region node_modules/stylis/src/Enum.js
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var NAMESPACE = "@namespace";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

//#endregion
//#region node_modules/stylis/src/Utility.js
/**
* @param {number}
* @return {number}
*/
var abs = Math.abs;
/**
* @param {number}
* @return {string}
*/
var from = String.fromCharCode;
/**
* @param {string} value
* @return {string}
*/
function trim(value) {
	return value.trim();
}
/**
* @param {string} value
* @param {(string|RegExp)} pattern
* @param {string} replacement
* @return {string}
*/
function replace(value, pattern$3, replacement) {
	return value.replace(pattern$3, replacement);
}
/**
* @param {string} value
* @param {string} search
* @param {number} position
* @return {number}
*/
function indexof(value, search, position$2) {
	return value.indexOf(search, position$2);
}
/**
* @param {string} value
* @param {number} index
* @return {number}
*/
function charat(value, index$2) {
	return value.charCodeAt(index$2) | 0;
}
/**
* @param {string} value
* @param {number} begin
* @param {number} end
* @return {string}
*/
function substr(value, begin, end) {
	return value.slice(begin, end);
}
/**
* @param {string} value
* @return {number}
*/
function strlen(value) {
	return value.length;
}
/**
* @param {any[]} value
* @return {number}
*/
function sizeof(value) {
	return value.length;
}
/**
* @param {any} value
* @param {any[]} array
* @return {any}
*/
function append(value, array$1) {
	return array$1.push(value), value;
}

//#endregion
//#region node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position$1 = 0;
var character = 0;
var characters = "";
/**
* @param {string} value
* @param {object | null} root
* @param {object | null} parent
* @param {string} type
* @param {string[] | string} props
* @param {object[] | string} children
* @param {object[]} siblings
* @param {number} length
*/
function node(value, root, parent, type$2, props, children, length$1, siblings) {
	return {
		value,
		root,
		parent,
		type: type$2,
		props,
		children,
		line,
		column,
		length: length$1,
		return: "",
		siblings
	};
}
/**
* @return {number}
*/
function char() {
	return character;
}
/**
* @return {number}
*/
function prev() {
	character = position$1 > 0 ? charat(characters, --position$1) : 0;
	if (column--, character === 10) column = 1, line--;
	return character;
}
/**
* @return {number}
*/
function next() {
	character = position$1 < length ? charat(characters, position$1++) : 0;
	if (column++, character === 10) column = 1, line++;
	return character;
}
/**
* @return {number}
*/
function peek() {
	return charat(characters, position$1);
}
/**
* @return {number}
*/
function caret() {
	return position$1;
}
/**
* @param {number} begin
* @param {number} end
* @return {string}
*/
function slice(begin, end) {
	return substr(characters, begin, end);
}
/**
* @param {number} type
* @return {number}
*/
function token(type$2) {
	switch (type$2) {
		case 0:
		case 9:
		case 10:
		case 13:
		case 32: return 5;
		case 33:
		case 43:
		case 44:
		case 47:
		case 62:
		case 64:
		case 126:
		case 59:
		case 123:
		case 125: return 4;
		case 58: return 3;
		case 34:
		case 39:
		case 40:
		case 91: return 2;
		case 41:
		case 93: return 1;
	}
	return 0;
}
/**
* @param {string} value
* @return {any[]}
*/
function alloc(value) {
	return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
}
/**
* @param {any} value
* @return {any}
*/
function dealloc(value) {
	return characters = "", value;
}
/**
* @param {number} type
* @return {string}
*/
function delimit(type$2) {
	return trim(slice(position$1 - 1, delimiter(type$2 === 91 ? type$2 + 2 : type$2 === 40 ? type$2 + 1 : type$2)));
}
/**
* @param {number} type
* @return {string}
*/
function whitespace$1(type$2) {
	while (character = peek()) if (character < 33) next();
	else break;
	return token(type$2) > 2 || token(character) > 3 ? "" : " ";
}
/**
* @param {number} index
* @param {number} count
* @return {string}
*/
function escaping(index$2, count) {
	while (--count && next()) if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
	return slice(index$2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
/**
* @param {number} type
* @return {number}
*/
function delimiter(type$2) {
	while (next()) switch (character) {
		case type$2: return position$1;
		case 34:
		case 39:
			if (type$2 !== 34 && type$2 !== 39) delimiter(character);
			break;
		case 40:
			if (type$2 === 41) delimiter(type$2);
			break;
		case 92:
			next();
			break;
	}
	return position$1;
}
/**
* @param {number} type
* @param {number} index
* @return {number}
*/
function commenter(type$2, index$2) {
	while (next()) if (type$2 + character === 57) break;
	else if (type$2 + character === 84 && peek() === 47) break;
	return "/*" + slice(index$2, position$1 - 1) + "*" + from(type$2 === 47 ? type$2 : next());
}
/**
* @param {number} index
* @return {string}
*/
function identifier(index$2) {
	while (!token(peek())) next();
	return slice(index$2, position$1);
}

//#endregion
//#region node_modules/stylis/src/Parser.js
/**
* @param {string} value
* @return {object[]}
*/
function compile(value) {
	return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {string[]} rule
* @param {string[]} rules
* @param {string[]} rulesets
* @param {number[]} pseudo
* @param {number[]} points
* @param {string[]} declarations
* @return {object}
*/
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index$2 = 0;
	var offset$2 = 0;
	var length$1 = pseudo;
	var atrule = 0;
	var property = 0;
	var previous = 0;
	var variable = 1;
	var scanning = 1;
	var ampersand = 1;
	var character$1 = 0;
	var type$2 = "";
	var props = rules;
	var children = rulesets;
	var reference = rule;
	var characters$1 = type$2;
	while (scanning) switch (previous = character$1, character$1 = next()) {
		case 40: if (previous != 108 && charat(characters$1, length$1 - 1) == 58) {
			if (indexof(characters$1 += replace(delimit(character$1), "&", "&\f"), "&\f", abs(index$2 ? points[index$2 - 1] : 0)) != -1) ampersand = -1;
			break;
		}
		case 34:
		case 39:
		case 91:
			characters$1 += delimit(character$1);
			break;
		case 9:
		case 10:
		case 13:
		case 32:
			characters$1 += whitespace$1(previous);
			break;
		case 92:
			characters$1 += escaping(caret() - 1, 7);
			continue;
		case 47:
			switch (peek()) {
				case 42:
				case 47:
					append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
					if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters$1) && substr(characters$1, -1, void 0) !== " ") characters$1 += " ";
					break;
				default: characters$1 += "/";
			}
			break;
		case 123 * variable: points[index$2++] = strlen(characters$1) * ampersand;
		case 125 * variable:
		case 59:
		case 0:
			switch (character$1) {
				case 0:
				case 125: scanning = 0;
				case 59 + offset$2:
					if (ampersand == -1) characters$1 = replace(characters$1, /\f/g, "");
					if (property > 0 && (strlen(characters$1) - length$1 || variable === 0 && previous === 47)) append(property > 32 ? declaration(characters$1 + ";", rule, parent, length$1 - 1, declarations) : declaration(replace(characters$1, " ", "") + ";", rule, parent, length$1 - 2, declarations), declarations);
					break;
				case 59: characters$1 += ";";
				default:
					append(reference = ruleset(characters$1, root, parent, index$2, offset$2, rules, points, type$2, props = [], children = [], length$1, rulesets), rulesets);
					if (character$1 === 123) if (offset$2 === 0) parse(characters$1, root, reference, reference, props, rulesets, length$1, points, children);
					else {
						switch (atrule) {
							case 99: if (charat(characters$1, 3) === 110) break;
							case 108: if (charat(characters$1, 2) === 97) break;
							default: offset$2 = 0;
							case 100:
							case 109:
							case 115:
						}
						if (offset$2) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type$2, rules, props = [], length$1, children), children), rules, children, length$1, points, rule ? props : children);
						else parse(characters$1, reference, reference, reference, [""], children, 0, points, children);
					}
			}
			index$2 = offset$2 = property = 0, variable = ampersand = 1, type$2 = characters$1 = "", length$1 = pseudo;
			break;
		case 58: length$1 = 1 + strlen(characters$1), property = previous;
		default:
			if (variable < 1) {
				if (character$1 == 123) --variable;
				else if (character$1 == 125 && variable++ == 0 && prev() == 125) continue;
			}
			switch (characters$1 += from(character$1), character$1 * variable) {
				case 38:
					ampersand = offset$2 > 0 ? 1 : (characters$1 += "\f", -1);
					break;
				case 44:
					points[index$2++] = (strlen(characters$1) - 1) * ampersand, ampersand = 1;
					break;
				case 64:
					if (peek() === 45) characters$1 += delimit(next());
					atrule = peek(), offset$2 = length$1 = strlen(type$2 = characters$1 += identifier(caret())), character$1++;
					break;
				case 45: if (previous === 45 && strlen(characters$1) == 2) variable = 0;
			}
	}
	return rulesets;
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {number} index
* @param {number} offset
* @param {string[]} rules
* @param {number[]} points
* @param {string} type
* @param {string[]} props
* @param {string[]} children
* @param {number} length
* @param {object[]} siblings
* @return {object}
*/
function ruleset(value, root, parent, index$2, offset$2, rules, points, type$2, props, children, length$1, siblings) {
	var post = offset$2 - 1;
	var rule = offset$2 === 0 ? rules : [""];
	var size = sizeof(rule);
	for (var i = 0, j = 0, k = 0; i < index$2; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
	return node(value, root, parent, offset$2 === 0 ? RULESET : type$2, props, children, length$1, siblings);
}
/**
* @param {number} value
* @param {object} root
* @param {object?} parent
* @param {object[]} siblings
* @return {object}
*/
function comment(value, root, parent, siblings) {
	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
/**
* @param {string} value
* @param {object} root
* @param {object?} parent
* @param {number} length
* @param {object[]} siblings
* @return {object}
*/
function declaration(value, root, parent, length$1, siblings) {
	return node(value, root, parent, DECLARATION, substr(value, 0, length$1), substr(value, length$1 + 1, -1), length$1, siblings);
}

//#endregion
//#region node_modules/stylis/src/Serializer.js
/**
* @param {object[]} children
* @param {function} callback
* @return {string}
*/
function serialize(children, callback) {
	var output = "";
	for (var i = 0; i < children.length; i++) output += callback(children[i], i, children, callback) || "";
	return output;
}
/**
* @param {object} element
* @param {number} index
* @param {object[]} children
* @param {function} callback
* @return {string}
*/
function stringify$2(element, index$2, children, callback) {
	switch (element.type) {
		case LAYER: if (element.children.length) break;
		case IMPORT:
		case NAMESPACE:
		case DECLARATION: return element.return = element.return || element.value;
		case COMMENT: return "";
		case KEYFRAMES: return element.return = element.value + "{" + serialize(element.children, callback) + "}";
		case RULESET: if (!strlen(element.value = element.props.join(","))) return "";
	}
	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/linters/utils.js
function lintWarning(message$1, info) {
	var path$1 = info.path, parentSelectors = info.parentSelectors;
	warning_default(false, "[Ant Design CSS-in-JS] ".concat(path$1 ? "Error in ".concat(path$1, ": ") : "").concat(message$1).concat(parentSelectors.length ? " Selector: ".concat(parentSelectors.join(" | ")) : ""));
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/linters/contentQuotesLinter.js
var linter$1 = function linter$2(key, value, info) {
	if (key === "content") {
		if (typeof value !== "string" || [
			"normal",
			"none",
			"initial",
			"inherit",
			"unset"
		].indexOf(value) === -1 && !/(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== "\"" && value.charAt(0) !== "'")) lintWarning("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(value, "\"'`."), info);
	}
};
var contentQuotesLinter_default = linter$1;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/linters/hashedAnimationLinter.js
var linter = function linter$2(key, value, info) {
	if (key === "animation") {
		if (info.hashId && value !== "none") lintWarning("You seem to be using hashed animation '".concat(value, "', in which case 'animationName' with Keyframe as value is recommended."), info);
	}
};
var hashedAnimationLinter_default = linter;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/util/cacheMapUtil.js
var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
/**
* This marks style from the css file.
* Which means not exist in `<style />` tag.
*/
var CSS_FILE_STYLE = "_FILE_STYLE__";
var cachePathMap;
var fromCSSFile = true;
function prepare() {
	if (!cachePathMap) {
		cachePathMap = {};
		if (canUseDom()) {
			var div = document.createElement("div");
			div.className = ATTR_CACHE_MAP;
			div.style.position = "fixed";
			div.style.visibility = "hidden";
			div.style.top = "-9999px";
			document.body.appendChild(div);
			var content = getComputedStyle(div).content || "";
			content = content.replace(/^"/, "").replace(/"$/, "");
			content.split(";").forEach(function(item) {
				var _item$split = item.split(":"), _item$split2 = _slicedToArray(_item$split, 2), path$1 = _item$split2[0];
				cachePathMap[path$1] = _item$split2[1];
			});
			var inlineMapStyle = document.querySelector("style[".concat(ATTR_CACHE_MAP, "]"));
			if (inlineMapStyle) {
				var _inlineMapStyle$paren;
				fromCSSFile = false;
				(_inlineMapStyle$paren = inlineMapStyle.parentNode) === null || _inlineMapStyle$paren === void 0 || _inlineMapStyle$paren.removeChild(inlineMapStyle);
			}
			document.body.removeChild(div);
		}
	}
}
function existPath(path$1) {
	prepare();
	return !!cachePathMap[path$1];
}
function getStyleAndHash(path$1) {
	var hash = cachePathMap[path$1];
	var styleStr = null;
	if (hash && canUseDom()) if (fromCSSFile) styleStr = CSS_FILE_STYLE;
	else {
		var _style = document.querySelector("style[".concat(ATTR_MARK, "=\"").concat(cachePathMap[path$1], "\"]"));
		if (_style) styleStr = _style.innerHTML;
		else delete cachePathMap[path$1];
	}
	return [styleStr, hash];
}

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js
var SKIP_CHECK = "_skip_check_";
var MULTI_VALUE = "_multi_value_";
function normalizeStyle(styleStr) {
	return serialize(compile(styleStr), stringify$2).replace(/\{%%%\:[^;];}/g, ";");
}
function isCompoundCSSProperty(value) {
	return _typeof(value) === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
}
function injectSelectorHash(key, hashId, hashPriority) {
	if (!hashId) return key;
	var hashClassName = ".".concat(hashId);
	var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
	return key.split(",").map(function(k) {
		var _firstPath$match;
		var fullPath = k.trim().split(/\s+/);
		var firstPath = fullPath[0] || "";
		var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
		firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
		return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
	}).join(",");
}
var parseStyle = function parseStyle$1(interpolation) {
	var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
		root: true,
		parentSelectors: []
	}, root = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
	var hashId = config.hashId, layer = config.layer, path$1 = config.path, hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers, _config$linters = config.linters, linters = _config$linters === void 0 ? [] : _config$linters;
	var styleStr = "";
	var effectStyle = {};
	function parseKeyframes(keyframes) {
		var animationName = keyframes.getName(hashId);
		if (!effectStyle[animationName]) {
			var _parseStyle = parseStyle$1(keyframes.style, config, {
				root: false,
				parentSelectors
			}), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
			effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
		}
	}
	function flattenList(list) {
		var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
		list.forEach(function(item) {
			if (Array.isArray(item)) flattenList(item, fullList);
			else if (item) fullList.push(item);
		});
		return fullList;
	}
	flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]).forEach(function(originStyle) {
		var style$1 = typeof originStyle === "string" && !root ? {} : originStyle;
		if (typeof style$1 === "string") styleStr += "".concat(style$1, "\n");
		else if (style$1._keyframe) parseKeyframes(style$1);
		else {
			var mergedStyle = transformers.reduce(function(prev$1, trans) {
				var _trans$visit;
				return (trans === null || trans === void 0 || (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev$1)) || prev$1;
			}, style$1);
			Object.keys(mergedStyle).forEach(function(key) {
				var value = mergedStyle[key];
				if (_typeof(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
					var subInjectHash = false;
					var mergedKey = key.trim();
					var nextRoot = false;
					if ((root || injectHash) && hashId) if (mergedKey.startsWith("@")) subInjectHash = true;
					else if (mergedKey === "&") mergedKey = injectSelectorHash("", hashId, hashPriority);
					else mergedKey = injectSelectorHash(key, hashId, hashPriority);
					else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
						mergedKey = "";
						nextRoot = true;
					}
					var _parseStyle3 = parseStyle$1(value, config, {
						root: nextRoot,
						injectHash: subInjectHash,
						parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
					}), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
					effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle);
					styleStr += "".concat(mergedKey).concat(_parsedStr2);
				} else {
					var _value;
					function appendStyle(cssKey, cssValue) {
						if (_typeof(value) !== "object" || !(value !== null && value !== void 0 && value[SKIP_CHECK])) [contentQuotesLinter_default, hashedAnimationLinter_default].concat(_toConsumableArray(linters)).forEach(function(linter$2) {
							return linter$2(cssKey, cssValue, {
								path: path$1,
								hashId,
								parentSelectors
							});
						});
						var styleName = cssKey.replace(/[A-Z]/g, function(match$1) {
							return "-".concat(match$1.toLowerCase());
						});
						var formatValue$1 = cssValue;
						if (!unitless_browser_esm_default[cssKey] && typeof formatValue$1 === "number" && formatValue$1 !== 0) formatValue$1 = "".concat(formatValue$1, "px");
						if (cssKey === "animationName" && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
							parseKeyframes(cssValue);
							formatValue$1 = cssValue.getName(hashId);
						}
						styleStr += "".concat(styleName, ":").concat(formatValue$1, ";");
					}
					var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
					if (_typeof(value) === "object" && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) actualValue.forEach(function(item) {
						appendStyle(key, item);
					});
					else appendStyle(key, actualValue);
				}
			});
		}
	});
	if (!root) styleStr = "{".concat(styleStr, "}");
	else if (layer) {
		if (styleStr) styleStr = "@layer ".concat(layer.name, " {").concat(styleStr, "}");
		if (layer.dependencies) effectStyle["@layer ".concat(layer.name)] = layer.dependencies.map(function(deps) {
			return "@layer ".concat(deps, ", ").concat(layer.name, ";");
		}).join("\n");
	}
	return [styleStr, effectStyle];
};
function uniqueHash(path$1, styleStr) {
	return hash_browser_esm_default("".concat(path$1.join("%")).concat(styleStr));
}
function Empty$2() {
	return null;
}
var STYLE_PREFIX = "style";
/**
* Register a style to the global style sheet.
*/
function useStyleRegister(info, styleFn) {
	var token$1 = info.token, path$1 = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce, clientOnly = info.clientOnly, _info$order = info.order, order = _info$order === void 0 ? 0 : _info$order;
	var _React$useContext = import_react.useContext(StyleContext_default), autoClear = _React$useContext.autoClear, mock = _React$useContext.mock, defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache, enableLayer = _React$useContext.layer;
	var tokenKey = token$1._tokenKey;
	var fullPath = [tokenKey];
	if (enableLayer) fullPath.push("layer");
	fullPath.push.apply(fullPath, _toConsumableArray(path$1));
	var isMergedClientSide = isClientSide;
	if (mock !== void 0) isMergedClientSide = mock === "client";
	var _useGlobalCache = useGlobalCache(STYLE_PREFIX, fullPath, function() {
		var cachePath = fullPath.join("|");
		if (existPath(cachePath)) {
			var _getStyleAndHash = getStyleAndHash(cachePath), _getStyleAndHash2 = _slicedToArray(_getStyleAndHash, 2), inlineCacheStyleStr = _getStyleAndHash2[0], styleHash = _getStyleAndHash2[1];
			if (inlineCacheStyleStr) return [
				inlineCacheStyleStr,
				tokenKey,
				styleHash,
				{},
				clientOnly,
				order
			];
		}
		var styleObj = styleFn();
		var _parseStyle5 = parseStyle(styleObj, {
			hashId,
			hashPriority,
			layer: enableLayer ? layer : void 0,
			path: path$1.join("-"),
			transformers,
			linters
		}), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
		var styleStr = normalizeStyle(parsedStyle);
		var styleId = uniqueHash(fullPath, styleStr);
		return [
			styleStr,
			tokenKey,
			styleId,
			effectStyle,
			clientOnly,
			order
		];
	}, function(_ref2, fromHMR) {
		var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
		if ((fromHMR || autoClear) && isClientSide) removeCSS(styleId, {
			mark: ATTR_MARK,
			attachTo: container
		});
	}, function(_ref4) {
		var _ref5 = _slicedToArray(_ref4, 4), styleStr = _ref5[0];
		_ref5[1];
		var styleId = _ref5[2], effectStyle = _ref5[3];
		if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
			var mergedCSSConfig = {
				mark: ATTR_MARK,
				prepend: enableLayer ? false : "queue",
				attachTo: container,
				priority: order
			};
			var nonceStr = typeof nonce === "function" ? nonce() : nonce;
			if (nonceStr) mergedCSSConfig.csp = { nonce: nonceStr };
			var effectLayerKeys = [];
			var effectRestKeys = [];
			Object.keys(effectStyle).forEach(function(key) {
				if (key.startsWith("@layer")) effectLayerKeys.push(key);
				else effectRestKeys.push(key);
			});
			effectLayerKeys.forEach(function(effectKey) {
				updateCSS(normalizeStyle(effectStyle[effectKey]), "_layer-".concat(effectKey), _objectSpread2(_objectSpread2({}, mergedCSSConfig), {}, { prepend: true }));
			});
			var style$1 = updateCSS(styleStr, styleId, mergedCSSConfig);
			style$1[CSS_IN_JS_INSTANCE] = cache.instanceId;
			style$1.setAttribute(ATTR_TOKEN, tokenKey);
			style$1.setAttribute(ATTR_CACHE_PATH, fullPath.join("|"));
			effectRestKeys.forEach(function(effectKey) {
				updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
			});
		}
	}), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
	return function(node$1) {
		var styleNode;
		if (!ssrInline || isMergedClientSide || !defaultCache) styleNode = /* @__PURE__ */ import_react.createElement(Empty$2, null);
		else styleNode = /* @__PURE__ */ import_react.createElement("style", _extends({}, _defineProperty(_defineProperty({}, ATTR_TOKEN, cachedTokenKey), ATTR_MARK, cachedStyleId), { dangerouslySetInnerHTML: { __html: cachedStyleStr } }));
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, styleNode, node$1);
	};
}
var extract$2 = function extract$3(cache, effectStyles, options) {
	var _cache = _slicedToArray(cache, 6), styleStr = _cache[0], tokenKey = _cache[1], styleId = _cache[2], effectStyle = _cache[3], clientOnly = _cache[4], order = _cache[5];
	var _ref7 = options || {}, plain = _ref7.plain;
	if (clientOnly) return null;
	var keyStyleText = styleStr;
	var sharedAttrs = {
		"data-rc-order": "prependQueue",
		"data-rc-priority": "".concat(order)
	};
	keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs, plain);
	if (effectStyle) Object.keys(effectStyle).forEach(function(effectKey) {
		if (!effectStyles[effectKey]) {
			effectStyles[effectKey] = true;
			var effectStyleStr = normalizeStyle(effectStyle[effectKey]);
			var effectStyleHTML = toStyleStr(effectStyleStr, tokenKey, "_effect-".concat(effectKey), sharedAttrs, plain);
			if (effectKey.startsWith("@layer")) keyStyleText = effectStyleHTML + keyStyleText;
			else keyStyleText += effectStyleHTML;
		}
	});
	return [
		order,
		styleId,
		keyStyleText
	];
};

//#endregion
//#region node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js
var CSS_VAR_PREFIX = "cssVar";
var useCSSVarRegister = function useCSSVarRegister$1(config, fn) {
	var key = config.key, prefix = config.prefix, unitless$1 = config.unitless, ignore$1 = config.ignore, token$1 = config.token, _config$scope = config.scope, scope = _config$scope === void 0 ? "" : _config$scope;
	var _useContext = (0, import_react.useContext)(StyleContext_default), instanceId = _useContext.cache.instanceId, container = _useContext.container;
	var tokenKey = token$1._tokenKey;
	var stylePath = [].concat(_toConsumableArray(config.path), [
		key,
		scope,
		tokenKey
	]);
	return useGlobalCache(CSS_VAR_PREFIX, stylePath, function() {
		var originToken = fn();
		var _transformToken = transformToken(originToken, key, {
			prefix,
			unitless: unitless$1,
			ignore: ignore$1,
			scope
		}), _transformToken2 = _slicedToArray(_transformToken, 2), mergedToken = _transformToken2[0], cssVarsStr = _transformToken2[1];
		var styleId = uniqueHash(stylePath, cssVarsStr);
		return [
			mergedToken,
			cssVarsStr,
			styleId,
			key
		];
	}, function(_ref) {
		var _ref2 = _slicedToArray(_ref, 3), styleId = _ref2[2];
		if (isClientSide) removeCSS(styleId, {
			mark: ATTR_MARK,
			attachTo: container
		});
	}, function(_ref3) {
		var _ref4 = _slicedToArray(_ref3, 3), cssVarsStr = _ref4[1], styleId = _ref4[2];
		if (!cssVarsStr) return;
		var style$1 = updateCSS(cssVarsStr, styleId, {
			mark: ATTR_MARK,
			prepend: "queue",
			attachTo: container,
			priority: -999
		});
		style$1[CSS_IN_JS_INSTANCE] = instanceId;
		style$1.setAttribute(ATTR_TOKEN, key);
	});
};
var extract$1 = function extract$3(cache, effectStyles, options) {
	var _cache = _slicedToArray(cache, 4), styleStr = _cache[1], styleId = _cache[2], cssVarKey = _cache[3];
	var _ref5 = options || {}, plain = _ref5.plain;
	if (!styleStr) return null;
	var order = -999;
	var sharedAttrs = {
		"data-rc-order": "prependQueue",
		"data-rc-priority": "".concat(order)
	};
	var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
	return [
		order,
		styleId,
		styleText
	];
};
var useCSSVarRegister_default = useCSSVarRegister;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/extractStyle.js
var ExtractStyleFns = _defineProperty(_defineProperty(_defineProperty({}, STYLE_PREFIX, extract$2), TOKEN_PREFIX, extract), CSS_VAR_PREFIX, extract$1);

//#endregion
//#region node_modules/@ant-design/cssinjs/es/Keyframes.js
var Keyframe = /* @__PURE__ */ function() {
	function Keyframe$1(name, style$1) {
		_classCallCheck(this, Keyframe$1);
		_defineProperty(this, "name", void 0);
		_defineProperty(this, "style", void 0);
		_defineProperty(this, "_keyframe", true);
		this.name = name;
		this.style = style$1;
	}
	_createClass(Keyframe$1, [{
		key: "getName",
		value: function getName() {
			var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
			return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
		}
	}]);
	return Keyframe$1;
}();
var Keyframes_default = Keyframe;

//#endregion
//#region node_modules/@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js
function noSplit(list) {
	list.notSplit = true;
	return list;
}
var keyMap = {
	inset: [
		"top",
		"right",
		"bottom",
		"left"
	],
	insetBlock: ["top", "bottom"],
	insetBlockStart: ["top"],
	insetBlockEnd: ["bottom"],
	insetInline: ["left", "right"],
	insetInlineStart: ["left"],
	insetInlineEnd: ["right"],
	marginBlock: ["marginTop", "marginBottom"],
	marginBlockStart: ["marginTop"],
	marginBlockEnd: ["marginBottom"],
	marginInline: ["marginLeft", "marginRight"],
	marginInlineStart: ["marginLeft"],
	marginInlineEnd: ["marginRight"],
	paddingBlock: ["paddingTop", "paddingBottom"],
	paddingBlockStart: ["paddingTop"],
	paddingBlockEnd: ["paddingBottom"],
	paddingInline: ["paddingLeft", "paddingRight"],
	paddingInlineStart: ["paddingLeft"],
	paddingInlineEnd: ["paddingRight"],
	borderBlock: noSplit(["borderTop", "borderBottom"]),
	borderBlockStart: noSplit(["borderTop"]),
	borderBlockEnd: noSplit(["borderBottom"]),
	borderInline: noSplit(["borderLeft", "borderRight"]),
	borderInlineStart: noSplit(["borderLeft"]),
	borderInlineEnd: noSplit(["borderRight"]),
	borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
	borderBlockStartWidth: ["borderTopWidth"],
	borderBlockEndWidth: ["borderBottomWidth"],
	borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
	borderInlineStartWidth: ["borderLeftWidth"],
	borderInlineEndWidth: ["borderRightWidth"],
	borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
	borderBlockStartStyle: ["borderTopStyle"],
	borderBlockEndStyle: ["borderBottomStyle"],
	borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
	borderInlineStartStyle: ["borderLeftStyle"],
	borderInlineEndStyle: ["borderRightStyle"],
	borderBlockColor: ["borderTopColor", "borderBottomColor"],
	borderBlockStartColor: ["borderTopColor"],
	borderBlockEndColor: ["borderBottomColor"],
	borderInlineColor: ["borderLeftColor", "borderRightColor"],
	borderInlineStartColor: ["borderLeftColor"],
	borderInlineEndColor: ["borderRightColor"],
	borderStartStartRadius: ["borderTopLeftRadius"],
	borderStartEndRadius: ["borderTopRightRadius"],
	borderEndStartRadius: ["borderBottomLeftRadius"],
	borderEndEndRadius: ["borderBottomRightRadius"]
};

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/components/Context.js
var IconContext = /* @__PURE__ */ (0, import_react.createContext)({});
var Context_default$2 = IconContext;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/toArray.js
function _toArray(r$1) {
	return _arrayWithHoles(r$1) || _iterableToArray(r$1) || _unsupportedIterableToArray(r$1) || _nonIterableRest();
}

//#endregion
//#region node_modules/rc-util/es/utils/get.js
function get(entity, path$1) {
	var current = entity;
	for (var i = 0; i < path$1.length; i += 1) {
		if (current === null || current === void 0) return;
		current = current[path$1[i]];
	}
	return current;
}

//#endregion
//#region node_modules/rc-util/es/utils/set.js
function internalSet(entity, paths, value, removeIfUndefined) {
	if (!paths.length) return value;
	var _paths = _toArray(paths), path$1 = _paths[0], restPath = _paths.slice(1);
	var clone;
	if (!entity && typeof path$1 === "number") clone = [];
	else if (Array.isArray(entity)) clone = _toConsumableArray(entity);
	else clone = _objectSpread2({}, entity);
	if (removeIfUndefined && value === void 0 && restPath.length === 1) delete clone[path$1][restPath[0]];
	else clone[path$1] = internalSet(clone[path$1], restPath, value, removeIfUndefined);
	return clone;
}
function set(entity, paths, value) {
	var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) return entity;
	return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
	return _typeof(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
	return Array.isArray(source) ? [] : {};
}
var keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
/**
* Merge objects which will create
*/
function merge$1() {
	for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) sources[_key] = arguments[_key];
	var clone = createEmpty(sources[0]);
	sources.forEach(function(src) {
		function internalMerge(path$1, parentLoopSet) {
			var loopSet = new Set(parentLoopSet);
			var value = get(src, path$1);
			var isArr = Array.isArray(value);
			if (isArr || isObject(value)) {
				if (!loopSet.has(value)) {
					loopSet.add(value);
					var originValue = get(clone, path$1);
					if (isArr) clone = set(clone, path$1, []);
					else if (!originValue || _typeof(originValue) !== "object") clone = set(clone, path$1, createEmpty(value));
					keys(value).forEach(function(key) {
						internalMerge([].concat(_toConsumableArray(path$1), [key]), loopSet);
					});
				}
			} else clone = set(clone, path$1, value);
		}
		internalMerge([]);
	});
	return clone;
}

//#endregion
//#region node_modules/antd/es/_util/warning.js
function noop$4() {}
var deprecatedWarnList = null;
var _warning = noop$4;
_warning = (valid, component, message$1) => {
	warning_default(valid, `[antd: ${component}] ${message$1}`);
};
var warning$3 = _warning;
const WarningContext = /* @__PURE__ */ import_react.createContext({});
/**
* This is a hook but we not named as `useWarning`
* since this is only used in development.
* We should always wrap this in `if (process.env.NODE_ENV !== 'production')` condition
*/
const devUseWarning = (component) => {
	const { strict } = import_react.useContext(WarningContext);
	const typeWarning = (valid, type$2, message$1) => {
		if (!valid) if (strict === false && type$2 === "deprecated") {
			const existWarning = deprecatedWarnList;
			if (!deprecatedWarnList) deprecatedWarnList = {};
			deprecatedWarnList[component] = deprecatedWarnList[component] || [];
			if (!deprecatedWarnList[component].includes(message$1 || "")) deprecatedWarnList[component].push(message$1 || "");
			if (!existWarning) console.warn("[antd] There exists deprecated usage in your code:", deprecatedWarnList);
		} else warning$3(valid, component, message$1);
	};
	typeWarning.deprecated = (valid, oldProp, newProp, message$1) => {
		typeWarning(valid, "deprecated", `\`${oldProp}\` is deprecated. Please use \`${newProp}\` instead.${message$1 ? ` ${message$1}` : ""}`);
	};
	return typeWarning;
};
var warning_default$1 = warning$3;

//#endregion
//#region node_modules/antd/es/form/validateMessagesContext.js
var validateMessagesContext_default = /* @__PURE__ */ (0, import_react.createContext)(void 0);

//#endregion
//#region node_modules/rc-pagination/es/locale/en_US.js
var locale$4 = {
	items_per_page: "/ page",
	jump_to: "Go to",
	jump_to_confirm: "confirm",
	page: "Page",
	prev_page: "Previous Page",
	next_page: "Next Page",
	prev_5: "Previous 5 Pages",
	next_5: "Next 5 Pages",
	prev_3: "Previous 3 Pages",
	next_3: "Next 3 Pages",
	page_size: "Page Size"
};
var en_US_default$1 = locale$4;

//#endregion
//#region node_modules/rc-picker/es/locale/common.js
var commonLocale = {
	yearFormat: "YYYY",
	dayFormat: "D",
	cellMeridiemFormat: "A",
	monthBeforeYear: true
};

//#endregion
//#region node_modules/rc-picker/es/locale/en_US.js
var locale$3 = _objectSpread2(_objectSpread2({}, commonLocale), {}, {
	locale: "en_US",
	today: "Today",
	now: "Now",
	backToToday: "Back to today",
	ok: "OK",
	clear: "Clear",
	week: "Week",
	month: "Month",
	year: "Year",
	timeSelect: "select time",
	dateSelect: "select date",
	weekSelect: "Choose a week",
	monthSelect: "Choose a month",
	yearSelect: "Choose a year",
	decadeSelect: "Choose a decade",
	dateFormat: "M/D/YYYY",
	dateTimeFormat: "M/D/YYYY HH:mm:ss",
	previousMonth: "Previous month (PageUp)",
	nextMonth: "Next month (PageDown)",
	previousYear: "Last year (Control + left)",
	nextYear: "Next year (Control + right)",
	previousDecade: "Last decade",
	nextDecade: "Next decade",
	previousCentury: "Last century",
	nextCentury: "Next century"
});
var en_US_default$5 = locale$3;

//#endregion
//#region node_modules/antd/es/time-picker/locale/en_US.js
var locale$2 = {
	placeholder: "Select time",
	rangePlaceholder: ["Start time", "End time"]
};
var en_US_default$4 = locale$2;

//#endregion
//#region node_modules/antd/es/date-picker/locale/en_US.js
var locale$1 = {
	lang: Object.assign({
		placeholder: "Select date",
		yearPlaceholder: "Select year",
		quarterPlaceholder: "Select quarter",
		monthPlaceholder: "Select month",
		weekPlaceholder: "Select week",
		rangePlaceholder: ["Start date", "End date"],
		rangeYearPlaceholder: ["Start year", "End year"],
		rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
		rangeMonthPlaceholder: ["Start month", "End month"],
		rangeWeekPlaceholder: ["Start week", "End week"]
	}, en_US_default$5),
	timePickerLocale: Object.assign({}, en_US_default$4)
};
var en_US_default$2 = locale$1;

//#endregion
//#region node_modules/antd/es/calendar/locale/en_US.js
var en_US_default$3 = en_US_default$2;

//#endregion
//#region node_modules/antd/es/locale/en_US.js
var typeTemplate$1 = "${label} is not a valid ${type}";
var localeValues = {
	locale: "en",
	Pagination: en_US_default$1,
	DatePicker: en_US_default$2,
	TimePicker: en_US_default$4,
	Calendar: en_US_default$3,
	global: {
		placeholder: "Please select",
		close: "Close"
	},
	Table: {
		filterTitle: "Filter menu",
		filterConfirm: "OK",
		filterReset: "Reset",
		filterEmptyText: "No filters",
		filterCheckAll: "Select all items",
		filterSearchPlaceholder: "Search in filters",
		emptyText: "No data",
		selectAll: "Select current page",
		selectInvert: "Invert current page",
		selectNone: "Clear all data",
		selectionAll: "Select all data",
		sortTitle: "Sort",
		expand: "Expand row",
		collapse: "Collapse row",
		triggerDesc: "Click to sort descending",
		triggerAsc: "Click to sort ascending",
		cancelSort: "Click to cancel sorting"
	},
	Tour: {
		Next: "Next",
		Previous: "Previous",
		Finish: "Finish"
	},
	Modal: {
		okText: "OK",
		cancelText: "Cancel",
		justOkText: "OK"
	},
	Popconfirm: {
		okText: "OK",
		cancelText: "Cancel"
	},
	Transfer: {
		titles: ["", ""],
		searchPlaceholder: "Search here",
		itemUnit: "item",
		itemsUnit: "items",
		remove: "Remove",
		selectCurrent: "Select current page",
		removeCurrent: "Remove current page",
		selectAll: "Select all data",
		deselectAll: "Deselect all data",
		removeAll: "Remove all data",
		selectInvert: "Invert current page"
	},
	Upload: {
		uploading: "Uploading...",
		removeFile: "Remove file",
		uploadError: "Upload error",
		previewFile: "Preview file",
		downloadFile: "Download file"
	},
	Empty: { description: "No data" },
	Icon: { icon: "icon" },
	Text: {
		edit: "Edit",
		copy: "Copy",
		copied: "Copied",
		expand: "Expand",
		collapse: "Collapse"
	},
	Form: {
		optional: "(optional)",
		defaultValidateMessages: {
			default: "Field validation error for ${label}",
			required: "Please enter ${label}",
			enum: "${label} must be one of [${enum}]",
			whitespace: "${label} cannot be a blank character",
			date: {
				format: "${label} date format is invalid",
				parse: "${label} cannot be converted to a date",
				invalid: "${label} is an invalid date"
			},
			types: {
				string: typeTemplate$1,
				method: typeTemplate$1,
				array: typeTemplate$1,
				object: typeTemplate$1,
				number: typeTemplate$1,
				date: typeTemplate$1,
				boolean: typeTemplate$1,
				integer: typeTemplate$1,
				float: typeTemplate$1,
				regexp: typeTemplate$1,
				email: typeTemplate$1,
				url: typeTemplate$1,
				hex: typeTemplate$1
			},
			string: {
				len: "${label} must be ${len} characters",
				min: "${label} must be at least ${min} characters",
				max: "${label} must be up to ${max} characters",
				range: "${label} must be between ${min}-${max} characters"
			},
			number: {
				len: "${label} must be equal to ${len}",
				min: "${label} must be minimum ${min}",
				max: "${label} must be maximum ${max}",
				range: "${label} must be between ${min}-${max}"
			},
			array: {
				len: "Must be ${len} ${label}",
				min: "At least ${min} ${label}",
				max: "At most ${max} ${label}",
				range: "The amount of ${label} must be between ${min}-${max}"
			},
			pattern: { mismatch: "${label} does not match the pattern ${pattern}" }
		}
	},
	Image: { preview: "Preview" },
	QRCode: {
		expired: "QR code expired",
		refresh: "Refresh",
		scanned: "Scanned"
	},
	ColorPicker: {
		presetEmpty: "Empty",
		transparent: "Transparent",
		singleColor: "Single",
		gradientColor: "Gradient"
	}
};
var en_US_default = localeValues;

//#endregion
//#region node_modules/antd/es/modal/locale.js
var runtimeLocale = Object.assign({}, en_US_default.Modal);
var localeList = [];
var generateLocale = () => localeList.reduce((merged, locale$5) => Object.assign(Object.assign({}, merged), locale$5), en_US_default.Modal);
function changeConfirmLocale(newLocale) {
	if (newLocale) {
		const cloneLocale = Object.assign({}, newLocale);
		localeList.push(cloneLocale);
		runtimeLocale = generateLocale();
		return () => {
			localeList = localeList.filter((locale$5) => locale$5 !== cloneLocale);
			runtimeLocale = generateLocale();
		};
	}
	runtimeLocale = Object.assign({}, en_US_default.Modal);
}
function getConfirmLocale() {
	return runtimeLocale;
}

//#endregion
//#region node_modules/antd/es/locale/context.js
var LocaleContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var context_default$10 = LocaleContext;

//#endregion
//#region node_modules/antd/es/locale/useLocale.js
var useLocale$1 = (componentName, defaultLocale) => {
	const fullLocale = import_react.useContext(context_default$10);
	const getLocale = import_react.useMemo(() => {
		var _a;
		const locale$5 = defaultLocale || en_US_default[componentName];
		const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
		return Object.assign(Object.assign({}, typeof locale$5 === "function" ? locale$5() : locale$5), localeFromContext || {});
	}, [
		componentName,
		defaultLocale,
		fullLocale
	]);
	const getLocaleCode = import_react.useMemo(() => {
		const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
		if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) return en_US_default.locale;
		return localeCode;
	}, [fullLocale]);
	return [getLocale, getLocaleCode];
};
var useLocale_default = useLocale$1;

//#endregion
//#region node_modules/antd/es/locale/index.js
const ANT_MARK = "internalMark";
var LocaleProvider = (props) => {
	const { locale: locale$5 = {}, children, _ANT_MARK__ } = props;
	devUseWarning("LocaleProvider")(_ANT_MARK__ === ANT_MARK, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale");
	import_react.useEffect(() => {
		return changeConfirmLocale(locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.Modal);
	}, [locale$5]);
	const getMemoizedContextValue = import_react.useMemo(() => Object.assign(Object.assign({}, locale$5), { exist: true }), [locale$5]);
	return /* @__PURE__ */ import_react.createElement(context_default$10.Provider, { value: getMemoizedContextValue }, children);
};
LocaleProvider.displayName = "LocaleProvider";
var locale_default = LocaleProvider;

//#endregion
//#region node_modules/antd/es/theme/themes/seed.js
const defaultPresetColors = {
	blue: "#1677FF",
	purple: "#722ED1",
	cyan: "#13C2C2",
	green: "#52C41A",
	magenta: "#EB2F96",
	pink: "#EB2F96",
	red: "#F5222D",
	orange: "#FA8C16",
	yellow: "#FADB14",
	volcano: "#FA541C",
	geekblue: "#2F54EB",
	gold: "#FAAD14",
	lime: "#A0D911"
};
var seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
	colorPrimary: "#1677ff",
	colorSuccess: "#52c41a",
	colorWarning: "#faad14",
	colorError: "#ff4d4f",
	colorInfo: "#1677ff",
	colorLink: "",
	colorTextBase: "",
	colorBgBase: "",
	fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
	fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
	fontSize: 14,
	lineWidth: 1,
	lineType: "solid",
	motionUnit: .1,
	motionBase: 0,
	motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
	motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
	motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
	motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
	motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
	motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
	motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
	motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
	borderRadius: 6,
	sizeUnit: 4,
	sizeStep: 4,
	sizePopupArrow: 16,
	controlHeight: 32,
	zIndexBase: 0,
	zIndexPopupBase: 1e3,
	opacityImage: 1,
	wireframe: false,
	motion: true
});
var seed_default = seedToken;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/fast-color/es/FastColor.js
var round$1 = Math.round;
/**
* Support format, alpha unit will check the % mark:
* - rgba(102, 204, 255, .5)      -> [102, 204, 255, 0.5]
* - rgb(102 204 255 / .5)        -> [102, 204, 255, 0.5]
* - rgb(100%, 50%, 0% / 50%)     -> [255, 128, 0, 0.5]
* - hsl(270, 60, 40, .5)         -> [270, 60, 40, 0.5]
* - hsl(270deg 60% 40% / 50%)   -> [270, 60, 40, 0.5]
*
* When `base` is provided, the percentage value will be divided by `base`.
*/
function splitColorStr$1(str, parseNum) {
	const match$1 = str.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [];
	const numList = match$1.map((item) => parseFloat(item));
	for (let i = 0; i < 3; i += 1) numList[i] = parseNum(numList[i] || 0, match$1[i] || "", i);
	if (match$1[3]) numList[3] = match$1[3].includes("%") ? numList[3] / 100 : numList[3];
	else numList[3] = 1;
	return numList;
}
var parseHSVorHSL$1 = (num, _, index$2) => index$2 === 0 ? num : num / 100;
/** round and limit number to integer between 0-255 */
function limitRange$1(value, max) {
	const mergedMax = max || 255;
	if (value > mergedMax) return mergedMax;
	if (value < 0) return 0;
	return value;
}
var FastColor = class FastColor {
	constructor(input) {
		/**
		* All FastColor objects are valid. So isValid is always true. This property is kept to be compatible with TinyColor.
		*/
		_defineProperty(this, "isValid", true);
		/**
		* Red, R in RGB
		*/
		_defineProperty(this, "r", 0);
		/**
		* Green, G in RGB
		*/
		_defineProperty(this, "g", 0);
		/**
		* Blue, B in RGB
		*/
		_defineProperty(this, "b", 0);
		/**
		* Alpha/Opacity, A in RGBA/HSLA
		*/
		_defineProperty(this, "a", 1);
		_defineProperty(this, "_h", void 0);
		_defineProperty(this, "_s", void 0);
		_defineProperty(this, "_l", void 0);
		_defineProperty(this, "_v", void 0);
		_defineProperty(this, "_max", void 0);
		_defineProperty(this, "_min", void 0);
		_defineProperty(this, "_brightness", void 0);
		/**
		* Always check 3 char in the object to determine the format.
		* We not use function in check to save bundle size.
		* e.g. 'rgb' -> { r: 0, g: 0, b: 0 }.
		*/
		function matchFormat(str) {
			return str[0] in input && str[1] in input && str[2] in input;
		}
		if (!input) {} else if (typeof input === "string") {
			const trimStr = input.trim();
			function matchPrefix(prefix) {
				return trimStr.startsWith(prefix);
			}
			if (/^#?[A-F\d]{3,8}$/i.test(trimStr)) this.fromHexString(trimStr);
			else if (matchPrefix("rgb")) this.fromRgbString(trimStr);
			else if (matchPrefix("hsl")) this.fromHslString(trimStr);
			else if (matchPrefix("hsv") || matchPrefix("hsb")) this.fromHsvString(trimStr);
		} else if (input instanceof FastColor) {
			this.r = input.r;
			this.g = input.g;
			this.b = input.b;
			this.a = input.a;
			this._h = input._h;
			this._s = input._s;
			this._l = input._l;
			this._v = input._v;
		} else if (matchFormat("rgb")) {
			this.r = limitRange$1(input.r);
			this.g = limitRange$1(input.g);
			this.b = limitRange$1(input.b);
			this.a = typeof input.a === "number" ? limitRange$1(input.a, 1) : 1;
		} else if (matchFormat("hsl")) this.fromHsl(input);
		else if (matchFormat("hsv")) this.fromHsv(input);
		else throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(input));
	}
	setR(value) {
		return this._sc("r", value);
	}
	setG(value) {
		return this._sc("g", value);
	}
	setB(value) {
		return this._sc("b", value);
	}
	setA(value) {
		return this._sc("a", value, 1);
	}
	setHue(value) {
		const hsv = this.toHsv();
		hsv.h = value;
		return this._c(hsv);
	}
	/**
	* Returns the perceived luminance of a color, from 0-1.
	* @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
	*/
	getLuminance() {
		function adjustGamma(raw) {
			const val = raw / 255;
			return val <= .03928 ? val / 12.92 : Math.pow((val + .055) / 1.055, 2.4);
		}
		const R = adjustGamma(this.r);
		const G = adjustGamma(this.g);
		const B = adjustGamma(this.b);
		return .2126 * R + .7152 * G + .0722 * B;
	}
	getHue() {
		if (typeof this._h === "undefined") {
			const delta = this.getMax() - this.getMin();
			if (delta === 0) this._h = 0;
			else this._h = round$1(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
		}
		return this._h;
	}
	getSaturation() {
		if (typeof this._s === "undefined") {
			const delta = this.getMax() - this.getMin();
			if (delta === 0) this._s = 0;
			else this._s = delta / this.getMax();
		}
		return this._s;
	}
	getLightness() {
		if (typeof this._l === "undefined") this._l = (this.getMax() + this.getMin()) / 510;
		return this._l;
	}
	getValue() {
		if (typeof this._v === "undefined") this._v = this.getMax() / 255;
		return this._v;
	}
	/**
	* Returns the perceived brightness of the color, from 0-255.
	* Note: this is not the b of HSB
	* @see http://www.w3.org/TR/AERT#color-contrast
	*/
	getBrightness() {
		if (typeof this._brightness === "undefined") this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3;
		return this._brightness;
	}
	darken(amount = 10) {
		const h = this.getHue();
		const s = this.getSaturation();
		let l$1 = this.getLightness() - amount / 100;
		if (l$1 < 0) l$1 = 0;
		return this._c({
			h,
			s,
			l: l$1,
			a: this.a
		});
	}
	lighten(amount = 10) {
		const h = this.getHue();
		const s = this.getSaturation();
		let l$1 = this.getLightness() + amount / 100;
		if (l$1 > 1) l$1 = 1;
		return this._c({
			h,
			s,
			l: l$1,
			a: this.a
		});
	}
	/**
	* Mix the current color a given amount with another color, from 0 to 100.
	* 0 means no mixing (return current color).
	*/
	mix(input, amount = 50) {
		const color = this._c(input);
		const p = amount / 100;
		const calc = (key) => (color[key] - this[key]) * p + this[key];
		const rgba = {
			r: round$1(calc("r")),
			g: round$1(calc("g")),
			b: round$1(calc("b")),
			a: round$1(calc("a") * 100) / 100
		};
		return this._c(rgba);
	}
	/**
	* Mix the color with pure white, from 0 to 100.
	* Providing 0 will do nothing, providing 100 will always return white.
	*/
	tint(amount = 10) {
		return this.mix({
			r: 255,
			g: 255,
			b: 255,
			a: 1
		}, amount);
	}
	/**
	* Mix the color with pure black, from 0 to 100.
	* Providing 0 will do nothing, providing 100 will always return black.
	*/
	shade(amount = 10) {
		return this.mix({
			r: 0,
			g: 0,
			b: 0,
			a: 1
		}, amount);
	}
	onBackground(background) {
		const bg = this._c(background);
		const alpha = this.a + bg.a * (1 - this.a);
		const calc = (key) => {
			return round$1((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha);
		};
		return this._c({
			r: calc("r"),
			g: calc("g"),
			b: calc("b"),
			a: alpha
		});
	}
	isDark() {
		return this.getBrightness() < 128;
	}
	isLight() {
		return this.getBrightness() >= 128;
	}
	equals(other) {
		return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
	}
	clone() {
		return this._c(this);
	}
	toHexString() {
		let hex = "#";
		const rHex = (this.r || 0).toString(16);
		hex += rHex.length === 2 ? rHex : "0" + rHex;
		const gHex = (this.g || 0).toString(16);
		hex += gHex.length === 2 ? gHex : "0" + gHex;
		const bHex = (this.b || 0).toString(16);
		hex += bHex.length === 2 ? bHex : "0" + bHex;
		if (typeof this.a === "number" && this.a >= 0 && this.a < 1) {
			const aHex = round$1(this.a * 255).toString(16);
			hex += aHex.length === 2 ? aHex : "0" + aHex;
		}
		return hex;
	}
	/** CSS support color pattern */
	toHsl() {
		return {
			h: this.getHue(),
			s: this.getSaturation(),
			l: this.getLightness(),
			a: this.a
		};
	}
	/** CSS support color pattern */
	toHslString() {
		const h = this.getHue();
		const s = round$1(this.getSaturation() * 100);
		const l$1 = round$1(this.getLightness() * 100);
		return this.a !== 1 ? `hsla(${h},${s}%,${l$1}%,${this.a})` : `hsl(${h},${s}%,${l$1}%)`;
	}
	/** Same as toHsb */
	toHsv() {
		return {
			h: this.getHue(),
			s: this.getSaturation(),
			v: this.getValue(),
			a: this.a
		};
	}
	toRgb() {
		return {
			r: this.r,
			g: this.g,
			b: this.b,
			a: this.a
		};
	}
	toRgbString() {
		return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
	}
	toString() {
		return this.toRgbString();
	}
	/** Return a new FastColor object with one channel changed */
	_sc(rgb, value, max) {
		const clone = this.clone();
		clone[rgb] = limitRange$1(value, max);
		return clone;
	}
	_c(input) {
		return new this.constructor(input);
	}
	getMax() {
		if (typeof this._max === "undefined") this._max = Math.max(this.r, this.g, this.b);
		return this._max;
	}
	getMin() {
		if (typeof this._min === "undefined") this._min = Math.min(this.r, this.g, this.b);
		return this._min;
	}
	fromHexString(trimStr) {
		const withoutPrefix = trimStr.replace("#", "");
		function connectNum(index1, index2) {
			return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);
		}
		if (withoutPrefix.length < 6) {
			this.r = connectNum(0);
			this.g = connectNum(1);
			this.b = connectNum(2);
			this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;
		} else {
			this.r = connectNum(0, 1);
			this.g = connectNum(2, 3);
			this.b = connectNum(4, 5);
			this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;
		}
	}
	fromHsl({ h, s, l: l$1, a }) {
		this._h = h % 360;
		this._s = s;
		this._l = l$1;
		this.a = typeof a === "number" ? a : 1;
		if (s <= 0) {
			const rgb = round$1(l$1 * 255);
			this.r = rgb;
			this.g = rgb;
			this.b = rgb;
		}
		let r$1 = 0, g = 0, b = 0;
		const huePrime = h / 60;
		const chroma = (1 - Math.abs(2 * l$1 - 1)) * s;
		const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
		if (huePrime >= 0 && huePrime < 1) {
			r$1 = chroma;
			g = secondComponent;
		} else if (huePrime >= 1 && huePrime < 2) {
			r$1 = secondComponent;
			g = chroma;
		} else if (huePrime >= 2 && huePrime < 3) {
			g = chroma;
			b = secondComponent;
		} else if (huePrime >= 3 && huePrime < 4) {
			g = secondComponent;
			b = chroma;
		} else if (huePrime >= 4 && huePrime < 5) {
			r$1 = secondComponent;
			b = chroma;
		} else if (huePrime >= 5 && huePrime < 6) {
			r$1 = chroma;
			b = secondComponent;
		}
		const lightnessModification = l$1 - chroma / 2;
		this.r = round$1((r$1 + lightnessModification) * 255);
		this.g = round$1((g + lightnessModification) * 255);
		this.b = round$1((b + lightnessModification) * 255);
	}
	fromHsv({ h, s, v, a }) {
		this._h = h % 360;
		this._s = s;
		this._v = v;
		this.a = typeof a === "number" ? a : 1;
		const vv = round$1(v * 255);
		this.r = vv;
		this.g = vv;
		this.b = vv;
		if (s <= 0) return;
		const hh = h / 60;
		const i = Math.floor(hh);
		const ff = hh - i;
		const p = round$1(v * (1 - s) * 255);
		const q = round$1(v * (1 - s * ff) * 255);
		const t$1 = round$1(v * (1 - s * (1 - ff)) * 255);
		switch (i) {
			case 0:
				this.g = t$1;
				this.b = p;
				break;
			case 1:
				this.r = q;
				this.b = p;
				break;
			case 2:
				this.r = p;
				this.b = t$1;
				break;
			case 3:
				this.r = p;
				this.g = q;
				break;
			case 4:
				this.r = t$1;
				this.g = p;
				break;
			case 5:
			default:
				this.g = p;
				this.b = q;
				break;
		}
	}
	fromHsvString(trimStr) {
		const cells = splitColorStr$1(trimStr, parseHSVorHSL$1);
		this.fromHsv({
			h: cells[0],
			s: cells[1],
			v: cells[2],
			a: cells[3]
		});
	}
	fromHslString(trimStr) {
		const cells = splitColorStr$1(trimStr, parseHSVorHSL$1);
		this.fromHsl({
			h: cells[0],
			s: cells[1],
			l: cells[2],
			a: cells[3]
		});
	}
	fromRgbString(trimStr) {
		const cells = splitColorStr$1(trimStr, (num, txt) => txt.includes("%") ? round$1(num / 100 * 255) : num);
		this.r = cells[0];
		this.g = cells[1];
		this.b = cells[2];
		this.a = cells[3];
	}
};

//#endregion
//#region node_modules/antd/node_modules/@ant-design/colors/es/generate.js
var hueStep = 2;
var saturationStep = .16;
var saturationStep2 = .05;
var brightnessStep1 = .05;
var brightnessStep2 = .15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [
	{
		index: 7,
		amount: 15
	},
	{
		index: 6,
		amount: 25
	},
	{
		index: 5,
		amount: 30
	},
	{
		index: 5,
		amount: 45
	},
	{
		index: 5,
		amount: 65
	},
	{
		index: 5,
		amount: 85
	},
	{
		index: 4,
		amount: 90
	},
	{
		index: 3,
		amount: 95
	},
	{
		index: 2,
		amount: 97
	},
	{
		index: 1,
		amount: 98
	}
];
function getHue(hsv, i, light) {
	var hue;
	if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
	else hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
	if (hue < 0) hue += 360;
	else if (hue >= 360) hue -= 360;
	return hue;
}
function getSaturation(hsv, i, light) {
	if (hsv.h === 0 && hsv.s === 0) return hsv.s;
	var saturation;
	if (light) saturation = hsv.s - saturationStep * i;
	else if (i === darkColorCount) saturation = hsv.s + saturationStep;
	else saturation = hsv.s + saturationStep2 * i;
	if (saturation > 1) saturation = 1;
	if (light && i === lightColorCount && saturation > .1) saturation = .1;
	if (saturation < .06) saturation = .06;
	return Math.round(saturation * 100) / 100;
}
function getValue$1(hsv, i, light) {
	var value;
	if (light) value = hsv.v + brightnessStep1 * i;
	else value = hsv.v - brightnessStep2 * i;
	value = Math.max(0, Math.min(1, value));
	return Math.round(value * 100) / 100;
}
function generate(color) {
	var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var patterns = [];
	var pColor = new FastColor(color);
	var hsv = pColor.toHsv();
	for (var i = lightColorCount; i > 0; i -= 1) {
		var c = new FastColor({
			h: getHue(hsv, i, true),
			s: getSaturation(hsv, i, true),
			v: getValue$1(hsv, i, true)
		});
		patterns.push(c);
	}
	patterns.push(pColor);
	for (var _i = 1; _i <= darkColorCount; _i += 1) {
		var _c = new FastColor({
			h: getHue(hsv, _i),
			s: getSaturation(hsv, _i),
			v: getValue$1(hsv, _i)
		});
		patterns.push(_c);
	}
	if (opts.theme === "dark") return darkColorMap.map(function(_ref) {
		var index$2 = _ref.index, amount = _ref.amount;
		return new FastColor(opts.backgroundColor || "#141414").mix(patterns[index$2], amount).toHexString();
	});
	return patterns.map(function(c$1) {
		return c$1.toHexString();
	});
}

//#endregion
//#region node_modules/antd/node_modules/@ant-design/colors/es/presets.js
var presetPrimaryColors = {
	"red": "#F5222D",
	"volcano": "#FA541C",
	"orange": "#FA8C16",
	"gold": "#FAAD14",
	"yellow": "#FADB14",
	"lime": "#A0D911",
	"green": "#52C41A",
	"cyan": "#13C2C2",
	"blue": "#1677FF",
	"geekblue": "#2F54EB",
	"purple": "#722ED1",
	"magenta": "#EB2F96",
	"grey": "#666666"
};
var red = [
	"#fff1f0",
	"#ffccc7",
	"#ffa39e",
	"#ff7875",
	"#ff4d4f",
	"#f5222d",
	"#cf1322",
	"#a8071a",
	"#820014",
	"#5c0011"
];
red.primary = red[5];
var volcano = [
	"#fff2e8",
	"#ffd8bf",
	"#ffbb96",
	"#ff9c6e",
	"#ff7a45",
	"#fa541c",
	"#d4380d",
	"#ad2102",
	"#871400",
	"#610b00"
];
volcano.primary = volcano[5];
var orange = [
	"#fff7e6",
	"#ffe7ba",
	"#ffd591",
	"#ffc069",
	"#ffa940",
	"#fa8c16",
	"#d46b08",
	"#ad4e00",
	"#873800",
	"#612500"
];
orange.primary = orange[5];
var gold = [
	"#fffbe6",
	"#fff1b8",
	"#ffe58f",
	"#ffd666",
	"#ffc53d",
	"#faad14",
	"#d48806",
	"#ad6800",
	"#874d00",
	"#613400"
];
gold.primary = gold[5];
var yellow = [
	"#feffe6",
	"#ffffb8",
	"#fffb8f",
	"#fff566",
	"#ffec3d",
	"#fadb14",
	"#d4b106",
	"#ad8b00",
	"#876800",
	"#614700"
];
yellow.primary = yellow[5];
var lime = [
	"#fcffe6",
	"#f4ffb8",
	"#eaff8f",
	"#d3f261",
	"#bae637",
	"#a0d911",
	"#7cb305",
	"#5b8c00",
	"#3f6600",
	"#254000"
];
lime.primary = lime[5];
var green = [
	"#f6ffed",
	"#d9f7be",
	"#b7eb8f",
	"#95de64",
	"#73d13d",
	"#52c41a",
	"#389e0d",
	"#237804",
	"#135200",
	"#092b00"
];
green.primary = green[5];
var cyan = [
	"#e6fffb",
	"#b5f5ec",
	"#87e8de",
	"#5cdbd3",
	"#36cfc9",
	"#13c2c2",
	"#08979c",
	"#006d75",
	"#00474f",
	"#002329"
];
cyan.primary = cyan[5];
var blue = [
	"#e6f4ff",
	"#bae0ff",
	"#91caff",
	"#69b1ff",
	"#4096ff",
	"#1677ff",
	"#0958d9",
	"#003eb3",
	"#002c8c",
	"#001d66"
];
blue.primary = blue[5];
var geekblue = [
	"#f0f5ff",
	"#d6e4ff",
	"#adc6ff",
	"#85a5ff",
	"#597ef7",
	"#2f54eb",
	"#1d39c4",
	"#10239e",
	"#061178",
	"#030852"
];
geekblue.primary = geekblue[5];
var purple = [
	"#f9f0ff",
	"#efdbff",
	"#d3adf7",
	"#b37feb",
	"#9254de",
	"#722ed1",
	"#531dab",
	"#391085",
	"#22075e",
	"#120338"
];
purple.primary = purple[5];
var magenta = [
	"#fff0f6",
	"#ffd6e7",
	"#ffadd2",
	"#ff85c0",
	"#f759ab",
	"#eb2f96",
	"#c41d7f",
	"#9e1068",
	"#780650",
	"#520339"
];
magenta.primary = magenta[5];
var grey = [
	"#a6a6a6",
	"#999999",
	"#8c8c8c",
	"#808080",
	"#737373",
	"#666666",
	"#404040",
	"#1a1a1a",
	"#000000",
	"#000000"
];
grey.primary = grey[5];
var presetPalettes = {
	red,
	volcano,
	orange,
	gold,
	yellow,
	lime,
	green,
	cyan,
	blue,
	geekblue,
	purple,
	magenta,
	grey
};
var redDark = [
	"#2a1215",
	"#431418",
	"#58181c",
	"#791a1f",
	"#a61d24",
	"#d32029",
	"#e84749",
	"#f37370",
	"#f89f9a",
	"#fac8c3"
];
redDark.primary = redDark[5];
var volcanoDark = [
	"#2b1611",
	"#441d12",
	"#592716",
	"#7c3118",
	"#aa3e19",
	"#d84a1b",
	"#e87040",
	"#f3956a",
	"#f8b692",
	"#fad4bc"
];
volcanoDark.primary = volcanoDark[5];
var orangeDark = [
	"#2b1d11",
	"#442a11",
	"#593815",
	"#7c4a15",
	"#aa6215",
	"#d87a16",
	"#e89a3c",
	"#f3b765",
	"#f8cf8d",
	"#fae3b7"
];
orangeDark.primary = orangeDark[5];
var goldDark = [
	"#2b2111",
	"#443111",
	"#594214",
	"#7c5914",
	"#aa7714",
	"#d89614",
	"#e8b339",
	"#f3cc62",
	"#f8df8b",
	"#faedb5"
];
goldDark.primary = goldDark[5];
var yellowDark = [
	"#2b2611",
	"#443b11",
	"#595014",
	"#7c6e14",
	"#aa9514",
	"#d8bd14",
	"#e8d639",
	"#f3ea62",
	"#f8f48b",
	"#fafab5"
];
yellowDark.primary = yellowDark[5];
var limeDark = [
	"#1f2611",
	"#2e3c10",
	"#3e4f13",
	"#536d13",
	"#6f9412",
	"#8bbb11",
	"#a9d134",
	"#c9e75d",
	"#e4f88b",
	"#f0fab5"
];
limeDark.primary = limeDark[5];
var greenDark = [
	"#162312",
	"#1d3712",
	"#274916",
	"#306317",
	"#3c8618",
	"#49aa19",
	"#6abe39",
	"#8fd460",
	"#b2e58b",
	"#d5f2bb"
];
greenDark.primary = greenDark[5];
var cyanDark = [
	"#112123",
	"#113536",
	"#144848",
	"#146262",
	"#138585",
	"#13a8a8",
	"#33bcb7",
	"#58d1c9",
	"#84e2d8",
	"#b2f1e8"
];
cyanDark.primary = cyanDark[5];
var blueDark = [
	"#111a2c",
	"#112545",
	"#15325b",
	"#15417e",
	"#1554ad",
	"#1668dc",
	"#3c89e8",
	"#65a9f3",
	"#8dc5f8",
	"#b7dcfa"
];
blueDark.primary = blueDark[5];
var geekblueDark = [
	"#131629",
	"#161d40",
	"#1c2755",
	"#203175",
	"#263ea0",
	"#2b4acb",
	"#5273e0",
	"#7f9ef3",
	"#a8c1f8",
	"#d2e0fa"
];
geekblueDark.primary = geekblueDark[5];
var purpleDark = [
	"#1a1325",
	"#24163a",
	"#301c4d",
	"#3e2069",
	"#51258f",
	"#642ab5",
	"#854eca",
	"#ab7ae0",
	"#cda8f0",
	"#ebd7fa"
];
purpleDark.primary = purpleDark[5];
var magentaDark = [
	"#291321",
	"#40162f",
	"#551c3b",
	"#75204f",
	"#a02669",
	"#cb2b83",
	"#e0529c",
	"#f37fb7",
	"#f8a8cc",
	"#fad2e3"
];
magentaDark.primary = magentaDark[5];
var greyDark = [
	"#151515",
	"#1f1f1f",
	"#2d2d2d",
	"#393939",
	"#494949",
	"#5a5a5a",
	"#6a6a6a",
	"#7b7b7b",
	"#888888",
	"#969696"
];
greyDark.primary = greyDark[5];

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genColorMapToken.js
function genColorMapToken(seed, { generateColorPalettes: generateColorPalettes$2, generateNeutralColorPalettes: generateNeutralColorPalettes$2 }) {
	const { colorSuccess: colorSuccessBase, colorWarning: colorWarningBase, colorError: colorErrorBase, colorInfo: colorInfoBase, colorPrimary: colorPrimaryBase, colorBgBase, colorTextBase } = seed;
	const primaryColors = generateColorPalettes$2(colorPrimaryBase);
	const successColors = generateColorPalettes$2(colorSuccessBase);
	const warningColors = generateColorPalettes$2(colorWarningBase);
	const errorColors = generateColorPalettes$2(colorErrorBase);
	const infoColors = generateColorPalettes$2(colorInfoBase);
	const neutralColors = generateNeutralColorPalettes$2(colorBgBase, colorTextBase);
	const colorLink = seed.colorLink || seed.colorInfo;
	const linkColors = generateColorPalettes$2(colorLink);
	const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
	return Object.assign(Object.assign({}, neutralColors), {
		colorPrimaryBg: primaryColors[1],
		colorPrimaryBgHover: primaryColors[2],
		colorPrimaryBorder: primaryColors[3],
		colorPrimaryBorderHover: primaryColors[4],
		colorPrimaryHover: primaryColors[5],
		colorPrimary: primaryColors[6],
		colorPrimaryActive: primaryColors[7],
		colorPrimaryTextHover: primaryColors[8],
		colorPrimaryText: primaryColors[9],
		colorPrimaryTextActive: primaryColors[10],
		colorSuccessBg: successColors[1],
		colorSuccessBgHover: successColors[2],
		colorSuccessBorder: successColors[3],
		colorSuccessBorderHover: successColors[4],
		colorSuccessHover: successColors[4],
		colorSuccess: successColors[6],
		colorSuccessActive: successColors[7],
		colorSuccessTextHover: successColors[8],
		colorSuccessText: successColors[9],
		colorSuccessTextActive: successColors[10],
		colorErrorBg: errorColors[1],
		colorErrorBgHover: errorColors[2],
		colorErrorBgFilledHover,
		colorErrorBgActive: errorColors[3],
		colorErrorBorder: errorColors[3],
		colorErrorBorderHover: errorColors[4],
		colorErrorHover: errorColors[5],
		colorError: errorColors[6],
		colorErrorActive: errorColors[7],
		colorErrorTextHover: errorColors[8],
		colorErrorText: errorColors[9],
		colorErrorTextActive: errorColors[10],
		colorWarningBg: warningColors[1],
		colorWarningBgHover: warningColors[2],
		colorWarningBorder: warningColors[3],
		colorWarningBorderHover: warningColors[4],
		colorWarningHover: warningColors[4],
		colorWarning: warningColors[6],
		colorWarningActive: warningColors[7],
		colorWarningTextHover: warningColors[8],
		colorWarningText: warningColors[9],
		colorWarningTextActive: warningColors[10],
		colorInfoBg: infoColors[1],
		colorInfoBgHover: infoColors[2],
		colorInfoBorder: infoColors[3],
		colorInfoBorderHover: infoColors[4],
		colorInfoHover: infoColors[4],
		colorInfo: infoColors[6],
		colorInfoActive: infoColors[7],
		colorInfoTextHover: infoColors[8],
		colorInfoText: infoColors[9],
		colorInfoTextActive: infoColors[10],
		colorLinkHover: linkColors[4],
		colorLink: linkColors[6],
		colorLinkActive: linkColors[7],
		colorBgMask: new FastColor("#000").setA(.45).toRgbString(),
		colorWhite: "#fff"
	});
}

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genRadius.js
var genRadius = (radiusBase) => {
	let radiusLG = radiusBase;
	let radiusSM = radiusBase;
	let radiusXS = radiusBase;
	let radiusOuter = radiusBase;
	if (radiusBase < 6 && radiusBase >= 5) radiusLG = radiusBase + 1;
	else if (radiusBase < 16 && radiusBase >= 6) radiusLG = radiusBase + 2;
	else if (radiusBase >= 16) radiusLG = 16;
	if (radiusBase < 7 && radiusBase >= 5) radiusSM = 4;
	else if (radiusBase < 8 && radiusBase >= 7) radiusSM = 5;
	else if (radiusBase < 14 && radiusBase >= 8) radiusSM = 6;
	else if (radiusBase < 16 && radiusBase >= 14) radiusSM = 7;
	else if (radiusBase >= 16) radiusSM = 8;
	if (radiusBase < 6 && radiusBase >= 2) radiusXS = 1;
	else if (radiusBase >= 6) radiusXS = 2;
	if (radiusBase > 4 && radiusBase < 8) radiusOuter = 4;
	else if (radiusBase >= 8) radiusOuter = 6;
	return {
		borderRadius: radiusBase,
		borderRadiusXS: radiusXS,
		borderRadiusSM: radiusSM,
		borderRadiusLG: radiusLG,
		borderRadiusOuter: radiusOuter
	};
};
var genRadius_default = genRadius;

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genCommonMapToken.js
function genCommonMapToken(token$1) {
	const { motionUnit, motionBase, borderRadius, lineWidth } = token$1;
	return Object.assign({
		motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
		motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
		motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
		lineWidthBold: lineWidth + 1
	}, genRadius_default(borderRadius));
}

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genControlHeight.js
var genControlHeight = (token$1) => {
	const { controlHeight } = token$1;
	return {
		controlHeightSM: controlHeight * .75,
		controlHeightXS: controlHeight * .5,
		controlHeightLG: controlHeight * 1.25
	};
};
var genControlHeight_default = genControlHeight;

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genFontSizes.js
function getLineHeight(fontSize) {
	return (fontSize + 8) / fontSize;
}
function getFontSizes(base) {
	const fontSizes = Array.from({ length: 10 }).map((_, index$2) => {
		const i = index$2 - 1;
		const baseSize = base * Math.pow(Math.E, i / 5);
		const intSize = index$2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
		return Math.floor(intSize / 2) * 2;
	});
	fontSizes[1] = base;
	return fontSizes.map((size) => ({
		size,
		lineHeight: getLineHeight(size)
	}));
}

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genFontMapToken.js
var genFontMapToken = (fontSize) => {
	const fontSizePairs = getFontSizes(fontSize);
	const fontSizes = fontSizePairs.map((pair) => pair.size);
	const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
	const fontSizeMD = fontSizes[1];
	const fontSizeSM = fontSizes[0];
	const fontSizeLG = fontSizes[2];
	const lineHeight = lineHeights[1];
	const lineHeightSM = lineHeights[0];
	const lineHeightLG = lineHeights[2];
	return {
		fontSizeSM,
		fontSize: fontSizeMD,
		fontSizeLG,
		fontSizeXL: fontSizes[3],
		fontSizeHeading1: fontSizes[6],
		fontSizeHeading2: fontSizes[5],
		fontSizeHeading3: fontSizes[4],
		fontSizeHeading4: fontSizes[3],
		fontSizeHeading5: fontSizes[2],
		lineHeight,
		lineHeightLG,
		lineHeightSM,
		fontHeight: Math.round(lineHeight * fontSizeMD),
		fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
		fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
		lineHeightHeading1: lineHeights[6],
		lineHeightHeading2: lineHeights[5],
		lineHeightHeading3: lineHeights[4],
		lineHeightHeading4: lineHeights[3],
		lineHeightHeading5: lineHeights[2]
	};
};
var genFontMapToken_default = genFontMapToken;

//#endregion
//#region node_modules/antd/es/theme/themes/shared/genSizeMapToken.js
function genSizeMapToken$1(token$1) {
	const { sizeUnit, sizeStep } = token$1;
	return {
		sizeXXL: sizeUnit * (sizeStep + 8),
		sizeXL: sizeUnit * (sizeStep + 4),
		sizeLG: sizeUnit * (sizeStep + 2),
		sizeMD: sizeUnit * (sizeStep + 1),
		sizeMS: sizeUnit * sizeStep,
		size: sizeUnit * sizeStep,
		sizeSM: sizeUnit * (sizeStep - 1),
		sizeXS: sizeUnit * (sizeStep - 2),
		sizeXXS: sizeUnit * (sizeStep - 3)
	};
}

//#endregion
//#region node_modules/antd/es/theme/themes/default/colorAlgorithm.js
const getAlphaColor$2 = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
const getSolidColor$1 = (baseColor, brightness) => {
	return new FastColor(baseColor).darken(brightness).toHexString();
};

//#endregion
//#region node_modules/antd/es/theme/themes/default/colors.js
const generateColorPalettes$1 = (baseColor) => {
	const colors = generate(baseColor);
	return {
		1: colors[0],
		2: colors[1],
		3: colors[2],
		4: colors[3],
		5: colors[4],
		6: colors[5],
		7: colors[6],
		8: colors[4],
		9: colors[5],
		10: colors[6]
	};
};
const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
	const colorBgBase = bgBaseColor || "#fff";
	const colorTextBase = textBaseColor || "#000";
	return {
		colorBgBase,
		colorTextBase,
		colorText: getAlphaColor$2(colorTextBase, .88),
		colorTextSecondary: getAlphaColor$2(colorTextBase, .65),
		colorTextTertiary: getAlphaColor$2(colorTextBase, .45),
		colorTextQuaternary: getAlphaColor$2(colorTextBase, .25),
		colorFill: getAlphaColor$2(colorTextBase, .15),
		colorFillSecondary: getAlphaColor$2(colorTextBase, .06),
		colorFillTertiary: getAlphaColor$2(colorTextBase, .04),
		colorFillQuaternary: getAlphaColor$2(colorTextBase, .02),
		colorBgSolid: getAlphaColor$2(colorTextBase, 1),
		colorBgSolidHover: getAlphaColor$2(colorTextBase, .75),
		colorBgSolidActive: getAlphaColor$2(colorTextBase, .95),
		colorBgLayout: getSolidColor$1(colorBgBase, 4),
		colorBgContainer: getSolidColor$1(colorBgBase, 0),
		colorBgElevated: getSolidColor$1(colorBgBase, 0),
		colorBgSpotlight: getAlphaColor$2(colorTextBase, .85),
		colorBgBlur: "transparent",
		colorBorder: getSolidColor$1(colorBgBase, 15),
		colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
	};
};

//#endregion
//#region node_modules/antd/es/theme/themes/default/index.js
function derivative(token$1) {
	presetPrimaryColors.pink = presetPrimaryColors.magenta;
	presetPalettes.pink = presetPalettes.magenta;
	const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
		const colors = token$1[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate(token$1[colorKey]);
		return Array.from({ length: 10 }, () => 1).reduce((prev$1, _, i) => {
			prev$1[`${colorKey}-${i + 1}`] = colors[i];
			prev$1[`${colorKey}${i + 1}`] = colors[i];
			return prev$1;
		}, {});
	}).reduce((prev$1, cur) => {
		prev$1 = Object.assign(Object.assign({}, prev$1), cur);
		return prev$1;
	}, {});
	return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token$1), colorPalettes), genColorMapToken(token$1, {
		generateColorPalettes: generateColorPalettes$1,
		generateNeutralColorPalettes: generateNeutralColorPalettes$1
	})), genFontMapToken_default(token$1.fontSize)), genSizeMapToken$1(token$1)), genControlHeight_default(token$1)), genCommonMapToken(token$1));
}

//#endregion
//#region node_modules/antd/es/theme/themes/default/theme.js
var defaultTheme = createTheme(derivative);
var theme_default$1 = defaultTheme;

//#endregion
//#region node_modules/antd/es/theme/context.js
const defaultConfig = {
	token: seed_default,
	override: { override: seed_default },
	hashed: true
};
const DesignTokenContext = /* @__PURE__ */ import_react.createContext(defaultConfig);

//#endregion
//#region node_modules/antd/es/config-provider/context.js
const defaultPrefixCls = "ant";
const defaultIconPrefixCls = "anticon";
const Variants = [
	"outlined",
	"borderless",
	"filled",
	"underlined"
];
var defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
	if (customizePrefixCls) return customizePrefixCls;
	return suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls;
};
const ConfigContext = /* @__PURE__ */ import_react.createContext({
	getPrefixCls: defaultGetPrefixCls,
	iconPrefixCls: defaultIconPrefixCls
});
const { Consumer: ConfigConsumer } = ConfigContext;
var EMPTY_OBJECT = {};
/**
* Get ConfigProvider configured component props.
* This help to reduce bundle size for saving `?.` operator.
* Do not use as `useMemo` deps since we do not cache the object here.
*
* NOTE: not refactor this with `useMemo` since memo will cost another memory space,
* which will waste both compare calculation & memory.
*/
function useComponentConfig(propName) {
	const context = import_react.useContext(ConfigContext);
	const { getPrefixCls, direction, getPopupContainer } = context;
	const propValue = context[propName];
	return Object.assign(Object.assign({
		classNames: EMPTY_OBJECT,
		styles: EMPTY_OBJECT
	}, propValue), {
		getPrefixCls,
		direction,
		getPopupContainer
	});
}

//#endregion
//#region node_modules/antd/es/config-provider/cssVariables.js
var dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
function getStyle$2(globalPrefixCls$1, theme) {
	const variables = {};
	const formatColor = (color, updater) => {
		let clone = color.clone();
		clone = (updater === null || updater === void 0 ? void 0 : updater(clone)) || clone;
		return clone.toRgbString();
	};
	const fillColor = (colorVal, type$2) => {
		const baseColor = new FastColor(colorVal);
		const colorPalettes = generate(baseColor.toRgbString());
		variables[`${type$2}-color`] = formatColor(baseColor);
		variables[`${type$2}-color-disabled`] = colorPalettes[1];
		variables[`${type$2}-color-hover`] = colorPalettes[4];
		variables[`${type$2}-color-active`] = colorPalettes[6];
		variables[`${type$2}-color-outline`] = baseColor.clone().setA(.2).toRgbString();
		variables[`${type$2}-color-deprecated-bg`] = colorPalettes[0];
		variables[`${type$2}-color-deprecated-border`] = colorPalettes[2];
	};
	if (theme.primaryColor) {
		fillColor(theme.primaryColor, "primary");
		const primaryColor = new FastColor(theme.primaryColor);
		const primaryColors = generate(primaryColor.toRgbString());
		primaryColors.forEach((color, index$2) => {
			variables[`primary-${index$2 + 1}`] = color;
		});
		variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c) => c.lighten(35));
		variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c) => c.lighten(20));
		variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c) => c.tint(20));
		variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c) => c.tint(50));
		variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c) => c.setA(c.a * .12));
		const primaryActiveColor = new FastColor(primaryColors[0]);
		variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c) => c.setA(c.a * .3));
		variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c) => c.darken(2));
	}
	if (theme.successColor) fillColor(theme.successColor, "success");
	if (theme.warningColor) fillColor(theme.warningColor, "warning");
	if (theme.errorColor) fillColor(theme.errorColor, "error");
	if (theme.infoColor) fillColor(theme.infoColor, "info");
	return `
  :root {
    ${Object.keys(variables).map((key) => `--${globalPrefixCls$1}-${key}: ${variables[key]};`).join("\n")}
  }
  `.trim();
}
function registerTheme(globalPrefixCls$1, theme) {
	const style$1 = getStyle$2(globalPrefixCls$1, theme);
	if (canUseDom()) updateCSS(style$1, `${dynamicStyleMark}-dynamic-theme`);
	else warning_default$1(false, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}

//#endregion
//#region node_modules/antd/es/config-provider/DisabledContext.js
var DisabledContext = /* @__PURE__ */ import_react.createContext(false);
const DisabledContextProvider = ({ children, disabled }) => {
	const originDisabled = import_react.useContext(DisabledContext);
	return /* @__PURE__ */ import_react.createElement(DisabledContext.Provider, { value: disabled !== null && disabled !== void 0 ? disabled : originDisabled }, children);
};
var DisabledContext_default = DisabledContext;

//#endregion
//#region node_modules/antd/es/config-provider/SizeContext.js
var SizeContext = /* @__PURE__ */ import_react.createContext(void 0);
const SizeContextProvider = ({ children, size }) => {
	const originSize = import_react.useContext(SizeContext);
	return /* @__PURE__ */ import_react.createElement(SizeContext.Provider, { value: size || originSize }, children);
};
var SizeContext_default = SizeContext;

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useConfig.js
function useConfig() {
	const componentDisabled = (0, import_react.useContext)(DisabledContext_default);
	const componentSize = (0, import_react.useContext)(SizeContext_default);
	return {
		componentDisabled,
		componentSize
	};
}
var useConfig_default = useConfig;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/calc/calculator.js
var AbstractCalculator = /* @__PURE__ */ _createClass(function AbstractCalculator$1() {
	_classCallCheck(this, AbstractCalculator$1);
});
var calculator_default = AbstractCalculator;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/calc/CSSCalculator.js
var CALC_UNIT = "CALC_UNIT";
var regexp$1 = new RegExp(CALC_UNIT, "g");
function unit$1(value) {
	if (typeof value === "number") return "".concat(value).concat(CALC_UNIT);
	return value;
}
var CSSCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
	_inherits(CSSCalculator$1, _AbstractCalculator);
	var _super = _createSuper(CSSCalculator$1);
	function CSSCalculator$1(num, unitlessCssVar) {
		var _this;
		_classCallCheck(this, CSSCalculator$1);
		_this = _super.call(this);
		_defineProperty(_assertThisInitialized(_this), "result", "");
		_defineProperty(_assertThisInitialized(_this), "unitlessCssVar", void 0);
		_defineProperty(_assertThisInitialized(_this), "lowPriority", void 0);
		var numType = _typeof(num);
		_this.unitlessCssVar = unitlessCssVar;
		if (num instanceof CSSCalculator$1) _this.result = "(".concat(num.result, ")");
		else if (numType === "number") _this.result = unit$1(num);
		else if (numType === "string") _this.result = num;
		return _this;
	}
	_createClass(CSSCalculator$1, [
		{
			key: "add",
			value: function add(num) {
				if (num instanceof CSSCalculator$1) this.result = "".concat(this.result, " + ").concat(num.getResult());
				else if (typeof num === "number" || typeof num === "string") this.result = "".concat(this.result, " + ").concat(unit$1(num));
				this.lowPriority = true;
				return this;
			}
		},
		{
			key: "sub",
			value: function sub(num) {
				if (num instanceof CSSCalculator$1) this.result = "".concat(this.result, " - ").concat(num.getResult());
				else if (typeof num === "number" || typeof num === "string") this.result = "".concat(this.result, " - ").concat(unit$1(num));
				this.lowPriority = true;
				return this;
			}
		},
		{
			key: "mul",
			value: function mul(num) {
				if (this.lowPriority) this.result = "(".concat(this.result, ")");
				if (num instanceof CSSCalculator$1) this.result = "".concat(this.result, " * ").concat(num.getResult(true));
				else if (typeof num === "number" || typeof num === "string") this.result = "".concat(this.result, " * ").concat(num);
				this.lowPriority = false;
				return this;
			}
		},
		{
			key: "div",
			value: function div(num) {
				if (this.lowPriority) this.result = "(".concat(this.result, ")");
				if (num instanceof CSSCalculator$1) this.result = "".concat(this.result, " / ").concat(num.getResult(true));
				else if (typeof num === "number" || typeof num === "string") this.result = "".concat(this.result, " / ").concat(num);
				this.lowPriority = false;
				return this;
			}
		},
		{
			key: "getResult",
			value: function getResult(force) {
				return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
			}
		},
		{
			key: "equal",
			value: function equal(options) {
				var _this2 = this;
				var _ref = options || {}, cssUnit = _ref.unit;
				var mergedUnit = true;
				if (typeof cssUnit === "boolean") mergedUnit = cssUnit;
				else if (Array.from(this.unitlessCssVar).some(function(cssVar) {
					return _this2.result.includes(cssVar);
				})) mergedUnit = false;
				this.result = this.result.replace(regexp$1, mergedUnit ? "px" : "");
				if (typeof this.lowPriority !== "undefined") return "calc(".concat(this.result, ")");
				return this.result;
			}
		}
	]);
	return CSSCalculator$1;
}(calculator_default);

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/calc/NumCalculator.js
var NumCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
	_inherits(NumCalculator$1, _AbstractCalculator);
	var _super = _createSuper(NumCalculator$1);
	function NumCalculator$1(num) {
		var _this;
		_classCallCheck(this, NumCalculator$1);
		_this = _super.call(this);
		_defineProperty(_assertThisInitialized(_this), "result", 0);
		if (num instanceof NumCalculator$1) _this.result = num.result;
		else if (typeof num === "number") _this.result = num;
		return _this;
	}
	_createClass(NumCalculator$1, [
		{
			key: "add",
			value: function add(num) {
				if (num instanceof NumCalculator$1) this.result += num.result;
				else if (typeof num === "number") this.result += num;
				return this;
			}
		},
		{
			key: "sub",
			value: function sub(num) {
				if (num instanceof NumCalculator$1) this.result -= num.result;
				else if (typeof num === "number") this.result -= num;
				return this;
			}
		},
		{
			key: "mul",
			value: function mul(num) {
				if (num instanceof NumCalculator$1) this.result *= num.result;
				else if (typeof num === "number") this.result *= num;
				return this;
			}
		},
		{
			key: "div",
			value: function div(num) {
				if (num instanceof NumCalculator$1) this.result /= num.result;
				else if (typeof num === "number") this.result /= num;
				return this;
			}
		},
		{
			key: "equal",
			value: function equal() {
				return this.result;
			}
		}
	]);
	return NumCalculator$1;
}(calculator_default);
var NumCalculator_default = NumCalculator;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/calc/index.js
var genCalc = function genCalc$1(type$2, unitlessCssVar) {
	var Calculator = type$2 === "css" ? CSSCalculator : NumCalculator_default;
	return function(num) {
		return new Calculator(num, unitlessCssVar);
	};
};
var calc_default = genCalc;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/getCompVarPrefix.js
var getCompVarPrefix = function getCompVarPrefix$1(component, prefix) {
	return "".concat([prefix, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
};
var getCompVarPrefix_default = getCompVarPrefix;

//#endregion
//#region node_modules/rc-util/es/hooks/useEvent.js
function useEvent(callback) {
	var fnRef = import_react.useRef();
	fnRef.current = callback;
	return import_react.useCallback(function() {
		var _fnRef$current;
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
	}, []);
}

//#endregion
//#region node_modules/rc-util/es/hooks/useState.js
/**
* Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
* We do not make this auto is to avoid real memory leak.
* Developer should confirm it's safe to ignore themselves.
*/
function useSafeState(defaultValue) {
	var destroyRef = import_react.useRef(false);
	var _React$useState = import_react.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
	import_react.useEffect(function() {
		destroyRef.current = false;
		return function() {
			destroyRef.current = true;
		};
	}, []);
	function safeSetState(updater, ignoreDestroy) {
		if (ignoreDestroy && destroyRef.current) return;
		setValue(updater);
	}
	return [value, safeSetState];
}

//#endregion
//#region node_modules/rc-util/es/hooks/useMergedState.js
/** We only think `undefined` is empty */
function hasValue$1(value) {
	return value !== void 0;
}
/**
* Similar to `useState` but will use props value if provided.
* Note that internal use rc-util `useState` hook.
*/
function useMergedState(defaultStateValue, option) {
	var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
	var _useState = useSafeState(function() {
		if (hasValue$1(value)) return value;
		else if (hasValue$1(defaultValue)) return typeof defaultValue === "function" ? defaultValue() : defaultValue;
		else return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
	}), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
	var mergedValue = value !== void 0 ? value : innerValue;
	var postMergedValue = postState ? postState(mergedValue) : mergedValue;
	var onChangeFn = useEvent(onChange);
	var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
	useLayoutUpdateEffect(function() {
		var prev$1 = prevValue[0];
		if (innerValue !== prev$1) onChangeFn(innerValue, prev$1);
	}, [prevValue]);
	useLayoutUpdateEffect(function() {
		if (!hasValue$1(value)) setInnerValue(value);
	}, [value]);
	var triggerChange = useEvent(function(updater, ignoreDestroy) {
		setInnerValue(updater, ignoreDestroy);
		setPrevValue([mergedValue], ignoreDestroy);
	});
	return [postMergedValue, triggerChange];
}

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/getComponentToken.js
function getComponentToken(component, token$1, defaultToken, options) {
	var customToken = _objectSpread2({}, token$1[component]);
	if (options !== null && options !== void 0 && options.deprecatedTokens) options.deprecatedTokens.forEach(function(_ref) {
		var _ref2 = _slicedToArray(_ref, 2), oldTokenKey = _ref2[0], newTokenKey = _ref2[1];
		warning_default(!(customToken !== null && customToken !== void 0 && customToken[oldTokenKey]), "Component Token `".concat(String(oldTokenKey), "` of ").concat(String(component), " is deprecated. Please use `").concat(String(newTokenKey), "` instead."));
		if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
			var _customToken$newToken;
			(_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 || (customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey]);
		}
	});
	var mergedToken = _objectSpread2(_objectSpread2({}, defaultToken), customToken);
	Object.keys(mergedToken).forEach(function(key) {
		if (mergedToken[key] === token$1[key]) delete mergedToken[key];
	});
	return mergedToken;
}
var getComponentToken_default = getComponentToken;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/statistic.js
var enableStatistic = true;
var recording = true;
/**
* This function will do as `Object.assign` in production. But will use Object.defineProperty:get to
* pass all value access in development. To support statistic field usage with alias token.
*/
function merge() {
	for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) objs[_key] = arguments[_key];
	/* istanbul ignore next */
	if (!enableStatistic) return Object.assign.apply(Object, [{}].concat(objs));
	recording = false;
	var ret = {};
	objs.forEach(function(obj) {
		if (_typeof(obj) !== "object") return;
		Object.keys(obj).forEach(function(key) {
			Object.defineProperty(ret, key, {
				configurable: true,
				enumerable: true,
				get: function get$1() {
					return obj[key];
				}
			});
		});
	});
	recording = true;
	return ret;
}
/** @internal Internal Usage. Not use in your production. */
var statistic = {};
/* istanbul ignore next */
function noop$3() {}
/** Statistic token usage case. Should use `merge` function if you do not want spread record. */
var statisticToken = function statisticToken$1(token$1) {
	var tokenKeys$1;
	var proxy = token$1;
	var flush = noop$3;
	if (enableStatistic && typeof Proxy !== "undefined") {
		tokenKeys$1 = /* @__PURE__ */ new Set();
		proxy = new Proxy(token$1, { get: function get$1(obj, prop) {
			if (recording) {
				var _tokenKeys;
				(_tokenKeys = tokenKeys$1) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
			}
			return obj[prop];
		} });
		flush = function flush$1(componentName, componentToken) {
			var _statistic$componentN;
			statistic[componentName] = {
				global: Array.from(tokenKeys$1),
				component: _objectSpread2(_objectSpread2({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
			};
		};
	}
	return {
		token: proxy,
		keys: tokenKeys$1,
		flush
	};
};
var statistic_default$1 = statisticToken;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/getDefaultComponentToken.js
function getDefaultComponentToken(component, token$1, getDefaultToken) {
	if (typeof getDefaultToken === "function") {
		var _token$component;
		return getDefaultToken(merge(token$1, (_token$component = token$1[component]) !== null && _token$component !== void 0 ? _token$component : {}));
	}
	return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
}
var getDefaultComponentToken_default = getDefaultComponentToken;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/maxmin.js
function genMaxMin(type$2) {
	if (type$2 === "js") return {
		max: Math.max,
		min: Math.min
	};
	return {
		max: function max() {
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			return "max(".concat(args.map(function(value) {
				return unit(value);
			}).join(","), ")");
		},
		min: function min() {
			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
			return "min(".concat(args.map(function(value) {
				return unit(value);
			}).join(","), ")");
		}
	};
}
var maxmin_default = genMaxMin;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js
var BEAT_LIMIT = 1e3 * 60 * 10;
var uniqueMap = new (/* @__PURE__ */ function() {
	function ArrayKeyMap() {
		_classCallCheck(this, ArrayKeyMap);
		_defineProperty(this, "map", /* @__PURE__ */ new Map());
		_defineProperty(this, "objectIDMap", /* @__PURE__ */ new WeakMap());
		_defineProperty(this, "nextID", 0);
		_defineProperty(this, "lastAccessBeat", /* @__PURE__ */ new Map());
		_defineProperty(this, "accessBeat", 0);
	}
	_createClass(ArrayKeyMap, [
		{
			key: "set",
			value: function set$1(keys$1, value) {
				this.clear();
				var compositeKey = this.getCompositeKey(keys$1);
				this.map.set(compositeKey, value);
				this.lastAccessBeat.set(compositeKey, Date.now());
			}
		},
		{
			key: "get",
			value: function get$1(keys$1) {
				var compositeKey = this.getCompositeKey(keys$1);
				var cache = this.map.get(compositeKey);
				this.lastAccessBeat.set(compositeKey, Date.now());
				this.accessBeat += 1;
				return cache;
			}
		},
		{
			key: "getCompositeKey",
			value: function getCompositeKey(keys$1) {
				var _this = this;
				return keys$1.map(function(key) {
					if (key && _typeof(key) === "object") return "obj_".concat(_this.getObjectID(key));
					return "".concat(_typeof(key), "_").concat(key);
				}).join("|");
			}
		},
		{
			key: "getObjectID",
			value: function getObjectID(obj) {
				if (this.objectIDMap.has(obj)) return this.objectIDMap.get(obj);
				var id = this.nextID;
				this.objectIDMap.set(obj, id);
				this.nextID += 1;
				return id;
			}
		},
		{
			key: "clear",
			value: function clear() {
				var _this2 = this;
				if (this.accessBeat > 1e4) {
					var now$1 = Date.now();
					this.lastAccessBeat.forEach(function(beat, key) {
						if (now$1 - beat > BEAT_LIMIT) {
							_this2.map.delete(key);
							_this2.lastAccessBeat.delete(key);
						}
					});
					this.accessBeat = 0;
				}
			}
		}
	]);
	return ArrayKeyMap;
}())();
/**
* Like `useMemo`, but this hook result will be shared across all instances.
*/
function useUniqueMemo(memoFn, deps) {
	return import_react.useMemo(function() {
		var cachedValue = uniqueMap.get(deps);
		if (cachedValue) return cachedValue;
		var newValue = memoFn();
		uniqueMap.set(deps, newValue);
		return newValue;
	}, deps);
}
var useUniqueMemo_default = useUniqueMemo;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/hooks/useCSP.js
/**
* Provide a default hook since not everyone needs to config this.
*/
var useDefaultCSP = function useDefaultCSP$1() {
	return {};
};
var useCSP_default = useDefaultCSP;

//#endregion
//#region node_modules/@ant-design/cssinjs-utils/es/util/genStyleUtils.js
function genStyleUtils(config) {
	var _config$useCSP = config.useCSP, useCSP = _config$useCSP === void 0 ? useCSP_default : _config$useCSP, useToken$2 = config.useToken, usePrefix = config.usePrefix, getResetStyles$1 = config.getResetStyles, getCommonStyle = config.getCommonStyle, getCompUnitless = config.getCompUnitless;
	function genStyleHooks$1(component, styleFn, getDefaultToken, options) {
		var componentName = Array.isArray(component) ? component[0] : component;
		function prefixToken(key) {
			return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
		}
		var originUnitless = (options === null || options === void 0 ? void 0 : options.unitless) || {};
		var originCompUnitless = typeof getCompUnitless === "function" ? getCompUnitless(component) : {};
		var compUnitless = _objectSpread2(_objectSpread2({}, originCompUnitless), {}, _defineProperty({}, prefixToken("zIndexPopup"), true));
		Object.keys(originUnitless).forEach(function(key) {
			compUnitless[prefixToken(key)] = originUnitless[key];
		});
		var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
			unitless: compUnitless,
			prefixToken
		});
		var useStyle = genComponentStyleHook$1(component, styleFn, getDefaultToken, mergedOptions);
		var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
		return function(prefixCls) {
			var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
			var _useStyle = useStyle(prefixCls, rootCls), _useStyle2 = _slicedToArray(_useStyle, 2), hashId = _useStyle2[1];
			var _useCSSVar = useCSSVar(rootCls), _useCSSVar2 = _slicedToArray(_useCSSVar, 2), wrapCSSVar = _useCSSVar2[0], cssVarCls = _useCSSVar2[1];
			return [
				wrapCSSVar,
				hashId,
				cssVarCls
			];
		};
	}
	function genCSSVarRegister(component, getDefaultToken, options) {
		var compUnitless = options.unitless, _options$injectStyle = options.injectStyle, injectStyle = _options$injectStyle === void 0 ? true : _options$injectStyle, prefixToken = options.prefixToken, ignore$1 = options.ignore;
		var CSSVarRegister = function CSSVarRegister$1(_ref) {
			var rootCls = _ref.rootCls, _ref$cssVar = _ref.cssVar, cssVar = _ref$cssVar === void 0 ? {} : _ref$cssVar;
			var _useToken = useToken$2(), realToken = _useToken.realToken;
			useCSSVarRegister_default({
				path: [component],
				prefix: cssVar.prefix,
				key: cssVar.key,
				unitless: compUnitless,
				ignore: ignore$1,
				token: realToken,
				scope: rootCls
			}, function() {
				var defaultToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
				var componentToken = getComponentToken_default(component, realToken, defaultToken, { deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens });
				Object.keys(defaultToken).forEach(function(key) {
					componentToken[prefixToken(key)] = componentToken[key];
					delete componentToken[key];
				});
				return componentToken;
			});
			return null;
		};
		return function useCSSVar(rootCls) {
			var _useToken2 = useToken$2(), cssVar = _useToken2.cssVar;
			return [function(node$1) {
				return injectStyle && cssVar ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(CSSVarRegister, {
					rootCls,
					cssVar,
					component
				}), node$1) : node$1;
			}, cssVar === null || cssVar === void 0 ? void 0 : cssVar.key];
		};
	}
	function genComponentStyleHook$1(componentName, styleFn, getDefaultToken) {
		var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
		var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
		var _cells = _slicedToArray(cells, 1), component = _cells[0];
		var concatComponent = cells.join("-");
		var mergedLayer = config.layer || { name: "antd" };
		return function(prefixCls) {
			var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
			var _useToken3 = useToken$2(), theme = _useToken3.theme, realToken = _useToken3.realToken, hashId = _useToken3.hashId, token$1 = _useToken3.token, cssVar = _useToken3.cssVar;
			var _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.rootPrefixCls, iconPrefixCls = _usePrefix.iconPrefixCls;
			var csp = useCSP();
			var type$2 = cssVar ? "css" : "js";
			var calc = useUniqueMemo_default(function() {
				var unitlessCssVar = /* @__PURE__ */ new Set();
				if (cssVar) Object.keys(options.unitless || {}).forEach(function(key) {
					unitlessCssVar.add(token2CSSVar(key, cssVar.prefix));
					unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)));
				});
				return calc_default(type$2, unitlessCssVar);
			}, [
				type$2,
				component,
				cssVar === null || cssVar === void 0 ? void 0 : cssVar.prefix
			]);
			var _genMaxMin = maxmin_default(type$2), max = _genMaxMin.max, min = _genMaxMin.min;
			var sharedConfig = {
				theme,
				token: token$1,
				hashId,
				nonce: function nonce() {
					return csp.nonce;
				},
				clientOnly: options.clientOnly,
				layer: mergedLayer,
				order: options.order || -999
			};
			if (typeof getResetStyles$1 === "function") useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
				clientOnly: false,
				path: ["Shared", rootPrefixCls]
			}), function() {
				return getResetStyles$1(token$1, {
					prefix: {
						rootPrefixCls,
						iconPrefixCls
					},
					csp
				});
			});
			return [useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, { path: [
				concatComponent,
				prefixCls,
				iconPrefixCls
			] }), function() {
				if (options.injectStyle === false) return [];
				var _statisticToken = statistic_default$1(token$1), proxyToken = _statisticToken.token, flush = _statisticToken.flush;
				var defaultComponentToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
				var componentCls = ".".concat(prefixCls);
				var componentToken = getComponentToken_default(component, realToken, defaultComponentToken, { deprecatedTokens: options.deprecatedTokens });
				if (cssVar && defaultComponentToken && _typeof(defaultComponentToken) === "object") Object.keys(defaultComponentToken).forEach(function(key) {
					defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)), ")");
				});
				var mergedToken = merge(proxyToken, {
					componentCls,
					prefixCls,
					iconCls: ".".concat(iconPrefixCls),
					antCls: ".".concat(rootPrefixCls),
					calc,
					max,
					min
				}, cssVar ? defaultComponentToken : componentToken);
				var styleInterpolation = styleFn(mergedToken, {
					hashId,
					prefixCls,
					rootPrefixCls,
					iconPrefixCls
				});
				flush(component, componentToken);
				var commonStyle = typeof getCommonStyle === "function" ? getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont) : null;
				return [options.resetStyle === false ? null : commonStyle, styleInterpolation];
			}), hashId];
		};
	}
	function genSubStyleComponent$1(componentName, styleFn, getDefaultToken) {
		var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
		var useStyle = genComponentStyleHook$1(componentName, styleFn, getDefaultToken, _objectSpread2({
			resetStyle: false,
			order: -998
		}, options));
		var StyledComponent = function StyledComponent$1(_ref2) {
			var prefixCls = _ref2.prefixCls, _ref2$rootCls = _ref2.rootCls;
			useStyle(prefixCls, _ref2$rootCls === void 0 ? prefixCls : _ref2$rootCls);
			return null;
		};
		StyledComponent.displayName = "SubStyle_".concat(String(Array.isArray(componentName) ? componentName.join(".") : componentName));
		return StyledComponent;
	}
	return {
		genStyleHooks: genStyleHooks$1,
		genSubStyleComponent: genSubStyleComponent$1,
		genComponentStyleHook: genComponentStyleHook$1
	};
}
var genStyleUtils_default = genStyleUtils;

//#endregion
//#region node_modules/antd/es/theme/interface/presetColors.js
const PresetColors = [
	"blue",
	"purple",
	"cyan",
	"green",
	"magenta",
	"pink",
	"red",
	"orange",
	"yellow",
	"volcano",
	"geekblue",
	"lime",
	"gold"
];

//#endregion
//#region node_modules/antd/es/version/version.js
var version_default$1 = "5.27.4";

//#endregion
//#region node_modules/antd/es/version/index.js
var version_default = version_default$1;

//#endregion
//#region node_modules/antd/es/theme/util/getAlphaColor.js
function isStableColor(color) {
	return color >= 0 && color <= 255;
}
function getAlphaColor$1(frontColor, backgroundColor) {
	const { r: fR, g: fG, b: fB, a: originAlpha } = new FastColor(frontColor).toRgb();
	if (originAlpha < 1) return frontColor;
	const { r: bR, g: bG, b: bB } = new FastColor(backgroundColor).toRgb();
	for (let fA = .01; fA <= 1; fA += .01) {
		const r$1 = Math.round((fR - bR * (1 - fA)) / fA);
		const g = Math.round((fG - bG * (1 - fA)) / fA);
		const b = Math.round((fB - bB * (1 - fA)) / fA);
		if (isStableColor(r$1) && isStableColor(g) && isStableColor(b)) return new FastColor({
			r: r$1,
			g,
			b,
			a: Math.round(fA * 100) / 100
		}).toRgbString();
	}
	/* istanbul ignore next */
	return new FastColor({
		r: fR,
		g: fG,
		b: fB,
		a: 1
	}).toRgbString();
}
var getAlphaColor_default = getAlphaColor$1;

//#endregion
//#region node_modules/antd/es/theme/util/alias.js
var __rest$114 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
/**
* Seed (designer) > Derivative (designer) > Alias (developer).
*
* Merge seed & derivative & override token and generate alias token for developer.
*/
function formatToken(derivativeToken) {
	const { override } = derivativeToken, restToken = __rest$114(derivativeToken, ["override"]);
	const overrideTokens = Object.assign({}, override);
	Object.keys(seed_default).forEach((token$1) => {
		delete overrideTokens[token$1];
	});
	const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
	const screenXS = 480;
	const screenSM = 576;
	const screenMD = 768;
	const screenLG = 992;
	const screenXL = 1200;
	const screenXXL = 1600;
	if (mergedToken.motion === false) {
		const fastDuration = "0s";
		mergedToken.motionDurationFast = fastDuration;
		mergedToken.motionDurationMid = fastDuration;
		mergedToken.motionDurationSlow = fastDuration;
	}
	return Object.assign(Object.assign(Object.assign({}, mergedToken), {
		colorFillContent: mergedToken.colorFillSecondary,
		colorFillContentHover: mergedToken.colorFill,
		colorFillAlter: mergedToken.colorFillQuaternary,
		colorBgContainerDisabled: mergedToken.colorFillTertiary,
		colorBorderBg: mergedToken.colorBgContainer,
		colorSplit: getAlphaColor_default(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
		colorTextPlaceholder: mergedToken.colorTextQuaternary,
		colorTextDisabled: mergedToken.colorTextQuaternary,
		colorTextHeading: mergedToken.colorText,
		colorTextLabel: mergedToken.colorTextSecondary,
		colorTextDescription: mergedToken.colorTextTertiary,
		colorTextLightSolid: mergedToken.colorWhite,
		colorHighlight: mergedToken.colorError,
		colorBgTextHover: mergedToken.colorFillSecondary,
		colorBgTextActive: mergedToken.colorFill,
		colorIcon: mergedToken.colorTextTertiary,
		colorIconHover: mergedToken.colorText,
		colorErrorOutline: getAlphaColor_default(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
		colorWarningOutline: getAlphaColor_default(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
		fontSizeIcon: mergedToken.fontSizeSM,
		lineWidthFocus: mergedToken.lineWidth * 3,
		lineWidth: mergedToken.lineWidth,
		controlOutlineWidth: mergedToken.lineWidth * 2,
		controlInteractiveSize: mergedToken.controlHeight / 2,
		controlItemBgHover: mergedToken.colorFillTertiary,
		controlItemBgActive: mergedToken.colorPrimaryBg,
		controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
		controlItemBgActiveDisabled: mergedToken.colorFill,
		controlTmpOutline: mergedToken.colorFillQuaternary,
		controlOutline: getAlphaColor_default(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
		lineType: mergedToken.lineType,
		borderRadius: mergedToken.borderRadius,
		borderRadiusXS: mergedToken.borderRadiusXS,
		borderRadiusSM: mergedToken.borderRadiusSM,
		borderRadiusLG: mergedToken.borderRadiusLG,
		fontWeightStrong: 600,
		opacityLoading: .65,
		linkDecoration: "none",
		linkHoverDecoration: "none",
		linkFocusDecoration: "none",
		controlPaddingHorizontal: 12,
		controlPaddingHorizontalSM: 8,
		paddingXXS: mergedToken.sizeXXS,
		paddingXS: mergedToken.sizeXS,
		paddingSM: mergedToken.sizeSM,
		padding: mergedToken.size,
		paddingMD: mergedToken.sizeMD,
		paddingLG: mergedToken.sizeLG,
		paddingXL: mergedToken.sizeXL,
		paddingContentHorizontalLG: mergedToken.sizeLG,
		paddingContentVerticalLG: mergedToken.sizeMS,
		paddingContentHorizontal: mergedToken.sizeMS,
		paddingContentVertical: mergedToken.sizeSM,
		paddingContentHorizontalSM: mergedToken.size,
		paddingContentVerticalSM: mergedToken.sizeXS,
		marginXXS: mergedToken.sizeXXS,
		marginXS: mergedToken.sizeXS,
		marginSM: mergedToken.sizeSM,
		margin: mergedToken.size,
		marginMD: mergedToken.sizeMD,
		marginLG: mergedToken.sizeLG,
		marginXL: mergedToken.sizeXL,
		marginXXL: mergedToken.sizeXXL,
		boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
		screenXS,
		screenXSMin: screenXS,
		screenXSMax: screenSM - 1,
		screenSM,
		screenSMMin: screenSM,
		screenSMMax: screenMD - 1,
		screenMD,
		screenMDMin: screenMD,
		screenMDMax: screenLG - 1,
		screenLG,
		screenLGMin: screenLG,
		screenLGMax: screenXL - 1,
		screenXL,
		screenXLMin: screenXL,
		screenXLMax: screenXXL - 1,
		screenXXL,
		screenXXLMin: screenXXL,
		boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
		boxShadowCard: `
      0 1px 2px -2px ${new FastColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new FastColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new FastColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
		boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
		boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
		boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
	}), overrideTokens);
}

//#endregion
//#region node_modules/antd/es/theme/useToken.js
var __rest$113 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const unitless = {
	lineHeight: true,
	lineHeightSM: true,
	lineHeightLG: true,
	lineHeightHeading1: true,
	lineHeightHeading2: true,
	lineHeightHeading3: true,
	lineHeightHeading4: true,
	lineHeightHeading5: true,
	opacityLoading: true,
	fontWeightStrong: true,
	zIndexPopupBase: true,
	zIndexBase: true,
	opacityImage: true
};
const ignore = {
	motionBase: true,
	motionUnit: true
};
var preserve = {
	screenXS: true,
	screenXSMin: true,
	screenXSMax: true,
	screenSM: true,
	screenSMMin: true,
	screenSMMax: true,
	screenMD: true,
	screenMDMin: true,
	screenMDMax: true,
	screenLG: true,
	screenLGMin: true,
	screenLGMax: true,
	screenXL: true,
	screenXLMin: true,
	screenXLMax: true,
	screenXXL: true,
	screenXXLMin: true
};
const getComputedToken$1 = (originToken, overrideToken, theme) => {
	const derivativeToken = theme.getDerivativeToken(originToken);
	const { override } = overrideToken, components$1 = __rest$113(overrideToken, ["override"]);
	let mergedDerivativeToken = Object.assign(Object.assign({}, derivativeToken), { override });
	mergedDerivativeToken = formatToken(mergedDerivativeToken);
	if (components$1) Object.entries(components$1).forEach(([key, value]) => {
		const { theme: componentTheme } = value, componentTokens = __rest$113(value, ["theme"]);
		let mergedComponentToken = componentTokens;
		if (componentTheme) mergedComponentToken = getComputedToken$1(Object.assign(Object.assign({}, mergedDerivativeToken), componentTokens), { override: componentTokens }, componentTheme);
		mergedDerivativeToken[key] = mergedComponentToken;
	});
	return mergedDerivativeToken;
};
function useToken() {
	const { token: rootDesignToken, hashed, theme, override, cssVar } = import_react.useContext(DesignTokenContext);
	const salt = `${version_default}-${hashed || ""}`;
	const mergedTheme = theme || theme_default$1;
	const [token$1, hashId, realToken] = useCacheToken(mergedTheme, [seed_default, rootDesignToken], {
		salt,
		override,
		getComputedToken: getComputedToken$1,
		formatToken,
		cssVar: cssVar && {
			prefix: cssVar.prefix,
			key: cssVar.key,
			unitless,
			ignore,
			preserve
		}
	});
	return [
		mergedTheme,
		realToken,
		hashed ? hashId : "",
		token$1,
		cssVar
	];
}

//#endregion
//#region node_modules/antd/es/style/index.js
const textEllipsis = {
	overflow: "hidden",
	whiteSpace: "nowrap",
	textOverflow: "ellipsis"
};
const resetComponent = (token$1, needInheritFontFamily = false) => ({
	boxSizing: "border-box",
	margin: 0,
	padding: 0,
	color: token$1.colorText,
	fontSize: token$1.fontSize,
	lineHeight: token$1.lineHeight,
	listStyle: "none",
	fontFamily: needInheritFontFamily ? "inherit" : token$1.fontFamily
});
const resetIcon = () => ({
	display: "inline-flex",
	alignItems: "center",
	color: "inherit",
	fontStyle: "normal",
	lineHeight: 0,
	textAlign: "center",
	textTransform: "none",
	verticalAlign: "-0.125em",
	textRendering: "optimizeLegibility",
	"-webkit-font-smoothing": "antialiased",
	"-moz-osx-font-smoothing": "grayscale",
	"> *": { lineHeight: 1 },
	svg: { display: "inline-block" }
});
const clearFix = () => ({
	"&::before": {
		display: "table",
		content: "\"\""
	},
	"&::after": {
		display: "table",
		clear: "both",
		content: "\"\""
	}
});
const genLinkStyle$1 = (token$1) => ({ a: {
	color: token$1.colorLink,
	textDecoration: token$1.linkDecoration,
	backgroundColor: "transparent",
	outline: "none",
	cursor: "pointer",
	transition: `color ${token$1.motionDurationSlow}`,
	"-webkit-text-decoration-skip": "objects",
	"&:hover": { color: token$1.colorLinkHover },
	"&:active": { color: token$1.colorLinkActive },
	"&:active, &:hover": {
		textDecoration: token$1.linkHoverDecoration,
		outline: 0
	},
	"&:focus": {
		textDecoration: token$1.linkFocusDecoration,
		outline: 0
	},
	"&[disabled]": {
		color: token$1.colorTextDisabled,
		cursor: "not-allowed"
	}
} });
const genCommonStyle = (token$1, componentPrefixCls, rootCls, resetFont) => {
	const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
	const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
	const resetStyle = {
		boxSizing: "border-box",
		"&::before, &::after": { boxSizing: "border-box" }
	};
	let resetFontStyle = {};
	if (resetFont !== false) resetFontStyle = {
		fontFamily: token$1.fontFamily,
		fontSize: token$1.fontSize
	};
	return { [rootPrefixSelector]: Object.assign(Object.assign(Object.assign({}, resetFontStyle), resetStyle), { [prefixSelector]: resetStyle }) };
};
const genFocusOutline = (token$1, offset$2) => ({
	outline: `${unit(token$1.lineWidthFocus)} solid ${token$1.colorPrimaryBorder}`,
	outlineOffset: offset$2 !== null && offset$2 !== void 0 ? offset$2 : 1,
	transition: "outline-offset 0s, outline 0s"
});
const genFocusStyle = (token$1, offset$2) => ({ "&:focus-visible": genFocusOutline(token$1, offset$2) });
const genIconStyle = (iconPrefixCls) => ({ [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), { [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: { display: "block" } }) });
const operationUnit = (token$1) => Object.assign(Object.assign({
	color: token$1.colorLink,
	textDecoration: token$1.linkDecoration,
	outline: "none",
	cursor: "pointer",
	transition: `all ${token$1.motionDurationSlow}`,
	border: 0,
	padding: 0,
	background: "none",
	userSelect: "none"
}, genFocusStyle(token$1)), {
	"&:hover": {
		color: token$1.colorLinkHover,
		textDecoration: token$1.linkHoverDecoration
	},
	"&:focus": {
		color: token$1.colorLinkHover,
		textDecoration: token$1.linkFocusDecoration
	},
	"&:active": {
		color: token$1.colorLinkActive,
		textDecoration: token$1.linkHoverDecoration
	}
});

//#endregion
//#region node_modules/antd/es/theme/util/genStyleUtils.js
const { genStyleHooks, genComponentStyleHook, genSubStyleComponent } = genStyleUtils_default({
	usePrefix: () => {
		const { getPrefixCls, iconPrefixCls } = (0, import_react.useContext)(ConfigContext);
		return {
			rootPrefixCls: getPrefixCls(),
			iconPrefixCls
		};
	},
	useToken: () => {
		const [theme, realToken, hashId, token$1, cssVar] = useToken();
		return {
			theme,
			realToken,
			hashId,
			token: token$1,
			cssVar
		};
	},
	useCSP: () => {
		const { csp } = (0, import_react.useContext)(ConfigContext);
		return csp !== null && csp !== void 0 ? csp : {};
	},
	getResetStyles: (token$1, config) => {
		var _a;
		const linkStyle = genLinkStyle$1(token$1);
		return [
			linkStyle,
			{ "&": linkStyle },
			genIconStyle((_a = config === null || config === void 0 ? void 0 : config.prefix.iconPrefixCls) !== null && _a !== void 0 ? _a : defaultIconPrefixCls)
		];
	},
	getCommonStyle: genCommonStyle,
	getCompUnitless: () => unitless
});

//#endregion
//#region node_modules/antd/es/theme/util/genPresetColor.js
function genPresetColor(token$1, genCss) {
	return PresetColors.reduce((prev$1, colorKey) => {
		const lightColor = token$1[`${colorKey}1`];
		const lightBorderColor = token$1[`${colorKey}3`];
		const darkColor = token$1[`${colorKey}6`];
		const textColor = token$1[`${colorKey}7`];
		return Object.assign(Object.assign({}, prev$1), genCss(colorKey, {
			lightColor,
			lightBorderColor,
			darkColor,
			textColor
		}));
	}, {});
}

//#endregion
//#region node_modules/antd/es/theme/util/useResetIconStyle.js
var useResetIconStyle = (iconPrefixCls, csp) => {
	const [theme, token$1] = useToken();
	return useStyleRegister({
		theme,
		token: token$1,
		hashId: "",
		path: ["ant-design-icons", iconPrefixCls],
		nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce,
		layer: { name: "antd" }
	}, () => genIconStyle(iconPrefixCls));
};
var useResetIconStyle_default = useResetIconStyle;

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useThemeKey.js
var { useId: useId$1 } = Object.assign({}, import_react);
var useEmptyId = () => "";
var useThemeKey = typeof useId$1 === "undefined" ? useEmptyId : useId$1;
var useThemeKey_default = useThemeKey;

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useTheme.js
function useTheme(theme, parentTheme, config) {
	var _a, _b;
	const warning$4 = devUseWarning("ConfigProvider");
	const themeConfig = theme || {};
	const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? Object.assign(Object.assign({}, defaultConfig), {
		hashed: (_a = parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.hashed) !== null && _a !== void 0 ? _a : defaultConfig.hashed,
		cssVar: parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.cssVar
	}) : parentTheme;
	const themeKey = useThemeKey_default();
	{
		const cssVarEnabled = themeConfig.cssVar || parentThemeConfig.cssVar;
		const validKey = !!(typeof themeConfig.cssVar === "object" && ((_b = themeConfig.cssVar) === null || _b === void 0 ? void 0 : _b.key) || themeKey);
		warning$4(!cssVarEnabled || validKey, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.");
	}
	return useMemo$1(() => {
		var _a$1, _b$1;
		if (!theme) return parentTheme;
		const mergedComponents = Object.assign({}, parentThemeConfig.components);
		Object.keys(theme.components || {}).forEach((componentName) => {
			mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme.components[componentName]);
		});
		const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
		const mergedCssVar = ((_a$1 = themeConfig.cssVar) !== null && _a$1 !== void 0 ? _a$1 : parentThemeConfig.cssVar) && Object.assign(Object.assign(Object.assign({ prefix: config === null || config === void 0 ? void 0 : config.prefixCls }, typeof parentThemeConfig.cssVar === "object" ? parentThemeConfig.cssVar : {}), typeof themeConfig.cssVar === "object" ? themeConfig.cssVar : {}), { key: typeof themeConfig.cssVar === "object" && ((_b$1 = themeConfig.cssVar) === null || _b$1 === void 0 ? void 0 : _b$1.key) || cssVarKey });
		return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
			token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
			components: mergedComponents,
			cssVar: mergedCssVar
		});
	}, [themeConfig, parentThemeConfig], (prev$1, next$1) => prev$1.some((prevTheme, index$2) => {
		const nextTheme = next$1[index$2];
		return !isEqual_default(prevTheme, nextTheme, true);
	}));
}

//#endregion
//#region node_modules/rc-motion/es/context.js
var _excluded$77 = ["children"];
var Context$1 = /* @__PURE__ */ import_react.createContext({});
function MotionProvider(_ref) {
	var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$77);
	return /* @__PURE__ */ import_react.createElement(Context$1.Provider, { value: props }, children);
}

//#endregion
//#region node_modules/rc-motion/es/DomWrapper.js
var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
	_inherits(DomWrapper$3, _React$Component);
	var _super = _createSuper(DomWrapper$3);
	function DomWrapper$3() {
		_classCallCheck(this, DomWrapper$3);
		return _super.apply(this, arguments);
	}
	_createClass(DomWrapper$3, [{
		key: "render",
		value: function render$1() {
			return this.props.children;
		}
	}]);
	return DomWrapper$3;
}(import_react.Component);
var DomWrapper_default = DomWrapper$1;

//#endregion
//#region node_modules/rc-util/es/hooks/useSyncState.js
/**
* Same as React.useState but will always get latest state.
* This is useful when React merge multiple state updates into one.
* e.g. onTransitionEnd trigger multiple event at once will be merged state update in React.
*/
function useSyncState$3(defaultValue) {
	var _React$useReducer = import_react.useReducer(function(x) {
		return x + 1;
	}, 0), _React$useReducer2 = _slicedToArray(_React$useReducer, 2), forceUpdate = _React$useReducer2[1];
	var currentValueRef = import_react.useRef(defaultValue);
	var getValue$2 = useEvent(function() {
		return currentValueRef.current;
	});
	var setValue = useEvent(function(updater) {
		currentValueRef.current = typeof updater === "function" ? updater(currentValueRef.current) : updater;
		forceUpdate();
	});
	return [getValue$2, setValue];
}

//#endregion
//#region node_modules/rc-motion/es/interface.js
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
/**
* Used for disabled motion case.
* Prepare stage will still work but start & active will be skipped.
*/
var STEP_PREPARED = "prepared";

//#endregion
//#region node_modules/rc-motion/es/util/motion.js
function makePrefixMap(styleProp, eventName) {
	var prefixes = {};
	prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
	prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
	prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
	prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
	return prefixes;
}
function getVendorPrefixes(domSupport, win$1) {
	var prefixes = {
		animationend: makePrefixMap("Animation", "AnimationEnd"),
		transitionend: makePrefixMap("Transition", "TransitionEnd")
	};
	if (domSupport) {
		if (!("AnimationEvent" in win$1)) delete prefixes.animationend.animation;
		if (!("TransitionEvent" in win$1)) delete prefixes.transitionend.transition;
	}
	return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
var style = {};
if (canUseDom()) style = document.createElement("div").style;
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
	if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
	var prefixMap = vendorPrefixes[eventName];
	if (prefixMap) {
		var stylePropList = Object.keys(prefixMap);
		var len = stylePropList.length;
		for (var i = 0; i < len; i += 1) {
			var styleProp = stylePropList[i];
			if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
				prefixedEventNames[eventName] = prefixMap[styleProp];
				return prefixedEventNames[eventName];
			}
		}
	}
	return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName$1(transitionName, transitionType) {
	if (!transitionName) return null;
	if (_typeof(transitionName) === "object") {
		var type$2 = transitionType.replace(/-\w/g, function(match$1) {
			return match$1[1].toUpperCase();
		});
		return transitionName[type$2];
	}
	return "".concat(transitionName, "-").concat(transitionType);
}

//#endregion
//#region node_modules/rc-motion/es/hooks/useDomMotionEvents.js
var useDomMotionEvents_default = (function(onInternalMotionEnd) {
	var cacheElementRef = (0, import_react.useRef)();
	function removeMotionEvents(element) {
		if (element) {
			element.removeEventListener(transitionEndName, onInternalMotionEnd);
			element.removeEventListener(animationEndName, onInternalMotionEnd);
		}
	}
	function patchMotionEvents(element) {
		if (cacheElementRef.current && cacheElementRef.current !== element) removeMotionEvents(cacheElementRef.current);
		if (element && element !== cacheElementRef.current) {
			element.addEventListener(transitionEndName, onInternalMotionEnd);
			element.addEventListener(animationEndName, onInternalMotionEnd);
			cacheElementRef.current = element;
		}
	}
	import_react.useEffect(function() {
		return function() {
			removeMotionEvents(cacheElementRef.current);
		};
	}, []);
	return [patchMotionEvents, removeMotionEvents];
});

//#endregion
//#region node_modules/rc-motion/es/hooks/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = canUseDom() ? import_react.useLayoutEffect : import_react.useEffect;
var useIsomorphicLayoutEffect_default = useIsomorphicLayoutEffect;

//#endregion
//#region node_modules/rc-motion/es/hooks/useNextFrame.js
var useNextFrame_default = (function() {
	var nextFrameRef = import_react.useRef(null);
	function cancelNextFrame() {
		raf_default.cancel(nextFrameRef.current);
	}
	function nextFrame(callback) {
		var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
		cancelNextFrame();
		var nextFrameId = raf_default(function() {
			if (delay <= 1) callback({ isCanceled: function isCanceled() {
				return nextFrameId !== nextFrameRef.current;
			} });
			else nextFrame(callback, delay - 1);
		});
		nextFrameRef.current = nextFrameId;
	}
	import_react.useEffect(function() {
		return function() {
			cancelNextFrame();
		};
	}, []);
	return [nextFrame, cancelNextFrame];
});

//#endregion
//#region node_modules/rc-motion/es/hooks/useStepQueue.js
var FULL_STEP_QUEUE = [
	STEP_PREPARE,
	STEP_START,
	STEP_ACTIVE,
	STEP_ACTIVATED
];
var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
/** Skip current step */
var SkipStep = false;
/** Current step should be update in */
var DoStep = true;
function isActive(step) {
	return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
var useStepQueue_default = (function(status, prepareOnly, callback) {
	var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
	var _useNextFrame = useNextFrame_default(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
	function startQueue() {
		setStep(STEP_PREPARE, true);
	}
	var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
	useIsomorphicLayoutEffect_default(function() {
		if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
			var index$2 = STEP_QUEUE.indexOf(step);
			var nextStep = STEP_QUEUE[index$2 + 1];
			var result = callback(step);
			if (result === SkipStep) setStep(nextStep, true);
			else if (nextStep) nextFrame(function(info) {
				function doNext() {
					if (info.isCanceled()) return;
					setStep(nextStep, true);
				}
				if (result === true) doNext();
				else Promise.resolve(result).then(doNext);
			});
		}
	}, [status, step]);
	import_react.useEffect(function() {
		return function() {
			cancelNextFrame();
		};
	}, []);
	return [startQueue, step];
});

//#endregion
//#region node_modules/rc-motion/es/hooks/useStatus.js
function useStatus$1(supportMotion, visible, getElement, _ref) {
	var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
	var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
	var _useSyncState = useSyncState$3(STATUS_NONE), _useSyncState2 = _slicedToArray(_useSyncState, 2), getStatus$1 = _useSyncState2[0], setStatus = _useSyncState2[1];
	var _useState3 = useSafeState(null), _useState4 = _slicedToArray(_useState3, 2), style$1 = _useState4[0], setStyle = _useState4[1];
	var currentStatus = getStatus$1();
	var mountedRef = (0, import_react.useRef)(false);
	var deadlineRef = (0, import_react.useRef)(null);
	function getDomElement() {
		return getElement();
	}
	var activeRef = (0, import_react.useRef)(false);
	/**
	* Clean up status & style
	*/
	function updateMotionEndStatus() {
		setStatus(STATUS_NONE);
		setStyle(null, true);
	}
	var onInternalMotionEnd = useEvent(function(event) {
		var status = getStatus$1();
		if (status === STATUS_NONE) return;
		var element = getDomElement();
		if (event && !event.deadline && event.target !== element) return;
		var currentActive = activeRef.current;
		var canEnd;
		if (status === STATUS_APPEAR && currentActive) canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
		else if (status === STATUS_ENTER && currentActive) canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
		else if (status === STATUS_LEAVE && currentActive) canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
		if (currentActive && canEnd !== false) updateMotionEndStatus();
	});
	var _useDomMotionEvents = useDomMotionEvents_default(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
	var getEventHandlers = function getEventHandlers$1(targetStatus) {
		switch (targetStatus) {
			case STATUS_APPEAR: return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onAppearPrepare), STEP_START, onAppearStart), STEP_ACTIVE, onAppearActive);
			case STATUS_ENTER: return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onEnterPrepare), STEP_START, onEnterStart), STEP_ACTIVE, onEnterActive);
			case STATUS_LEAVE: return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onLeavePrepare), STEP_START, onLeaveStart), STEP_ACTIVE, onLeaveActive);
			default: return {};
		}
	};
	var eventHandlers = import_react.useMemo(function() {
		return getEventHandlers(currentStatus);
	}, [currentStatus]);
	var _useStepQueue = useStepQueue_default(currentStatus, !supportMotion, function(newStep) {
		if (newStep === STEP_PREPARE) {
			var onPrepare = eventHandlers[STEP_PREPARE];
			if (!onPrepare) return SkipStep;
			return onPrepare(getDomElement());
		}
		if (step in eventHandlers) {
			var _eventHandlers$step;
			setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
		}
		if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
			patchMotionEvents(getDomElement());
			if (motionDeadline > 0) {
				clearTimeout(deadlineRef.current);
				deadlineRef.current = setTimeout(function() {
					onInternalMotionEnd({ deadline: true });
				}, motionDeadline);
			}
		}
		if (step === STEP_PREPARED) updateMotionEndStatus();
		return DoStep;
	}), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
	activeRef.current = isActive(step);
	var visibleRef = (0, import_react.useRef)(null);
	useIsomorphicLayoutEffect_default(function() {
		if (mountedRef.current && visibleRef.current === visible) return;
		setAsyncVisible(visible);
		var isMounted = mountedRef.current;
		mountedRef.current = true;
		var nextStatus;
		if (!isMounted && visible && motionAppear) nextStatus = STATUS_APPEAR;
		if (isMounted && visible && motionEnter) nextStatus = STATUS_ENTER;
		if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) nextStatus = STATUS_LEAVE;
		var nextEventHandlers = getEventHandlers(nextStatus);
		if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
			setStatus(nextStatus);
			startStep();
		} else setStatus(STATUS_NONE);
		visibleRef.current = visible;
	}, [visible]);
	(0, import_react.useEffect)(function() {
		if (currentStatus === STATUS_APPEAR && !motionAppear || currentStatus === STATUS_ENTER && !motionEnter || currentStatus === STATUS_LEAVE && !motionLeave) setStatus(STATUS_NONE);
	}, [
		motionAppear,
		motionEnter,
		motionLeave
	]);
	(0, import_react.useEffect)(function() {
		return function() {
			mountedRef.current = false;
			clearTimeout(deadlineRef.current);
		};
	}, []);
	var firstMountChangeRef = import_react.useRef(false);
	(0, import_react.useEffect)(function() {
		if (asyncVisible) firstMountChangeRef.current = true;
		if (asyncVisible !== void 0 && currentStatus === STATUS_NONE) {
			if (firstMountChangeRef.current || asyncVisible) onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);
			firstMountChangeRef.current = true;
		}
	}, [asyncVisible, currentStatus]);
	var mergedStyle = style$1;
	if (eventHandlers[STEP_PREPARE] && step === STEP_START) mergedStyle = _objectSpread2({ transition: "none" }, mergedStyle);
	return [
		currentStatus,
		step,
		mergedStyle,
		asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible
	];
}

//#endregion
//#region node_modules/rc-motion/es/CSSMotion.js
/**
* `transitionSupport` is used for none transition test case.
* Default we use browser transition event support check.
*/
function genCSSMotion(config) {
	var transitionSupport = config;
	if (_typeof(config) === "object") transitionSupport = config.transitionSupport;
	function isSupportTransition(props, contextMotion) {
		return !!(props.motionName && transitionSupport && contextMotion !== false);
	}
	var CSSMotion = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
		var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
		var _React$useContext = import_react.useContext(Context$1), contextMotion = _React$useContext.motion;
		var supportMotion = isSupportTransition(props, contextMotion);
		var nodeRef = (0, import_react.useRef)();
		var wrapperNodeRef = (0, import_react.useRef)();
		function getDomElement() {
			try {
				return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
			} catch (e$2) {
				return null;
			}
		}
		var _useStatus = useStatus$1(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
		var renderedRef = import_react.useRef(mergedVisible);
		if (mergedVisible) renderedRef.current = true;
		var setNodeRef = import_react.useCallback(function(node$1) {
			nodeRef.current = node$1;
			fillRef(ref, node$1);
		}, [ref]);
		var motionChildren;
		var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, { visible });
		if (!children) motionChildren = null;
		else if (status === STATUS_NONE) if (mergedVisible) motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
		else if (!removeOnLeave && renderedRef.current && leavedClassName) motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, { className: leavedClassName }), setNodeRef);
		else if (forceRender || !removeOnLeave && !leavedClassName) motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, { style: { display: "none" } }), setNodeRef);
		else motionChildren = null;
		else {
			var statusSuffix;
			if (statusStep === STEP_PREPARE) statusSuffix = "prepare";
			else if (isActive(statusStep)) statusSuffix = "active";
			else if (statusStep === STEP_START) statusSuffix = "start";
			var motionCls = getTransitionName$1(motionName, "".concat(status, "-").concat(statusSuffix));
			motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
				className: (0, import_classnames$279.default)(getTransitionName$1(motionName, status), _defineProperty(_defineProperty({}, motionCls, motionCls && statusSuffix), motionName, typeof motionName === "string")),
				style: statusStyle
			}), setNodeRef);
		}
		if (/* @__PURE__ */ import_react.isValidElement(motionChildren) && supportRef(motionChildren)) {
			if (!getNodeRef(motionChildren)) motionChildren = /* @__PURE__ */ import_react.cloneElement(motionChildren, { ref: setNodeRef });
		}
		return /* @__PURE__ */ import_react.createElement(DomWrapper_default, { ref: wrapperNodeRef }, motionChildren);
	});
	CSSMotion.displayName = "CSSMotion";
	return CSSMotion;
}
var CSSMotion_default = genCSSMotion(supportTransition);

//#endregion
//#region node_modules/rc-motion/es/util/diff.js
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
	var keyObj;
	if (key && _typeof(key) === "object" && "key" in key) keyObj = key;
	else keyObj = { key };
	return _objectSpread2(_objectSpread2({}, keyObj), {}, { key: String(keyObj.key) });
}
function parseKeys() {
	return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map(wrapKeyToObject);
}
function diffKeys() {
	var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
	var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	var list = [];
	var currentIndex = 0;
	var currentLen = currentKeys.length;
	var prevKeyObjects = parseKeys(prevKeys);
	var currentKeyObjects = parseKeys(currentKeys);
	prevKeyObjects.forEach(function(keyObj) {
		var hit = false;
		for (var i = currentIndex; i < currentLen; i += 1) {
			var currentKeyObj = currentKeyObjects[i];
			if (currentKeyObj.key === keyObj.key) {
				if (currentIndex < i) {
					list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {
						return _objectSpread2(_objectSpread2({}, obj), {}, { status: STATUS_ADD });
					}));
					currentIndex = i;
				}
				list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, { status: STATUS_KEEP }));
				currentIndex += 1;
				hit = true;
				break;
			}
		}
		if (!hit) list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, { status: STATUS_REMOVE }));
	});
	if (currentIndex < currentLen) list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
		return _objectSpread2(_objectSpread2({}, obj), {}, { status: STATUS_ADD });
	}));
	/**
	* Merge same key when it remove and add again:
	*    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
	*/
	var keys$1 = {};
	list.forEach(function(_ref) {
		var key = _ref.key;
		keys$1[key] = (keys$1[key] || 0) + 1;
	});
	Object.keys(keys$1).filter(function(key) {
		return keys$1[key] > 1;
	}).forEach(function(matchKey) {
		list = list.filter(function(_ref2) {
			var key = _ref2.key, status = _ref2.status;
			return key !== matchKey || status !== STATUS_REMOVE;
		});
		list.forEach(function(node$1) {
			if (node$1.key === matchKey) node$1.status = STATUS_KEEP;
		});
	});
	return list;
}

//#endregion
//#region node_modules/rc-motion/es/CSSMotionList.js
var _excluded$76 = [
	"component",
	"children",
	"onVisibleChanged",
	"onAllRemoved"
], _excluded2$14 = ["status"];
var MOTION_PROP_NAMES = [
	"eventProps",
	"visible",
	"children",
	"motionName",
	"motionAppear",
	"motionEnter",
	"motionLeave",
	"motionLeaveImmediately",
	"motionDeadline",
	"removeOnLeave",
	"leavedClassName",
	"onAppearPrepare",
	"onAppearStart",
	"onAppearActive",
	"onAppearEnd",
	"onEnterStart",
	"onEnterActive",
	"onEnterEnd",
	"onLeaveStart",
	"onLeaveActive",
	"onLeaveEnd"
];
/**
* Generate a CSSMotionList component with config
* @param transitionSupport No need since CSSMotionList no longer depends on transition support
* @param CSSMotion CSSMotion component
*/
function genCSSMotionList(transitionSupport) {
	var CSSMotion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion_default;
	var CSSMotionList = /* @__PURE__ */ function(_React$Component) {
		_inherits(CSSMotionList$1, _React$Component);
		var _super = _createSuper(CSSMotionList$1);
		function CSSMotionList$1() {
			var _this;
			_classCallCheck(this, CSSMotionList$1);
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			_this = _super.call.apply(_super, [this].concat(args));
			_defineProperty(_assertThisInitialized(_this), "state", { keyEntities: [] });
			_defineProperty(_assertThisInitialized(_this), "removeKey", function(removeKey) {
				_this.setState(function(prevState) {
					return { keyEntities: prevState.keyEntities.map(function(entity) {
						if (entity.key !== removeKey) return entity;
						return _objectSpread2(_objectSpread2({}, entity), {}, { status: STATUS_REMOVED });
					}) };
				}, function() {
					if (_this.state.keyEntities.filter(function(_ref) {
						return _ref.status !== STATUS_REMOVED;
					}).length === 0 && _this.props.onAllRemoved) _this.props.onAllRemoved();
				});
			});
			return _this;
		}
		_createClass(CSSMotionList$1, [{
			key: "render",
			value: function render$1() {
				var _this2 = this;
				var keyEntities = this.state.keyEntities, _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged;
				_this$props.onAllRemoved;
				var restProps = _objectWithoutProperties(_this$props, _excluded$76);
				var Component$2 = component || import_react.Fragment;
				var motionProps = {};
				MOTION_PROP_NAMES.forEach(function(prop) {
					motionProps[prop] = restProps[prop];
					delete restProps[prop];
				});
				delete restProps.keys;
				return /* @__PURE__ */ import_react.createElement(Component$2, restProps, keyEntities.map(function(_ref2, index$2) {
					var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded2$14);
					var visible = status === STATUS_ADD || status === STATUS_KEEP;
					return /* @__PURE__ */ import_react.createElement(CSSMotion, _extends({}, motionProps, {
						key: eventProps.key,
						visible,
						eventProps,
						onVisibleChanged: function onVisibleChanged(changedVisible) {
							_onVisibleChanged === null || _onVisibleChanged === void 0 || _onVisibleChanged(changedVisible, { key: eventProps.key });
							if (!changedVisible) _this2.removeKey(eventProps.key);
						}
					}), function(props, ref) {
						return children(_objectSpread2(_objectSpread2({}, props), {}, { index: index$2 }), ref);
					});
				}));
			}
		}], [{
			key: "getDerivedStateFromProps",
			value: function getDerivedStateFromProps(_ref3, _ref4) {
				var keys$1 = _ref3.keys;
				var keyEntities = _ref4.keyEntities;
				var parsedKeyObjects = parseKeys(keys$1);
				return { keyEntities: diffKeys(keyEntities, parsedKeyObjects).filter(function(entity) {
					var prevEntity = keyEntities.find(function(_ref5) {
						var key = _ref5.key;
						return entity.key === key;
					});
					if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) return false;
					return true;
				}) };
			}
		}]);
		return CSSMotionList$1;
	}(import_react.Component);
	_defineProperty(CSSMotionList, "defaultProps", { component: "div" });
	return CSSMotionList;
}
var CSSMotionList_default = genCSSMotionList(supportTransition);

//#endregion
//#region node_modules/rc-motion/es/index.js
var es_default$2 = CSSMotion_default;

//#endregion
//#region node_modules/antd/es/config-provider/MotionWrapper.js
var MotionCacheContext = /* @__PURE__ */ import_react.createContext(true);
MotionCacheContext.displayName = "MotionCacheContext";
function MotionWrapper(props) {
	const parentMotion = import_react.useContext(MotionCacheContext);
	const { children } = props;
	const [, token$1] = useToken();
	const { motion: motion$1 } = token$1;
	const needWrapMotionProviderRef = import_react.useRef(false);
	needWrapMotionProviderRef.current || (needWrapMotionProviderRef.current = parentMotion !== motion$1);
	if (needWrapMotionProviderRef.current) return /* @__PURE__ */ import_react.createElement(MotionCacheContext.Provider, { value: motion$1 }, /* @__PURE__ */ import_react.createElement(MotionProvider, { motion: motion$1 }, children));
	return children;
}

//#endregion
//#region node_modules/antd/es/config-provider/PropWarning.js
/**
* Warning for ConfigProviderProps.
* This will be empty function in production.
*/
var PropWarning = /* @__PURE__ */ import_react.memo(({ dropdownMatchSelectWidth }) => {
	devUseWarning("ConfigProvider").deprecated(dropdownMatchSelectWidth === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth");
	return null;
});
PropWarning.displayName = "PropWarning";
var PropWarning_default = PropWarning;

//#endregion
//#region node_modules/antd/es/config-provider/index.js
var __rest$112 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
/**
* Since too many feedback using static method like `Modal.confirm` not getting theme, we record the
* theme register info here to help developer get warning info.
*/
var existThemeConfig = false;
const warnContext = (componentName) => {
	warning_default$1(!existThemeConfig, componentName, `Static function can not consume context like dynamic theme. Please use 'App' component instead.`);
};
var PASSED_PROPS = [
	"getTargetContainer",
	"getPopupContainer",
	"renderEmpty",
	"input",
	"pagination",
	"form",
	"select",
	"button"
];
var globalPrefixCls;
var globalIconPrefixCls;
var globalTheme;
var globalHolderRender;
function getGlobalPrefixCls() {
	return globalPrefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
	return globalIconPrefixCls || defaultIconPrefixCls;
}
function isLegacyTheme(theme) {
	return Object.keys(theme).some((key) => key.endsWith("Color"));
}
var setGlobalConfig = (props) => {
	const { prefixCls, iconPrefixCls, theme, holderRender } = props;
	if (prefixCls !== void 0) globalPrefixCls = prefixCls;
	if (iconPrefixCls !== void 0) globalIconPrefixCls = iconPrefixCls;
	if ("holderRender" in props) globalHolderRender = holderRender;
	if (theme) if (isLegacyTheme(theme)) {
		warning_default$1(false, "ConfigProvider", "`config` of css variable theme is not work in v5. Please use new `theme` config instead.");
		registerTheme(getGlobalPrefixCls(), theme);
	} else globalTheme = theme;
};
const globalConfig = () => ({
	getPrefixCls: (suffixCls, customizePrefixCls) => {
		if (customizePrefixCls) return customizePrefixCls;
		return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
	},
	getIconPrefixCls: getGlobalIconPrefixCls,
	getRootPrefixCls: () => {
		if (globalPrefixCls) return globalPrefixCls;
		return getGlobalPrefixCls();
	},
	getTheme: () => globalTheme,
	holderRender: globalHolderRender
});
var ProviderChildren = (props) => {
	const { children, csp: customCsp, autoInsertSpaceInButton, alert, anchor, form, locale: locale$5, componentSize, direction, space, splitter, virtual, dropdownMatchSelectWidth, popupMatchSelectWidth, popupOverflow, legacyLocale, parentContext, iconPrefixCls: customIconPrefixCls, theme, componentDisabled, segmented, statistic: statistic$1, spin, calendar, carousel, cascader, collapse, typography, checkbox, descriptions, divider, drawer, skeleton, steps, image, layout, list, mentions, modal, progress, result, slider, breadcrumb, menu, pagination, input, textArea, empty: empty$1, badge, radio, rate, switch: SWITCH, transfer, avatar, message: message$1, tag, table, card, tabs, timeline, timePicker, upload: upload$1, notification: notification$1, tree, colorPicker, datePicker, rangePicker, flex, wave, dropdown, warning: warningConfig, tour, tooltip, popover, popconfirm, floatButton, floatButtonGroup, variant, inputNumber, treeSelect } = props;
	const getPrefixCls = import_react.useCallback((suffixCls, customizePrefixCls) => {
		const { prefixCls } = props;
		if (customizePrefixCls) return customizePrefixCls;
		const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
		return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
	}, [parentContext.getPrefixCls, props.prefixCls]);
	const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
	const csp = customCsp || parentContext.csp;
	useResetIconStyle_default(iconPrefixCls, csp);
	const mergedTheme = useTheme(theme, parentContext.theme, { prefixCls: getPrefixCls("") });
	existThemeConfig = existThemeConfig || !!mergedTheme;
	const baseConfig = {
		csp,
		autoInsertSpaceInButton,
		alert,
		anchor,
		locale: locale$5 || legacyLocale,
		direction,
		space,
		splitter,
		virtual,
		popupMatchSelectWidth: popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth,
		popupOverflow,
		getPrefixCls,
		iconPrefixCls,
		theme: mergedTheme,
		segmented,
		statistic: statistic$1,
		spin,
		calendar,
		carousel,
		cascader,
		collapse,
		typography,
		checkbox,
		descriptions,
		divider,
		drawer,
		skeleton,
		steps,
		image,
		input,
		textArea,
		layout,
		list,
		mentions,
		modal,
		progress,
		result,
		slider,
		breadcrumb,
		menu,
		pagination,
		empty: empty$1,
		badge,
		radio,
		rate,
		switch: SWITCH,
		transfer,
		avatar,
		message: message$1,
		tag,
		table,
		card,
		tabs,
		timeline,
		timePicker,
		upload: upload$1,
		notification: notification$1,
		tree,
		colorPicker,
		datePicker,
		rangePicker,
		flex,
		wave,
		dropdown,
		warning: warningConfig,
		tour,
		tooltip,
		popover,
		popconfirm,
		floatButton,
		floatButtonGroup,
		variant,
		inputNumber,
		treeSelect
	};
	devUseWarning("ConfigProvider")(!("autoInsertSpaceInButton" in props), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
	const config = Object.assign({}, parentContext);
	Object.keys(baseConfig).forEach((key) => {
		if (baseConfig[key] !== void 0) config[key] = baseConfig[key];
	});
	PASSED_PROPS.forEach((propName) => {
		const propValue = props[propName];
		if (propValue) config[propName] = propValue;
	});
	if (typeof autoInsertSpaceInButton !== "undefined") config.button = Object.assign({ autoInsertSpace: autoInsertSpaceInButton }, config.button);
	const memoedConfig = useMemo$1(() => config, config, (prevConfig, currentConfig) => {
		const prevKeys = Object.keys(prevConfig);
		const currentKeys = Object.keys(currentConfig);
		return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
	});
	const { layer } = import_react.useContext(StyleContext_default);
	const memoIconContextValue = import_react.useMemo(() => ({
		prefixCls: iconPrefixCls,
		csp,
		layer: layer ? "antd" : void 0
	}), [
		iconPrefixCls,
		csp,
		layer
	]);
	let childNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(PropWarning_default, { dropdownMatchSelectWidth }), children);
	const validateMessages = import_react.useMemo(() => {
		var _a, _b, _c, _d;
		return merge$1(((_a = en_US_default.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, ((_d = memoedConfig.form) === null || _d === void 0 ? void 0 : _d.validateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
	}, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
	if (Object.keys(validateMessages).length > 0) childNode = /* @__PURE__ */ import_react.createElement(validateMessagesContext_default.Provider, { value: validateMessages }, childNode);
	if (locale$5) childNode = /* @__PURE__ */ import_react.createElement(locale_default, {
		locale: locale$5,
		_ANT_MARK__: ANT_MARK
	}, childNode);
	if (iconPrefixCls || csp) childNode = /* @__PURE__ */ import_react.createElement(Context_default$2.Provider, { value: memoIconContextValue }, childNode);
	if (componentSize) childNode = /* @__PURE__ */ import_react.createElement(SizeContextProvider, { size: componentSize }, childNode);
	childNode = /* @__PURE__ */ import_react.createElement(MotionWrapper, null, childNode);
	const memoTheme = import_react.useMemo(() => {
		const _a = mergedTheme || {}, { algorithm, token: token$1, components: components$1, cssVar } = _a, rest = __rest$112(_a, [
			"algorithm",
			"token",
			"components",
			"cssVar"
		]);
		const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : theme_default$1;
		const parsedComponents = {};
		Object.entries(components$1 || {}).forEach(([componentName, componentToken]) => {
			const parsedToken = Object.assign({}, componentToken);
			if ("algorithm" in parsedToken) {
				if (parsedToken.algorithm === true) parsedToken.theme = themeObj;
				else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") parsedToken.theme = createTheme(parsedToken.algorithm);
				delete parsedToken.algorithm;
			}
			parsedComponents[componentName] = parsedToken;
		});
		const mergedToken = Object.assign(Object.assign({}, seed_default), token$1);
		return Object.assign(Object.assign({}, rest), {
			theme: themeObj,
			token: mergedToken,
			components: parsedComponents,
			override: Object.assign({ override: mergedToken }, parsedComponents),
			cssVar
		});
	}, [mergedTheme]);
	if (theme) childNode = /* @__PURE__ */ import_react.createElement(DesignTokenContext.Provider, { value: memoTheme }, childNode);
	if (memoedConfig.warning) childNode = /* @__PURE__ */ import_react.createElement(WarningContext.Provider, { value: memoedConfig.warning }, childNode);
	if (componentDisabled !== void 0) childNode = /* @__PURE__ */ import_react.createElement(DisabledContextProvider, { disabled: componentDisabled }, childNode);
	return /* @__PURE__ */ import_react.createElement(ConfigContext.Provider, { value: memoedConfig }, childNode);
};
var ConfigProvider = (props) => {
	const context = import_react.useContext(ConfigContext);
	const antLocale = import_react.useContext(context_default$10);
	return /* @__PURE__ */ import_react.createElement(ProviderChildren, Object.assign({
		parentContext: context,
		legacyLocale: antLocale
	}, props));
};
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext_default;
ConfigProvider.config = setGlobalConfig;
ConfigProvider.useConfig = useConfig_default;
Object.defineProperty(ConfigProvider, "SizeContext", { get: () => {
	warning_default$1(false, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead.");
	return SizeContext_default;
} });
ConfigProvider.displayName = "ConfigProvider";
var config_provider_default = ConfigProvider;

//#endregion
//#region node_modules/antd/es/affix/style/index.js
var genSharedAffixStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		position: "fixed",
		zIndex: token$1.zIndexPopup
	} };
};
const prepareComponentToken$57 = (token$1) => ({ zIndexPopup: token$1.zIndexBase + 10 });
var style_default$63 = genStyleHooks("Affix", genSharedAffixStyle, prepareComponentToken$57);

//#endregion
//#region node_modules/antd/es/affix/utils.js
function getTargetRect(target) {
	return target !== window ? target.getBoundingClientRect() : {
		top: 0,
		bottom: window.innerHeight
	};
}
function getFixedTop(placeholderRect, targetRect, offsetTop) {
	if (offsetTop !== void 0 && Math.round(targetRect.top) > Math.round(placeholderRect.top) - offsetTop) return offsetTop + targetRect.top;
}
function getFixedBottom(placeholderRect, targetRect, offsetBottom) {
	if (offsetBottom !== void 0 && Math.round(targetRect.bottom) < Math.round(placeholderRect.bottom) + offsetBottom) {
		const targetBottomOffset = window.innerHeight - targetRect.bottom;
		return offsetBottom + targetBottomOffset;
	}
}

//#endregion
//#region node_modules/antd/es/affix/index.js
var import_classnames$278 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$111 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var TRIGGER_EVENTS = [
	"resize",
	"scroll",
	"touchstart",
	"touchmove",
	"touchend",
	"pageshow",
	"load"
];
function getDefaultTarget() {
	return typeof window !== "undefined" ? window : null;
}
var AFFIX_STATUS_NONE = 0;
var AFFIX_STATUS_PREPARE = 1;
var Affix = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a;
	const { style: style$1, offsetTop, offsetBottom, prefixCls, className, rootClassName, children, target, onChange, onTestUpdatePosition } = props, restProps = __rest$111(props, [
		"style",
		"offsetTop",
		"offsetBottom",
		"prefixCls",
		"className",
		"rootClassName",
		"children",
		"target",
		"onChange",
		"onTestUpdatePosition"
	]);
	const { getPrefixCls, getTargetContainer } = import_react.useContext(ConfigContext);
	const affixPrefixCls = getPrefixCls("affix", prefixCls);
	const [lastAffix, setLastAffix] = import_react.useState(false);
	const [affixStyle, setAffixStyle] = import_react.useState();
	const [placeholderStyle, setPlaceholderStyle] = import_react.useState();
	const status = import_react.useRef(AFFIX_STATUS_NONE);
	const prevTarget = import_react.useRef(null);
	const prevListener = import_react.useRef(null);
	const placeholderNodeRef = import_react.useRef(null);
	const fixedNodeRef = import_react.useRef(null);
	const timer = import_react.useRef(null);
	const targetFunc = (_a = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultTarget;
	const internalOffsetTop = offsetBottom === void 0 && offsetTop === void 0 ? 0 : offsetTop;
	const measure = () => {
		if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) return;
		const targetNode = targetFunc();
		if (targetNode) {
			const newState = { status: AFFIX_STATUS_NONE };
			const placeholderRect = getTargetRect(placeholderNodeRef.current);
			if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) return;
			const targetRect = getTargetRect(targetNode);
			const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
			const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
			if (fixedTop !== void 0) {
				newState.affixStyle = {
					position: "fixed",
					top: fixedTop,
					width: placeholderRect.width,
					height: placeholderRect.height
				};
				newState.placeholderStyle = {
					width: placeholderRect.width,
					height: placeholderRect.height
				};
			} else if (fixedBottom !== void 0) {
				newState.affixStyle = {
					position: "fixed",
					bottom: fixedBottom,
					width: placeholderRect.width,
					height: placeholderRect.height
				};
				newState.placeholderStyle = {
					width: placeholderRect.width,
					height: placeholderRect.height
				};
			}
			newState.lastAffix = !!newState.affixStyle;
			if (lastAffix !== newState.lastAffix) onChange === null || onChange === void 0 || onChange(newState.lastAffix);
			status.current = newState.status;
			setAffixStyle(newState.affixStyle);
			setPlaceholderStyle(newState.placeholderStyle);
			setLastAffix(newState.lastAffix);
		}
	};
	const prepareMeasure = () => {
		status.current = AFFIX_STATUS_PREPARE;
		measure();
	};
	const updatePosition = throttleByAnimationFrame_default(() => {
		prepareMeasure();
	});
	const lazyUpdatePosition = throttleByAnimationFrame_default(() => {
		if (targetFunc && affixStyle) {
			const targetNode = targetFunc();
			if (targetNode && placeholderNodeRef.current) {
				const targetRect = getTargetRect(targetNode);
				const placeholderRect = getTargetRect(placeholderNodeRef.current);
				const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
				const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
				if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) return;
			}
		}
		prepareMeasure();
	});
	const addListeners = () => {
		const listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();
		if (!listenerTarget) return;
		TRIGGER_EVENTS.forEach((eventName) => {
			var _a$1;
			if (prevListener.current) (_a$1 = prevTarget.current) === null || _a$1 === void 0 || _a$1.removeEventListener(eventName, prevListener.current);
			listenerTarget === null || listenerTarget === void 0 || listenerTarget.addEventListener(eventName, lazyUpdatePosition);
		});
		prevTarget.current = listenerTarget;
		prevListener.current = lazyUpdatePosition;
	};
	const removeListeners = () => {
		if (timer.current) {
			clearTimeout(timer.current);
			timer.current = null;
		}
		const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();
		TRIGGER_EVENTS.forEach((eventName) => {
			var _a$1;
			newTarget === null || newTarget === void 0 || newTarget.removeEventListener(eventName, lazyUpdatePosition);
			if (prevListener.current) (_a$1 = prevTarget.current) === null || _a$1 === void 0 || _a$1.removeEventListener(eventName, prevListener.current);
		});
		updatePosition.cancel();
		lazyUpdatePosition.cancel();
	};
	import_react.useImperativeHandle(ref, () => ({ updatePosition }));
	import_react.useEffect(() => {
		timer.current = setTimeout(addListeners);
		return () => removeListeners();
	}, []);
	import_react.useEffect(() => {
		addListeners();
		return () => removeListeners();
	}, [
		target,
		affixStyle,
		lastAffix,
		offsetTop,
		offsetBottom
	]);
	import_react.useEffect(() => {
		updatePosition();
	}, [
		target,
		offsetTop,
		offsetBottom
	]);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$63(affixPrefixCls);
	const rootCls = (0, import_classnames$278.default)(rootClassName, hashId, affixPrefixCls, cssVarCls);
	const mergedCls = (0, import_classnames$278.default)({ [rootCls]: affixStyle });
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default, { onResize: updatePosition }, /* @__PURE__ */ import_react.createElement("div", Object.assign({
		style: style$1,
		className,
		ref: placeholderNodeRef
	}, restProps), affixStyle && /* @__PURE__ */ import_react.createElement("div", {
		style: placeholderStyle,
		"aria-hidden": "true"
	}), /* @__PURE__ */ import_react.createElement("div", {
		className: mergedCls,
		ref: fixedNodeRef,
		style: affixStyle
	}, /* @__PURE__ */ import_react.createElement(es_default, { onResize: updatePosition }, children)))));
});
Affix.displayName = "Affix";
var affix_default = Affix;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CheckCircleFilled.js
var CheckCircleFilled = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" }
		}]
	},
	"name": "check-circle",
	"theme": "filled"
};
var CheckCircleFilled_default$1 = CheckCircleFilled;

//#endregion
//#region node_modules/rc-util/es/Dom/shadow.js
function getRoot(ele) {
	var _ele$getRootNode;
	return ele === null || ele === void 0 || (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
}
/**
* Check if is in shadowRoot
*/
function inShadow(ele) {
	return getRoot(ele) instanceof ShadowRoot;
}
/**
* Return shadowRoot if possible
*/
function getShadowRoot(ele) {
	return inShadow(ele) ? getRoot(ele) : null;
}

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/utils.js
function camelCase(input) {
	return input.replace(/-(.)/g, function(match$1, g) {
		return g.toUpperCase();
	});
}
function warning$2(valid, message$1) {
	warning_default(valid, "[@ant-design/icons] ".concat(message$1));
}
function isIconDefinition(target) {
	return _typeof(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs() {
	var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	return Object.keys(attrs).reduce(function(acc, key) {
		var val = attrs[key];
		switch (key) {
			case "class":
				acc.className = val;
				delete acc.class;
				break;
			default:
				delete acc[key];
				acc[camelCase(key)] = val;
		}
		return acc;
	}, {});
}
function generate$1(node$1, key, rootProps) {
	if (!rootProps) return /* @__PURE__ */ import_react.createElement(node$1.tag, _objectSpread2({ key }, normalizeAttrs(node$1.attrs)), (node$1.children || []).map(function(child, index$2) {
		return generate$1(child, "".concat(key, "-").concat(node$1.tag, "-").concat(index$2));
	}));
	return /* @__PURE__ */ import_react.createElement(node$1.tag, _objectSpread2(_objectSpread2({ key }, normalizeAttrs(node$1.attrs)), rootProps), (node$1.children || []).map(function(child, index$2) {
		return generate$1(child, "".concat(key, "-").concat(node$1.tag, "-").concat(index$2));
	}));
}
function getSecondaryColor(primaryColor) {
	return generate(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
	if (!twoToneColor) return [];
	return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-flex;\n  align-items: center;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles = function useInsertStyles$1(eleRef) {
	var _useContext = (0, import_react.useContext)(Context_default$2), csp = _useContext.csp, prefixCls = _useContext.prefixCls, layer = _useContext.layer;
	var mergedStyleStr = iconStyles;
	if (prefixCls) mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
	if (layer) mergedStyleStr = "@layer ".concat(layer, " {\n").concat(mergedStyleStr, "\n}");
	(0, import_react.useEffect)(function() {
		var ele = eleRef.current;
		var shadowRoot = getShadowRoot(ele);
		updateCSS(mergedStyleStr, "@ant-design-icons", {
			prepend: !layer,
			csp,
			attachTo: shadowRoot
		});
	}, []);
};

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/components/IconBase.js
var _excluded$75 = [
	"icon",
	"className",
	"onClick",
	"style",
	"primaryColor",
	"secondaryColor"
];
var twoToneColorPalette = {
	primaryColor: "#333",
	secondaryColor: "#E6E6E6",
	calculated: false
};
function setTwoToneColors(_ref) {
	var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
	twoToneColorPalette.primaryColor = primaryColor;
	twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
	twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
	return _objectSpread2({}, twoToneColorPalette);
}
var IconBase = function IconBase$1(props) {
	var icon = props.icon, className = props.className, onClick = props.onClick, style$1 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$75);
	var svgRef = import_react.useRef();
	var colors = twoToneColorPalette;
	if (primaryColor) colors = {
		primaryColor,
		secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
	};
	useInsertStyles(svgRef);
	warning$2(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
	if (!isIconDefinition(icon)) return null;
	var target = icon;
	if (target && typeof target.icon === "function") target = _objectSpread2(_objectSpread2({}, target), {}, { icon: target.icon(colors.primaryColor, colors.secondaryColor) });
	return generate$1(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
		className,
		onClick,
		style: style$1,
		"data-icon": target.name,
		width: "1em",
		height: "1em",
		fill: "currentColor",
		"aria-hidden": "true"
	}, restProps), {}, { ref: svgRef }));
};
IconBase.displayName = "IconReact";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
var IconBase_default = IconBase;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/components/twoTonePrimaryColor.js
function setTwoToneColor(twoToneColor) {
	var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
	return IconBase_default.setTwoToneColors({
		primaryColor,
		secondaryColor
	});
}
function getTwoToneColor() {
	var colors = IconBase_default.getTwoToneColors();
	if (!colors.calculated) return colors.primaryColor;
	return [colors.primaryColor, colors.secondaryColor];
}

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/components/AntdIcon.js
var import_classnames$277 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$74 = [
	"className",
	"icon",
	"spin",
	"rotate",
	"tabIndex",
	"onClick",
	"twoToneColor"
];
setTwoToneColor(blue.primary);
var Icon$3 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded$74);
	var _React$useContext = import_react.useContext(Context_default$2), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
	var classString = (0, import_classnames$277.default)(rootClassName, prefixCls, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), className);
	var iconTabIndex = tabIndex;
	if (iconTabIndex === void 0 && onClick) iconTabIndex = -1;
	var svgStyle = rotate ? {
		msTransform: "rotate(".concat(rotate, "deg)"),
		transform: "rotate(".concat(rotate, "deg)")
	} : void 0;
	var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
	return /* @__PURE__ */ import_react.createElement("span", _extends({
		role: "img",
		"aria-label": icon.name
	}, restProps, {
		ref,
		tabIndex: iconTabIndex,
		onClick,
		className: classString
	}), /* @__PURE__ */ import_react.createElement(IconBase_default, {
		icon,
		primaryColor,
		secondaryColor,
		style: svgStyle
	}));
});
Icon$3.displayName = "AntdIcon";
Icon$3.getTwoToneColor = getTwoToneColor;
Icon$3.setTwoToneColor = setTwoToneColor;
var AntdIcon_default = Icon$3;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CheckCircleFilled.js
/**![check-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0xOTMuNSAzMDEuN2wtMjEwLjYgMjkyYTMxLjggMzEuOCAwIDAxLTUxLjcgMEwzMTguNSA0ODQuOWMtMy44LTUuMyAwLTEyLjcgNi41LTEyLjdoNDYuOWMxMC4yIDAgMTkuOSA0LjkgMjUuOSAxMy4zbDcxLjIgOTguOCAxNTcuMi0yMThjNi04LjMgMTUuNi0xMy4zIDI1LjktMTMuM0g2OTljNi41IDAgMTAuMyA3LjQgNi41IDEyLjd6IiAvPjwvc3ZnPg==) */
var RefIcon$50 = /* @__PURE__ */ import_react.forwardRef(function CheckCircleFilled$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CheckCircleFilled_default$1
	}));
});
RefIcon$50.displayName = "CheckCircleFilled";
var CheckCircleFilled_default = RefIcon$50;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CloseCircleFilled.js
var CloseCircleFilled = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"fill-rule": "evenodd",
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" }
		}]
	},
	"name": "close-circle",
	"theme": "filled"
};
var CloseCircleFilled_default$1 = CloseCircleFilled;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js
/**![close-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdmlld0JveD0iNjQgNjQgODk2IDg5NiIgZm9jdXNhYmxlPSJmYWxzZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNTEyIDY0YzI0Ny40IDAgNDQ4IDIwMC42IDQ0OCA0NDhTNzU5LjQgOTYwIDUxMiA5NjAgNjQgNzU5LjQgNjQgNTEyIDI2NC42IDY0IDUxMiA2NHptMTI3Ljk4IDI3NC44MmgtLjA0bC0uMDguMDZMNTEyIDQ2Ni43NSAzODQuMTQgMzM4Ljg4Yy0uMDQtLjA1LS4wNi0uMDYtLjA4LS4wNmEuMTIuMTIgMCAwMC0uMDcgMGMtLjAzIDAtLjA1LjAxLS4wOS4wNWwtNDUuMDIgNDUuMDJhLjIuMiAwIDAwLS4wNS4wOS4xMi4xMiAwIDAwMCAuMDd2LjAyYS4yNy4yNyAwIDAwLjA2LjA2TDQ2Ni43NSA1MTIgMzM4Ljg4IDYzOS44NmMtLjA1LjA0LS4wNi4wNi0uMDYuMDhhLjEyLjEyIDAgMDAwIC4wN2MwIC4wMy4wMS4wNS4wNS4wOWw0NS4wMiA0NS4wMmEuMi4yIDAgMDAuMDkuMDUuMTIuMTIgMCAwMC4wNyAwYy4wMiAwIC4wNC0uMDEuMDgtLjA1TDUxMiA1NTcuMjVsMTI3Ljg2IDEyNy44N2MuMDQuMDQuMDYuMDUuMDguMDVhLjEyLjEyIDAgMDAuMDcgMGMuMDMgMCAuMDUtLjAxLjA5LS4wNWw0NS4wMi00NS4wMmEuMi4yIDAgMDAuMDUtLjA5LjEyLjEyIDAgMDAwLS4wN3YtLjAyYS4yNy4yNyAwIDAwLS4wNS0uMDZMNTU3LjI1IDUxMmwxMjcuODctMTI3Ljg2Yy4wNC0uMDQuMDUtLjA2LjA1LS4wOGEuMTIuMTIgMCAwMDAtLjA3YzAtLjAzLS4wMS0uMDUtLjA1LS4wOWwtNDUuMDItNDUuMDJhLjIuMiAwIDAwLS4wOS0uMDUuMTIuMTIgMCAwMC0uMDcgMHoiIC8+PC9zdmc+) */
var RefIcon$49 = /* @__PURE__ */ import_react.forwardRef(function CloseCircleFilled$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CloseCircleFilled_default$1
	}));
});
RefIcon$49.displayName = "CloseCircleFilled";
var CloseCircleFilled_default = RefIcon$49;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CloseOutlined.js
var CloseOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"fill-rule": "evenodd",
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" }
		}]
	},
	"name": "close",
	"theme": "outlined"
};
var CloseOutlined_default$1 = CloseOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CloseOutlined.js
/**![close](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdmlld0JveD0iNjQgNjQgODk2IDg5NiIgZm9jdXNhYmxlPSJmYWxzZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNzk5Ljg2IDE2Ni4zMWMuMDIgMCAuMDQuMDIuMDguMDZsNTcuNjkgNTcuN2MuMDQuMDMuMDUuMDUuMDYuMDhhLjEyLjEyIDAgMDEwIC4wNmMwIC4wMy0uMDIuMDUtLjA2LjA5TDU2OS45MyA1MTJsMjg3LjcgMjg3LjdjLjA0LjA0LjA1LjA2LjA2LjA5YS4xMi4xMiAwIDAxMCAuMDdjMCAuMDItLjAyLjA0LS4wNi4wOGwtNTcuNyA1Ny42OWMtLjAzLjA0LS4wNS4wNS0uMDcuMDZhLjEyLjEyIDAgMDEtLjA3IDBjLS4wMyAwLS4wNS0uMDItLjA5LS4wNkw1MTIgNTY5LjkzbC0yODcuNyAyODcuN2MtLjA0LjA0LS4wNi4wNS0uMDkuMDZhLjEyLjEyIDAgMDEtLjA3IDBjLS4wMiAwLS4wNC0uMDItLjA4LS4wNmwtNTcuNjktNTcuN2MtLjA0LS4wMy0uMDUtLjA1LS4wNi0uMDdhLjEyLjEyIDAgMDEwLS4wN2MwLS4wMy4wMi0uMDUuMDYtLjA5TDQ1NC4wNyA1MTJsLTI4Ny43LTI4Ny43Yy0uMDQtLjA0LS4wNS0uMDYtLjA2LS4wOWEuMTIuMTIgMCAwMTAtLjA3YzAtLjAyLjAyLS4wNC4wNi0uMDhsNTcuNy01Ny42OWMuMDMtLjA0LjA1LS4wNS4wNy0uMDZhLjEyLjEyIDAgMDEuMDcgMGMuMDMgMCAuMDUuMDIuMDkuMDZMNTEyIDQ1NC4wN2wyODcuNy0yODcuN2MuMDQtLjA0LjA2LS4wNS4wOS0uMDZhLjEyLjEyIDAgMDEuMDcgMHoiIC8+PC9zdmc+) */
var RefIcon$48 = /* @__PURE__ */ import_react.forwardRef(function CloseOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CloseOutlined_default$1
	}));
});
RefIcon$48.displayName = "CloseOutlined";
var CloseOutlined_default = RefIcon$48;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/ExclamationCircleFilled.js
var ExclamationCircleFilled = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" }
		}]
	},
	"name": "exclamation-circle",
	"theme": "filled"
};
var ExclamationCircleFilled_default$1 = ExclamationCircleFilled;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/ExclamationCircleFilled.js
/**![exclamation-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0tMzIgMjMyYzAtNC40IDMuNi04IDgtOGg0OGM0LjQgMCA4IDMuNiA4IDh2MjcyYzAgNC40LTMuNiA4LTggOGgtNDhjLTQuNCAwLTgtMy42LTgtOFYyOTZ6bTMyIDQ0MGE0OC4wMSA0OC4wMSAwIDAxMC05NiA0OC4wMSA0OC4wMSAwIDAxMCA5NnoiIC8+PC9zdmc+) */
var RefIcon$47 = /* @__PURE__ */ import_react.forwardRef(function ExclamationCircleFilled$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: ExclamationCircleFilled_default$1
	}));
});
RefIcon$47.displayName = "ExclamationCircleFilled";
var ExclamationCircleFilled_default = RefIcon$47;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/InfoCircleFilled.js
var InfoCircleFilled = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" }
		}]
	},
	"name": "info-circle",
	"theme": "filled"
};
var InfoCircleFilled_default$1 = InfoCircleFilled;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/InfoCircleFilled.js
/**![info-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0zMiA2NjRjMCA0LjQtMy42IDgtOCA4aC00OGMtNC40IDAtOC0zLjYtOC04VjQ1NmMwLTQuNCAzLjYtOCA4LThoNDhjNC40IDAgOCAzLjYgOCA4djI3MnptLTMyLTM0NGE0OC4wMSA0OC4wMSAwIDAxMC05NiA0OC4wMSA0OC4wMSAwIDAxMCA5NnoiIC8+PC9zdmc+) */
var RefIcon$46 = /* @__PURE__ */ import_react.forwardRef(function InfoCircleFilled$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: InfoCircleFilled_default$1
	}));
});
RefIcon$46.displayName = "InfoCircleFilled";
var InfoCircleFilled_default = RefIcon$46;

//#endregion
//#region node_modules/rc-util/es/pickAttrs.js
var propList = "".concat("accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap", " ").concat("onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError").split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key, prefix) {
	return key.indexOf(prefix) === 0;
}
/**
* Picker props from exist props with filter
* @param props Passed props
* @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
*/
function pickAttrs(props) {
	var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	var mergedConfig;
	if (ariaOnly === false) mergedConfig = {
		aria: true,
		data: true,
		attr: true
	};
	else if (ariaOnly === true) mergedConfig = { aria: true };
	else mergedConfig = _objectSpread2({}, ariaOnly);
	var attrs = {};
	Object.keys(props).forEach(function(key) {
		if (mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || mergedConfig.data && match(key, dataPrefix) || mergedConfig.attr && propList.includes(key)) attrs[key] = props[key];
	});
	return attrs;
}

//#endregion
//#region node_modules/antd/es/_util/reactNode.js
function isFragment(child) {
	return child && /* @__PURE__ */ import_react.isValidElement(child) && child.type === import_react.Fragment;
}
const replaceElement = (element, replacement, props) => {
	if (!/* @__PURE__ */ import_react.isValidElement(element)) return replacement;
	return /* @__PURE__ */ import_react.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
};
function cloneElement(element, props) {
	return replaceElement(element, element, props);
}

//#endregion
//#region node_modules/antd/es/alert/style/index.js
var genAlertTypeStyle = (bgColor, borderColor, iconColor, token$1, alertCls) => ({
	background: bgColor,
	border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${borderColor}`,
	[`${alertCls}-icon`]: { color: iconColor }
});
const genBaseStyle$18 = (token$1) => {
	const { componentCls, motionDurationSlow: duration, marginXS, marginSM, fontSize, fontSizeLG, lineHeight, borderRadiusLG: borderRadius, motionEaseInOutCirc, withDescriptionIconSize, colorText, colorTextHeading, withDescriptionPadding, defaultPadding } = token$1;
	return {
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "relative",
			display: "flex",
			alignItems: "center",
			padding: defaultPadding,
			wordWrap: "break-word",
			borderRadius,
			[`&${componentCls}-rtl`]: { direction: "rtl" },
			[`${componentCls}-content`]: {
				flex: 1,
				minWidth: 0
			},
			[`${componentCls}-icon`]: {
				marginInlineEnd: marginXS,
				lineHeight: 0
			},
			"&-description": {
				display: "none",
				fontSize,
				lineHeight
			},
			"&-message": { color: colorTextHeading },
			[`&${componentCls}-motion-leave`]: {
				overflow: "hidden",
				opacity: 1,
				transition: `max-height ${duration} ${motionEaseInOutCirc}, opacity ${duration} ${motionEaseInOutCirc},
        padding-top ${duration} ${motionEaseInOutCirc}, padding-bottom ${duration} ${motionEaseInOutCirc},
        margin-bottom ${duration} ${motionEaseInOutCirc}`
			},
			[`&${componentCls}-motion-leave-active`]: {
				maxHeight: 0,
				marginBottom: "0 !important",
				paddingTop: 0,
				paddingBottom: 0,
				opacity: 0
			}
		}),
		[`${componentCls}-with-description`]: {
			alignItems: "flex-start",
			padding: withDescriptionPadding,
			[`${componentCls}-icon`]: {
				marginInlineEnd: marginSM,
				fontSize: withDescriptionIconSize,
				lineHeight: 0
			},
			[`${componentCls}-message`]: {
				display: "block",
				marginBottom: marginXS,
				color: colorTextHeading,
				fontSize: fontSizeLG
			},
			[`${componentCls}-description`]: {
				display: "block",
				color: colorText
			}
		},
		[`${componentCls}-banner`]: {
			marginBottom: 0,
			border: "0 !important",
			borderRadius: 0
		}
	};
};
const genTypeStyle = (token$1) => {
	const { componentCls, colorSuccess, colorSuccessBorder, colorSuccessBg, colorWarning, colorWarningBorder, colorWarningBg, colorError, colorErrorBorder, colorErrorBg, colorInfo, colorInfoBorder, colorInfoBg } = token$1;
	return { [componentCls]: {
		"&-success": genAlertTypeStyle(colorSuccessBg, colorSuccessBorder, colorSuccess, token$1, componentCls),
		"&-info": genAlertTypeStyle(colorInfoBg, colorInfoBorder, colorInfo, token$1, componentCls),
		"&-warning": genAlertTypeStyle(colorWarningBg, colorWarningBorder, colorWarning, token$1, componentCls),
		"&-error": Object.assign(Object.assign({}, genAlertTypeStyle(colorErrorBg, colorErrorBorder, colorError, token$1, componentCls)), { [`${componentCls}-description > pre`]: {
			margin: 0,
			padding: 0
		} })
	} };
};
const genActionStyle = (token$1) => {
	const { componentCls, iconCls, motionDurationMid, marginXS, fontSizeIcon, colorIcon, colorIconHover } = token$1;
	return { [componentCls]: {
		"&-action": { marginInlineStart: marginXS },
		[`${componentCls}-close-icon`]: {
			marginInlineStart: marginXS,
			padding: 0,
			overflow: "hidden",
			fontSize: fontSizeIcon,
			lineHeight: unit(fontSizeIcon),
			backgroundColor: "transparent",
			border: "none",
			outline: "none",
			cursor: "pointer",
			[`${iconCls}-close`]: {
				color: colorIcon,
				transition: `color ${motionDurationMid}`,
				"&:hover": { color: colorIconHover }
			}
		},
		"&-close-text": {
			color: colorIcon,
			transition: `color ${motionDurationMid}`,
			"&:hover": { color: colorIconHover }
		}
	} };
};
const prepareComponentToken$56 = (token$1) => {
	return {
		withDescriptionIconSize: token$1.fontSizeHeading3,
		defaultPadding: `${token$1.paddingContentVerticalSM}px 12px`,
		withDescriptionPadding: `${token$1.paddingMD}px ${token$1.paddingContentHorizontalLG}px`
	};
};
var style_default$62 = genStyleHooks("Alert", (token$1) => [
	genBaseStyle$18(token$1),
	genTypeStyle(token$1),
	genActionStyle(token$1)
], prepareComponentToken$56);

//#endregion
//#region node_modules/antd/es/alert/Alert.js
var import_classnames$276 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$110 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var iconMapFilled = {
	success: CheckCircleFilled_default,
	info: InfoCircleFilled_default,
	error: CloseCircleFilled_default,
	warning: ExclamationCircleFilled_default
};
var IconNode = (props) => {
	const { icon, prefixCls, type: type$2 } = props;
	const iconType = iconMapFilled[type$2] || null;
	if (icon) return replaceElement(icon, /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-icon` }, icon), () => ({ className: (0, import_classnames$276.default)(`${prefixCls}-icon`, icon.props.className) }));
	return /* @__PURE__ */ import_react.createElement(iconType, { className: `${prefixCls}-icon` });
};
var CloseIconNode = (props) => {
	const { isClosable, prefixCls, closeIcon, handleClose, ariaProps } = props;
	const mergedCloseIcon = closeIcon === true || closeIcon === void 0 ? /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null) : closeIcon;
	return isClosable ? /* @__PURE__ */ import_react.createElement("button", Object.assign({
		type: "button",
		onClick: handleClose,
		className: `${prefixCls}-close-icon`,
		tabIndex: 0
	}, ariaProps), mergedCloseIcon) : null;
};
var Alert$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { description, prefixCls: customizePrefixCls, message: message$1, banner, className, rootClassName, style: style$1, onMouseEnter, onMouseLeave, onClick, afterClose, showIcon, closable, closeText, closeIcon, action, id } = props, otherProps = __rest$110(props, [
		"description",
		"prefixCls",
		"message",
		"banner",
		"className",
		"rootClassName",
		"style",
		"onMouseEnter",
		"onMouseLeave",
		"onClick",
		"afterClose",
		"showIcon",
		"closable",
		"closeText",
		"closeIcon",
		"action",
		"id"
	]);
	const [closed, setClosed] = import_react.useState(false);
	devUseWarning("Alert").deprecated(!closeText, "closeText", "closable.closeIcon");
	const internalRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: internalRef.current }));
	const { getPrefixCls, direction, closable: contextClosable, closeIcon: contextCloseIcon, className: contextClassName, style: contextStyle } = useComponentConfig("alert");
	const prefixCls = getPrefixCls("alert", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$62(prefixCls);
	const handleClose = (e$2) => {
		var _a;
		setClosed(true);
		(_a = props.onClose) === null || _a === void 0 || _a.call(props, e$2);
	};
	const type$2 = import_react.useMemo(() => {
		if (props.type !== void 0) return props.type;
		return banner ? "warning" : "info";
	}, [props.type, banner]);
	const isClosable = import_react.useMemo(() => {
		if (typeof closable === "object" && closable.closeIcon) return true;
		if (closeText) return true;
		if (typeof closable === "boolean") return closable;
		if (closeIcon !== false && closeIcon !== null && closeIcon !== void 0) return true;
		return !!contextClosable;
	}, [
		closeText,
		closeIcon,
		closable,
		contextClosable
	]);
	const isShowIcon = banner && showIcon === void 0 ? true : showIcon;
	const alertCls = (0, import_classnames$276.default)(prefixCls, `${prefixCls}-${type$2}`, {
		[`${prefixCls}-with-description`]: !!description,
		[`${prefixCls}-no-icon`]: !isShowIcon,
		[`${prefixCls}-banner`]: !!banner,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, contextClassName, className, rootClassName, cssVarCls, hashId);
	const restProps = pickAttrs(otherProps, {
		aria: true,
		data: true
	});
	const mergedCloseIcon = import_react.useMemo(() => {
		if (typeof closable === "object" && closable.closeIcon) return closable.closeIcon;
		if (closeText) return closeText;
		if (closeIcon !== void 0) return closeIcon;
		if (typeof contextClosable === "object" && contextClosable.closeIcon) return contextClosable.closeIcon;
		return contextCloseIcon;
	}, [
		closeIcon,
		closable,
		closeText,
		contextCloseIcon
	]);
	const mergedAriaProps = import_react.useMemo(() => {
		const merged = closable !== null && closable !== void 0 ? closable : contextClosable;
		if (typeof merged === "object") {
			const { closeIcon: _ } = merged;
			return __rest$110(merged, ["closeIcon"]);
		}
		return {};
	}, [closable, contextClosable]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$2, {
		visible: !closed,
		motionName: `${prefixCls}-motion`,
		motionAppear: false,
		motionEnter: false,
		onLeaveStart: (node$1) => ({ maxHeight: node$1.offsetHeight }),
		onLeaveEnd: afterClose
	}, ({ className: motionClassName, style: motionStyle }, setRef) => /* @__PURE__ */ import_react.createElement("div", Object.assign({
		id,
		ref: composeRef(internalRef, setRef),
		"data-show": !closed,
		className: (0, import_classnames$276.default)(alertCls, motionClassName),
		style: Object.assign(Object.assign(Object.assign({}, contextStyle), style$1), motionStyle),
		onMouseEnter,
		onMouseLeave,
		onClick,
		role: "alert"
	}, restProps), isShowIcon ? /* @__PURE__ */ import_react.createElement(IconNode, {
		description,
		icon: props.icon,
		prefixCls,
		type: type$2
	}) : null, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-content` }, message$1 ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-message` }, message$1) : null, description ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-description` }, description) : null), action ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-action` }, action) : null, /* @__PURE__ */ import_react.createElement(CloseIconNode, {
		isClosable,
		prefixCls,
		closeIcon: mergedCloseIcon,
		handleClose,
		ariaProps: mergedAriaProps
	}))));
});
Alert$1.displayName = "Alert";
var Alert_default = Alert$1;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/callSuper.js
function _callSuper$5(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}

//#endregion
//#region node_modules/antd/es/alert/ErrorBoundary.js
var ErrorBoundary = /* @__PURE__ */ function(_React$Component) {
	function ErrorBoundary$1() {
		var _this;
		_classCallCheck(this, ErrorBoundary$1);
		_this = _callSuper$5(this, ErrorBoundary$1, arguments);
		_this.state = {
			error: void 0,
			info: { componentStack: "" }
		};
		return _this;
	}
	_inherits(ErrorBoundary$1, _React$Component);
	return _createClass(ErrorBoundary$1, [{
		key: "componentDidCatch",
		value: function componentDidCatch(error, info) {
			this.setState({
				error,
				info
			});
		}
	}, {
		key: "render",
		value: function render$1() {
			const { message: message$1, description, id, children } = this.props;
			const { error, info } = this.state;
			const componentStack = (info === null || info === void 0 ? void 0 : info.componentStack) || null;
			const errorMessage = typeof message$1 === "undefined" ? (error || "").toString() : message$1;
			const errorDescription = typeof description === "undefined" ? componentStack : description;
			if (error) return /* @__PURE__ */ import_react.createElement(Alert_default, {
				id,
				type: "error",
				message: errorMessage,
				description: /* @__PURE__ */ import_react.createElement("pre", { style: {
					fontSize: "0.9em",
					overflowX: "auto"
				} }, errorDescription)
			});
			return children;
		}
	}]);
}(import_react.Component);
var ErrorBoundary_default = ErrorBoundary;

//#endregion
//#region node_modules/antd/es/alert/index.js
var Alert = Alert_default;
Alert.ErrorBoundary = ErrorBoundary_default;
var alert_default = Alert;

//#endregion
//#region node_modules/compute-scroll-into-view/dist/index.js
var t = (t$1) => "object" == typeof t$1 && null != t$1 && 1 === t$1.nodeType, e$1 = (t$1, e$2) => (!e$2 || "hidden" !== t$1) && "visible" !== t$1 && "clip" !== t$1, n = (t$1, n$1) => {
	if (t$1.clientHeight < t$1.scrollHeight || t$1.clientWidth < t$1.scrollWidth) {
		const o$2 = getComputedStyle(t$1, null);
		return e$1(o$2.overflowY, n$1) || e$1(o$2.overflowX, n$1) || ((t$2) => {
			const e$2 = ((t$3) => {
				if (!t$3.ownerDocument || !t$3.ownerDocument.defaultView) return null;
				try {
					return t$3.ownerDocument.defaultView.frameElement;
				} catch (t$4) {
					return null;
				}
			})(t$2);
			return !!e$2 && (e$2.clientHeight < t$2.scrollHeight || e$2.clientWidth < t$2.scrollWidth);
		})(t$1);
	}
	return !1;
}, o$1 = (t$1, e$2, n$1, o$2, l$1, r$1, i, s) => r$1 < t$1 && i > e$2 || r$1 > t$1 && i < e$2 ? 0 : r$1 <= t$1 && s <= n$1 || i >= e$2 && s >= n$1 ? r$1 - t$1 - o$2 : i > e$2 && s < n$1 || r$1 < t$1 && s > n$1 ? i - e$2 + l$1 : 0, l = (t$1) => {
	const e$2 = t$1.parentElement;
	return null == e$2 ? t$1.getRootNode().host || null : e$2;
}, r = (e$2, r$1) => {
	var i, s, d, h;
	if ("undefined" == typeof document) return [];
	const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r$1, p = "function" == typeof a ? a : (t$1) => t$1 !== a;
	if (!t(e$2)) throw new TypeError("Invalid target");
	const m = document.scrollingElement || document.documentElement, w = [];
	let W = e$2;
	for (; t(W) && p(W);) {
		if (W = l(W), W === m) {
			w.push(W);
			break;
		}
		null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
	}
	const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e$2.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t$1) => {
		const e$3 = window.getComputedStyle(t$1);
		return {
			top: parseFloat(e$3.scrollMarginTop) || 0,
			right: parseFloat(e$3.scrollMarginRight) || 0,
			bottom: parseFloat(e$3.scrollMarginBottom) || 0,
			left: parseFloat(e$3.scrollMarginLeft) || 0
		};
	})(e$2);
	let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
	const L = [];
	for (let t$1 = 0; t$1 < w.length; t$1++) {
		const e$3 = w[t$1], { height: l$1, width: r$2, top: i$1, right: s$1, bottom: d$1, left: h$1 } = e$3.getBoundingClientRect();
		if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && (e$3 === m && !n(e$3) || x >= i$1 && I <= d$1 && R >= h$1 && C <= s$1)) return L;
		const a$1 = getComputedStyle(e$3), g$1 = parseInt(a$1.borderLeftWidth, 10), p$1 = parseInt(a$1.borderTopWidth, 10), W$1 = parseInt(a$1.borderRightWidth, 10), T$1 = parseInt(a$1.borderBottomWidth, 10);
		let B$1 = 0, F$1 = 0;
		const V$1 = "offsetWidth" in e$3 ? e$3.offsetWidth - e$3.clientWidth - g$1 - W$1 : 0, S = "offsetHeight" in e$3 ? e$3.offsetHeight - e$3.clientHeight - p$1 - T$1 : 0, X = "offsetWidth" in e$3 ? 0 === e$3.offsetWidth ? 0 : r$2 / e$3.offsetWidth : 0, Y = "offsetHeight" in e$3 ? 0 === e$3.offsetHeight ? 0 : l$1 / e$3.offsetHeight : 0;
		if (m === e$3) B$1 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o$1(M, M + H, H, p$1, T$1, M + k, M + k + v, v) : k - H / 2, F$1 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o$1(y, y + b, b, g$1, W$1, y + D, y + D + E, E), B$1 = Math.max(0, B$1 + M), F$1 = Math.max(0, F$1 + y);
		else {
			B$1 = "start" === f ? k - i$1 - p$1 : "end" === f ? k - d$1 + T$1 + S : "nearest" === f ? o$1(i$1, d$1, l$1, p$1, T$1 + S, k, k + v, v) : k - (i$1 + l$1 / 2) + S / 2, F$1 = "start" === u ? D - h$1 - g$1 : "center" === u ? D - (h$1 + r$2 / 2) + V$1 / 2 : "end" === u ? D - s$1 + W$1 + V$1 : o$1(h$1, s$1, r$2, g$1, W$1 + V$1, D, D + E, E);
			const { scrollLeft: t$2, scrollTop: n$1 } = e$3;
			B$1 = 0 === Y ? 0 : Math.max(0, Math.min(n$1 + B$1 / Y, e$3.scrollHeight - l$1 / Y + S)), F$1 = 0 === X ? 0 : Math.max(0, Math.min(t$2 + F$1 / X, e$3.scrollWidth - r$2 / X + V$1)), k += n$1 - B$1, D += t$2 - F$1;
		}
		L.push({
			el: e$3,
			top: B$1,
			left: F$1
		});
	}
	return L;
};

//#endregion
//#region node_modules/scroll-into-view-if-needed/dist/index.js
var o = (t$1) => !1 === t$1 ? {
	block: "end",
	inline: "nearest"
} : ((t$2) => t$2 === Object(t$2) && 0 !== Object.keys(t$2).length)(t$1) ? t$1 : {
	block: "start",
	inline: "nearest"
};
function e(e$2, r$1) {
	if (!e$2.isConnected || !((t$1) => {
		let o$2 = t$1;
		for (; o$2 && o$2.parentNode;) {
			if (o$2.parentNode === document) return !0;
			o$2 = o$2.parentNode instanceof ShadowRoot ? o$2.parentNode.host : o$2.parentNode;
		}
		return !1;
	})(e$2)) return;
	const n$1 = ((t$1) => {
		const o$2 = window.getComputedStyle(t$1);
		return {
			top: parseFloat(o$2.scrollMarginTop) || 0,
			right: parseFloat(o$2.scrollMarginRight) || 0,
			bottom: parseFloat(o$2.scrollMarginBottom) || 0,
			left: parseFloat(o$2.scrollMarginLeft) || 0
		};
	})(e$2);
	if (((t$1) => "object" == typeof t$1 && "function" == typeof t$1.behavior)(r$1)) return r$1.behavior(r(e$2, r$1));
	const l$1 = "boolean" == typeof r$1 || null == r$1 ? void 0 : r$1.behavior;
	for (const { el: a, top: i, left: s } of r(e$2, o(r$1))) {
		const t$1 = i - n$1.top + n$1.bottom, o$2 = s - n$1.left + n$1.right;
		a.scroll({
			top: t$1,
			left: o$2,
			behavior: l$1
		});
	}
}

//#endregion
//#region node_modules/antd/es/_util/getScroll.js
function isWindow(obj) {
	return obj !== null && obj !== void 0 && obj === obj.window;
}
var getScroll$2 = (target) => {
	var _a, _b;
	if (typeof window === "undefined")
 /* istanbul ignore next */
	return 0;
	let result = 0;
	if (isWindow(target)) result = target.pageYOffset;
	else if (target instanceof Document) result = target.documentElement.scrollTop;
	else if (target instanceof HTMLElement) result = target.scrollTop;
	else if (target) result = target["scrollTop"];
	if (target && !isWindow(target) && typeof result !== "number") result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b.scrollTop;
	return result;
};
var getScroll_default = getScroll$2;

//#endregion
//#region node_modules/antd/es/_util/easings.js
function easeInOutCubic(t$1, b, c, d) {
	const cc = c - b;
	t$1 /= d / 2;
	if (t$1 < 1) return cc / 2 * t$1 * t$1 * t$1 + b;
	return cc / 2 * ((t$1 -= 2) * t$1 * t$1 + 2) + b;
}

//#endregion
//#region node_modules/antd/es/_util/scrollTo.js
function scrollTo(y, options = {}) {
	const { getContainer: getContainer$1 = () => window, callback, duration = 450 } = options;
	const container = getContainer$1();
	const scrollTop = getScroll_default(container);
	const startTime = Date.now();
	const frameFunc = () => {
		const time = Date.now() - startTime;
		const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
		if (isWindow(container)) container.scrollTo(window.pageXOffset, nextScrollTop);
		else if (container instanceof Document || container.constructor.name === "HTMLDocument") container.documentElement.scrollTop = nextScrollTop;
		else container.scrollTop = nextScrollTop;
		if (time < duration) raf_default(frameFunc);
		else if (typeof callback === "function") callback();
	};
	raf_default(frameFunc);
}

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
/**
* This hook is only for cssVar to add root className for components.
* If root ClassName is needed, this hook could be refactored with `-root`
* @param prefixCls
*/
var useCSSVarCls = (prefixCls) => {
	const [, , , , cssVar] = useToken();
	return cssVar ? `${prefixCls}-css-var` : "";
};
var useCSSVarCls_default = useCSSVarCls;

//#endregion
//#region node_modules/antd/es/anchor/context.js
var AnchorContext = /* @__PURE__ */ import_react.createContext(void 0);
var context_default$9 = AnchorContext;

//#endregion
//#region node_modules/antd/es/anchor/AnchorLink.js
var import_classnames$275 = /* @__PURE__ */ __toESM(require_classnames());
var AnchorLink = (props) => {
	const { href, title, prefixCls: customizePrefixCls, children, className, target, replace: replace$1 } = props;
	const { registerLink, unregisterLink, scrollTo: scrollTo$1, onClick, activeLink, direction } = import_react.useContext(context_default$9) || {};
	import_react.useEffect(() => {
		registerLink === null || registerLink === void 0 || registerLink(href);
		return () => {
			unregisterLink === null || unregisterLink === void 0 || unregisterLink(href);
		};
	}, [href]);
	const handleClick = (e$2) => {
		onClick === null || onClick === void 0 || onClick(e$2, {
			title,
			href
		});
		scrollTo$1 === null || scrollTo$1 === void 0 || scrollTo$1(href);
		if (e$2.defaultPrevented) return;
		if (href.startsWith("http://") || href.startsWith("https://")) {
			if (replace$1) {
				e$2.preventDefault();
				window.location.replace(href);
			}
			return;
		}
		e$2.preventDefault();
		const historyMethod = replace$1 ? "replaceState" : "pushState";
		window.history[historyMethod](null, "", href);
	};
	devUseWarning("Anchor.Link")(!children || direction !== "horizontal", "usage", "`Anchor.Link children` is not supported when `Anchor` direction is horizontal");
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("anchor", customizePrefixCls);
	const active = activeLink === href;
	const wrapperClassName = (0, import_classnames$275.default)(`${prefixCls}-link`, className, { [`${prefixCls}-link-active`]: active });
	const titleClassName = (0, import_classnames$275.default)(`${prefixCls}-link-title`, { [`${prefixCls}-link-title-active`]: active });
	return /* @__PURE__ */ import_react.createElement("div", { className: wrapperClassName }, /* @__PURE__ */ import_react.createElement("a", {
		className: titleClassName,
		href,
		title: typeof title === "string" ? title : "",
		target,
		onClick: handleClick
	}, title), direction !== "horizontal" ? children : null);
};
var AnchorLink_default = AnchorLink;

//#endregion
//#region node_modules/antd/es/anchor/style/index.js
var genSharedAnchorStyle = (token$1) => {
	const { componentCls, holderOffsetBlock, motionDurationSlow, lineWidthBold, colorPrimary, lineType, colorSplit, calc } = token$1;
	return { [`${componentCls}-wrapper`]: {
		marginBlockStart: calc(holderOffsetBlock).mul(-1).equal(),
		paddingBlockStart: holderOffsetBlock,
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "relative",
			paddingInlineStart: lineWidthBold,
			[`${componentCls}-link`]: {
				paddingBlock: token$1.linkPaddingBlock,
				paddingInline: `${unit(token$1.linkPaddingInlineStart)} 0`,
				"&-title": Object.assign(Object.assign({}, textEllipsis), {
					position: "relative",
					display: "block",
					marginBlockEnd: token$1.anchorTitleBlock,
					color: token$1.colorText,
					transition: `all ${token$1.motionDurationSlow}`,
					"&:only-child": { marginBlockEnd: 0 }
				}),
				[`&-active > ${componentCls}-link-title`]: { color: token$1.colorPrimary },
				[`${componentCls}-link`]: { paddingBlock: token$1.anchorPaddingBlockSecondary }
			}
		}),
		[`&:not(${componentCls}-wrapper-horizontal)`]: { [componentCls]: {
			"&::before": {
				position: "absolute",
				insetInlineStart: 0,
				top: 0,
				height: "100%",
				borderInlineStart: `${unit(lineWidthBold)} ${lineType} ${colorSplit}`,
				content: "\" \""
			},
			[`${componentCls}-ink`]: {
				position: "absolute",
				insetInlineStart: 0,
				display: "none",
				transform: "translateY(-50%)",
				transition: `top ${motionDurationSlow} ease-in-out`,
				width: lineWidthBold,
				backgroundColor: colorPrimary,
				[`&${componentCls}-ink-visible`]: { display: "inline-block" }
			}
		} },
		[`${componentCls}-fixed ${componentCls}-ink ${componentCls}-ink`]: { display: "none" }
	} };
};
var genSharedAnchorHorizontalStyle = (token$1) => {
	const { componentCls, motionDurationSlow, lineWidthBold, colorPrimary } = token$1;
	return { [`${componentCls}-wrapper-horizontal`]: {
		position: "relative",
		"&::before": {
			position: "absolute",
			left: {
				_skip_check_: true,
				value: 0
			},
			right: {
				_skip_check_: true,
				value: 0
			},
			bottom: 0,
			borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
			content: "\" \""
		},
		[componentCls]: {
			overflowX: "scroll",
			position: "relative",
			display: "flex",
			scrollbarWidth: "none",
			"&::-webkit-scrollbar": { display: "none" },
			[`${componentCls}-link:first-of-type`]: { paddingInline: 0 },
			[`${componentCls}-ink`]: {
				position: "absolute",
				bottom: 0,
				transition: `left ${motionDurationSlow} ease-in-out, width ${motionDurationSlow} ease-in-out`,
				height: lineWidthBold,
				backgroundColor: colorPrimary
			}
		}
	} };
};
const prepareComponentToken$55 = (token$1) => ({
	linkPaddingBlock: token$1.paddingXXS,
	linkPaddingInlineStart: token$1.padding
});
var style_default$61 = genStyleHooks("Anchor", (token$1) => {
	const { fontSize, fontSizeLG, paddingXXS, calc } = token$1;
	const anchorToken = merge(token$1, {
		holderOffsetBlock: paddingXXS,
		anchorPaddingBlockSecondary: calc(paddingXXS).div(2).equal(),
		anchorTitleBlock: calc(fontSize).div(14).mul(3).equal(),
		anchorBallSize: calc(fontSizeLG).div(2).equal()
	});
	return [genSharedAnchorStyle(anchorToken), genSharedAnchorHorizontalStyle(anchorToken)];
}, prepareComponentToken$55);

//#endregion
//#region node_modules/antd/es/anchor/Anchor.js
var import_classnames$274 = /* @__PURE__ */ __toESM(require_classnames());
function getDefaultContainer() {
	return window;
}
function getOffsetTop(element, container) {
	if (!element.getClientRects().length) return 0;
	const rect = element.getBoundingClientRect();
	if (rect.width || rect.height) {
		if (container === window) return rect.top - element.ownerDocument.documentElement.clientTop;
		return rect.top - container.getBoundingClientRect().top;
	}
	return rect.top;
}
var sharpMatcherRegex = /#([\S ]+)$/;
var Anchor$1 = (props) => {
	var _a;
	const { rootClassName, prefixCls: customPrefixCls, className, style: style$1, offsetTop, affix = true, showInkInFixed = false, children, items, direction: anchorDirection = "vertical", bounds, targetOffset: targetOffset$3, onClick, onChange, getContainer: getContainer$1, getCurrentAnchor, replace: replace$1 } = props;
	{
		const warning$4 = devUseWarning("Anchor");
		warning$4.deprecated(!children, "Anchor children", "items");
		warning$4(!(anchorDirection === "horizontal" && (items === null || items === void 0 ? void 0 : items.some((n$1) => "children" in n$1))), "usage", "`Anchor items#children` is not supported when `Anchor` direction is horizontal.");
	}
	const [links, setLinks] = import_react.useState([]);
	const [activeLink, setActiveLink] = import_react.useState(null);
	const activeLinkRef = import_react.useRef(activeLink);
	const wrapperRef = import_react.useRef(null);
	const spanLinkNode = import_react.useRef(null);
	const animating = import_react.useRef(false);
	const { direction, getPrefixCls, className: anchorClassName, style: anchorStyle } = useComponentConfig("anchor");
	const { getTargetContainer } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("anchor", customPrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$61(prefixCls, rootCls);
	const getCurrentContainer = (_a = getContainer$1 !== null && getContainer$1 !== void 0 ? getContainer$1 : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultContainer;
	const dependencyListItem = JSON.stringify(links);
	const registerLink = useEvent((link) => {
		if (!links.includes(link)) setLinks((prev$1) => [].concat(_toConsumableArray(prev$1), [link]));
	});
	const unregisterLink = useEvent((link) => {
		if (links.includes(link)) setLinks((prev$1) => prev$1.filter((i) => i !== link));
	});
	const updateInk = () => {
		var _a$1;
		const linkNode = (_a$1 = wrapperRef.current) === null || _a$1 === void 0 ? void 0 : _a$1.querySelector(`.${prefixCls}-link-title-active`);
		if (linkNode && spanLinkNode.current) {
			const { style: inkStyle } = spanLinkNode.current;
			const horizontalAnchor = anchorDirection === "horizontal";
			inkStyle.top = horizontalAnchor ? "" : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;
			inkStyle.height = horizontalAnchor ? "" : `${linkNode.clientHeight}px`;
			inkStyle.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : "";
			inkStyle.width = horizontalAnchor ? `${linkNode.clientWidth}px` : "";
			if (horizontalAnchor) e(linkNode, {
				scrollMode: "if-needed",
				block: "nearest"
			});
		}
	};
	const getInternalCurrentAnchor = (_links, _offsetTop = 0, _bounds = 5) => {
		const linkSections = [];
		const container = getCurrentContainer();
		_links.forEach((link) => {
			const sharpLinkMatch = sharpMatcherRegex.exec(link === null || link === void 0 ? void 0 : link.toString());
			if (!sharpLinkMatch) return;
			const target = document.getElementById(sharpLinkMatch[1]);
			if (target) {
				const top = getOffsetTop(target, container);
				if (top <= _offsetTop + _bounds) linkSections.push({
					link,
					top
				});
			}
		});
		if (linkSections.length) return linkSections.reduce((prev$1, curr) => curr.top > prev$1.top ? curr : prev$1).link;
		return "";
	};
	const setCurrentActiveLink = useEvent((link) => {
		if (activeLinkRef.current === link) return;
		const newLink = typeof getCurrentAnchor === "function" ? getCurrentAnchor(link) : link;
		setActiveLink(newLink);
		activeLinkRef.current = newLink;
		onChange === null || onChange === void 0 || onChange(link);
	});
	const handleScroll = import_react.useCallback(() => {
		if (animating.current) return;
		const currentActiveLink = getInternalCurrentAnchor(links, targetOffset$3 !== void 0 ? targetOffset$3 : offsetTop || 0, bounds);
		setCurrentActiveLink(currentActiveLink);
	}, [
		dependencyListItem,
		targetOffset$3,
		offsetTop
	]);
	const handleScrollTo = import_react.useCallback((link) => {
		setCurrentActiveLink(link);
		const sharpLinkMatch = sharpMatcherRegex.exec(link);
		if (!sharpLinkMatch) return;
		const targetElement = document.getElementById(sharpLinkMatch[1]);
		if (!targetElement) return;
		const container = getCurrentContainer();
		const scrollTop = getScroll_default(container);
		const eleOffsetTop = getOffsetTop(targetElement, container);
		let y = scrollTop + eleOffsetTop;
		y -= targetOffset$3 !== void 0 ? targetOffset$3 : offsetTop || 0;
		animating.current = true;
		scrollTo(y, {
			getContainer: getCurrentContainer,
			callback() {
				animating.current = false;
			}
		});
	}, [targetOffset$3, offsetTop]);
	const wrapperClass = (0, import_classnames$274.default)(hashId, cssVarCls, rootCls, rootClassName, `${prefixCls}-wrapper`, {
		[`${prefixCls}-wrapper-horizontal`]: anchorDirection === "horizontal",
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, anchorClassName);
	const anchorClass = (0, import_classnames$274.default)(prefixCls, { [`${prefixCls}-fixed`]: !affix && !showInkInFixed });
	const inkClass = (0, import_classnames$274.default)(`${prefixCls}-ink`, { [`${prefixCls}-ink-visible`]: activeLink });
	const wrapperStyle = Object.assign(Object.assign({ maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : "100vh" }, anchorStyle), style$1);
	const createNestedLink = (options) => Array.isArray(options) ? options.map((item) => /* @__PURE__ */ import_react.createElement(AnchorLink_default, Object.assign({ replace: replace$1 }, item, { key: item.key }), anchorDirection === "vertical" && createNestedLink(item.children))) : null;
	const anchorContent = /* @__PURE__ */ import_react.createElement("div", {
		ref: wrapperRef,
		className: wrapperClass,
		style: wrapperStyle
	}, /* @__PURE__ */ import_react.createElement("div", { className: anchorClass }, /* @__PURE__ */ import_react.createElement("span", {
		className: inkClass,
		ref: spanLinkNode
	}), "items" in props ? createNestedLink(items) : children));
	import_react.useEffect(() => {
		const scrollContainer = getCurrentContainer();
		handleScroll();
		scrollContainer === null || scrollContainer === void 0 || scrollContainer.addEventListener("scroll", handleScroll);
		return () => {
			scrollContainer === null || scrollContainer === void 0 || scrollContainer.removeEventListener("scroll", handleScroll);
		};
	}, [dependencyListItem]);
	import_react.useEffect(() => {
		if (typeof getCurrentAnchor === "function") setCurrentActiveLink(getCurrentAnchor(activeLinkRef.current || ""));
	}, [getCurrentAnchor]);
	import_react.useEffect(() => {
		updateInk();
	}, [
		anchorDirection,
		getCurrentAnchor,
		dependencyListItem,
		activeLink
	]);
	const memoizedContextValue = import_react.useMemo(() => ({
		registerLink,
		unregisterLink,
		scrollTo: handleScrollTo,
		activeLink,
		onClick,
		direction: anchorDirection
	}), [
		activeLink,
		onClick,
		handleScrollTo,
		anchorDirection
	]);
	const affixProps = affix && typeof affix === "object" ? affix : void 0;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(context_default$9.Provider, { value: memoizedContextValue }, affix ? /* @__PURE__ */ import_react.createElement(affix_default, Object.assign({
		offsetTop,
		target: getCurrentContainer
	}, affixProps), anchorContent) : anchorContent));
};
Anchor$1.displayName = "Anchor";
var Anchor_default = Anchor$1;

//#endregion
//#region node_modules/antd/es/anchor/index.js
var Anchor = Anchor_default;
Anchor.Link = AnchorLink_default;
var anchor_default = Anchor;

//#endregion
//#region node_modules/rc-util/es/KeyCode.js
/**
* @ignore
* some key-codes definition and utils from closure-library
* @author yiminghe@gmail.com
*/
var KeyCode = {
	MAC_ENTER: 3,
	BACKSPACE: 8,
	TAB: 9,
	NUM_CENTER: 12,
	ENTER: 13,
	SHIFT: 16,
	CTRL: 17,
	ALT: 18,
	PAUSE: 19,
	CAPS_LOCK: 20,
	ESC: 27,
	SPACE: 32,
	PAGE_UP: 33,
	PAGE_DOWN: 34,
	END: 35,
	HOME: 36,
	LEFT: 37,
	UP: 38,
	RIGHT: 39,
	DOWN: 40,
	PRINT_SCREEN: 44,
	INSERT: 45,
	DELETE: 46,
	ZERO: 48,
	ONE: 49,
	TWO: 50,
	THREE: 51,
	FOUR: 52,
	FIVE: 53,
	SIX: 54,
	SEVEN: 55,
	EIGHT: 56,
	NINE: 57,
	QUESTION_MARK: 63,
	A: 65,
	B: 66,
	C: 67,
	D: 68,
	E: 69,
	F: 70,
	G: 71,
	H: 72,
	I: 73,
	J: 74,
	K: 75,
	L: 76,
	M: 77,
	N: 78,
	O: 79,
	P: 80,
	Q: 81,
	R: 82,
	S: 83,
	T: 84,
	U: 85,
	V: 86,
	W: 87,
	X: 88,
	Y: 89,
	Z: 90,
	META: 91,
	WIN_KEY_RIGHT: 92,
	CONTEXT_MENU: 93,
	NUM_ZERO: 96,
	NUM_ONE: 97,
	NUM_TWO: 98,
	NUM_THREE: 99,
	NUM_FOUR: 100,
	NUM_FIVE: 101,
	NUM_SIX: 102,
	NUM_SEVEN: 103,
	NUM_EIGHT: 104,
	NUM_NINE: 105,
	NUM_MULTIPLY: 106,
	NUM_PLUS: 107,
	NUM_MINUS: 109,
	NUM_PERIOD: 110,
	NUM_DIVISION: 111,
	F1: 112,
	F2: 113,
	F3: 114,
	F4: 115,
	F5: 116,
	F6: 117,
	F7: 118,
	F8: 119,
	F9: 120,
	F10: 121,
	F11: 122,
	F12: 123,
	NUMLOCK: 144,
	SEMICOLON: 186,
	DASH: 189,
	EQUALS: 187,
	COMMA: 188,
	PERIOD: 190,
	SLASH: 191,
	APOSTROPHE: 192,
	SINGLE_QUOTE: 222,
	OPEN_SQUARE_BRACKET: 219,
	BACKSLASH: 220,
	CLOSE_SQUARE_BRACKET: 221,
	WIN_KEY: 224,
	MAC_FF_META: 224,
	WIN_IME: 229,
	isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e$2) {
		var keyCode = e$2.keyCode;
		if (e$2.altKey && !e$2.ctrlKey || e$2.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) return false;
		switch (keyCode) {
			case KeyCode.ALT:
			case KeyCode.CAPS_LOCK:
			case KeyCode.CONTEXT_MENU:
			case KeyCode.CTRL:
			case KeyCode.DOWN:
			case KeyCode.END:
			case KeyCode.ESC:
			case KeyCode.HOME:
			case KeyCode.INSERT:
			case KeyCode.LEFT:
			case KeyCode.MAC_FF_META:
			case KeyCode.META:
			case KeyCode.NUMLOCK:
			case KeyCode.NUM_CENTER:
			case KeyCode.PAGE_DOWN:
			case KeyCode.PAGE_UP:
			case KeyCode.PAUSE:
			case KeyCode.PRINT_SCREEN:
			case KeyCode.RIGHT:
			case KeyCode.SHIFT:
			case KeyCode.UP:
			case KeyCode.WIN_KEY:
			case KeyCode.WIN_KEY_RIGHT: return false;
			default: return true;
		}
	},
	isCharacterKey: function isCharacterKey(keyCode) {
		if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) return true;
		if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) return true;
		if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) return true;
		if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) return true;
		switch (keyCode) {
			case KeyCode.SPACE:
			case KeyCode.QUESTION_MARK:
			case KeyCode.NUM_PLUS:
			case KeyCode.NUM_MINUS:
			case KeyCode.NUM_PERIOD:
			case KeyCode.NUM_DIVISION:
			case KeyCode.SEMICOLON:
			case KeyCode.DASH:
			case KeyCode.EQUALS:
			case KeyCode.COMMA:
			case KeyCode.PERIOD:
			case KeyCode.SLASH:
			case KeyCode.APOSTROPHE:
			case KeyCode.SINGLE_QUOTE:
			case KeyCode.OPEN_SQUARE_BRACKET:
			case KeyCode.BACKSLASH:
			case KeyCode.CLOSE_SQUARE_BRACKET: return true;
			default: return false;
		}
	}
};
var KeyCode_default = KeyCode;

//#endregion
//#region node_modules/rc-notification/es/Notice.js
var import_classnames$273 = /* @__PURE__ */ __toESM(require_classnames());
var Notify = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, style$1 = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, showProgress = props.showProgress, _props$pauseOnHover = props.pauseOnHover, pauseOnHover = _props$pauseOnHover === void 0 ? true : _props$pauseOnHover, eventKey = props.eventKey, content = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? "x" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times, forcedHovering = props.hovering;
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];
	var _React$useState3 = import_react.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), percent = _React$useState4[0], setPercent = _React$useState4[1];
	var _React$useState5 = import_react.useState(0), _React$useState6 = _slicedToArray(_React$useState5, 2), spentTime = _React$useState6[0], setSpentTime = _React$useState6[1];
	var mergedHovering = forcedHovering || hovering;
	var mergedShowProgress = duration > 0 && showProgress;
	var onInternalClose = function onInternalClose$1() {
		onNoticeClose(eventKey);
	};
	var onCloseKeyDown = function onCloseKeyDown$1(e$2) {
		if (e$2.key === "Enter" || e$2.code === "Enter" || e$2.keyCode === KeyCode_default.ENTER) onInternalClose();
	};
	import_react.useEffect(function() {
		if (!mergedHovering && duration > 0) {
			var start = Date.now() - spentTime;
			var timeout = setTimeout(function() {
				onInternalClose();
			}, duration * 1e3 - spentTime);
			return function() {
				if (pauseOnHover) clearTimeout(timeout);
				setSpentTime(Date.now() - start);
			};
		}
	}, [
		duration,
		mergedHovering,
		times
	]);
	import_react.useEffect(function() {
		if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
			var start = performance.now();
			var animationFrame;
			(function calculate() {
				cancelAnimationFrame(animationFrame);
				animationFrame = requestAnimationFrame(function(timestamp) {
					var runtime = timestamp + spentTime - start;
					var progress = Math.min(runtime / (duration * 1e3), 1);
					setPercent(progress * 100);
					if (progress < 1) calculate();
				});
			})();
			return function() {
				if (pauseOnHover) cancelAnimationFrame(animationFrame);
			};
		}
	}, [
		duration,
		spentTime,
		mergedHovering,
		mergedShowProgress,
		times
	]);
	var closableObj = import_react.useMemo(function() {
		if (_typeof(closable) === "object" && closable !== null) return closable;
		if (closable) return { closeIcon };
		return {};
	}, [closable, closeIcon]);
	var ariaProps = pickAttrs(closableObj, true);
	var validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);
	var noticePrefixCls = "".concat(prefixCls, "-notice");
	return /* @__PURE__ */ import_react.createElement("div", _extends({}, divProps, {
		ref,
		className: (0, import_classnames$273.default)(noticePrefixCls, className, _defineProperty({}, "".concat(noticePrefixCls, "-closable"), closable)),
		style: style$1,
		onMouseEnter: function onMouseEnter(e$2) {
			var _divProps$onMouseEnte;
			setHovering(true);
			divProps === null || divProps === void 0 || (_divProps$onMouseEnte = divProps.onMouseEnter) === null || _divProps$onMouseEnte === void 0 || _divProps$onMouseEnte.call(divProps, e$2);
		},
		onMouseLeave: function onMouseLeave(e$2) {
			var _divProps$onMouseLeav;
			setHovering(false);
			divProps === null || divProps === void 0 || (_divProps$onMouseLeav = divProps.onMouseLeave) === null || _divProps$onMouseLeav === void 0 || _divProps$onMouseLeav.call(divProps, e$2);
		},
		onClick
	}), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(noticePrefixCls, "-content") }, content), closable && /* @__PURE__ */ import_react.createElement("a", _extends({
		tabIndex: 0,
		className: "".concat(noticePrefixCls, "-close"),
		onKeyDown: onCloseKeyDown,
		"aria-label": "Close"
	}, ariaProps, { onClick: function onClick$1(e$2) {
		e$2.preventDefault();
		e$2.stopPropagation();
		onInternalClose();
	} }), closableObj.closeIcon), mergedShowProgress && /* @__PURE__ */ import_react.createElement("progress", {
		className: "".concat(noticePrefixCls, "-progress"),
		max: "100",
		value: validPercent
	}, validPercent + "%"));
});
var Notice_default = Notify;

//#endregion
//#region node_modules/rc-notification/es/NotificationProvider.js
var NotificationContext = /* @__PURE__ */ import_react.createContext({});
var NotificationProvider = function NotificationProvider$1(_ref) {
	var children = _ref.children, classNames$252 = _ref.classNames;
	return /* @__PURE__ */ import_react.createElement(NotificationContext.Provider, { value: { classNames: classNames$252 } }, children);
};
var NotificationProvider_default = NotificationProvider;

//#endregion
//#region node_modules/rc-notification/es/hooks/useStack.js
var DEFAULT_OFFSET$2 = 8;
var DEFAULT_THRESHOLD = 3;
var DEFAULT_GAP = 16;
var useStack = function useStack$1(config) {
	var result = {
		offset: DEFAULT_OFFSET$2,
		threshold: DEFAULT_THRESHOLD,
		gap: DEFAULT_GAP
	};
	if (config && _typeof(config) === "object") {
		var _config$offset, _config$threshold, _config$gap;
		result.offset = (_config$offset = config.offset) !== null && _config$offset !== void 0 ? _config$offset : DEFAULT_OFFSET$2;
		result.threshold = (_config$threshold = config.threshold) !== null && _config$threshold !== void 0 ? _config$threshold : DEFAULT_THRESHOLD;
		result.gap = (_config$gap = config.gap) !== null && _config$gap !== void 0 ? _config$gap : DEFAULT_GAP;
	}
	return [!!config, result];
};
var useStack_default = useStack;

//#endregion
//#region node_modules/rc-notification/es/NoticeList.js
var import_classnames$272 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$73 = [
	"className",
	"style",
	"classNames",
	"styles"
];
var NoticeList = function NoticeList$1(props) {
	var configList = props.configList, placement = props.placement, prefixCls = props.prefixCls, className = props.className, style$1 = props.style, motion$1 = props.motion, onAllNoticeRemoved = props.onAllNoticeRemoved, onNoticeClose = props.onNoticeClose, stackConfig = props.stack;
	var _useContext = (0, import_react.useContext)(NotificationContext), ctxCls = _useContext.classNames;
	var dictRef = (0, import_react.useRef)({});
	var _useState = (0, import_react.useState)(null), _useState2 = _slicedToArray(_useState, 2), latestNotice = _useState2[0], setLatestNotice = _useState2[1];
	var _useState3 = (0, import_react.useState)([]), _useState4 = _slicedToArray(_useState3, 2), hoverKeys = _useState4[0], setHoverKeys = _useState4[1];
	var keys$1 = configList.map(function(config) {
		return {
			config,
			key: String(config.key)
		};
	});
	var _useStack = useStack_default(stackConfig), _useStack2 = _slicedToArray(_useStack, 2), stack = _useStack2[0], _useStack2$ = _useStack2[1], offset$2 = _useStack2$.offset, threshold = _useStack2$.threshold, gap = _useStack2$.gap;
	var expanded = stack && (hoverKeys.length > 0 || keys$1.length <= threshold);
	var placementMotion = typeof motion$1 === "function" ? motion$1(placement) : motion$1;
	(0, import_react.useEffect)(function() {
		if (stack && hoverKeys.length > 1) setHoverKeys(function(prev$1) {
			return prev$1.filter(function(key) {
				return keys$1.some(function(_ref) {
					var dataKey = _ref.key;
					return key === dataKey;
				});
			});
		});
	}, [
		hoverKeys,
		keys$1,
		stack
	]);
	(0, import_react.useEffect)(function() {
		var _keys;
		if (stack && dictRef.current[(_keys = keys$1[keys$1.length - 1]) === null || _keys === void 0 ? void 0 : _keys.key]) {
			var _keys2;
			setLatestNotice(dictRef.current[(_keys2 = keys$1[keys$1.length - 1]) === null || _keys2 === void 0 ? void 0 : _keys2.key]);
		}
	}, [keys$1, stack]);
	return /* @__PURE__ */ import_react.createElement(CSSMotionList_default, _extends({
		key: placement,
		className: (0, import_classnames$272.default)(prefixCls, "".concat(prefixCls, "-").concat(placement), ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.list, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-stack"), !!stack), "".concat(prefixCls, "-stack-expanded"), expanded)),
		style: style$1,
		keys: keys$1,
		motionAppear: true
	}, placementMotion, { onAllRemoved: function onAllRemoved() {
		onAllNoticeRemoved(placement);
	} }), function(_ref2, nodeRef) {
		var config = _ref2.config, motionClassName = _ref2.className, motionStyle = _ref2.style, motionIndex = _ref2.index;
		var _ref3 = config, key = _ref3.key, times = _ref3.times;
		var strKey = String(key);
		var _ref4 = config, configClassName = _ref4.className, configStyle = _ref4.style, configClassNames = _ref4.classNames, configStyles = _ref4.styles, restConfig = _objectWithoutProperties(_ref4, _excluded$73);
		var dataIndex = keys$1.findIndex(function(item) {
			return item.key === strKey;
		});
		var stackStyle = {};
		if (stack) {
			var index$2 = keys$1.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
			var transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
			if (index$2 > 0) {
				var _dictRef$current$strK, _dictRef$current$strK2, _dictRef$current$strK3;
				stackStyle.height = expanded ? (_dictRef$current$strK = dictRef.current[strKey]) === null || _dictRef$current$strK === void 0 ? void 0 : _dictRef$current$strK.offsetHeight : latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetHeight;
				var verticalOffset = 0;
				for (var i = 0; i < index$2; i++) {
					var _dictRef$current$keys;
					verticalOffset += ((_dictRef$current$keys = dictRef.current[keys$1[keys$1.length - 1 - i].key]) === null || _dictRef$current$keys === void 0 ? void 0 : _dictRef$current$keys.offsetHeight) + gap;
				}
				var transformY = (expanded ? verticalOffset : index$2 * offset$2) * (placement.startsWith("top") ? 1 : -1);
				var scaleX = !expanded && latestNotice !== null && latestNotice !== void 0 && latestNotice.offsetWidth && (_dictRef$current$strK2 = dictRef.current[strKey]) !== null && _dictRef$current$strK2 !== void 0 && _dictRef$current$strK2.offsetWidth ? ((latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetWidth) - offset$2 * 2 * (index$2 < 3 ? index$2 : 3)) / ((_dictRef$current$strK3 = dictRef.current[strKey]) === null || _dictRef$current$strK3 === void 0 ? void 0 : _dictRef$current$strK3.offsetWidth) : 1;
				stackStyle.transform = "translate3d(".concat(transformX, ", ").concat(transformY, "px, 0) scaleX(").concat(scaleX, ")");
			} else stackStyle.transform = "translate3d(".concat(transformX, ", 0, 0)");
		}
		return /* @__PURE__ */ import_react.createElement("div", {
			ref: nodeRef,
			className: (0, import_classnames$272.default)("".concat(prefixCls, "-notice-wrapper"), motionClassName, configClassNames === null || configClassNames === void 0 ? void 0 : configClassNames.wrapper),
			style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), stackStyle), configStyles === null || configStyles === void 0 ? void 0 : configStyles.wrapper),
			onMouseEnter: function onMouseEnter() {
				return setHoverKeys(function(prev$1) {
					return prev$1.includes(strKey) ? prev$1 : [].concat(_toConsumableArray(prev$1), [strKey]);
				});
			},
			onMouseLeave: function onMouseLeave() {
				return setHoverKeys(function(prev$1) {
					return prev$1.filter(function(k) {
						return k !== strKey;
					});
				});
			}
		}, /* @__PURE__ */ import_react.createElement(Notice_default, _extends({}, restConfig, {
			ref: function ref(node$1) {
				if (dataIndex > -1) dictRef.current[strKey] = node$1;
				else delete dictRef.current[strKey];
			},
			prefixCls,
			classNames: configClassNames,
			styles: configStyles,
			className: (0, import_classnames$272.default)(configClassName, ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.notice),
			style: configStyle,
			times,
			key,
			eventKey: key,
			onNoticeClose,
			hovering: stack && hoverKeys.length > 0
		})));
	});
};
NoticeList.displayName = "NoticeList";
var NoticeList_default = NoticeList;

//#endregion
//#region node_modules/rc-notification/es/Notifications.js
var import_react_dom$10 = /* @__PURE__ */ __toESM(require_react_dom());
var Notifications = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-notification" : _props$prefixCls, container = props.container, motion$1 = props.motion, maxCount = props.maxCount, className = props.className, style$1 = props.style, onAllRemoved = props.onAllRemoved, stack = props.stack, renderNotifications$2 = props.renderNotifications;
	var _React$useState = import_react.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];
	var onNoticeClose = function onNoticeClose$1(key) {
		var _config$onClose;
		var config = configList.find(function(item) {
			return item.key === key;
		});
		config === null || config === void 0 || (_config$onClose = config.onClose) === null || _config$onClose === void 0 || _config$onClose.call(config);
		setConfigList(function(list) {
			return list.filter(function(item) {
				return item.key !== key;
			});
		});
	};
	import_react.useImperativeHandle(ref, function() {
		return {
			open: function open$2(config) {
				setConfigList(function(list) {
					var clone = _toConsumableArray(list);
					var index$2 = clone.findIndex(function(item) {
						return item.key === config.key;
					});
					var innerConfig = _objectSpread2({}, config);
					if (index$2 >= 0) {
						var _list$index;
						innerConfig.times = (((_list$index = list[index$2]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
						clone[index$2] = innerConfig;
					} else {
						innerConfig.times = 0;
						clone.push(innerConfig);
					}
					if (maxCount > 0 && clone.length > maxCount) clone = clone.slice(-maxCount);
					return clone;
				});
			},
			close: function close(key) {
				onNoticeClose(key);
			},
			destroy: function destroy$2() {
				setConfigList([]);
			}
		};
	});
	var _React$useState3 = import_react.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), placements$4 = _React$useState4[0], setPlacements = _React$useState4[1];
	import_react.useEffect(function() {
		var nextPlacements = {};
		configList.forEach(function(config) {
			var _config$placement = config.placement, placement = _config$placement === void 0 ? "topRight" : _config$placement;
			if (placement) {
				nextPlacements[placement] = nextPlacements[placement] || [];
				nextPlacements[placement].push(config);
			}
		});
		Object.keys(placements$4).forEach(function(placement) {
			nextPlacements[placement] = nextPlacements[placement] || [];
		});
		setPlacements(nextPlacements);
	}, [configList]);
	var onAllNoticeRemoved = function onAllNoticeRemoved$1(placement) {
		setPlacements(function(originPlacements) {
			var clone = _objectSpread2({}, originPlacements);
			if (!(clone[placement] || []).length) delete clone[placement];
			return clone;
		});
	};
	var emptyRef = import_react.useRef(false);
	import_react.useEffect(function() {
		if (Object.keys(placements$4).length > 0) emptyRef.current = true;
		else if (emptyRef.current) {
			onAllRemoved === null || onAllRemoved === void 0 || onAllRemoved();
			emptyRef.current = false;
		}
	}, [placements$4]);
	if (!container) return null;
	var placementList = Object.keys(placements$4);
	return /* @__PURE__ */ (0, import_react_dom$10.createPortal)(/* @__PURE__ */ import_react.createElement(import_react.Fragment, null, placementList.map(function(placement) {
		var placementConfigList = placements$4[placement];
		var list = /* @__PURE__ */ import_react.createElement(NoticeList_default, {
			key: placement,
			configList: placementConfigList,
			placement,
			prefixCls,
			className: className === null || className === void 0 ? void 0 : className(placement),
			style: style$1 === null || style$1 === void 0 ? void 0 : style$1(placement),
			motion: motion$1,
			onNoticeClose,
			onAllNoticeRemoved,
			stack
		});
		return renderNotifications$2 ? renderNotifications$2(list, {
			prefixCls,
			key: placement
		}) : list;
	})), container);
});
Notifications.displayName = "Notifications";
var Notifications_default = Notifications;

//#endregion
//#region node_modules/rc-notification/es/hooks/useNotification.js
var _excluded$72 = [
	"getContainer",
	"motion",
	"prefixCls",
	"maxCount",
	"className",
	"style",
	"onAllRemoved",
	"stack",
	"renderNotifications"
];
var defaultGetContainer = function defaultGetContainer$1() {
	return document.body;
};
var uniqueKey = 0;
function mergeConfig() {
	var clone = {};
	for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) objList[_key] = arguments[_key];
	objList.forEach(function(obj) {
		if (obj) Object.keys(obj).forEach(function(key) {
			var val = obj[key];
			if (val !== void 0) clone[key] = val;
		});
	});
	return clone;
}
function useNotification$1() {
	var rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	var _rootConfig$getContai = rootConfig.getContainer, getContainer$1 = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion$1 = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style$1 = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, stack = rootConfig.stack, renderNotifications$2 = rootConfig.renderNotifications, shareConfig = _objectWithoutProperties(rootConfig, _excluded$72);
	var _React$useState = import_react.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), container = _React$useState2[0], setContainer = _React$useState2[1];
	var notificationsRef = import_react.useRef();
	var contextHolder = /* @__PURE__ */ import_react.createElement(Notifications_default, {
		container,
		ref: notificationsRef,
		prefixCls,
		motion: motion$1,
		maxCount,
		className,
		style: style$1,
		onAllRemoved,
		stack,
		renderNotifications: renderNotifications$2
	});
	var _React$useState3 = import_react.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), taskQueue$2 = _React$useState4[0], setTaskQueue = _React$useState4[1];
	var open$2 = useEvent(function(config) {
		var mergedConfig = mergeConfig(shareConfig, config);
		if (mergedConfig.key === null || mergedConfig.key === void 0) {
			mergedConfig.key = "rc-notification-".concat(uniqueKey);
			uniqueKey += 1;
		}
		setTaskQueue(function(queue) {
			return [].concat(_toConsumableArray(queue), [{
				type: "open",
				config: mergedConfig
			}]);
		});
	});
	var api = import_react.useMemo(function() {
		return {
			open: open$2,
			close: function close(key) {
				setTaskQueue(function(queue) {
					return [].concat(_toConsumableArray(queue), [{
						type: "close",
						key
					}]);
				});
			},
			destroy: function destroy$2() {
				setTaskQueue(function(queue) {
					return [].concat(_toConsumableArray(queue), [{ type: "destroy" }]);
				});
			}
		};
	}, []);
	import_react.useEffect(function() {
		setContainer(getContainer$1());
	});
	import_react.useEffect(function() {
		if (notificationsRef.current && taskQueue$2.length) {
			taskQueue$2.forEach(function(task) {
				switch (task.type) {
					case "open":
						notificationsRef.current.open(task.config);
						break;
					case "close":
						notificationsRef.current.close(task.key);
						break;
					case "destroy":
						notificationsRef.current.destroy();
						break;
				}
			});
			var oriTaskQueue;
			var tgtTaskQueue;
			setTaskQueue(function(oriQueue) {
				if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {
					oriTaskQueue = oriQueue;
					tgtTaskQueue = oriQueue.filter(function(task) {
						return !taskQueue$2.includes(task);
					});
				}
				return tgtTaskQueue;
			});
		}
	}, [taskQueue$2]);
	return [api, contextHolder];
}

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/LoadingOutlined.js
var LoadingOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" }
		}]
	},
	"name": "loading",
	"theme": "outlined"
};
var LoadingOutlined_default$1 = LoadingOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/LoadingOutlined.js
/**![loading](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk4OCA1NDhjLTE5LjkgMC0zNi0xNi4xLTM2LTM2IDAtNTkuNC0xMS42LTExNy0zNC42LTE3MS4zYTQ0MC40NSA0NDAuNDUgMCAwMC05NC4zLTEzOS45IDQzNy43MSA0MzcuNzEgMCAwMC0xMzkuOS05NC4zQzYyOSA4My42IDU3MS40IDcyIDUxMiA3MmMtMTkuOSAwLTM2LTE2LjEtMzYtMzZzMTYuMS0zNiAzNi0zNmM2OS4xIDAgMTM2LjIgMTMuNSAxOTkuMyA0MC4zQzc3Mi4zIDY2IDgyNyAxMDMgODc0IDE1MGM0NyA0NyA4My45IDEwMS44IDEwOS43IDE2Mi43IDI2LjcgNjMuMSA0MC4yIDEzMC4yIDQwLjIgMTk5LjMuMSAxOS45LTE2IDM2LTM1LjkgMzZ6IiAvPjwvc3ZnPg==) */
var RefIcon$45 = /* @__PURE__ */ import_react.forwardRef(function LoadingOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: LoadingOutlined_default$1
	}));
});
RefIcon$45.displayName = "LoadingOutlined";
var LoadingOutlined_default = RefIcon$45;

//#endregion
//#region node_modules/antd/es/_util/zindexContext.js
var zIndexContext = /* @__PURE__ */ import_react.createContext(void 0);
zIndexContext.displayName = "zIndexContext";
var zindexContext_default = zIndexContext;

//#endregion
//#region node_modules/antd/es/_util/hooks/useZIndex.js
var CONTAINER_OFFSET = 100;
var CONTAINER_OFFSET_MAX_COUNT = 10;
const CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
/**
* Static function will default be the `CONTAINER_MAX_OFFSET`.
* But it still may have children component like Select, Dropdown.
* So the warning zIndex should exceed the `CONTAINER_MAX_OFFSET`.
*/
var CONTAINER_MAX_OFFSET_WITH_CHILDREN = CONTAINER_MAX_OFFSET + CONTAINER_OFFSET;
const containerBaseZIndexOffset = {
	Modal: CONTAINER_OFFSET,
	Drawer: CONTAINER_OFFSET,
	Popover: CONTAINER_OFFSET,
	Popconfirm: CONTAINER_OFFSET,
	Tooltip: CONTAINER_OFFSET,
	Tour: CONTAINER_OFFSET,
	FloatButton: CONTAINER_OFFSET
};
const consumerBaseZIndexOffset = {
	SelectLike: 50,
	Dropdown: 50,
	DatePicker: 50,
	Menu: 50,
	ImagePreview: 1
};
function isContainerType(type$2) {
	return type$2 in containerBaseZIndexOffset;
}
const useZIndex = (componentType, customZIndex) => {
	const [, token$1] = useToken();
	const parentZIndex = import_react.useContext(zindexContext_default);
	const isContainer = isContainerType(componentType);
	let result;
	if (customZIndex !== void 0) result = [customZIndex, customZIndex];
	else {
		let zIndex = parentZIndex !== null && parentZIndex !== void 0 ? parentZIndex : 0;
		if (isContainer) zIndex += (parentZIndex ? 0 : token$1.zIndexPopupBase) + containerBaseZIndexOffset[componentType];
		else zIndex += consumerBaseZIndexOffset[componentType];
		result = [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
	}
	{
		const warning$4 = devUseWarning(componentType);
		const maxZIndex = token$1.zIndexPopupBase + CONTAINER_MAX_OFFSET_WITH_CHILDREN;
		const currentZIndex = result[0] || 0;
		warning$4(customZIndex !== void 0 || currentZIndex <= maxZIndex, "usage", "`zIndex` is over design token `zIndexPopupBase` too much. It may cause unexpected override.");
	}
	return result;
};

//#endregion
//#region node_modules/antd/es/message/style/index.js
var genMessageStyle = (token$1) => {
	const { componentCls, iconCls, boxShadow, colorText, colorSuccess, colorError, colorWarning, colorInfo, fontSizeLG, motionEaseInOutCirc, motionDurationSlow, marginXS, paddingXS, borderRadiusLG, zIndexPopup, contentPadding, contentBg } = token$1;
	const noticeCls = `${componentCls}-notice`;
	const messageMoveIn = new Keyframes_default("MessageMoveIn", {
		"0%": {
			padding: 0,
			transform: "translateY(-100%)",
			opacity: 0
		},
		"100%": {
			padding: paddingXS,
			transform: "translateY(0)",
			opacity: 1
		}
	});
	const messageMoveOut = new Keyframes_default("MessageMoveOut", {
		"0%": {
			maxHeight: token$1.height,
			padding: paddingXS,
			opacity: 1
		},
		"100%": {
			maxHeight: 0,
			padding: 0,
			opacity: 0
		}
	});
	const noticeStyle = {
		padding: paddingXS,
		textAlign: "center",
		[`${componentCls}-custom-content`]: {
			display: "flex",
			alignItems: "center"
		},
		[`${componentCls}-custom-content > ${iconCls}`]: {
			marginInlineEnd: marginXS,
			fontSize: fontSizeLG
		},
		[`${noticeCls}-content`]: {
			display: "inline-block",
			padding: contentPadding,
			background: contentBg,
			borderRadius: borderRadiusLG,
			boxShadow,
			pointerEvents: "all"
		},
		[`${componentCls}-success > ${iconCls}`]: { color: colorSuccess },
		[`${componentCls}-error > ${iconCls}`]: { color: colorError },
		[`${componentCls}-warning > ${iconCls}`]: { color: colorWarning },
		[`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: { color: colorInfo }
	};
	return [
		{ [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			color: colorText,
			position: "fixed",
			top: marginXS,
			width: "100%",
			pointerEvents: "none",
			zIndex: zIndexPopup,
			[`${componentCls}-move-up`]: { animationFillMode: "forwards" },
			[`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
				animationName: messageMoveIn,
				animationDuration: motionDurationSlow,
				animationPlayState: "paused",
				animationTimingFunction: motionEaseInOutCirc
			},
			[`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: { animationPlayState: "running" },
			[`${componentCls}-move-up-leave`]: {
				animationName: messageMoveOut,
				animationDuration: motionDurationSlow,
				animationPlayState: "paused",
				animationTimingFunction: motionEaseInOutCirc
			},
			[`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: { animationPlayState: "running" },
			"&-rtl": {
				direction: "rtl",
				span: { direction: "rtl" }
			}
		}) },
		{ [componentCls]: { [`${noticeCls}-wrapper`]: Object.assign({}, noticeStyle) } },
		{ [`${componentCls}-notice-pure-panel`]: Object.assign(Object.assign({}, noticeStyle), {
			padding: 0,
			textAlign: "start"
		}) }
	];
};
const prepareComponentToken$54 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
	contentBg: token$1.colorBgElevated,
	contentPadding: `${(token$1.controlHeightLG - token$1.fontSize * token$1.lineHeight) / 2}px ${token$1.paddingSM}px`
});
var style_default$60 = genStyleHooks("Message", (token$1) => {
	const combinedToken = merge(token$1, { height: 150 });
	return genMessageStyle(combinedToken);
}, prepareComponentToken$54);

//#endregion
//#region node_modules/antd/es/message/PurePanel.js
var import_classnames$271 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$109 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const TypeIcon = {
	info: /* @__PURE__ */ import_react.createElement(InfoCircleFilled_default, null),
	success: /* @__PURE__ */ import_react.createElement(CheckCircleFilled_default, null),
	error: /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null),
	warning: /* @__PURE__ */ import_react.createElement(ExclamationCircleFilled_default, null),
	loading: /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null)
};
const PureContent$1 = ({ prefixCls, type: type$2, icon, children }) => /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$271.default)(`${prefixCls}-custom-content`, `${prefixCls}-${type$2}`) }, icon || TypeIcon[type$2], /* @__PURE__ */ import_react.createElement("span", null, children));
/** @private Internal Component. Do not use in your production. */
var PurePanel$14 = (props) => {
	const { prefixCls: staticPrefixCls, className, type: type$2, icon, content } = props, restProps = __rest$109(props, [
		"prefixCls",
		"className",
		"type",
		"icon",
		"content"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = staticPrefixCls || getPrefixCls("message");
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$60(prefixCls, rootCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(Notice_default, Object.assign({}, restProps, {
		prefixCls,
		className: (0, import_classnames$271.default)(className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
		eventKey: "pure",
		duration: null,
		content: /* @__PURE__ */ import_react.createElement(PureContent$1, {
			prefixCls,
			type: type$2,
			icon
		}, content)
	})));
};
var PurePanel_default$6 = PurePanel$14;

//#endregion
//#region node_modules/antd/es/message/util.js
function getMotion$3(prefixCls, transitionName) {
	return { motionName: transitionName !== null && transitionName !== void 0 ? transitionName : `${prefixCls}-move-up` };
}
/** Wrap message open with promise like function */
function wrapPromiseFn(openFn) {
	let closeFn;
	const closePromise = new Promise((resolve) => {
		closeFn = openFn(() => {
			resolve(true);
		});
	});
	const result = () => {
		closeFn === null || closeFn === void 0 || closeFn();
	};
	result.then = (filled, rejected) => closePromise.then(filled, rejected);
	result.promise = closePromise;
	return result;
}

//#endregion
//#region node_modules/antd/es/message/useMessage.js
var import_classnames$270 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$108 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var DEFAULT_OFFSET$1 = 8;
var DEFAULT_DURATION$1 = 3;
var Wrapper$1 = ({ children, prefixCls }) => {
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$60(prefixCls, rootCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(NotificationProvider_default, { classNames: { list: (0, import_classnames$270.default)(hashId, cssVarCls, rootCls) } }, children));
};
var renderNotifications$1 = (node$1, { prefixCls, key }) => /* @__PURE__ */ import_react.createElement(Wrapper$1, {
	prefixCls,
	key
}, node$1);
var Holder$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { top, prefixCls: staticPrefixCls, getContainer: staticGetContainer, maxCount, duration = DEFAULT_DURATION$1, rtl, transitionName, onAllRemoved } = props;
	const { getPrefixCls, getPopupContainer, message: message$1, direction } = import_react.useContext(ConfigContext);
	const prefixCls = staticPrefixCls || getPrefixCls("message");
	const getStyle$3 = () => ({
		left: "50%",
		transform: "translateX(-50%)",
		top: top !== null && top !== void 0 ? top : DEFAULT_OFFSET$1
	});
	const getClassName = () => (0, import_classnames$270.default)({ [`${prefixCls}-rtl`]: rtl !== null && rtl !== void 0 ? rtl : direction === "rtl" });
	const getNotificationMotion = () => getMotion$3(prefixCls, transitionName);
	const mergedCloseIcon = /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-close-x` }, /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` }));
	const [api, holder] = useNotification$1({
		prefixCls,
		style: getStyle$3,
		className: getClassName,
		motion: getNotificationMotion,
		closable: false,
		closeIcon: mergedCloseIcon,
		duration,
		getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
		maxCount,
		onAllRemoved,
		renderNotifications: renderNotifications$1
	});
	import_react.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
		prefixCls,
		message: message$1
	}));
	return holder;
});
var keyIndex = 0;
function useInternalMessage(messageConfig) {
	const holderRef = import_react.useRef(null);
	const warning$4 = devUseWarning("Message");
	return [import_react.useMemo(() => {
		const close = (key) => {
			var _a;
			(_a = holderRef.current) === null || _a === void 0 || _a.close(key);
		};
		const open$2 = (config) => {
			if (!holderRef.current) {
				warning$4(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.");
				const fakeResult = () => {};
				fakeResult.then = () => {};
				return fakeResult;
			}
			const { open: originOpen, prefixCls, message: message$1 } = holderRef.current;
			const noticePrefixCls = `${prefixCls}-notice`;
			const { content, icon, type: type$2, key, className, style: style$1, onClose } = config, restConfig = __rest$108(config, [
				"content",
				"icon",
				"type",
				"key",
				"className",
				"style",
				"onClose"
			]);
			let mergedKey = key;
			if (mergedKey === void 0 || mergedKey === null) {
				keyIndex += 1;
				mergedKey = `antd-message-${keyIndex}`;
			}
			return wrapPromiseFn((resolve) => {
				originOpen(Object.assign(Object.assign({}, restConfig), {
					key: mergedKey,
					content: /* @__PURE__ */ import_react.createElement(PureContent$1, {
						prefixCls,
						type: type$2,
						icon
					}, content),
					placement: "top",
					className: (0, import_classnames$270.default)(type$2 && `${noticePrefixCls}-${type$2}`, className, message$1 === null || message$1 === void 0 ? void 0 : message$1.className),
					style: Object.assign(Object.assign({}, message$1 === null || message$1 === void 0 ? void 0 : message$1.style), style$1),
					onClose: () => {
						onClose === null || onClose === void 0 || onClose();
						resolve();
					}
				}));
				return () => {
					close(mergedKey);
				};
			});
		};
		const destroy$2 = (key) => {
			var _a;
			if (key !== void 0) close(key);
			else (_a = holderRef.current) === null || _a === void 0 || _a.destroy();
		};
		const clone = {
			open: open$2,
			destroy: destroy$2
		};
		[
			"info",
			"success",
			"warning",
			"error",
			"loading"
		].forEach((type$2) => {
			const typeOpen$1 = (jointContent, duration, onClose) => {
				let config;
				if (jointContent && typeof jointContent === "object" && "content" in jointContent) config = jointContent;
				else config = { content: jointContent };
				let mergedDuration;
				let mergedOnClose;
				if (typeof duration === "function") mergedOnClose = duration;
				else {
					mergedDuration = duration;
					mergedOnClose = onClose;
				}
				const mergedConfig = Object.assign(Object.assign({
					onClose: mergedOnClose,
					duration: mergedDuration
				}, config), { type: type$2 });
				return open$2(mergedConfig);
			};
			clone[type$2] = typeOpen$1;
		});
		return clone;
	}, []), /* @__PURE__ */ import_react.createElement(Holder$1, Object.assign({ key: "message-holder" }, messageConfig, { ref: holderRef }))];
}
function useMessage(messageConfig) {
	return useInternalMessage(messageConfig);
}

//#endregion
//#region node_modules/antd/es/_util/hooks/usePatchElement.js
function usePatchElement() {
	const [elements, setElements] = import_react.useState([]);
	const patchElement = import_react.useCallback((element) => {
		setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
		return () => {
			setElements((originElements) => originElements.filter((ele) => ele !== element));
		};
	}, []);
	return [elements, patchElement];
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/OverloadYield.js
function _OverloadYield(e$2, d) {
	this.v = e$2, this.k = d;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/regeneratorDefine.js
function _regeneratorDefine(e$2, r$1, n$1, t$1) {
	var i = Object.defineProperty;
	try {
		i({}, "", {});
	} catch (e$3) {
		i = 0;
	}
	_regeneratorDefine = function regeneratorDefine(e$3, r$2, n$2, t$2) {
		function o$2(r$3, n$3) {
			_regeneratorDefine(e$3, r$3, function(e$4) {
				return this._invoke(r$3, n$3, e$4);
			});
		}
		r$2 ? i ? i(e$3, r$2, {
			value: n$2,
			enumerable: !t$2,
			configurable: !t$2,
			writable: !t$2
		}) : e$3[r$2] = n$2 : (o$2("next", 0), o$2("throw", 1), o$2("return", 2));
	}, _regeneratorDefine(e$2, r$1, n$1, t$1);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/regenerator.js
function _regenerator() {
	/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
	var e$2, t$1, r$1 = "function" == typeof Symbol ? Symbol : {}, n$1 = r$1.iterator || "@@iterator", o$2 = r$1.toStringTag || "@@toStringTag";
	function i(r$2, n$2, o$3, i$1) {
		var c$1 = n$2 && n$2.prototype instanceof Generator ? n$2 : Generator, u$1 = Object.create(c$1.prototype);
		return _regeneratorDefine(u$1, "_invoke", function(r$3, n$3, o$4) {
			var i$2, c$2, u$2, f$1 = 0, p = o$4 || [], y = !1, G = {
				p: 0,
				n: 0,
				v: e$2,
				a: d,
				f: d.bind(e$2, 4),
				d: function d$1(t$2, r$4) {
					return i$2 = t$2, c$2 = 0, u$2 = e$2, G.n = r$4, a;
				}
			};
			function d(r$4, n$4) {
				for (c$2 = r$4, u$2 = n$4, t$1 = 0; !y && f$1 && !o$5 && t$1 < p.length; t$1++) {
					var o$5, i$3 = p[t$1], d$1 = G.p, l$1 = i$3[2];
					r$4 > 3 ? (o$5 = l$1 === n$4) && (u$2 = i$3[(c$2 = i$3[4]) ? 5 : (c$2 = 3, 3)], i$3[4] = i$3[5] = e$2) : i$3[0] <= d$1 && ((o$5 = r$4 < 2 && d$1 < i$3[1]) ? (c$2 = 0, G.v = n$4, G.n = i$3[1]) : d$1 < l$1 && (o$5 = r$4 < 3 || i$3[0] > n$4 || n$4 > l$1) && (i$3[4] = r$4, i$3[5] = n$4, G.n = l$1, c$2 = 0));
				}
				if (o$5 || r$4 > 1) return a;
				throw y = !0, n$4;
			}
			return function(o$5, p$1, l$1) {
				if (f$1 > 1) throw TypeError("Generator is already running");
				for (y && 1 === p$1 && d(p$1, l$1), c$2 = p$1, u$2 = l$1; (t$1 = c$2 < 2 ? e$2 : u$2) || !y;) {
					i$2 || (c$2 ? c$2 < 3 ? (c$2 > 1 && (G.n = -1), d(c$2, u$2)) : G.n = u$2 : G.v = u$2);
					try {
						if (f$1 = 2, i$2) {
							if (c$2 || (o$5 = "next"), t$1 = i$2[o$5]) {
								if (!(t$1 = t$1.call(i$2, u$2))) throw TypeError("iterator result is not an object");
								if (!t$1.done) return t$1;
								u$2 = t$1.value, c$2 < 2 && (c$2 = 0);
							} else 1 === c$2 && (t$1 = i$2["return"]) && t$1.call(i$2), c$2 < 2 && (u$2 = TypeError("The iterator does not provide a '" + o$5 + "' method"), c$2 = 1);
							i$2 = e$2;
						} else if ((t$1 = (y = G.n < 0) ? u$2 : r$3.call(n$3, G)) !== a) break;
					} catch (t$2) {
						i$2 = e$2, c$2 = 1, u$2 = t$2;
					} finally {
						f$1 = 1;
					}
				}
				return {
					value: t$1,
					done: y
				};
			};
		}(r$2, o$3, i$1), !0), u$1;
	}
	var a = {};
	function Generator() {}
	function GeneratorFunction() {}
	function GeneratorFunctionPrototype() {}
	t$1 = Object.getPrototypeOf;
	var c = [][n$1] ? t$1(t$1([][n$1]())) : (_regeneratorDefine(t$1 = {}, n$1, function() {
		return this;
	}), t$1), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
	function f(e$3) {
		return Object.setPrototypeOf ? Object.setPrototypeOf(e$3, GeneratorFunctionPrototype) : (e$3.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e$3, o$2, "GeneratorFunction")), e$3.prototype = Object.create(u), e$3;
	}
	return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o$2, "GeneratorFunction"), _regeneratorDefine(u), _regeneratorDefine(u, o$2, "Generator"), _regeneratorDefine(u, n$1, function() {
		return this;
	}), _regeneratorDefine(u, "toString", function() {
		return "[object Generator]";
	}), (_regenerator = function _regenerator$1() {
		return {
			w: i,
			m: f
		};
	})();
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/regeneratorAsyncIterator.js
function AsyncIterator(t$1, e$2) {
	function n$1(r$2, o$2, i, f) {
		try {
			var c = t$1[r$2](o$2), u = c.value;
			return u instanceof _OverloadYield ? e$2.resolve(u.v).then(function(t$2) {
				n$1("next", t$2, i, f);
			}, function(t$2) {
				n$1("throw", t$2, i, f);
			}) : e$2.resolve(u).then(function(t$2) {
				c.value = t$2, i(c);
			}, function(t$2) {
				return n$1("throw", t$2, i, f);
			});
		} catch (t$2) {
			f(t$2);
		}
	}
	var r$1;
	this.next || (_regeneratorDefine(AsyncIterator.prototype), _regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
		return this;
	})), _regeneratorDefine(this, "_invoke", function(t$2, o$2, i) {
		function f() {
			return new e$2(function(e$3, r$2) {
				n$1(t$2, i, e$3, r$2);
			});
		}
		return r$1 = r$1 ? r$1.then(f, f) : f();
	}, !0);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/regeneratorAsyncGen.js
function _regeneratorAsyncGen(r$1, e$2, t$1, o$2, n$1) {
	return new AsyncIterator(_regenerator().w(r$1, e$2, t$1, o$2), n$1 || Promise);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/regeneratorAsync.js
function _regeneratorAsync(n$1, e$2, r$1, t$1, o$2) {
	var a = _regeneratorAsyncGen(n$1, e$2, r$1, t$1, o$2);
	return a.next().then(function(n$2) {
		return n$2.done ? n$2.value : a.next();
	});
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/regeneratorKeys.js
function _regeneratorKeys(e$2) {
	var n$1 = Object(e$2), r$1 = [];
	for (var t$1 in n$1) r$1.unshift(t$1);
	return function e$3() {
		for (; r$1.length;) if ((t$1 = r$1.pop()) in n$1) return e$3.value = t$1, e$3.done = !1, e$3;
		return e$3.done = !0, e$3;
	};
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/regeneratorValues.js
function _regeneratorValues(e$2) {
	if (null != e$2) {
		var t$1 = e$2["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r$1 = 0;
		if (t$1) return t$1.call(e$2);
		if ("function" == typeof e$2.next) return e$2;
		if (!isNaN(e$2.length)) return { next: function next$1() {
			return e$2 && r$1 >= e$2.length && (e$2 = void 0), {
				value: e$2 && e$2[r$1++],
				done: !e$2
			};
		} };
	}
	throw new TypeError(_typeof(e$2) + " is not iterable");
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
function _regeneratorRuntime() {
	var r$1 = _regenerator(), e$2 = r$1.m(_regeneratorRuntime), t$1 = (Object.getPrototypeOf ? Object.getPrototypeOf(e$2) : e$2.__proto__).constructor;
	function n$1(r$2) {
		var e$3 = "function" == typeof r$2 && r$2.constructor;
		return !!e$3 && (e$3 === t$1 || "GeneratorFunction" === (e$3.displayName || e$3.name));
	}
	var o$2 = {
		"throw": 1,
		"return": 2,
		"break": 3,
		"continue": 3
	};
	function a(r$2) {
		var e$3, t$2;
		return function(n$2) {
			e$3 || (e$3 = {
				stop: function stop() {
					return t$2(n$2.a, 2);
				},
				"catch": function _catch() {
					return n$2.v;
				},
				abrupt: function abrupt(r$3, e$4) {
					return t$2(n$2.a, o$2[r$3], e$4);
				},
				delegateYield: function delegateYield(r$3, o$3, a$1) {
					return e$3.resultName = o$3, t$2(n$2.d, _regeneratorValues(r$3), a$1);
				},
				finish: function finish(r$3) {
					return t$2(n$2.f, r$3);
				}
			}, t$2 = function t$3(r$3, _t, o$3) {
				n$2.p = e$3.prev, n$2.n = e$3.next;
				try {
					return r$3(_t, o$3);
				} finally {
					e$3.next = n$2.n;
				}
			}), e$3.resultName && (e$3[e$3.resultName] = n$2.v, e$3.resultName = void 0), e$3.sent = n$2.v, e$3.next = n$2.n;
			try {
				return r$2.call(this, e$3);
			} finally {
				n$2.p = e$3.prev, n$2.n = e$3.next;
			}
		};
	}
	return (_regeneratorRuntime = function _regeneratorRuntime$1() {
		return {
			wrap: function wrap(e$3, t$2, n$2, o$3) {
				return r$1.w(a(e$3), t$2, n$2, o$3 && o$3.reverse());
			},
			isGeneratorFunction: n$1,
			mark: r$1.m,
			awrap: function awrap(r$2, e$3) {
				return new _OverloadYield(r$2, e$3);
			},
			AsyncIterator,
			async: function async(r$2, e$3, t$2, o$3, u) {
				return (n$1(e$3) ? _regeneratorAsyncGen : _regeneratorAsync)(a(r$2), e$3, t$2, o$3, u);
			},
			keys: _regeneratorKeys,
			values: _regeneratorValues
		};
	})();
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n$1, t$1, e$2, r$1, o$2, a, c) {
	try {
		var i = n$1[a](c), u = i.value;
	} catch (n$2) {
		e$2(n$2);
		return;
	}
	i.done ? t$1(u) : Promise.resolve(u).then(r$1, o$2);
}
function _asyncToGenerator(n$1) {
	return function() {
		var t$1 = this, e$2 = arguments;
		return new Promise(function(r$1, o$2) {
			var a = n$1.apply(t$1, e$2);
			function _next(n$2) {
				asyncGeneratorStep(a, r$1, o$2, _next, _throw, "next", n$2);
			}
			function _throw(n$2) {
				asyncGeneratorStep(a, r$1, o$2, _next, _throw, "throw", n$2);
			}
			_next(void 0);
		});
	};
}

//#endregion
//#region node_modules/rc-util/es/React/render.js
var import_react_dom$9 = /* @__PURE__ */ __toESM(require_react_dom());
var fullClone = _objectSpread2({}, import_react_dom$9);
var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
	if (Number((version || "").split(".")[0]) >= 18) createRoot = fullClone.createRoot;
} catch (e$2) {}
function toggleWarning(skip) {
	var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
	if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
}
var MARK = "__rc_react_root__";
function modernRender(node$1, container) {
	toggleWarning(true);
	var root = container[MARK] || createRoot(container);
	toggleWarning(false);
	root.render(node$1);
	container[MARK] = root;
}
function legacyRender(node$1, container) {
	reactRender === null || reactRender === void 0 || reactRender(node$1, container);
}
function render(node$1, container) {
	if (createRoot) {
		modernRender(node$1, container);
		return;
	}
	legacyRender(node$1, container);
}
function modernUnmount(_x) {
	return _modernUnmount.apply(this, arguments);
}
function _modernUnmount() {
	_modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
		return _regeneratorRuntime().wrap(function _callee$(_context) {
			while (1) switch (_context.prev = _context.next) {
				case 0: return _context.abrupt("return", Promise.resolve().then(function() {
					var _container$MARK;
					(_container$MARK = container[MARK]) === null || _container$MARK === void 0 || _container$MARK.unmount();
					delete container[MARK];
				}));
				case 1:
				case "end": return _context.stop();
			}
		}, _callee);
	}));
	return _modernUnmount.apply(this, arguments);
}
function legacyUnmount(container) {
	unmountComponentAtNode(container);
}
function unmount(_x2) {
	return _unmount.apply(this, arguments);
}
function _unmount() {
	_unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
		return _regeneratorRuntime().wrap(function _callee2$(_context2) {
			while (1) switch (_context2.prev = _context2.next) {
				case 0:
					if (!(createRoot !== void 0)) {
						_context2.next = 2;
						break;
					}
					return _context2.abrupt("return", modernUnmount(container));
				case 2: legacyUnmount(container);
				case 3:
				case "end": return _context2.stop();
			}
		}, _callee2);
	}));
	return _unmount.apply(this, arguments);
}

//#endregion
//#region node_modules/antd/es/config-provider/UnstableContext.js
var import_react_dom$8 = /* @__PURE__ */ __toESM(require_react_dom());
var defaultReactRender = (node$1, container) => {
	{
		const majorVersion = parseInt(import_react.version.split(".")[0], 10);
		warning_default$1(majorVersion < 19 || Object.keys(import_react_dom$8).includes("createRoot"), "compatible", "antd v5 support React is 16 ~ 18. see https://u.ant.design/v5-for-19 for compatible.");
	}
	render(node$1, container);
	return () => {
		return unmount(container);
	};
};
var unstableRender = defaultReactRender;
/**
* @deprecated Set React render function for compatible usage.
* This is internal usage only compatible with React 19.
* And will be removed in next major version.
*/
function unstableSetRender(render$1) {
	if (render$1) unstableRender = render$1;
	return unstableRender;
}

//#endregion
//#region node_modules/antd/es/_util/motion.js
var getCollapsedHeight = () => ({
	height: 0,
	opacity: 0
});
var getRealHeight = (node$1) => {
	const { scrollHeight } = node$1;
	return {
		height: scrollHeight,
		opacity: 1
	};
};
var getCurrentHeight = (node$1) => ({ height: node$1 ? node$1.offsetHeight : 0 });
var skipOpacityTransition = (_, event) => (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
var initCollapseMotion = (rootCls = defaultPrefixCls) => ({
	motionName: `${rootCls}-motion-collapse`,
	onAppearStart: getCollapsedHeight,
	onEnterStart: getCollapsedHeight,
	onAppearActive: getRealHeight,
	onEnterActive: getRealHeight,
	onLeaveStart: getCurrentHeight,
	onLeaveActive: getCollapsedHeight,
	onAppearEnd: skipOpacityTransition,
	onEnterEnd: skipOpacityTransition,
	onLeaveEnd: skipOpacityTransition,
	motionDeadline: 500
});
var getTransitionName = (rootPrefixCls, motion$1, transitionName) => {
	if (transitionName !== void 0) return transitionName;
	return `${rootPrefixCls}-${motion$1}`;
};
var motion_default = initCollapseMotion;

//#endregion
//#region node_modules/rc-util/es/omit.js
function omit(obj, fields) {
	var clone = Object.assign({}, obj);
	if (Array.isArray(fields)) fields.forEach(function(key) {
		delete clone[key];
	});
	return clone;
}

//#endregion
//#region node_modules/rc-util/es/Dom/isVisible.js
var isVisible_default = (function(element) {
	if (!element) return false;
	if (element instanceof Element) {
		if (element.offsetParent) return true;
		if (element.getBBox) {
			var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
			if (width || height) return true;
		}
		if (element.getBoundingClientRect) {
			var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
			if (_width || _height) return true;
		}
	}
	return false;
});

//#endregion
//#region node_modules/antd/es/_util/wave/style.js
var genWaveStyle = (token$1) => {
	const { componentCls, colorPrimary } = token$1;
	return { [componentCls]: {
		position: "absolute",
		background: "transparent",
		pointerEvents: "none",
		boxSizing: "border-box",
		color: `var(--wave-color, ${colorPrimary})`,
		boxShadow: `0 0 0 0 currentcolor`,
		opacity: .2,
		"&.wave-motion-appear": {
			transition: [`box-shadow 0.4s ${token$1.motionEaseOutCirc}`, `opacity 2s ${token$1.motionEaseOutCirc}`].join(","),
			"&-active": {
				boxShadow: `0 0 0 6px currentcolor`,
				opacity: 0
			},
			"&.wave-quick": { transition: [`box-shadow ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`, `opacity ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`].join(",") }
		}
	} };
};
var style_default$59 = genComponentStyleHook("Wave", genWaveStyle);

//#endregion
//#region node_modules/antd/es/_util/wave/interface.js
const TARGET_CLS = `${defaultPrefixCls}-wave-target`;

//#endregion
//#region node_modules/antd/es/_util/wave/util.js
function isValidWaveColor(color) {
	return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color) && color !== "transparent" && color !== "canvastext";
}
function getTargetWaveColor(node$1) {
	var _a;
	const { borderTopColor, borderColor, backgroundColor } = getComputedStyle(node$1);
	return (_a = [
		borderTopColor,
		borderColor,
		backgroundColor
	].find(isValidWaveColor)) !== null && _a !== void 0 ? _a : null;
}

//#endregion
//#region node_modules/antd/es/_util/wave/WaveEffect.js
var import_classnames$269 = /* @__PURE__ */ __toESM(require_classnames());
function validateNum(value) {
	return Number.isNaN(value) ? 0 : value;
}
var WaveEffect = (props) => {
	const { className, target, component, registerUnmount } = props;
	const divRef = import_react.useRef(null);
	const unmountRef = import_react.useRef(null);
	import_react.useEffect(() => {
		unmountRef.current = registerUnmount();
	}, []);
	const [color, setWaveColor] = import_react.useState(null);
	const [borderRadius, setBorderRadius] = import_react.useState([]);
	const [left, setLeft] = import_react.useState(0);
	const [top, setTop] = import_react.useState(0);
	const [width, setWidth] = import_react.useState(0);
	const [height, setHeight] = import_react.useState(0);
	const [enabled, setEnabled] = import_react.useState(false);
	const waveStyle = {
		left,
		top,
		width,
		height,
		borderRadius: borderRadius.map((radius$1) => `${radius$1}px`).join(" ")
	};
	if (color) waveStyle["--wave-color"] = color;
	function syncPos() {
		const nodeStyle = getComputedStyle(target);
		setWaveColor(getTargetWaveColor(target));
		const isStatic = nodeStyle.position === "static";
		const { borderLeftWidth, borderTopWidth } = nodeStyle;
		setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
		setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
		setWidth(target.offsetWidth);
		setHeight(target.offsetHeight);
		const { borderTopLeftRadius, borderTopRightRadius, borderBottomLeftRadius, borderBottomRightRadius } = nodeStyle;
		setBorderRadius([
			borderTopLeftRadius,
			borderTopRightRadius,
			borderBottomRightRadius,
			borderBottomLeftRadius
		].map((radius$1) => validateNum(parseFloat(radius$1))));
	}
	import_react.useEffect(() => {
		if (target) {
			const id = raf_default(() => {
				syncPos();
				setEnabled(true);
			});
			let resizeObserver$1;
			if (typeof ResizeObserver !== "undefined") {
				resizeObserver$1 = new ResizeObserver(syncPos);
				resizeObserver$1.observe(target);
			}
			return () => {
				raf_default.cancel(id);
				resizeObserver$1 === null || resizeObserver$1 === void 0 || resizeObserver$1.disconnect();
			};
		}
	}, []);
	if (!enabled) return null;
	const isSmallComponent = (component === "Checkbox" || component === "Radio") && (target === null || target === void 0 ? void 0 : target.classList.contains(TARGET_CLS));
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible: true,
		motionAppear: true,
		motionName: "wave-motion",
		motionDeadline: 5e3,
		onAppearEnd: (_, event) => {
			var _a, _b;
			if (event.deadline || event.propertyName === "opacity") {
				const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
				(_b = unmountRef.current) === null || _b === void 0 || _b.call(unmountRef).then(() => {
					holder === null || holder === void 0 || holder.remove();
				});
			}
			return false;
		}
	}, ({ className: motionClassName }, ref) => /* @__PURE__ */ import_react.createElement("div", {
		ref: composeRef(divRef, ref),
		className: (0, import_classnames$269.default)(className, motionClassName, { "wave-quick": isSmallComponent }),
		style: waveStyle
	}));
};
var showWaveEffect = (target, info) => {
	var _a;
	const { component } = info;
	if (component === "Checkbox" && !((_a = target.querySelector("input")) === null || _a === void 0 ? void 0 : _a.checked)) return;
	const holder = document.createElement("div");
	holder.style.position = "absolute";
	holder.style.left = "0px";
	holder.style.top = "0px";
	target === null || target === void 0 || target.insertBefore(holder, target === null || target === void 0 ? void 0 : target.firstChild);
	const reactRender$1 = unstableSetRender();
	let unmountCallback = null;
	function registerUnmount() {
		return unmountCallback;
	}
	unmountCallback = reactRender$1(/* @__PURE__ */ import_react.createElement(WaveEffect, Object.assign({}, info, {
		target,
		registerUnmount
	})), holder);
};
var WaveEffect_default = showWaveEffect;

//#endregion
//#region node_modules/antd/es/_util/wave/useWave.js
var useWave = (nodeRef, className, component) => {
	const { wave } = import_react.useContext(ConfigContext);
	const [, token$1, hashId] = useToken();
	const showWave = useEvent((event) => {
		const node$1 = nodeRef.current;
		if ((wave === null || wave === void 0 ? void 0 : wave.disabled) || !node$1) return;
		const targetNode = node$1.querySelector(`.${TARGET_CLS}`) || node$1;
		const { showEffect } = wave || {};
		(showEffect || WaveEffect_default)(targetNode, {
			className,
			token: token$1,
			component,
			event,
			hashId
		});
	});
	const rafId = import_react.useRef(null);
	const showDebounceWave = (event) => {
		raf_default.cancel(rafId.current);
		rafId.current = raf_default(() => {
			showWave(event);
		});
	};
	return showDebounceWave;
};
var useWave_default = useWave;

//#endregion
//#region node_modules/antd/es/_util/wave/index.js
var import_classnames$268 = /* @__PURE__ */ __toESM(require_classnames());
var Wave = (props) => {
	const { children, disabled, component } = props;
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const containerRef = (0, import_react.useRef)(null);
	const prefixCls = getPrefixCls("wave");
	const [, hashId] = style_default$59(prefixCls);
	const showWave = useWave_default(containerRef, (0, import_classnames$268.default)(prefixCls, hashId), component);
	import_react.useEffect(() => {
		const node$1 = containerRef.current;
		if (!node$1 || node$1.nodeType !== window.Node.ELEMENT_NODE || disabled) return;
		const onClick = (e$2) => {
			if (!isVisible_default(e$2.target) || !node$1.getAttribute || node$1.getAttribute("disabled") || node$1.disabled || node$1.className.includes("disabled") && !node$1.className.includes("disabled:") || node$1.getAttribute("aria-disabled") === "true" || node$1.className.includes("-leave")) return;
			showWave(e$2);
		};
		node$1.addEventListener("click", onClick, true);
		return () => {
			node$1.removeEventListener("click", onClick, true);
		};
	}, [disabled]);
	if (!/* @__PURE__ */ import_react.isValidElement(children)) return children !== null && children !== void 0 ? children : null;
	const ref = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
	return cloneElement(children, { ref });
};
Wave.displayName = "Wave";
var wave_default = Wave;

//#endregion
//#region node_modules/antd/es/config-provider/hooks/useSize.js
var useSize = (customSize) => {
	const size = import_react.useContext(SizeContext_default);
	return import_react.useMemo(() => {
		if (!customSize) return size;
		if (typeof customSize === "string") return customSize !== null && customSize !== void 0 ? customSize : size;
		if (typeof customSize === "function") return customSize(size);
		return size;
	}, [customSize, size]);
};
var useSize_default = useSize;

//#endregion
//#region node_modules/antd/es/space/style/compact.js
var genSpaceCompactStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		"&-block": {
			display: "flex",
			width: "100%"
		},
		"&-vertical": { flexDirection: "column" }
	} };
};
var compact_default$2 = genSpaceCompactStyle;

//#endregion
//#region node_modules/antd/es/space/style/index.js
var genSpaceStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	return { [componentCls]: {
		display: "inline-flex",
		"&-rtl": { direction: "rtl" },
		"&-vertical": { flexDirection: "column" },
		"&-align": {
			flexDirection: "column",
			"&-center": { alignItems: "center" },
			"&-start": { alignItems: "flex-start" },
			"&-end": { alignItems: "flex-end" },
			"&-baseline": { alignItems: "baseline" }
		},
		[`${componentCls}-item:empty`]: { display: "none" },
		[`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: { display: "block" }
	} };
};
var genSpaceGapStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		"&-gap-row-small": { rowGap: token$1.spaceGapSmallSize },
		"&-gap-row-middle": { rowGap: token$1.spaceGapMiddleSize },
		"&-gap-row-large": { rowGap: token$1.spaceGapLargeSize },
		"&-gap-col-small": { columnGap: token$1.spaceGapSmallSize },
		"&-gap-col-middle": { columnGap: token$1.spaceGapMiddleSize },
		"&-gap-col-large": { columnGap: token$1.spaceGapLargeSize }
	} };
};
var style_default$29 = genStyleHooks("Space", (token$1) => {
	const spaceToken = merge(token$1, {
		spaceGapSmallSize: token$1.paddingXS,
		spaceGapMiddleSize: token$1.padding,
		spaceGapLargeSize: token$1.paddingLG
	});
	return [
		genSpaceStyle(spaceToken),
		genSpaceGapStyle(spaceToken),
		compact_default$2(spaceToken)
	];
}, () => ({}), { resetStyle: false });

//#endregion
//#region node_modules/antd/es/space/Compact.js
var import_classnames$267 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$107 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const SpaceCompactItemContext = /* @__PURE__ */ import_react.createContext(null);
const useCompactItemContext = (prefixCls, direction) => {
	const compactItemContext = import_react.useContext(SpaceCompactItemContext);
	const compactItemClassnames = import_react.useMemo(() => {
		if (!compactItemContext) return "";
		const { compactDirection, isFirstItem, isLastItem } = compactItemContext;
		const separator = compactDirection === "vertical" ? "-vertical-" : "-";
		return (0, import_classnames$267.default)(`${prefixCls}-compact${separator}item`, {
			[`${prefixCls}-compact${separator}first-item`]: isFirstItem,
			[`${prefixCls}-compact${separator}last-item`]: isLastItem,
			[`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
		});
	}, [
		prefixCls,
		direction,
		compactItemContext
	]);
	return {
		compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
		compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
		compactItemClassnames
	};
};
const NoCompactStyle = (props) => {
	const { children } = props;
	return /* @__PURE__ */ import_react.createElement(SpaceCompactItemContext.Provider, { value: null }, children);
};
var CompactItem = (props) => {
	const { children } = props, others = __rest$107(props, ["children"]);
	return /* @__PURE__ */ import_react.createElement(SpaceCompactItemContext.Provider, { value: import_react.useMemo(() => others, [others]) }, children);
};
var Compact = (props) => {
	const { getPrefixCls, direction: directionConfig } = import_react.useContext(ConfigContext);
	const { size, direction, block, prefixCls: customizePrefixCls, className, rootClassName, children } = props, restProps = __rest$107(props, [
		"size",
		"direction",
		"block",
		"prefixCls",
		"className",
		"rootClassName",
		"children"
	]);
	const mergedSize = useSize_default((ctx) => size !== null && size !== void 0 ? size : ctx);
	const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
	const [wrapCSSVar, hashId] = style_default$29(prefixCls);
	const clx = (0, import_classnames$267.default)(prefixCls, hashId, {
		[`${prefixCls}-rtl`]: directionConfig === "rtl",
		[`${prefixCls}-block`]: block,
		[`${prefixCls}-vertical`]: direction === "vertical"
	}, className, rootClassName);
	const compactItemContext = import_react.useContext(SpaceCompactItemContext);
	const childNodes = toArray(children);
	const nodes = import_react.useMemo(() => childNodes.map((child, i) => {
		const key = (child === null || child === void 0 ? void 0 : child.key) || `${prefixCls}-item-${i}`;
		return /* @__PURE__ */ import_react.createElement(CompactItem, {
			key,
			compactSize: mergedSize,
			compactDirection: direction,
			isFirstItem: i === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
			isLastItem: i === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
		}, child);
	}), [
		size,
		childNodes,
		compactItemContext
	]);
	if (childNodes.length === 0) return null;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({ className: clx }, restProps), nodes));
};
var Compact_default = Compact;

//#endregion
//#region node_modules/antd/es/button/button-group.js
var import_classnames$266 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$106 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const GroupSizeContext = /* @__PURE__ */ import_react.createContext(void 0);
var ButtonGroup = (props) => {
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, size, className } = props, others = __rest$106(props, [
		"prefixCls",
		"size",
		"className"
	]);
	const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
	const [, , hashId] = useToken();
	const sizeCls = import_react.useMemo(() => {
		switch (size) {
			case "large": return "lg";
			case "small": return "sm";
			default: return "";
		}
	}, [size]);
	{
		const warning$4 = devUseWarning("Button.Group");
		warning$4.deprecated(false, "Button.Group", "Space.Compact");
		warning$4(!size || [
			"large",
			"small",
			"middle"
		].includes(size), "usage", "Invalid prop `size`.");
	}
	const classes = (0, import_classnames$266.default)(prefixCls, {
		[`${prefixCls}-${sizeCls}`]: sizeCls,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, hashId);
	return /* @__PURE__ */ import_react.createElement(GroupSizeContext.Provider, { value: size }, /* @__PURE__ */ import_react.createElement("div", Object.assign({}, others, { className: classes })));
};
var button_group_default = ButtonGroup;

//#endregion
//#region node_modules/antd/es/button/buttonHelpers.js
var rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function convertLegacyProps(type$2) {
	if (type$2 === "danger") return { danger: true };
	return { type: type$2 };
}
function isString$1(str) {
	return typeof str === "string";
}
function isUnBorderedButtonVariant(type$2) {
	return type$2 === "text" || type$2 === "link";
}
function splitCNCharsBySpace(child, needInserted) {
	if (child === null || child === void 0) return;
	const SPACE = needInserted ? " " : "";
	if (typeof child !== "string" && typeof child !== "number" && isString$1(child.type) && isTwoCNChar(child.props.children)) return cloneElement(child, { children: child.props.children.split("").join(SPACE) });
	if (isString$1(child)) return isTwoCNChar(child) ? /* @__PURE__ */ import_react.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ import_react.createElement("span", null, child);
	if (isFragment(child)) return /* @__PURE__ */ import_react.createElement("span", null, child);
	return child;
}
function spaceChildren(children, needInserted) {
	let isPrevChildPure = false;
	const childList = [];
	import_react.Children.forEach(children, (child) => {
		const type$2 = typeof child;
		const isCurrentChildPure = type$2 === "string" || type$2 === "number";
		if (isPrevChildPure && isCurrentChildPure) {
			const lastIndex = childList.length - 1;
			childList[lastIndex] = `${childList[lastIndex]}${child}`;
		} else childList.push(child);
		isPrevChildPure = isCurrentChildPure;
	});
	return import_react.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
}
const _ButtonColorTypes = [
	"default",
	"primary",
	"danger"
].concat(_toConsumableArray(PresetColors));

//#endregion
//#region node_modules/antd/es/button/IconWrapper.js
var import_classnames$265 = /* @__PURE__ */ __toESM(require_classnames());
var IconWrapper = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { className, style: style$1, children, prefixCls } = props;
	const iconWrapperCls = (0, import_classnames$265.default)(`${prefixCls}-icon`, className);
	return /* @__PURE__ */ import_react.createElement("span", {
		ref,
		className: iconWrapperCls,
		style: style$1
	}, children);
});
var IconWrapper_default = IconWrapper;

//#endregion
//#region node_modules/antd/es/button/DefaultLoadingIcon.js
var import_classnames$264 = /* @__PURE__ */ __toESM(require_classnames());
var InnerLoadingIcon = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls, className, style: style$1, iconClassName } = props;
	const mergedIconCls = (0, import_classnames$264.default)(`${prefixCls}-loading-icon`, className);
	return /* @__PURE__ */ import_react.createElement(IconWrapper_default, {
		prefixCls,
		className: mergedIconCls,
		style: style$1,
		ref
	}, /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { className: iconClassName }));
});
var getCollapsedWidth = () => ({
	width: 0,
	opacity: 0,
	transform: "scale(0)"
});
var getRealWidth = (node$1) => ({
	width: node$1.scrollWidth,
	opacity: 1,
	transform: "scale(1)"
});
var DefaultLoadingIcon = (props) => {
	const { prefixCls, loading, existIcon, className, style: style$1, mount } = props;
	const visible = !!loading;
	if (existIcon) return /* @__PURE__ */ import_react.createElement(InnerLoadingIcon, {
		prefixCls,
		className,
		style: style$1
	});
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible,
		motionName: `${prefixCls}-loading-icon-motion`,
		motionAppear: !mount,
		motionEnter: !mount,
		motionLeave: !mount,
		removeOnLeave: true,
		onAppearStart: getCollapsedWidth,
		onAppearActive: getRealWidth,
		onEnterStart: getCollapsedWidth,
		onEnterActive: getRealWidth,
		onLeaveStart: getRealWidth,
		onLeaveActive: getCollapsedWidth
	}, ({ className: motionCls, style: motionStyle }, ref) => {
		const mergedStyle = Object.assign(Object.assign({}, style$1), motionStyle);
		return /* @__PURE__ */ import_react.createElement(InnerLoadingIcon, {
			prefixCls,
			className: (0, import_classnames$264.default)(className, motionCls),
			style: mergedStyle,
			ref
		});
	});
};
var DefaultLoadingIcon_default = DefaultLoadingIcon;

//#endregion
//#region node_modules/antd/es/button/style/group.js
var genButtonBorderStyle = (buttonTypeCls, borderColor) => ({ [`> span, > ${buttonTypeCls}`]: {
	"&:not(:last-child)": { [`&, & > ${buttonTypeCls}`]: { "&:not(:disabled)": { borderInlineEndColor: borderColor } } },
	"&:not(:first-child)": { [`&, & > ${buttonTypeCls}`]: { "&:not(:disabled)": { borderInlineStartColor: borderColor } } }
} });
var genGroupStyle$2 = (token$1) => {
	const { componentCls, fontSize, lineWidth, groupBorderColor, colorErrorHover } = token$1;
	return { [`${componentCls}-group`]: [
		{
			position: "relative",
			display: "inline-flex",
			[`> span, > ${componentCls}`]: {
				"&:not(:last-child)": { [`&, & > ${componentCls}`]: {
					borderStartEndRadius: 0,
					borderEndEndRadius: 0
				} },
				"&:not(:first-child)": {
					marginInlineStart: token$1.calc(lineWidth).mul(-1).equal(),
					[`&, & > ${componentCls}`]: {
						borderStartStartRadius: 0,
						borderEndStartRadius: 0
					}
				}
			},
			[componentCls]: {
				position: "relative",
				zIndex: 1,
				"&:hover, &:focus, &:active": { zIndex: 2 },
				"&[disabled]": { zIndex: 0 }
			},
			[`${componentCls}-icon-only`]: { fontSize }
		},
		genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
		genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
	] };
};
var group_default$1 = genGroupStyle$2;

//#endregion
//#region node_modules/@rc-component/color-picker/node_modules/@ant-design/fast-color/es/FastColor.js
var round = Math.round;
/**
* Support format, alpha unit will check the % mark:
* - rgba(102, 204, 255, .5)      -> [102, 204, 255, 0.5]
* - rgb(102 204 255 / .5)        -> [102, 204, 255, 0.5]
* - rgb(100%, 50%, 0% / 50%)     -> [255, 128, 0, 0.5]
* - hsl(270, 60, 40, .5)         -> [270, 60, 40, 0.5]
* - hsl(270deg 60% 40% / 50%)   -> [270, 60, 40, 0.5]
*
* When `base` is provided, the percentage value will be divided by `base`.
*/
function splitColorStr(str, parseNum) {
	const match$1 = str.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [];
	const numList = match$1.map((item) => parseFloat(item));
	for (let i = 0; i < 3; i += 1) numList[i] = parseNum(numList[i] || 0, match$1[i] || "", i);
	if (match$1[3]) numList[3] = match$1[3].includes("%") ? numList[3] / 100 : numList[3];
	else numList[3] = 1;
	return numList;
}
var parseHSVorHSL = (num, _, index$2) => index$2 === 0 ? num : num / 100;
/** round and limit number to integer between 0-255 */
function limitRange(value, max) {
	const mergedMax = max || 255;
	if (value > mergedMax) return mergedMax;
	if (value < 0) return 0;
	return value;
}
var FastColor$1 = class FastColor$1 {
	constructor(input) {
		/**
		* All FastColor objects are valid. So isValid is always true. This property is kept to be compatible with TinyColor.
		*/
		_defineProperty(this, "isValid", true);
		/**
		* Red, R in RGB
		*/
		_defineProperty(this, "r", 0);
		/**
		* Green, G in RGB
		*/
		_defineProperty(this, "g", 0);
		/**
		* Blue, B in RGB
		*/
		_defineProperty(this, "b", 0);
		/**
		* Alpha/Opacity, A in RGBA/HSLA
		*/
		_defineProperty(this, "a", 1);
		_defineProperty(this, "_h", void 0);
		_defineProperty(this, "_s", void 0);
		_defineProperty(this, "_l", void 0);
		_defineProperty(this, "_v", void 0);
		_defineProperty(this, "_max", void 0);
		_defineProperty(this, "_min", void 0);
		_defineProperty(this, "_brightness", void 0);
		/**
		* Always check 3 char in the object to determine the format.
		* We not use function in check to save bundle size.
		* e.g. 'rgb' -> { r: 0, g: 0, b: 0 }.
		*/
		function matchFormat(str) {
			return str[0] in input && str[1] in input && str[2] in input;
		}
		if (!input) {} else if (typeof input === "string") {
			const trimStr = input.trim();
			function matchPrefix(prefix) {
				return trimStr.startsWith(prefix);
			}
			if (/^#?[A-F\d]{3,8}$/i.test(trimStr)) this.fromHexString(trimStr);
			else if (matchPrefix("rgb")) this.fromRgbString(trimStr);
			else if (matchPrefix("hsl")) this.fromHslString(trimStr);
			else if (matchPrefix("hsv") || matchPrefix("hsb")) this.fromHsvString(trimStr);
		} else if (input instanceof FastColor$1) {
			this.r = input.r;
			this.g = input.g;
			this.b = input.b;
			this.a = input.a;
			this._h = input._h;
			this._s = input._s;
			this._l = input._l;
			this._v = input._v;
		} else if (matchFormat("rgb")) {
			this.r = limitRange(input.r);
			this.g = limitRange(input.g);
			this.b = limitRange(input.b);
			this.a = typeof input.a === "number" ? limitRange(input.a, 1) : 1;
		} else if (matchFormat("hsl")) this.fromHsl(input);
		else if (matchFormat("hsv")) this.fromHsv(input);
		else throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(input));
	}
	setR(value) {
		return this._sc("r", value);
	}
	setG(value) {
		return this._sc("g", value);
	}
	setB(value) {
		return this._sc("b", value);
	}
	setA(value) {
		return this._sc("a", value, 1);
	}
	setHue(value) {
		const hsv = this.toHsv();
		hsv.h = value;
		return this._c(hsv);
	}
	/**
	* Returns the perceived luminance of a color, from 0-1.
	* @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
	*/
	getLuminance() {
		function adjustGamma(raw) {
			const val = raw / 255;
			return val <= .03928 ? val / 12.92 : Math.pow((val + .055) / 1.055, 2.4);
		}
		const R = adjustGamma(this.r);
		const G = adjustGamma(this.g);
		const B = adjustGamma(this.b);
		return .2126 * R + .7152 * G + .0722 * B;
	}
	getHue() {
		if (typeof this._h === "undefined") {
			const delta = this.getMax() - this.getMin();
			if (delta === 0) this._h = 0;
			else this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
		}
		return this._h;
	}
	getSaturation() {
		if (typeof this._s === "undefined") {
			const delta = this.getMax() - this.getMin();
			if (delta === 0) this._s = 0;
			else this._s = delta / this.getMax();
		}
		return this._s;
	}
	getLightness() {
		if (typeof this._l === "undefined") this._l = (this.getMax() + this.getMin()) / 510;
		return this._l;
	}
	getValue() {
		if (typeof this._v === "undefined") this._v = this.getMax() / 255;
		return this._v;
	}
	/**
	* Returns the perceived brightness of the color, from 0-255.
	* Note: this is not the b of HSB
	* @see http://www.w3.org/TR/AERT#color-contrast
	*/
	getBrightness() {
		if (typeof this._brightness === "undefined") this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3;
		return this._brightness;
	}
	darken(amount = 10) {
		const h = this.getHue();
		const s = this.getSaturation();
		let l$1 = this.getLightness() - amount / 100;
		if (l$1 < 0) l$1 = 0;
		return this._c({
			h,
			s,
			l: l$1,
			a: this.a
		});
	}
	lighten(amount = 10) {
		const h = this.getHue();
		const s = this.getSaturation();
		let l$1 = this.getLightness() + amount / 100;
		if (l$1 > 1) l$1 = 1;
		return this._c({
			h,
			s,
			l: l$1,
			a: this.a
		});
	}
	/**
	* Mix the current color a given amount with another color, from 0 to 100.
	* 0 means no mixing (return current color).
	*/
	mix(input, amount = 50) {
		const color = this._c(input);
		const p = amount / 100;
		const calc = (key) => (color[key] - this[key]) * p + this[key];
		const rgba = {
			r: round(calc("r")),
			g: round(calc("g")),
			b: round(calc("b")),
			a: round(calc("a") * 100) / 100
		};
		return this._c(rgba);
	}
	/**
	* Mix the color with pure white, from 0 to 100.
	* Providing 0 will do nothing, providing 100 will always return white.
	*/
	tint(amount = 10) {
		return this.mix({
			r: 255,
			g: 255,
			b: 255,
			a: 1
		}, amount);
	}
	/**
	* Mix the color with pure black, from 0 to 100.
	* Providing 0 will do nothing, providing 100 will always return black.
	*/
	shade(amount = 10) {
		return this.mix({
			r: 0,
			g: 0,
			b: 0,
			a: 1
		}, amount);
	}
	onBackground(background) {
		const bg = this._c(background);
		const alpha = this.a + bg.a * (1 - this.a);
		const calc = (key) => {
			return round((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha);
		};
		return this._c({
			r: calc("r"),
			g: calc("g"),
			b: calc("b"),
			a: alpha
		});
	}
	isDark() {
		return this.getBrightness() < 128;
	}
	isLight() {
		return this.getBrightness() >= 128;
	}
	equals(other) {
		return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
	}
	clone() {
		return this._c(this);
	}
	toHexString() {
		let hex = "#";
		const rHex = (this.r || 0).toString(16);
		hex += rHex.length === 2 ? rHex : "0" + rHex;
		const gHex = (this.g || 0).toString(16);
		hex += gHex.length === 2 ? gHex : "0" + gHex;
		const bHex = (this.b || 0).toString(16);
		hex += bHex.length === 2 ? bHex : "0" + bHex;
		if (typeof this.a === "number" && this.a >= 0 && this.a < 1) {
			const aHex = round(this.a * 255).toString(16);
			hex += aHex.length === 2 ? aHex : "0" + aHex;
		}
		return hex;
	}
	/** CSS support color pattern */
	toHsl() {
		return {
			h: this.getHue(),
			s: this.getSaturation(),
			l: this.getLightness(),
			a: this.a
		};
	}
	/** CSS support color pattern */
	toHslString() {
		const h = this.getHue();
		const s = round(this.getSaturation() * 100);
		const l$1 = round(this.getLightness() * 100);
		return this.a !== 1 ? `hsla(${h},${s}%,${l$1}%,${this.a})` : `hsl(${h},${s}%,${l$1}%)`;
	}
	/** Same as toHsb */
	toHsv() {
		return {
			h: this.getHue(),
			s: this.getSaturation(),
			v: this.getValue(),
			a: this.a
		};
	}
	toRgb() {
		return {
			r: this.r,
			g: this.g,
			b: this.b,
			a: this.a
		};
	}
	toRgbString() {
		return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
	}
	toString() {
		return this.toRgbString();
	}
	/** Return a new FastColor object with one channel changed */
	_sc(rgb, value, max) {
		const clone = this.clone();
		clone[rgb] = limitRange(value, max);
		return clone;
	}
	_c(input) {
		return new this.constructor(input);
	}
	getMax() {
		if (typeof this._max === "undefined") this._max = Math.max(this.r, this.g, this.b);
		return this._max;
	}
	getMin() {
		if (typeof this._min === "undefined") this._min = Math.min(this.r, this.g, this.b);
		return this._min;
	}
	fromHexString(trimStr) {
		const withoutPrefix = trimStr.replace("#", "");
		function connectNum(index1, index2) {
			return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);
		}
		if (withoutPrefix.length < 6) {
			this.r = connectNum(0);
			this.g = connectNum(1);
			this.b = connectNum(2);
			this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;
		} else {
			this.r = connectNum(0, 1);
			this.g = connectNum(2, 3);
			this.b = connectNum(4, 5);
			this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;
		}
	}
	fromHsl({ h, s, l: l$1, a }) {
		this._h = h % 360;
		this._s = s;
		this._l = l$1;
		this.a = typeof a === "number" ? a : 1;
		if (s <= 0) {
			const rgb = round(l$1 * 255);
			this.r = rgb;
			this.g = rgb;
			this.b = rgb;
		}
		let r$1 = 0, g = 0, b = 0;
		const huePrime = h / 60;
		const chroma = (1 - Math.abs(2 * l$1 - 1)) * s;
		const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
		if (huePrime >= 0 && huePrime < 1) {
			r$1 = chroma;
			g = secondComponent;
		} else if (huePrime >= 1 && huePrime < 2) {
			r$1 = secondComponent;
			g = chroma;
		} else if (huePrime >= 2 && huePrime < 3) {
			g = chroma;
			b = secondComponent;
		} else if (huePrime >= 3 && huePrime < 4) {
			g = secondComponent;
			b = chroma;
		} else if (huePrime >= 4 && huePrime < 5) {
			r$1 = secondComponent;
			b = chroma;
		} else if (huePrime >= 5 && huePrime < 6) {
			r$1 = chroma;
			b = secondComponent;
		}
		const lightnessModification = l$1 - chroma / 2;
		this.r = round((r$1 + lightnessModification) * 255);
		this.g = round((g + lightnessModification) * 255);
		this.b = round((b + lightnessModification) * 255);
	}
	fromHsv({ h, s, v, a }) {
		this._h = h % 360;
		this._s = s;
		this._v = v;
		this.a = typeof a === "number" ? a : 1;
		const vv = round(v * 255);
		this.r = vv;
		this.g = vv;
		this.b = vv;
		if (s <= 0) return;
		const hh = h / 60;
		const i = Math.floor(hh);
		const ff = hh - i;
		const p = round(v * (1 - s) * 255);
		const q = round(v * (1 - s * ff) * 255);
		const t$1 = round(v * (1 - s * (1 - ff)) * 255);
		switch (i) {
			case 0:
				this.g = t$1;
				this.b = p;
				break;
			case 1:
				this.r = q;
				this.b = p;
				break;
			case 2:
				this.r = p;
				this.b = t$1;
				break;
			case 3:
				this.r = p;
				this.g = q;
				break;
			case 4:
				this.r = t$1;
				this.g = p;
				break;
			case 5:
			default:
				this.g = p;
				this.b = q;
				break;
		}
	}
	fromHsvString(trimStr) {
		const cells = splitColorStr(trimStr, parseHSVorHSL);
		this.fromHsv({
			h: cells[0],
			s: cells[1],
			v: cells[2],
			a: cells[3]
		});
	}
	fromHslString(trimStr) {
		const cells = splitColorStr(trimStr, parseHSVorHSL);
		this.fromHsl({
			h: cells[0],
			s: cells[1],
			l: cells[2],
			a: cells[3]
		});
	}
	fromRgbString(trimStr) {
		const cells = splitColorStr(trimStr, (num, txt) => txt.includes("%") ? round(num / 100 * 255) : num);
		this.r = cells[0];
		this.g = cells[1];
		this.b = cells[2];
		this.a = cells[3];
	}
};

//#endregion
//#region node_modules/@rc-component/color-picker/es/color.js
var _excluded$71 = ["b"], _excluded2$13 = ["v"];
var getRoundNumber$1 = function getRoundNumber$2(value) {
	return Math.round(Number(value || 0));
};
var convertHsb2Hsv = function convertHsb2Hsv$1(color) {
	if (color instanceof FastColor$1) return color;
	if (color && _typeof(color) === "object" && "h" in color && "b" in color) {
		var _ref = color, b = _ref.b, resets = _objectWithoutProperties(_ref, _excluded$71);
		return _objectSpread2(_objectSpread2({}, resets), {}, { v: b });
	}
	if (typeof color === "string" && /hsb/.test(color)) return color.replace(/hsb/, "hsv");
	return color;
};
var Color = /* @__PURE__ */ function(_FastColor) {
	_inherits(Color$1, _FastColor);
	var _super = _createSuper(Color$1);
	function Color$1(color) {
		_classCallCheck(this, Color$1);
		return _super.call(this, convertHsb2Hsv(color));
	}
	_createClass(Color$1, [{
		key: "toHsbString",
		value: function toHsbString() {
			var hsb = this.toHsb();
			var saturation = getRoundNumber$1(hsb.s * 100);
			var lightness = getRoundNumber$1(hsb.b * 100);
			var hue = getRoundNumber$1(hsb.h);
			var alpha = hsb.a;
			var hsbString = "hsb(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%)");
			var hsbaString = "hsba(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%, ").concat(alpha.toFixed(alpha === 0 ? 0 : 2), ")");
			return alpha === 1 ? hsbString : hsbaString;
		}
	}, {
		key: "toHsb",
		value: function toHsb() {
			var _this$toHsv = this.toHsv(), v = _this$toHsv.v, resets = _objectWithoutProperties(_this$toHsv, _excluded2$13);
			return _objectSpread2(_objectSpread2({}, resets), {}, {
				b: v,
				a: this.a
			});
		}
	}]);
	return Color$1;
}(FastColor$1);

//#endregion
//#region node_modules/@rc-component/color-picker/es/util.js
var ColorPickerPrefixCls = "rc-color-picker";
var generateColor$1 = function generateColor$2(color) {
	if (color instanceof Color) return color;
	return new Color(color);
};
var defaultColor = generateColor$1("#1677ff");
var calculateColor = function calculateColor$1(props) {
	var offset$2 = props.offset, targetRef = props.targetRef, containerRef = props.containerRef, color = props.color, type$2 = props.type;
	var _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height;
	var _targetRef$current$ge = targetRef.current.getBoundingClientRect(), targetWidth = _targetRef$current$ge.width, targetHeight = _targetRef$current$ge.height;
	var centerOffsetX = targetWidth / 2;
	var centerOffsetY = targetHeight / 2;
	var saturation = (offset$2.x + centerOffsetX) / width;
	var bright = 1 - (offset$2.y + centerOffsetY) / height;
	var hsb = color.toHsb();
	var alphaOffset = saturation;
	var hueOffset = (offset$2.x + centerOffsetX) / width * 360;
	if (type$2) switch (type$2) {
		case "hue": return generateColor$1(_objectSpread2(_objectSpread2({}, hsb), {}, { h: hueOffset <= 0 ? 0 : hueOffset }));
		case "alpha": return generateColor$1(_objectSpread2(_objectSpread2({}, hsb), {}, { a: alphaOffset <= 0 ? 0 : alphaOffset }));
	}
	return generateColor$1({
		h: hsb.h,
		s: saturation <= 0 ? 0 : saturation,
		b: bright >= 1 ? 1 : bright,
		a: hsb.a
	});
};
var calcOffset = function calcOffset$1(color, type$2) {
	var hsb = color.toHsb();
	switch (type$2) {
		case "hue": return {
			x: hsb.h / 360 * 100,
			y: 50
		};
		case "alpha": return {
			x: color.a * 100,
			y: 50
		};
		default: return {
			x: hsb.s * 100,
			y: (1 - hsb.b) * 100
		};
	}
};

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/ColorBlock.js
var import_classnames$263 = /* @__PURE__ */ __toESM(require_classnames());
var ColorBlock = function ColorBlock$1(_ref) {
	var color = _ref.color, prefixCls = _ref.prefixCls, className = _ref.className, style$1 = _ref.style, onClick = _ref.onClick;
	var colorBlockCls = "".concat(prefixCls, "-color-block");
	return /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$263.default)(colorBlockCls, className),
		style: style$1,
		onClick
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(colorBlockCls, "-inner"),
		style: { background: color }
	}));
};
var ColorBlock_default = ColorBlock;

//#endregion
//#region node_modules/@rc-component/color-picker/es/hooks/useColorDrag.js
function getPosition$2(e$2) {
	var obj = "touches" in e$2 ? e$2.touches[0] : e$2;
	var scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;
	var scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
	return {
		pageX: obj.pageX - scrollXOffset,
		pageY: obj.pageY - scrollYOffset
	};
}
function useColorDrag(props) {
	var targetRef = props.targetRef, containerRef = props.containerRef, direction = props.direction, onDragChange = props.onDragChange, onDragChangeComplete = props.onDragChangeComplete, calculate = props.calculate, color = props.color, disabledDrag = props.disabledDrag;
	var _useState = (0, import_react.useState)({
		x: 0,
		y: 0
	}), _useState2 = _slicedToArray(_useState, 2), offsetValue = _useState2[0], setOffsetValue = _useState2[1];
	var mouseMoveRef = (0, import_react.useRef)(null);
	var mouseUpRef = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(function() {
		setOffsetValue(calculate());
	}, [color]);
	(0, import_react.useEffect)(function() {
		return function() {
			document.removeEventListener("mousemove", mouseMoveRef.current);
			document.removeEventListener("mouseup", mouseUpRef.current);
			document.removeEventListener("touchmove", mouseMoveRef.current);
			document.removeEventListener("touchend", mouseUpRef.current);
			mouseMoveRef.current = null;
			mouseUpRef.current = null;
		};
	}, []);
	var updateOffset = function updateOffset$1(e$2) {
		var _getPosition = getPosition$2(e$2), pageX = _getPosition.pageX, pageY = _getPosition.pageY;
		var _containerRef$current = containerRef.current.getBoundingClientRect(), rectX = _containerRef$current.x, rectY = _containerRef$current.y, width = _containerRef$current.width, height = _containerRef$current.height;
		var _targetRef$current$ge = targetRef.current.getBoundingClientRect(), targetWidth = _targetRef$current$ge.width, targetHeight = _targetRef$current$ge.height;
		var centerOffsetX = targetWidth / 2;
		var centerOffsetY = targetHeight / 2;
		var offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;
		var offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;
		var calcOffset$1 = {
			x: offsetX,
			y: direction === "x" ? offsetValue.y : offsetY
		};
		if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) return false;
		onDragChange === null || onDragChange === void 0 || onDragChange(calcOffset$1);
	};
	var onDragMove = function onDragMove$1(e$2) {
		e$2.preventDefault();
		updateOffset(e$2);
	};
	var onDragStop = function onDragStop$1(e$2) {
		e$2.preventDefault();
		document.removeEventListener("mousemove", mouseMoveRef.current);
		document.removeEventListener("mouseup", mouseUpRef.current);
		document.removeEventListener("touchmove", mouseMoveRef.current);
		document.removeEventListener("touchend", mouseUpRef.current);
		mouseMoveRef.current = null;
		mouseUpRef.current = null;
		onDragChangeComplete === null || onDragChangeComplete === void 0 || onDragChangeComplete();
	};
	return [offsetValue, function onDragStart(e$2) {
		document.removeEventListener("mousemove", mouseMoveRef.current);
		document.removeEventListener("mouseup", mouseUpRef.current);
		if (disabledDrag) return;
		updateOffset(e$2);
		document.addEventListener("mousemove", onDragMove);
		document.addEventListener("mouseup", onDragStop);
		document.addEventListener("touchmove", onDragMove);
		document.addEventListener("touchend", onDragStop);
		mouseMoveRef.current = onDragMove;
		mouseUpRef.current = onDragStop;
	}];
}
var useColorDrag_default = useColorDrag;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Handler.js
var import_classnames$262 = /* @__PURE__ */ __toESM(require_classnames());
var Handler = function Handler$1(_ref) {
	var _ref$size = _ref.size, size = _ref$size === void 0 ? "default" : _ref$size, color = _ref.color, prefixCls = _ref.prefixCls;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$262.default)("".concat(prefixCls, "-handler"), _defineProperty({}, "".concat(prefixCls, "-handler-sm"), size === "small")),
		style: { backgroundColor: color }
	});
};
var Handler_default = Handler;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Palette.js
var Palette = function Palette$1(_ref) {
	var children = _ref.children, style$1 = _ref.style, prefixCls = _ref.prefixCls;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-palette"),
		style: _objectSpread2({ position: "relative" }, style$1)
	}, children);
};
var Palette_default = Palette;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Transform.js
var Transform = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var children = props.children, x = props.x, y = props.y;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		style: {
			position: "absolute",
			left: "".concat(x, "%"),
			top: "".concat(y, "%"),
			zIndex: 1,
			transform: "translate(-50%, -50%)"
		}
	}, children);
});
var Transform_default = Transform;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Picker.js
var Picker$1 = function Picker$2(_ref) {
	var color = _ref.color, onChange = _ref.onChange, prefixCls = _ref.prefixCls, onChangeComplete = _ref.onChangeComplete, disabled = _ref.disabled;
	var pickerRef = (0, import_react.useRef)();
	var transformRef = (0, import_react.useRef)();
	var colorRef = (0, import_react.useRef)(color);
	var onDragChange = useEvent(function(offsetValue) {
		var calcColor = calculateColor({
			offset: offsetValue,
			targetRef: transformRef,
			containerRef: pickerRef,
			color
		});
		colorRef.current = calcColor;
		onChange(calcColor);
	});
	var _useColorDrag = useColorDrag_default({
		color,
		containerRef: pickerRef,
		targetRef: transformRef,
		calculate: function calculate() {
			return calcOffset(color);
		},
		onDragChange,
		onDragChangeComplete: function onDragChangeComplete() {
			return onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(colorRef.current);
		},
		disabledDrag: disabled
	}), _useColorDrag2 = _slicedToArray(_useColorDrag, 2), offset$2 = _useColorDrag2[0], dragStartHandle = _useColorDrag2[1];
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: pickerRef,
		className: "".concat(prefixCls, "-select"),
		onMouseDown: dragStartHandle,
		onTouchStart: dragStartHandle
	}, /* @__PURE__ */ import_react.createElement(Palette_default, { prefixCls }, /* @__PURE__ */ import_react.createElement(Transform_default, {
		x: offset$2.x,
		y: offset$2.y,
		ref: transformRef
	}, /* @__PURE__ */ import_react.createElement(Handler_default, {
		color: color.toRgbString(),
		prefixCls
	})), /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-saturation"),
		style: {
			backgroundColor: "hsl(".concat(color.toHsb().h, ",100%, 50%)"),
			backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
		}
	})));
};
var Picker_default = Picker$1;

//#endregion
//#region node_modules/@rc-component/color-picker/es/hooks/useColorState.js
var useColorState = function useColorState$1(defaultValue, value) {
	var _useMergedState = useMergedState(defaultValue, { value }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setValue = _useMergedState2[1];
	return [(0, import_react.useMemo)(function() {
		return generateColor$1(mergedValue);
	}, [mergedValue]), setValue];
};
var useColorState_default = useColorState;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Gradient.js
var Gradient = function Gradient$1(_ref) {
	var colors = _ref.colors, children = _ref.children, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? "to right" : _ref$direction, type$2 = _ref.type, prefixCls = _ref.prefixCls;
	var gradientColors = (0, import_react.useMemo)(function() {
		return colors.map(function(color, idx) {
			var result = generateColor$1(color);
			if (type$2 === "alpha" && idx === colors.length - 1) result = new Color(result.setA(1));
			return result.toRgbString();
		}).join(",");
	}, [colors, type$2]);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-gradient"),
		style: {
			position: "absolute",
			inset: 0,
			background: "linear-gradient(".concat(direction, ", ").concat(gradientColors, ")")
		}
	}, children);
};
var Gradient_default = Gradient;

//#endregion
//#region node_modules/@rc-component/color-picker/es/components/Slider.js
var import_classnames$261 = /* @__PURE__ */ __toESM(require_classnames());
var Slider$3 = function Slider$4(props) {
	var prefixCls = props.prefixCls, colors = props.colors, disabled = props.disabled, onChange = props.onChange, onChangeComplete = props.onChangeComplete, color = props.color, type$2 = props.type;
	var sliderRef = (0, import_react.useRef)();
	var transformRef = (0, import_react.useRef)();
	var colorRef = (0, import_react.useRef)(color);
	var getValue$2 = function getValue$3(c) {
		return type$2 === "hue" ? c.getHue() : c.a * 100;
	};
	var onDragChange = useEvent(function(offsetValue) {
		var calcColor = calculateColor({
			offset: offsetValue,
			targetRef: transformRef,
			containerRef: sliderRef,
			color,
			type: type$2
		});
		colorRef.current = calcColor;
		onChange(getValue$2(calcColor));
	});
	var _useColorDrag = useColorDrag_default({
		color,
		targetRef: transformRef,
		containerRef: sliderRef,
		calculate: function calculate() {
			return calcOffset(color, type$2);
		},
		onDragChange,
		onDragChangeComplete: function onDragChangeComplete() {
			onChangeComplete(getValue$2(colorRef.current));
		},
		direction: "x",
		disabledDrag: disabled
	}), _useColorDrag2 = _slicedToArray(_useColorDrag, 2), offset$2 = _useColorDrag2[0], dragStartHandle = _useColorDrag2[1];
	var handleColor = import_react.useMemo(function() {
		if (type$2 === "hue") {
			var hsb = color.toHsb();
			hsb.s = 1;
			hsb.b = 1;
			hsb.a = 1;
			return new Color(hsb);
		}
		return color;
	}, [color, type$2]);
	var gradientList = import_react.useMemo(function() {
		return colors.map(function(info) {
			return "".concat(info.color, " ").concat(info.percent, "%");
		});
	}, [colors]);
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: sliderRef,
		className: (0, import_classnames$261.default)("".concat(prefixCls, "-slider"), "".concat(prefixCls, "-slider-").concat(type$2)),
		onMouseDown: dragStartHandle,
		onTouchStart: dragStartHandle
	}, /* @__PURE__ */ import_react.createElement(Palette_default, { prefixCls }, /* @__PURE__ */ import_react.createElement(Transform_default, {
		x: offset$2.x,
		y: offset$2.y,
		ref: transformRef
	}, /* @__PURE__ */ import_react.createElement(Handler_default, {
		size: "small",
		color: handleColor.toHexString(),
		prefixCls
	})), /* @__PURE__ */ import_react.createElement(Gradient_default, {
		colors: gradientList,
		type: type$2,
		prefixCls
	})));
};
var Slider_default$1 = Slider$3;

//#endregion
//#region node_modules/@rc-component/color-picker/es/hooks/useComponent.js
function useComponent(components$1) {
	return import_react.useMemo(function() {
		return [(components$1 || {}).slider || Slider_default$1];
	}, [components$1]);
}

//#endregion
//#region node_modules/@rc-component/color-picker/es/ColorPicker.js
var import_classnames$260 = /* @__PURE__ */ __toESM(require_classnames());
var HUE_COLORS = [
	{
		color: "rgb(255, 0, 0)",
		percent: 0
	},
	{
		color: "rgb(255, 255, 0)",
		percent: 17
	},
	{
		color: "rgb(0, 255, 0)",
		percent: 33
	},
	{
		color: "rgb(0, 255, 255)",
		percent: 50
	},
	{
		color: "rgb(0, 0, 255)",
		percent: 67
	},
	{
		color: "rgb(255, 0, 255)",
		percent: 83
	},
	{
		color: "rgb(255, 0, 0)",
		percent: 100
	}
];
var ColorPicker$1 = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var value = props.value, defaultValue = props.defaultValue, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? ColorPickerPrefixCls : _props$prefixCls, onChange = props.onChange, onChangeComplete = props.onChangeComplete, className = props.className, style$1 = props.style, panelRender = props.panelRender, _props$disabledAlpha = props.disabledAlpha, disabledAlpha = _props$disabledAlpha === void 0 ? false : _props$disabledAlpha, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, components$1 = props.components;
	var _useComponent = useComponent(components$1), _useComponent2 = _slicedToArray(_useComponent, 1), Slider$4 = _useComponent2[0];
	var _useColorState = useColorState_default(defaultValue || defaultColor, value), _useColorState2 = _slicedToArray(_useColorState, 2), colorValue = _useColorState2[0], setColorValue = _useColorState2[1];
	var alphaColor = (0, import_react.useMemo)(function() {
		return colorValue.setA(1).toRgbString();
	}, [colorValue]);
	var handleChange = function handleChange$1(data, type$2) {
		if (!value) setColorValue(data);
		onChange === null || onChange === void 0 || onChange(data, type$2);
	};
	var getHueColor = function getHueColor$1(hue) {
		return new Color(colorValue.setHue(hue));
	};
	var getAlphaColor$3 = function getAlphaColor$4(alpha) {
		return new Color(colorValue.setA(alpha / 100));
	};
	var onHueChange = function onHueChange$1(hue) {
		handleChange(getHueColor(hue), {
			type: "hue",
			value: hue
		});
	};
	var onAlphaChange = function onAlphaChange$1(alpha) {
		handleChange(getAlphaColor$3(alpha), {
			type: "alpha",
			value: alpha
		});
	};
	var onHueChangeComplete = function onHueChangeComplete$1(hue) {
		if (onChangeComplete) onChangeComplete(getHueColor(hue));
	};
	var onAlphaChangeComplete = function onAlphaChangeComplete$1(alpha) {
		if (onChangeComplete) onChangeComplete(getAlphaColor$3(alpha));
	};
	var mergeCls = (0, import_classnames$260.default)("".concat(prefixCls, "-panel"), className, _defineProperty({}, "".concat(prefixCls, "-panel-disabled"), disabled));
	var sharedSliderProps = {
		prefixCls,
		disabled,
		color: colorValue
	};
	var defaultPanel = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Picker_default, _extends({ onChange: handleChange }, sharedSliderProps, { onChangeComplete })), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-slider-container") }, /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$260.default)("".concat(prefixCls, "-slider-group"), _defineProperty({}, "".concat(prefixCls, "-slider-group-disabled-alpha"), disabledAlpha)) }, /* @__PURE__ */ import_react.createElement(Slider$4, _extends({}, sharedSliderProps, {
		type: "hue",
		colors: HUE_COLORS,
		min: 0,
		max: 359,
		value: colorValue.getHue(),
		onChange: onHueChange,
		onChangeComplete: onHueChangeComplete
	})), !disabledAlpha && /* @__PURE__ */ import_react.createElement(Slider$4, _extends({}, sharedSliderProps, {
		type: "alpha",
		colors: [{
			percent: 0,
			color: "rgba(255, 0, 4, 0)"
		}, {
			percent: 100,
			color: alphaColor
		}],
		min: 0,
		max: 100,
		value: colorValue.a * 100,
		onChange: onAlphaChange,
		onChangeComplete: onAlphaChangeComplete
	}))), /* @__PURE__ */ import_react.createElement(ColorBlock_default, {
		color: colorValue.toRgbString(),
		prefixCls
	})));
	return /* @__PURE__ */ import_react.createElement("div", {
		className: mergeCls,
		style: style$1,
		ref
	}, typeof panelRender === "function" ? panelRender(defaultPanel) : defaultPanel);
});
ColorPicker$1.displayName = "ColorPicker";
var ColorPicker_default$1 = ColorPicker$1;

//#endregion
//#region node_modules/@rc-component/color-picker/es/index.js
var es_default$20 = ColorPicker_default$1;

//#endregion
//#region node_modules/antd/es/color-picker/color.js
const toHexFormat = (value, alpha) => (value === null || value === void 0 ? void 0 : value.replace(/[^\w/]/g, "").slice(0, alpha ? 8 : 6)) || "";
const getHex = (value, alpha) => value ? toHexFormat(value, alpha) : "";
let AggregationColor = /* @__PURE__ */ function() {
	function AggregationColor$1(color) {
		_classCallCheck(this, AggregationColor$1);
		var _a;
		this.cleared = false;
		if (color instanceof AggregationColor$1) {
			this.metaColor = color.metaColor.clone();
			this.colors = (_a = color.colors) === null || _a === void 0 ? void 0 : _a.map((info) => ({
				color: new AggregationColor$1(info.color),
				percent: info.percent
			}));
			this.cleared = color.cleared;
			return;
		}
		const isArray = Array.isArray(color);
		if (isArray && color.length) {
			this.colors = color.map(({ color: c, percent }) => ({
				color: new AggregationColor$1(c),
				percent
			}));
			this.metaColor = new Color(this.colors[0].color.metaColor);
		} else this.metaColor = new Color(isArray ? "" : color);
		if (!color || isArray && !this.colors) {
			this.metaColor = this.metaColor.setA(0);
			this.cleared = true;
		}
	}
	return _createClass(AggregationColor$1, [
		{
			key: "toHsb",
			value: function toHsb() {
				return this.metaColor.toHsb();
			}
		},
		{
			key: "toHsbString",
			value: function toHsbString() {
				return this.metaColor.toHsbString();
			}
		},
		{
			key: "toHex",
			value: function toHex() {
				return getHex(this.toHexString(), this.metaColor.a < 1);
			}
		},
		{
			key: "toHexString",
			value: function toHexString() {
				return this.metaColor.toHexString();
			}
		},
		{
			key: "toRgb",
			value: function toRgb() {
				return this.metaColor.toRgb();
			}
		},
		{
			key: "toRgbString",
			value: function toRgbString() {
				return this.metaColor.toRgbString();
			}
		},
		{
			key: "isGradient",
			value: function isGradient() {
				return !!this.colors && !this.cleared;
			}
		},
		{
			key: "getColors",
			value: function getColors() {
				return this.colors || [{
					color: this,
					percent: 0
				}];
			}
		},
		{
			key: "toCssString",
			value: function toCssString() {
				const { colors } = this;
				if (colors) return `linear-gradient(90deg, ${colors.map((c) => `${c.color.toRgbString()} ${c.percent}%`).join(", ")})`;
				return this.metaColor.toRgbString();
			}
		},
		{
			key: "equals",
			value: function equals(color) {
				if (!color || this.isGradient() !== color.isGradient()) return false;
				if (!this.isGradient()) return this.toHexString() === color.toHexString();
				return this.colors.length === color.colors.length && this.colors.every((c, i) => {
					const target = color.colors[i];
					return c.percent === target.percent && c.color.equals(target.color);
				});
			}
		}
	]);
}();

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/RightOutlined.js
var RightOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" }
		}]
	},
	"name": "right",
	"theme": "outlined"
};
var RightOutlined_default$1 = RightOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/RightOutlined.js
/**![right](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTc2NS43IDQ4Ni44TDMxNC45IDEzNC43QTcuOTcgNy45NyAwIDAwMzAyIDE0MXY3Ny4zYzAgNC45IDIuMyA5LjYgNi4xIDEyLjZsMzYwIDI4MS4xLTM2MCAyODEuMWMtMy45IDMtNi4xIDcuNy02LjEgMTIuNlY4ODNjMCA2LjcgNy43IDEwLjQgMTIuOSA2LjNsNDUwLjgtMzUyLjFhMzEuOTYgMzEuOTYgMCAwMDAtNTAuNHoiIC8+PC9zdmc+) */
var RefIcon$44 = /* @__PURE__ */ import_react.forwardRef(function RightOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: RightOutlined_default$1
	}));
});
RefIcon$44.displayName = "RightOutlined";
var RightOutlined_default = RefIcon$44;

//#endregion
//#region node_modules/rc-collapse/es/PanelContent.js
var import_classnames$259 = /* @__PURE__ */ __toESM(require_classnames());
var PanelContent = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, forceRender = props.forceRender, className = props.className, style$1 = props.style, children = props.children, isActive$1 = props.isActive, role = props.role, customizeClassNames = props.classNames, styles = props.styles;
	var _React$useState = import_react.useState(isActive$1 || forceRender), _React$useState2 = _slicedToArray(_React$useState, 2), rendered = _React$useState2[0], setRendered = _React$useState2[1];
	import_react.useEffect(function() {
		if (forceRender || isActive$1) setRendered(true);
	}, [forceRender, isActive$1]);
	if (!rendered) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		className: (0, import_classnames$259.default)("".concat(prefixCls, "-content"), _defineProperty(_defineProperty({}, "".concat(prefixCls, "-content-active"), isActive$1), "".concat(prefixCls, "-content-inactive"), !isActive$1), className),
		style: style$1,
		role
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$259.default)("".concat(prefixCls, "-content-box"), customizeClassNames === null || customizeClassNames === void 0 ? void 0 : customizeClassNames.body),
		style: styles === null || styles === void 0 ? void 0 : styles.body
	}, children));
});
PanelContent.displayName = "PanelContent";
var PanelContent_default = PanelContent;

//#endregion
//#region node_modules/rc-collapse/es/Panel.js
var import_classnames$258 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$70 = [
	"showArrow",
	"headerClass",
	"isActive",
	"onItemClick",
	"forceRender",
	"className",
	"classNames",
	"styles",
	"prefixCls",
	"collapsible",
	"accordion",
	"panelKey",
	"extra",
	"header",
	"expandIcon",
	"openMotion",
	"destroyInactivePanel",
	"children"
];
var CollapsePanel$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, headerClass = props.headerClass, isActive$1 = props.isActive, onItemClick = props.onItemClick, forceRender = props.forceRender, className = props.className, _props$classNames = props.classNames, customizeClassNames = _props$classNames === void 0 ? {} : _props$classNames, _props$styles = props.styles, styles = _props$styles === void 0 ? {} : _props$styles, prefixCls = props.prefixCls, collapsible = props.collapsible, accordion = props.accordion, panelKey = props.panelKey, extra = props.extra, header = props.header, expandIcon = props.expandIcon, openMotion = props.openMotion, destroyInactivePanel = props.destroyInactivePanel, children = props.children, resetProps = _objectWithoutProperties(props, _excluded$70);
	var disabled = collapsible === "disabled";
	var ifExtraExist = extra !== null && extra !== void 0 && typeof extra !== "boolean";
	var collapsibleProps = _defineProperty(_defineProperty(_defineProperty({
		onClick: function onClick() {
			onItemClick === null || onItemClick === void 0 || onItemClick(panelKey);
		},
		onKeyDown: function onKeyDown$1(e$2) {
			if (e$2.key === "Enter" || e$2.keyCode === KeyCode_default.ENTER || e$2.which === KeyCode_default.ENTER) onItemClick === null || onItemClick === void 0 || onItemClick(panelKey);
		},
		role: accordion ? "tab" : "button"
	}, "aria-expanded", isActive$1), "aria-disabled", disabled), "tabIndex", disabled ? -1 : 0);
	var iconNodeInner = typeof expandIcon === "function" ? expandIcon(props) : /* @__PURE__ */ import_react.createElement("i", { className: "arrow" });
	var iconNode = iconNodeInner && /* @__PURE__ */ import_react.createElement("div", _extends({ className: "".concat(prefixCls, "-expand-icon") }, ["header", "icon"].includes(collapsible) ? collapsibleProps : {}), iconNodeInner);
	var collapsePanelClassNames = (0, import_classnames$258.default)("".concat(prefixCls, "-item"), _defineProperty(_defineProperty({}, "".concat(prefixCls, "-item-active"), isActive$1), "".concat(prefixCls, "-item-disabled"), disabled), className);
	var headerClassName = (0, import_classnames$258.default)(headerClass, "".concat(prefixCls, "-header"), _defineProperty({}, "".concat(prefixCls, "-collapsible-").concat(collapsible), !!collapsible), customizeClassNames.header);
	var headerProps = _objectSpread2({
		className: headerClassName,
		style: styles.header
	}, ["header", "icon"].includes(collapsible) ? {} : collapsibleProps);
	return /* @__PURE__ */ import_react.createElement("div", _extends({}, resetProps, {
		ref,
		className: collapsePanelClassNames
	}), /* @__PURE__ */ import_react.createElement("div", headerProps, showArrow && iconNode, /* @__PURE__ */ import_react.createElement("span", _extends({ className: "".concat(prefixCls, "-header-text") }, collapsible === "header" ? collapsibleProps : {}), header), ifExtraExist && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-extra") }, extra)), /* @__PURE__ */ import_react.createElement(es_default$2, _extends({
		visible: isActive$1,
		leavedClassName: "".concat(prefixCls, "-content-hidden")
	}, openMotion, {
		forceRender,
		removeOnLeave: destroyInactivePanel
	}), function(_ref, motionRef) {
		var motionClassName = _ref.className, motionStyle = _ref.style;
		return /* @__PURE__ */ import_react.createElement(PanelContent_default, {
			ref: motionRef,
			prefixCls,
			className: motionClassName,
			classNames: customizeClassNames,
			style: motionStyle,
			styles,
			isActive: isActive$1,
			forceRender,
			role: accordion ? "tabpanel" : void 0
		}, children);
	}));
});
var Panel_default$4 = CollapsePanel$1;

//#endregion
//#region node_modules/rc-collapse/es/hooks/useItems.js
var _excluded$69 = [
	"children",
	"label",
	"key",
	"collapsible",
	"onItemClick",
	"destroyInactivePanel"
];
var convertItemsToNodes$1 = function convertItemsToNodes$2(items, props) {
	var prefixCls = props.prefixCls, accordion = props.accordion, collapsible = props.collapsible, destroyInactivePanel = props.destroyInactivePanel, onItemClick = props.onItemClick, activeKey = props.activeKey, openMotion = props.openMotion, expandIcon = props.expandIcon;
	return items.map(function(item, index$2) {
		var children = item.children, label = item.label, rawKey = item.key, rawCollapsible = item.collapsible, rawOnItemClick = item.onItemClick, rawDestroyInactivePanel = item.destroyInactivePanel, restProps = _objectWithoutProperties(item, _excluded$69);
		var key = String(rawKey !== null && rawKey !== void 0 ? rawKey : index$2);
		var mergeCollapsible = rawCollapsible !== null && rawCollapsible !== void 0 ? rawCollapsible : collapsible;
		var mergeDestroyInactivePanel = rawDestroyInactivePanel !== null && rawDestroyInactivePanel !== void 0 ? rawDestroyInactivePanel : destroyInactivePanel;
		var handleItemClick = function handleItemClick$1(value) {
			if (mergeCollapsible === "disabled") return;
			onItemClick(value);
			rawOnItemClick === null || rawOnItemClick === void 0 || rawOnItemClick(value);
		};
		var isActive$1 = false;
		if (accordion) isActive$1 = activeKey[0] === key;
		else isActive$1 = activeKey.indexOf(key) > -1;
		return /* @__PURE__ */ import_react.createElement(Panel_default$4, _extends({}, restProps, {
			prefixCls,
			key,
			panelKey: key,
			isActive: isActive$1,
			accordion,
			openMotion,
			expandIcon,
			header: label,
			collapsible: mergeCollapsible,
			onItemClick: handleItemClick,
			destroyInactivePanel: mergeDestroyInactivePanel
		}), children);
	});
};
/**
* @deprecated The next major version will be removed
*/
var getNewChild = function getNewChild$1(child, index$2, props) {
	if (!child) return null;
	var prefixCls = props.prefixCls, accordion = props.accordion, collapsible = props.collapsible, destroyInactivePanel = props.destroyInactivePanel, onItemClick = props.onItemClick, activeKey = props.activeKey, openMotion = props.openMotion, expandIcon = props.expandIcon;
	var key = child.key || String(index$2);
	var _child$props = child.props, header = _child$props.header, headerClass = _child$props.headerClass, childDestroyInactivePanel = _child$props.destroyInactivePanel, childCollapsible = _child$props.collapsible, childOnItemClick = _child$props.onItemClick;
	var isActive$1 = false;
	if (accordion) isActive$1 = activeKey[0] === key;
	else isActive$1 = activeKey.indexOf(key) > -1;
	var mergeCollapsible = childCollapsible !== null && childCollapsible !== void 0 ? childCollapsible : collapsible;
	var childProps = {
		key,
		panelKey: key,
		header,
		headerClass,
		isActive: isActive$1,
		prefixCls,
		destroyInactivePanel: childDestroyInactivePanel !== null && childDestroyInactivePanel !== void 0 ? childDestroyInactivePanel : destroyInactivePanel,
		openMotion,
		accordion,
		children: child.props.children,
		onItemClick: function handleItemClick(value) {
			if (mergeCollapsible === "disabled") return;
			onItemClick(value);
			childOnItemClick === null || childOnItemClick === void 0 || childOnItemClick(value);
		},
		expandIcon,
		collapsible: mergeCollapsible
	};
	if (typeof child.type === "string") return child;
	Object.keys(childProps).forEach(function(propName) {
		if (typeof childProps[propName] === "undefined") delete childProps[propName];
	});
	return /* @__PURE__ */ import_react.cloneElement(child, childProps);
};
function useItems$4(items, rawChildren, props) {
	if (Array.isArray(items)) return convertItemsToNodes$1(items, props);
	return toArray(rawChildren).map(function(child, index$2) {
		return getNewChild(child, index$2, props);
	});
}
var useItems_default$2 = useItems$4;

//#endregion
//#region node_modules/rc-collapse/es/Collapse.js
var import_classnames$257 = /* @__PURE__ */ __toESM(require_classnames());
function getActiveKeysArray(activeKey) {
	var currentActiveKey = activeKey;
	if (!Array.isArray(currentActiveKey)) {
		var activeKeyType = _typeof(currentActiveKey);
		currentActiveKey = activeKeyType === "number" || activeKeyType === "string" ? [currentActiveKey] : [];
	}
	return currentActiveKey.map(function(key) {
		return String(key);
	});
}
var Collapse$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-collapse" : _props$prefixCls, _props$destroyInactiv = props.destroyInactivePanel, destroyInactivePanel = _props$destroyInactiv === void 0 ? false : _props$destroyInactiv, style$1 = props.style, accordion = props.accordion, className = props.className, children = props.children, collapsible = props.collapsible, openMotion = props.openMotion, expandIcon = props.expandIcon, rawActiveKey = props.activeKey, defaultActiveKey = props.defaultActiveKey, _onChange = props.onChange, items = props.items;
	var collapseClassName = (0, import_classnames$257.default)(prefixCls, className);
	var _useMergedState = useMergedState([], {
		value: rawActiveKey,
		onChange: function onChange(v) {
			return _onChange === null || _onChange === void 0 ? void 0 : _onChange(v);
		},
		defaultValue: defaultActiveKey,
		postState: getActiveKeysArray
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), activeKey = _useMergedState2[0], setActiveKey = _useMergedState2[1];
	var onItemClick = function onItemClick$1(key) {
		return setActiveKey(function() {
			if (accordion) return activeKey[0] === key ? [] : [key];
			if (activeKey.indexOf(key) > -1) return activeKey.filter(function(item) {
				return item !== key;
			});
			return [].concat(_toConsumableArray(activeKey), [key]);
		});
	};
	warning_default(!children, "[rc-collapse] `children` will be removed in next major version. Please use `items` instead.");
	var mergedChildren = useItems_default$2(items, children, {
		prefixCls,
		accordion,
		openMotion,
		expandIcon,
		collapsible,
		destroyInactivePanel,
		onItemClick,
		activeKey
	});
	return /* @__PURE__ */ import_react.createElement("div", _extends({
		ref,
		className: collapseClassName,
		style: style$1,
		role: accordion ? "tablist" : void 0
	}, pickAttrs(props, {
		aria: true,
		data: true
	})), mergedChildren);
});
var Collapse_default$1 = Object.assign(Collapse$1, { Panel: Panel_default$4 });

//#endregion
//#region node_modules/rc-collapse/es/index.js
var es_default$35 = Collapse_default$1;
/**
* @deprecated use `items` instead, will be removed in `v4.0.0`
*/
var Panel$4 = Collapse_default$1.Panel;

//#endregion
//#region node_modules/antd/es/collapse/CollapsePanel.js
var import_classnames$256 = /* @__PURE__ */ __toESM(require_classnames());
var CollapsePanel = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	devUseWarning("Collapse.Panel").deprecated(!("disabled" in props), "disabled", "collapsible=\"disabled\"");
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, className, showArrow = true } = props;
	const prefixCls = getPrefixCls("collapse", customizePrefixCls);
	const collapsePanelClassName = (0, import_classnames$256.default)({ [`${prefixCls}-no-arrow`]: !showArrow }, className);
	return /* @__PURE__ */ import_react.createElement(es_default$35.Panel, Object.assign({ ref }, props, {
		prefixCls,
		className: collapsePanelClassName
	}));
});
var CollapsePanel_default = CollapsePanel;

//#endregion
//#region node_modules/antd/es/style/motion/collapse.js
var genCollapseMotion = (token$1) => ({ [token$1.componentCls]: {
	[`${token$1.antCls}-motion-collapse-legacy`]: {
		overflow: "hidden",
		"&-active": { transition: `height ${token$1.motionDurationMid} ${token$1.motionEaseInOut},
        opacity ${token$1.motionDurationMid} ${token$1.motionEaseInOut} !important` }
	},
	[`${token$1.antCls}-motion-collapse`]: {
		overflow: "hidden",
		transition: `height ${token$1.motionDurationMid} ${token$1.motionEaseInOut},
        opacity ${token$1.motionDurationMid} ${token$1.motionEaseInOut} !important`
	}
} });
var collapse_default$1 = genCollapseMotion;

//#endregion
//#region node_modules/antd/es/style/motion/motion.js
var initMotionCommon = (duration) => ({
	animationDuration: duration,
	animationFillMode: "both"
});
var initMotionCommonLeave = (duration) => ({
	animationDuration: duration,
	animationFillMode: "both"
});
const initMotion = (motionCls, inKeyframes, outKeyframes, duration, sameLevel = false) => {
	const sameLevelPrefix = sameLevel ? "&" : "";
	return {
		[`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), { animationPlayState: "paused" }),
		[`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), { animationPlayState: "paused" }),
		[`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
			animationName: inKeyframes,
			animationPlayState: "running"
		},
		[`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
			animationName: outKeyframes,
			animationPlayState: "running",
			pointerEvents: "none"
		}
	};
};

//#endregion
//#region node_modules/antd/es/style/motion/fade.js
const fadeIn = new Keyframes_default("antFadeIn", {
	"0%": { opacity: 0 },
	"100%": { opacity: 1 }
});
const fadeOut = new Keyframes_default("antFadeOut", {
	"0%": { opacity: 1 },
	"100%": { opacity: 0 }
});
const initFadeMotion = (token$1, sameLevel = false) => {
	const { antCls } = token$1;
	const motionCls = `${antCls}-fade`;
	const sameLevelPrefix = sameLevel ? "&" : "";
	return [initMotion(motionCls, fadeIn, fadeOut, token$1.motionDurationMid, sameLevel), {
		[`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
			opacity: 0,
			animationTimingFunction: "linear"
		},
		[`${sameLevelPrefix}${motionCls}-leave`]: { animationTimingFunction: "linear" }
	}];
};

//#endregion
//#region node_modules/antd/es/style/motion/move.js
const moveDownIn = new Keyframes_default("antMoveDownIn", {
	"0%": {
		transform: "translate3d(0, 100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveDownOut = new Keyframes_default("antMoveDownOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(0, 100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
const moveLeftIn = new Keyframes_default("antMoveLeftIn", {
	"0%": {
		transform: "translate3d(-100%, 0, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveLeftOut = new Keyframes_default("antMoveLeftOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(-100%, 0, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
const moveRightIn = new Keyframes_default("antMoveRightIn", {
	"0%": {
		transform: "translate3d(100%, 0, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveRightOut = new Keyframes_default("antMoveRightOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(100%, 0, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
const moveUpIn = new Keyframes_default("antMoveUpIn", {
	"0%": {
		transform: "translate3d(0, -100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	},
	"100%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	}
});
const moveUpOut = new Keyframes_default("antMoveUpOut", {
	"0%": {
		transform: "translate3d(0, 0, 0)",
		transformOrigin: "0 0",
		opacity: 1
	},
	"100%": {
		transform: "translate3d(0, -100%, 0)",
		transformOrigin: "0 0",
		opacity: 0
	}
});
var moveMotion = {
	"move-up": {
		inKeyframes: moveUpIn,
		outKeyframes: moveUpOut
	},
	"move-down": {
		inKeyframes: moveDownIn,
		outKeyframes: moveDownOut
	},
	"move-left": {
		inKeyframes: moveLeftIn,
		outKeyframes: moveLeftOut
	},
	"move-right": {
		inKeyframes: moveRightIn,
		outKeyframes: moveRightOut
	}
};
const initMoveMotion = (token$1, motionName) => {
	const { antCls } = token$1;
	const motionCls = `${antCls}-${motionName}`;
	const { inKeyframes, outKeyframes } = moveMotion[motionName];
	return [initMotion(motionCls, inKeyframes, outKeyframes, token$1.motionDurationMid), {
		[`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
			opacity: 0,
			animationTimingFunction: token$1.motionEaseOutCirc
		},
		[`${motionCls}-leave`]: { animationTimingFunction: token$1.motionEaseInOutCirc }
	}];
};

//#endregion
//#region node_modules/antd/es/style/motion/slide.js
const slideUpIn = new Keyframes_default("antSlideUpIn", {
	"0%": {
		transform: "scaleY(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scaleY(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	}
});
const slideUpOut = new Keyframes_default("antSlideUpOut", {
	"0%": {
		transform: "scaleY(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	},
	"100%": {
		transform: "scaleY(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	}
});
const slideDownIn = new Keyframes_default("antSlideDownIn", {
	"0%": {
		transform: "scaleY(0.8)",
		transformOrigin: "100% 100%",
		opacity: 0
	},
	"100%": {
		transform: "scaleY(1)",
		transformOrigin: "100% 100%",
		opacity: 1
	}
});
const slideDownOut = new Keyframes_default("antSlideDownOut", {
	"0%": {
		transform: "scaleY(1)",
		transformOrigin: "100% 100%",
		opacity: 1
	},
	"100%": {
		transform: "scaleY(0.8)",
		transformOrigin: "100% 100%",
		opacity: 0
	}
});
const slideLeftIn = new Keyframes_default("antSlideLeftIn", {
	"0%": {
		transform: "scaleX(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scaleX(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	}
});
const slideLeftOut = new Keyframes_default("antSlideLeftOut", {
	"0%": {
		transform: "scaleX(1)",
		transformOrigin: "0% 0%",
		opacity: 1
	},
	"100%": {
		transform: "scaleX(0.8)",
		transformOrigin: "0% 0%",
		opacity: 0
	}
});
const slideRightIn = new Keyframes_default("antSlideRightIn", {
	"0%": {
		transform: "scaleX(0.8)",
		transformOrigin: "100% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scaleX(1)",
		transformOrigin: "100% 0%",
		opacity: 1
	}
});
const slideRightOut = new Keyframes_default("antSlideRightOut", {
	"0%": {
		transform: "scaleX(1)",
		transformOrigin: "100% 0%",
		opacity: 1
	},
	"100%": {
		transform: "scaleX(0.8)",
		transformOrigin: "100% 0%",
		opacity: 0
	}
});
var slideMotion = {
	"slide-up": {
		inKeyframes: slideUpIn,
		outKeyframes: slideUpOut
	},
	"slide-down": {
		inKeyframes: slideDownIn,
		outKeyframes: slideDownOut
	},
	"slide-left": {
		inKeyframes: slideLeftIn,
		outKeyframes: slideLeftOut
	},
	"slide-right": {
		inKeyframes: slideRightIn,
		outKeyframes: slideRightOut
	}
};
const initSlideMotion = (token$1, motionName) => {
	const { antCls } = token$1;
	const motionCls = `${antCls}-${motionName}`;
	const { inKeyframes, outKeyframes } = slideMotion[motionName];
	return [initMotion(motionCls, inKeyframes, outKeyframes, token$1.motionDurationMid), {
		[`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
			transform: "scale(0)",
			transformOrigin: "0% 0%",
			opacity: 0,
			animationTimingFunction: token$1.motionEaseOutQuint,
			"&-prepare": { transform: "scale(1)" }
		},
		[`${motionCls}-leave`]: { animationTimingFunction: token$1.motionEaseInQuint }
	}];
};

//#endregion
//#region node_modules/antd/es/style/motion/zoom.js
const zoomIn = new Keyframes_default("antZoomIn", {
	"0%": {
		transform: "scale(0.2)",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		opacity: 1
	}
});
const zoomOut = new Keyframes_default("antZoomOut", {
	"0%": { transform: "scale(1)" },
	"100%": {
		transform: "scale(0.2)",
		opacity: 0
	}
});
const zoomBigIn = new Keyframes_default("antZoomBigIn", {
	"0%": {
		transform: "scale(0.8)",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		opacity: 1
	}
});
const zoomBigOut = new Keyframes_default("antZoomBigOut", {
	"0%": { transform: "scale(1)" },
	"100%": {
		transform: "scale(0.8)",
		opacity: 0
	}
});
const zoomUpIn = new Keyframes_default("antZoomUpIn", {
	"0%": {
		transform: "scale(0.8)",
		transformOrigin: "50% 0%",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		transformOrigin: "50% 0%"
	}
});
const zoomUpOut = new Keyframes_default("antZoomUpOut", {
	"0%": {
		transform: "scale(1)",
		transformOrigin: "50% 0%"
	},
	"100%": {
		transform: "scale(0.8)",
		transformOrigin: "50% 0%",
		opacity: 0
	}
});
const zoomLeftIn = new Keyframes_default("antZoomLeftIn", {
	"0%": {
		transform: "scale(0.8)",
		transformOrigin: "0% 50%",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		transformOrigin: "0% 50%"
	}
});
const zoomLeftOut = new Keyframes_default("antZoomLeftOut", {
	"0%": {
		transform: "scale(1)",
		transformOrigin: "0% 50%"
	},
	"100%": {
		transform: "scale(0.8)",
		transformOrigin: "0% 50%",
		opacity: 0
	}
});
const zoomRightIn = new Keyframes_default("antZoomRightIn", {
	"0%": {
		transform: "scale(0.8)",
		transformOrigin: "100% 50%",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		transformOrigin: "100% 50%"
	}
});
const zoomRightOut = new Keyframes_default("antZoomRightOut", {
	"0%": {
		transform: "scale(1)",
		transformOrigin: "100% 50%"
	},
	"100%": {
		transform: "scale(0.8)",
		transformOrigin: "100% 50%",
		opacity: 0
	}
});
const zoomDownIn = new Keyframes_default("antZoomDownIn", {
	"0%": {
		transform: "scale(0.8)",
		transformOrigin: "50% 100%",
		opacity: 0
	},
	"100%": {
		transform: "scale(1)",
		transformOrigin: "50% 100%"
	}
});
const zoomDownOut = new Keyframes_default("antZoomDownOut", {
	"0%": {
		transform: "scale(1)",
		transformOrigin: "50% 100%"
	},
	"100%": {
		transform: "scale(0.8)",
		transformOrigin: "50% 100%",
		opacity: 0
	}
});
var zoomMotion = {
	zoom: {
		inKeyframes: zoomIn,
		outKeyframes: zoomOut
	},
	"zoom-big": {
		inKeyframes: zoomBigIn,
		outKeyframes: zoomBigOut
	},
	"zoom-big-fast": {
		inKeyframes: zoomBigIn,
		outKeyframes: zoomBigOut
	},
	"zoom-left": {
		inKeyframes: zoomLeftIn,
		outKeyframes: zoomLeftOut
	},
	"zoom-right": {
		inKeyframes: zoomRightIn,
		outKeyframes: zoomRightOut
	},
	"zoom-up": {
		inKeyframes: zoomUpIn,
		outKeyframes: zoomUpOut
	},
	"zoom-down": {
		inKeyframes: zoomDownIn,
		outKeyframes: zoomDownOut
	}
};
const initZoomMotion = (token$1, motionName) => {
	const { antCls } = token$1;
	const motionCls = `${antCls}-${motionName}`;
	const { inKeyframes, outKeyframes } = zoomMotion[motionName];
	return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token$1.motionDurationFast : token$1.motionDurationMid), {
		[`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
			transform: "scale(0)",
			opacity: 0,
			animationTimingFunction: token$1.motionEaseOutCirc,
			"&-prepare": { transform: "none" }
		},
		[`${motionCls}-leave`]: { animationTimingFunction: token$1.motionEaseInOutCirc }
	}];
};

//#endregion
//#region node_modules/antd/es/collapse/style/index.js
const genBaseStyle$17 = (token$1) => {
	const { componentCls, contentBg, padding, headerBg, headerPadding, collapseHeaderPaddingSM, collapseHeaderPaddingLG, collapsePanelBorderRadius, lineWidth, lineType, colorBorder, colorText, colorTextHeading, colorTextDisabled, fontSizeLG, lineHeight, lineHeightLG, marginSM, paddingSM, paddingLG, paddingXS, motionDurationSlow, fontSizeIcon, contentPadding, fontHeight, fontHeightLG } = token$1;
	const borderBase = `${unit(lineWidth)} ${lineType} ${colorBorder}`;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		backgroundColor: headerBg,
		border: borderBase,
		borderRadius: collapsePanelBorderRadius,
		"&-rtl": { direction: "rtl" },
		[`& > ${componentCls}-item`]: {
			borderBottom: borderBase,
			"&:first-child": { [`
            &,
            & > ${componentCls}-header`]: { borderRadius: `${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)} 0 0` } },
			"&:last-child": { [`
            &,
            & > ${componentCls}-header`]: { borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}` } },
			[`> ${componentCls}-header`]: Object.assign(Object.assign({
				position: "relative",
				display: "flex",
				flexWrap: "nowrap",
				alignItems: "flex-start",
				padding: headerPadding,
				color: colorTextHeading,
				lineHeight,
				cursor: "pointer",
				transition: `all ${motionDurationSlow}, visibility 0s`
			}, genFocusStyle(token$1)), {
				[`> ${componentCls}-header-text`]: { flex: "auto" },
				[`${componentCls}-expand-icon`]: {
					height: fontHeight,
					display: "flex",
					alignItems: "center",
					paddingInlineEnd: marginSM
				},
				[`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
					fontSize: fontSizeIcon,
					transition: `transform ${motionDurationSlow}`,
					svg: { transition: `transform ${motionDurationSlow}` }
				}),
				[`${componentCls}-header-text`]: { marginInlineEnd: "auto" }
			}),
			[`${componentCls}-collapsible-header`]: {
				cursor: "default",
				[`${componentCls}-header-text`]: {
					flex: "none",
					cursor: "pointer"
				},
				[`${componentCls}-expand-icon`]: { cursor: "pointer" }
			},
			[`${componentCls}-collapsible-icon`]: {
				cursor: "unset",
				[`${componentCls}-expand-icon`]: { cursor: "pointer" }
			}
		},
		[`${componentCls}-content`]: {
			color: colorText,
			backgroundColor: contentBg,
			borderTop: borderBase,
			[`& > ${componentCls}-content-box`]: { padding: contentPadding },
			"&-hidden": { display: "none" }
		},
		"&-small": { [`> ${componentCls}-item`]: {
			[`> ${componentCls}-header`]: {
				padding: collapseHeaderPaddingSM,
				paddingInlineStart: paddingXS,
				[`> ${componentCls}-expand-icon`]: { marginInlineStart: token$1.calc(paddingSM).sub(paddingXS).equal() }
			},
			[`> ${componentCls}-content > ${componentCls}-content-box`]: { padding: paddingSM }
		} },
		"&-large": { [`> ${componentCls}-item`]: {
			fontSize: fontSizeLG,
			lineHeight: lineHeightLG,
			[`> ${componentCls}-header`]: {
				padding: collapseHeaderPaddingLG,
				paddingInlineStart: padding,
				[`> ${componentCls}-expand-icon`]: {
					height: fontHeightLG,
					marginInlineStart: token$1.calc(paddingLG).sub(padding).equal()
				}
			},
			[`> ${componentCls}-content > ${componentCls}-content-box`]: { padding: paddingLG }
		} },
		[`${componentCls}-item:last-child`]: {
			borderBottom: 0,
			[`> ${componentCls}-content`]: { borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}` }
		},
		[`& ${componentCls}-item-disabled > ${componentCls}-header`]: { [`
          &,
          & > .arrow
        `]: {
			color: colorTextDisabled,
			cursor: "not-allowed"
		} },
		[`&${componentCls}-icon-position-end`]: { [`& > ${componentCls}-item`]: { [`> ${componentCls}-header`]: { [`${componentCls}-expand-icon`]: {
			order: 1,
			paddingInlineEnd: 0,
			paddingInlineStart: marginSM
		} } } }
	}) };
};
var genArrowStyle = (token$1) => {
	const { componentCls } = token$1;
	const fixedSelector = `> ${componentCls}-item > ${componentCls}-header ${componentCls}-arrow`;
	return { [`${componentCls}-rtl`]: { [fixedSelector]: { transform: `rotate(180deg)` } } };
};
var genBorderlessStyle$2 = (token$1) => {
	const { componentCls, headerBg, borderlessContentPadding, borderlessContentBg, colorBorder } = token$1;
	return { [`${componentCls}-borderless`]: {
		backgroundColor: headerBg,
		border: 0,
		[`> ${componentCls}-item`]: { borderBottom: `1px solid ${colorBorder}` },
		[`
        > ${componentCls}-item:last-child,
        > ${componentCls}-item:last-child ${componentCls}-header
      `]: { borderRadius: 0 },
		[`> ${componentCls}-item:last-child`]: { borderBottom: 0 },
		[`> ${componentCls}-item > ${componentCls}-content`]: {
			backgroundColor: borderlessContentBg,
			borderTop: 0
		},
		[`> ${componentCls}-item > ${componentCls}-content > ${componentCls}-content-box`]: { padding: borderlessContentPadding }
	} };
};
var genGhostStyle = (token$1) => {
	const { componentCls, paddingSM } = token$1;
	return { [`${componentCls}-ghost`]: {
		backgroundColor: "transparent",
		border: 0,
		[`> ${componentCls}-item`]: {
			borderBottom: 0,
			[`> ${componentCls}-content`]: {
				backgroundColor: "transparent",
				border: 0,
				[`> ${componentCls}-content-box`]: { paddingBlock: paddingSM }
			}
		}
	} };
};
const prepareComponentToken$53 = (token$1) => ({
	headerPadding: `${token$1.paddingSM}px ${token$1.padding}px`,
	headerBg: token$1.colorFillAlter,
	contentPadding: `${token$1.padding}px 16px`,
	contentBg: token$1.colorBgContainer,
	borderlessContentPadding: `${token$1.paddingXXS}px 16px ${token$1.padding}px`,
	borderlessContentBg: "transparent"
});
var style_default$58 = genStyleHooks("Collapse", (token$1) => {
	const collapseToken = merge(token$1, {
		collapseHeaderPaddingSM: `${unit(token$1.paddingXS)} ${unit(token$1.paddingSM)}`,
		collapseHeaderPaddingLG: `${unit(token$1.padding)} ${unit(token$1.paddingLG)}`,
		collapsePanelBorderRadius: token$1.borderRadiusLG
	});
	return [
		genBaseStyle$17(collapseToken),
		genBorderlessStyle$2(collapseToken),
		genGhostStyle(collapseToken),
		genArrowStyle(collapseToken),
		collapse_default$1(collapseToken)
	];
}, prepareComponentToken$53);

//#endregion
//#region node_modules/antd/es/collapse/Collapse.js
var import_classnames$255 = /* @__PURE__ */ __toESM(require_classnames());
var Collapse = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { getPrefixCls, direction, expandIcon: contextExpandIcon, className: contextClassName, style: contextStyle } = useComponentConfig("collapse");
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, bordered = true, ghost, size: customizeSize, expandIconPosition = "start", children, destroyInactivePanel, destroyOnHidden, expandIcon } = props;
	const mergedSize = useSize_default((ctx) => {
		var _a;
		return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : ctx) !== null && _a !== void 0 ? _a : "middle";
	});
	const prefixCls = getPrefixCls("collapse", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const [wrapCSSVar, hashId, cssVarCls] = style_default$58(prefixCls);
	{
		const warning$4 = devUseWarning("Collapse");
		warning$4(expandIconPosition !== "left" && expandIconPosition !== "right", "deprecated", "`expandIconPosition` with `left` or `right` is deprecated. Please use `start` or `end` instead.");
		warning$4.deprecated(!("destroyInactivePanel" in props), "destroyInactivePanel", "destroyOnHidden");
	}
	const mergedExpandIconPosition = import_react.useMemo(() => {
		if (expandIconPosition === "left") return "start";
		return expandIconPosition === "right" ? "end" : expandIconPosition;
	}, [expandIconPosition]);
	const mergedExpandIcon = expandIcon !== null && expandIcon !== void 0 ? expandIcon : contextExpandIcon;
	const renderExpandIcon$2 = import_react.useCallback((panelProps = {}) => {
		const icon = typeof mergedExpandIcon === "function" ? mergedExpandIcon(panelProps) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, {
			rotate: panelProps.isActive ? direction === "rtl" ? -90 : 90 : void 0,
			"aria-label": panelProps.isActive ? "expanded" : "collapsed"
		});
		return cloneElement(icon, () => {
			var _a;
			return { className: (0, import_classnames$255.default)((_a = icon.props) === null || _a === void 0 ? void 0 : _a.className, `${prefixCls}-arrow`) };
		});
	}, [
		mergedExpandIcon,
		prefixCls,
		direction
	]);
	const collapseClassName = (0, import_classnames$255.default)(`${prefixCls}-icon-position-${mergedExpandIconPosition}`, {
		[`${prefixCls}-borderless`]: !bordered,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-ghost`]: !!ghost,
		[`${prefixCls}-${mergedSize}`]: mergedSize !== "middle"
	}, contextClassName, className, rootClassName, hashId, cssVarCls);
	const openMotion = import_react.useMemo(() => Object.assign(Object.assign({}, motion_default(rootPrefixCls)), {
		motionAppear: false,
		leavedClassName: `${prefixCls}-content-hidden`
	}), [rootPrefixCls, prefixCls]);
	const items = import_react.useMemo(() => {
		if (!children) return null;
		return toArray(children).map((child, index$2) => {
			var _a, _b;
			const childProps = child.props;
			if (childProps === null || childProps === void 0 ? void 0 : childProps.disabled) {
				const key = (_a = child.key) !== null && _a !== void 0 ? _a : String(index$2);
				const mergedChildProps = Object.assign(Object.assign({}, omit(child.props, ["disabled"])), {
					key,
					collapsible: (_b = childProps.collapsible) !== null && _b !== void 0 ? _b : "disabled"
				});
				return cloneElement(child, mergedChildProps);
			}
			return child;
		});
	}, [children]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$35, Object.assign({
		ref,
		openMotion
	}, omit(props, ["rootClassName"]), {
		expandIcon: renderExpandIcon$2,
		prefixCls,
		className: collapseClassName,
		style: Object.assign(Object.assign({}, contextStyle), style$1),
		destroyInactivePanel: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyInactivePanel
	}), items));
});
Collapse.displayName = "Collapse";
var Collapse_default = Object.assign(Collapse, { Panel: CollapsePanel_default });

//#endregion
//#region node_modules/antd/es/collapse/index.js
var collapse_default = Collapse_default;

//#endregion
//#region node_modules/antd/es/color-picker/util.js
const generateColor = (color) => {
	if (color instanceof AggregationColor) return color;
	return new AggregationColor(color);
};
const getRoundNumber = (value) => Math.round(Number(value || 0));
const getColorAlpha = (color) => getRoundNumber(color.toHsb().a * 100);
/** Return the color whose `alpha` is 1 */
const genAlphaColor = (color, alpha) => {
	const rgba = color.toRgb();
	if (!rgba.r && !rgba.g && !rgba.b) {
		const hsba = color.toHsb();
		hsba.a = alpha || 1;
		return generateColor(hsba);
	}
	rgba.a = alpha || 1;
	return generateColor(rgba);
};
/**
* Get percent position color. e.g. [10%-#fff, 20%-#000], 15% => #888
*/
const getGradientPercentColor = (colors, percent) => {
	const filledColors = [{
		percent: 0,
		color: colors[0].color
	}].concat(_toConsumableArray(colors), [{
		percent: 100,
		color: colors[colors.length - 1].color
	}]);
	for (let i = 0; i < filledColors.length - 1; i += 1) {
		const startPtg = filledColors[i].percent;
		const endPtg = filledColors[i + 1].percent;
		const startColor = filledColors[i].color;
		const endColor = filledColors[i + 1].color;
		if (startPtg <= percent && percent <= endPtg) {
			const dist = endPtg - startPtg;
			if (dist === 0) return startColor;
			const ratio = (percent - startPtg) / dist * 100;
			const startRcColor = new Color(startColor);
			const endRcColor = new Color(endColor);
			return startRcColor.mix(endRcColor, ratio).toRgbString();
		}
	}
	/* istanbul ignore next */
	return "";
};

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorPresets.js
var import_classnames$254 = /* @__PURE__ */ __toESM(require_classnames());
var genPresetColor$1 = (list) => list.map((value) => {
	value.colors = value.colors.map(generateColor);
	return value;
});
const isBright = (value, bgColorToken) => {
	const { r: r$1, g, b, a } = value.toRgb();
	const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
	if (a <= .5) return hsv.v > .5;
	return r$1 * .299 + g * .587 + b * .114 > 192;
};
var genCollapsePanelKey = (preset, index$2) => {
	var _a;
	return `panel-${(_a = preset.key) !== null && _a !== void 0 ? _a : index$2}`;
};
var ColorPresets = ({ prefixCls, presets, value: color, onChange }) => {
	const [locale$5] = useLocale_default("ColorPicker");
	const [, token$1] = useToken();
	const [presetsValue] = useMergedState(genPresetColor$1(presets), {
		value: genPresetColor$1(presets),
		postState: genPresetColor$1
	});
	const colorPresetsPrefixCls = `${prefixCls}-presets`;
	const activeKeys = (0, import_react.useMemo)(() => presetsValue.reduce((acc, preset, index$2) => {
		const { defaultOpen = true } = preset;
		if (defaultOpen) acc.push(genCollapsePanelKey(preset, index$2));
		return acc;
	}, []), [presetsValue]);
	const handleClick = (colorValue) => {
		onChange === null || onChange === void 0 || onChange(colorValue);
	};
	const items = presetsValue.map((preset, index$2) => {
		var _a;
		return {
			key: genCollapsePanelKey(preset, index$2),
			label: /* @__PURE__ */ import_react.createElement("div", { className: `${colorPresetsPrefixCls}-label` }, preset === null || preset === void 0 ? void 0 : preset.label),
			children: /* @__PURE__ */ import_react.createElement("div", { className: `${colorPresetsPrefixCls}-items` }, Array.isArray(preset === null || preset === void 0 ? void 0 : preset.colors) && ((_a = preset.colors) === null || _a === void 0 ? void 0 : _a.length) > 0 ? preset.colors.map((presetColor, index$3) => /* @__PURE__ */ import_react.createElement(ColorBlock_default, {
				key: `preset-${index$3}-${presetColor.toHexString()}`,
				color: generateColor(presetColor).toRgbString(),
				prefixCls,
				className: (0, import_classnames$254.default)(`${colorPresetsPrefixCls}-color`, {
					[`${colorPresetsPrefixCls}-color-checked`]: presetColor.toHexString() === (color === null || color === void 0 ? void 0 : color.toHexString()),
					[`${colorPresetsPrefixCls}-color-bright`]: isBright(presetColor, token$1.colorBgElevated)
				}),
				onClick: () => handleClick(presetColor)
			})) : /* @__PURE__ */ import_react.createElement("span", { className: `${colorPresetsPrefixCls}-empty` }, locale$5.presetEmpty))
		};
	});
	return /* @__PURE__ */ import_react.createElement("div", { className: colorPresetsPrefixCls }, /* @__PURE__ */ import_react.createElement(collapse_default, {
		defaultActiveKey: activeKeys,
		ghost: true,
		items
	}));
};
var ColorPresets_default = ColorPresets;

//#endregion
//#region node_modules/antd/es/button/style/token.js
const prepareToken$5 = (token$1) => {
	const { paddingInline, onlyIconSize } = token$1;
	return merge(token$1, {
		buttonPaddingHorizontal: paddingInline,
		buttonPaddingVertical: 0,
		buttonIconOnlyFontSize: onlyIconSize
	});
};
const prepareComponentToken$52 = (token$1) => {
	var _a, _b, _c, _d, _e, _f;
	const contentFontSize = (_a = token$1.contentFontSize) !== null && _a !== void 0 ? _a : token$1.fontSize;
	const contentFontSizeSM = (_b = token$1.contentFontSizeSM) !== null && _b !== void 0 ? _b : token$1.fontSize;
	const contentFontSizeLG = (_c = token$1.contentFontSizeLG) !== null && _c !== void 0 ? _c : token$1.fontSizeLG;
	const contentLineHeight = (_d = token$1.contentLineHeight) !== null && _d !== void 0 ? _d : getLineHeight(contentFontSize);
	const contentLineHeightSM = (_e = token$1.contentLineHeightSM) !== null && _e !== void 0 ? _e : getLineHeight(contentFontSizeSM);
	const contentLineHeightLG = (_f = token$1.contentLineHeightLG) !== null && _f !== void 0 ? _f : getLineHeight(contentFontSizeLG);
	const solidTextColor = isBright(new AggregationColor(token$1.colorBgSolid), "#fff") ? "#000" : "#fff";
	const shadowColorTokens = PresetColors.reduce((prev$1, colorKey) => Object.assign(Object.assign({}, prev$1), { [`${colorKey}ShadowColor`]: `0 ${unit(token$1.controlOutlineWidth)} 0 ${getAlphaColor_default(token$1[`${colorKey}1`], token$1.colorBgContainer)}` }), {});
	return Object.assign(Object.assign({}, shadowColorTokens), {
		fontWeight: 400,
		iconGap: token$1.marginXS,
		defaultShadow: `0 ${token$1.controlOutlineWidth}px 0 ${token$1.controlTmpOutline}`,
		primaryShadow: `0 ${token$1.controlOutlineWidth}px 0 ${token$1.controlOutline}`,
		dangerShadow: `0 ${token$1.controlOutlineWidth}px 0 ${token$1.colorErrorOutline}`,
		primaryColor: token$1.colorTextLightSolid,
		dangerColor: token$1.colorTextLightSolid,
		borderColorDisabled: token$1.colorBorder,
		defaultGhostColor: token$1.colorBgContainer,
		ghostBg: "transparent",
		defaultGhostBorderColor: token$1.colorBgContainer,
		paddingInline: token$1.paddingContentHorizontal - token$1.lineWidth,
		paddingInlineLG: token$1.paddingContentHorizontal - token$1.lineWidth,
		paddingInlineSM: 8 - token$1.lineWidth,
		onlyIconSize: "inherit",
		onlyIconSizeSM: "inherit",
		onlyIconSizeLG: "inherit",
		groupBorderColor: token$1.colorPrimaryHover,
		linkHoverBg: "transparent",
		textTextColor: token$1.colorText,
		textTextHoverColor: token$1.colorText,
		textTextActiveColor: token$1.colorText,
		textHoverBg: token$1.colorFillTertiary,
		defaultColor: token$1.colorText,
		defaultBg: token$1.colorBgContainer,
		defaultBorderColor: token$1.colorBorder,
		defaultBorderColorDisabled: token$1.colorBorder,
		defaultHoverBg: token$1.colorBgContainer,
		defaultHoverColor: token$1.colorPrimaryHover,
		defaultHoverBorderColor: token$1.colorPrimaryHover,
		defaultActiveBg: token$1.colorBgContainer,
		defaultActiveColor: token$1.colorPrimaryActive,
		defaultActiveBorderColor: token$1.colorPrimaryActive,
		solidTextColor,
		contentFontSize,
		contentFontSizeSM,
		contentFontSizeLG,
		contentLineHeight,
		contentLineHeightSM,
		contentLineHeightLG,
		paddingBlock: Math.max((token$1.controlHeight - contentFontSize * contentLineHeight) / 2 - token$1.lineWidth, 0),
		paddingBlockSM: Math.max((token$1.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token$1.lineWidth, 0),
		paddingBlockLG: Math.max((token$1.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token$1.lineWidth, 0)
	});
};

//#endregion
//#region node_modules/antd/es/button/style/index.js
var genSharedButtonStyle = (token$1) => {
	const { componentCls, iconCls, fontWeight, opacityLoading, motionDurationSlow, motionEaseInOut, iconGap, calc } = token$1;
	return { [componentCls]: {
		outline: "none",
		position: "relative",
		display: "inline-flex",
		gap: iconGap,
		alignItems: "center",
		justifyContent: "center",
		fontWeight,
		whiteSpace: "nowrap",
		textAlign: "center",
		backgroundImage: "none",
		background: "transparent",
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
		cursor: "pointer",
		transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseInOut}`,
		userSelect: "none",
		touchAction: "manipulation",
		color: token$1.colorText,
		"&:disabled > *": { pointerEvents: "none" },
		[`${componentCls}-icon > svg`]: resetIcon(),
		"> a": { color: "currentColor" },
		"&:not(:disabled)": genFocusStyle(token$1),
		[`&${componentCls}-two-chinese-chars::first-letter`]: { letterSpacing: "0.34em" },
		[`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
			marginInlineEnd: "-0.34em",
			letterSpacing: "0.34em"
		},
		[`&${componentCls}-icon-only`]: {
			paddingInline: 0,
			[`&${componentCls}-compact-item`]: { flex: "none" }
		},
		[`&${componentCls}-loading`]: {
			opacity: opacityLoading,
			cursor: "default"
		},
		[`${componentCls}-loading-icon`]: { transition: [
			"width",
			"opacity",
			"margin"
		].map((transition) => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(",") },
		[`&:not(${componentCls}-icon-end)`]: { [`${componentCls}-loading-icon-motion`]: {
			"&-appear-start, &-enter-start": { marginInlineEnd: calc(iconGap).mul(-1).equal() },
			"&-appear-active, &-enter-active": { marginInlineEnd: 0 },
			"&-leave-start": { marginInlineEnd: 0 },
			"&-leave-active": { marginInlineEnd: calc(iconGap).mul(-1).equal() }
		} },
		"&-icon-end": {
			flexDirection: "row-reverse",
			[`${componentCls}-loading-icon-motion`]: {
				"&-appear-start, &-enter-start": { marginInlineStart: calc(iconGap).mul(-1).equal() },
				"&-appear-active, &-enter-active": { marginInlineStart: 0 },
				"&-leave-start": { marginInlineStart: 0 },
				"&-leave-active": { marginInlineStart: calc(iconGap).mul(-1).equal() }
			}
		}
	} };
};
var genHoverActiveButtonStyle = (btnCls, hoverStyle, activeStyle) => ({ [`&:not(:disabled):not(${btnCls}-disabled)`]: {
	"&:hover": hoverStyle,
	"&:active": activeStyle
} });
var genCircleButtonStyle = (token$1) => ({
	minWidth: token$1.controlHeight,
	paddingInline: 0,
	borderRadius: "50%"
});
var genDisabledStyle$1 = (token$1) => ({
	cursor: "not-allowed",
	borderColor: token$1.borderColorDisabled,
	color: token$1.colorTextDisabled,
	background: token$1.colorBgContainerDisabled,
	boxShadow: "none"
});
var genGhostButtonStyle = (btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({ [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
	color: textColor || void 0,
	background,
	borderColor: borderColor || void 0,
	boxShadow: "none"
}, genHoverActiveButtonStyle(btnCls, Object.assign({ background }, hoverStyle), Object.assign({ background }, activeStyle))), { "&:disabled": {
	cursor: "not-allowed",
	color: textColorDisabled || void 0,
	borderColor: borderColorDisabled || void 0
} }) });
var genSolidDisabledButtonStyle = (token$1) => ({ [`&:disabled, &${token$1.componentCls}-disabled`]: Object.assign({}, genDisabledStyle$1(token$1)) });
var genPureDisabledButtonStyle = (token$1) => ({ [`&:disabled, &${token$1.componentCls}-disabled`]: {
	cursor: "not-allowed",
	color: token$1.colorTextDisabled
} });
var genVariantButtonStyle = (token$1, hoverStyle, activeStyle, variant) => {
	const genDisabledButtonStyle = variant && ["link", "text"].includes(variant) ? genPureDisabledButtonStyle : genSolidDisabledButtonStyle;
	return Object.assign(Object.assign({}, genDisabledButtonStyle(token$1)), genHoverActiveButtonStyle(token$1.componentCls, hoverStyle, activeStyle));
};
var genSolidButtonStyle = (token$1, textColor, background, hoverStyle, activeStyle) => ({ [`&${token$1.componentCls}-variant-solid`]: Object.assign({
	color: textColor,
	background
}, genVariantButtonStyle(token$1, hoverStyle, activeStyle)) });
var genOutlinedDashedButtonStyle = (token$1, borderColor, background, hoverStyle, activeStyle) => ({ [`&${token$1.componentCls}-variant-outlined, &${token$1.componentCls}-variant-dashed`]: Object.assign({
	borderColor,
	background
}, genVariantButtonStyle(token$1, hoverStyle, activeStyle)) });
var genDashedButtonStyle = (token$1) => ({ [`&${token$1.componentCls}-variant-dashed`]: { borderStyle: "dashed" } });
var genFilledButtonStyle = (token$1, background, hoverStyle, activeStyle) => ({ [`&${token$1.componentCls}-variant-filled`]: Object.assign({
	boxShadow: "none",
	background
}, genVariantButtonStyle(token$1, hoverStyle, activeStyle)) });
var genTextLinkButtonStyle = (token$1, textColor, variant, hoverStyle, activeStyle) => ({ [`&${token$1.componentCls}-variant-${variant}`]: Object.assign({
	color: textColor,
	boxShadow: "none"
}, genVariantButtonStyle(token$1, hoverStyle, activeStyle, variant)) });
var genPresetColorStyle = (token$1) => {
	const { componentCls } = token$1;
	return PresetColors.reduce((prev$1, colorKey) => {
		const darkColor = token$1[`${colorKey}6`];
		const lightColor = token$1[`${colorKey}1`];
		const hoverColor = token$1[`${colorKey}5`];
		const lightHoverColor = token$1[`${colorKey}2`];
		const lightBorderColor = token$1[`${colorKey}3`];
		const activeColor = token$1[`${colorKey}7`];
		return Object.assign(Object.assign({}, prev$1), { [`&${componentCls}-color-${colorKey}`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
			color: darkColor,
			boxShadow: token$1[`${colorKey}ShadowColor`]
		}, genSolidButtonStyle(token$1, token$1.colorTextLightSolid, darkColor, { background: hoverColor }, { background: activeColor })), genOutlinedDashedButtonStyle(token$1, darkColor, token$1.colorBgContainer, {
			color: hoverColor,
			borderColor: hoverColor,
			background: token$1.colorBgContainer
		}, {
			color: activeColor,
			borderColor: activeColor,
			background: token$1.colorBgContainer
		})), genDashedButtonStyle(token$1)), genFilledButtonStyle(token$1, lightColor, {
			color: darkColor,
			background: lightHoverColor
		}, {
			color: darkColor,
			background: lightBorderColor
		})), genTextLinkButtonStyle(token$1, darkColor, "link", { color: hoverColor }, { color: activeColor })), genTextLinkButtonStyle(token$1, darkColor, "text", {
			color: hoverColor,
			background: lightColor
		}, {
			color: activeColor,
			background: lightBorderColor
		})) });
	}, {});
};
var genDefaultButtonStyle = (token$1) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
	color: token$1.defaultColor,
	boxShadow: token$1.defaultShadow
}, genSolidButtonStyle(token$1, token$1.solidTextColor, token$1.colorBgSolid, {
	color: token$1.solidTextColor,
	background: token$1.colorBgSolidHover
}, {
	color: token$1.solidTextColor,
	background: token$1.colorBgSolidActive
})), genDashedButtonStyle(token$1)), genFilledButtonStyle(token$1, token$1.colorFillTertiary, {
	color: token$1.defaultColor,
	background: token$1.colorFillSecondary
}, {
	color: token$1.defaultColor,
	background: token$1.colorFill
})), genGhostButtonStyle(token$1.componentCls, token$1.ghostBg, token$1.defaultGhostColor, token$1.defaultGhostBorderColor, token$1.colorTextDisabled, token$1.colorBorder)), genTextLinkButtonStyle(token$1, token$1.textTextColor, "link", {
	color: token$1.colorLinkHover,
	background: token$1.linkHoverBg
}, { color: token$1.colorLinkActive }));
var genPrimaryButtonStyle = (token$1) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
	color: token$1.colorPrimary,
	boxShadow: token$1.primaryShadow
}, genOutlinedDashedButtonStyle(token$1, token$1.colorPrimary, token$1.colorBgContainer, {
	color: token$1.colorPrimaryTextHover,
	borderColor: token$1.colorPrimaryHover,
	background: token$1.colorBgContainer
}, {
	color: token$1.colorPrimaryTextActive,
	borderColor: token$1.colorPrimaryActive,
	background: token$1.colorBgContainer
})), genDashedButtonStyle(token$1)), genFilledButtonStyle(token$1, token$1.colorPrimaryBg, {
	color: token$1.colorPrimary,
	background: token$1.colorPrimaryBgHover
}, {
	color: token$1.colorPrimary,
	background: token$1.colorPrimaryBorder
})), genTextLinkButtonStyle(token$1, token$1.colorPrimaryText, "text", {
	color: token$1.colorPrimaryTextHover,
	background: token$1.colorPrimaryBg
}, {
	color: token$1.colorPrimaryTextActive,
	background: token$1.colorPrimaryBorder
})), genTextLinkButtonStyle(token$1, token$1.colorPrimaryText, "link", {
	color: token$1.colorPrimaryTextHover,
	background: token$1.linkHoverBg
}, { color: token$1.colorPrimaryTextActive })), genGhostButtonStyle(token$1.componentCls, token$1.ghostBg, token$1.colorPrimary, token$1.colorPrimary, token$1.colorTextDisabled, token$1.colorBorder, {
	color: token$1.colorPrimaryHover,
	borderColor: token$1.colorPrimaryHover
}, {
	color: token$1.colorPrimaryActive,
	borderColor: token$1.colorPrimaryActive
}));
var genDangerousStyle = (token$1) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
	color: token$1.colorError,
	boxShadow: token$1.dangerShadow
}, genSolidButtonStyle(token$1, token$1.dangerColor, token$1.colorError, { background: token$1.colorErrorHover }, { background: token$1.colorErrorActive })), genOutlinedDashedButtonStyle(token$1, token$1.colorError, token$1.colorBgContainer, {
	color: token$1.colorErrorHover,
	borderColor: token$1.colorErrorBorderHover
}, {
	color: token$1.colorErrorActive,
	borderColor: token$1.colorErrorActive
})), genDashedButtonStyle(token$1)), genFilledButtonStyle(token$1, token$1.colorErrorBg, {
	color: token$1.colorError,
	background: token$1.colorErrorBgFilledHover
}, {
	color: token$1.colorError,
	background: token$1.colorErrorBgActive
})), genTextLinkButtonStyle(token$1, token$1.colorError, "text", {
	color: token$1.colorErrorHover,
	background: token$1.colorErrorBg
}, {
	color: token$1.colorErrorHover,
	background: token$1.colorErrorBgActive
})), genTextLinkButtonStyle(token$1, token$1.colorError, "link", { color: token$1.colorErrorHover }, { color: token$1.colorErrorActive })), genGhostButtonStyle(token$1.componentCls, token$1.ghostBg, token$1.colorError, token$1.colorError, token$1.colorTextDisabled, token$1.colorBorder, {
	color: token$1.colorErrorHover,
	borderColor: token$1.colorErrorHover
}, {
	color: token$1.colorErrorActive,
	borderColor: token$1.colorErrorActive
}));
var genLinkStyle = (token$1) => Object.assign(Object.assign({}, genTextLinkButtonStyle(token$1, token$1.colorLink, "link", { color: token$1.colorLinkHover }, { color: token$1.colorLinkActive })), genGhostButtonStyle(token$1.componentCls, token$1.ghostBg, token$1.colorInfo, token$1.colorInfo, token$1.colorTextDisabled, token$1.colorBorder, {
	color: token$1.colorInfoHover,
	borderColor: token$1.colorInfoHover
}, {
	color: token$1.colorInfoActive,
	borderColor: token$1.colorInfoActive
}));
var genColorButtonStyle = (token$1) => {
	const { componentCls } = token$1;
	return Object.assign({
		[`${componentCls}-color-default`]: genDefaultButtonStyle(token$1),
		[`${componentCls}-color-primary`]: genPrimaryButtonStyle(token$1),
		[`${componentCls}-color-dangerous`]: genDangerousStyle(token$1),
		[`${componentCls}-color-link`]: genLinkStyle(token$1)
	}, genPresetColorStyle(token$1));
};
var genCompatibleButtonStyle = (token$1) => Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedDashedButtonStyle(token$1, token$1.defaultBorderColor, token$1.defaultBg, {
	color: token$1.defaultHoverColor,
	borderColor: token$1.defaultHoverBorderColor,
	background: token$1.defaultHoverBg
}, {
	color: token$1.defaultActiveColor,
	borderColor: token$1.defaultActiveBorderColor,
	background: token$1.defaultActiveBg
})), genTextLinkButtonStyle(token$1, token$1.textTextColor, "text", {
	color: token$1.textTextHoverColor,
	background: token$1.textHoverBg
}, {
	color: token$1.textTextActiveColor,
	background: token$1.colorBgTextActive
})), genSolidButtonStyle(token$1, token$1.primaryColor, token$1.colorPrimary, {
	background: token$1.colorPrimaryHover,
	color: token$1.primaryColor
}, {
	background: token$1.colorPrimaryActive,
	color: token$1.primaryColor
})), genTextLinkButtonStyle(token$1, token$1.colorLink, "link", {
	color: token$1.colorLinkHover,
	background: token$1.linkHoverBg
}, { color: token$1.colorLinkActive }));
var genButtonStyle = (token$1, prefixCls = "") => {
	const { componentCls, controlHeight, fontSize, borderRadius, buttonPaddingHorizontal, iconCls, buttonPaddingVertical, buttonIconOnlyFontSize } = token$1;
	return [
		{ [prefixCls]: {
			fontSize,
			height: controlHeight,
			padding: `${unit(buttonPaddingVertical)} ${unit(buttonPaddingHorizontal)}`,
			borderRadius,
			[`&${componentCls}-icon-only`]: {
				width: controlHeight,
				[iconCls]: { fontSize: buttonIconOnlyFontSize }
			}
		} },
		{ [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token$1) },
		{ [`${componentCls}${componentCls}-round${prefixCls}`]: {
			borderRadius: token$1.controlHeight,
			[`&:not(${componentCls}-icon-only)`]: { paddingInline: token$1.buttonPaddingHorizontal }
		} }
	];
};
var genSizeBaseButtonStyle = (token$1) => {
	const baseToken = merge(token$1, { fontSize: token$1.contentFontSize });
	return genButtonStyle(baseToken, token$1.componentCls);
};
var genSizeSmallButtonStyle = (token$1) => {
	const smallToken = merge(token$1, {
		controlHeight: token$1.controlHeightSM,
		fontSize: token$1.contentFontSizeSM,
		padding: token$1.paddingXS,
		buttonPaddingHorizontal: token$1.paddingInlineSM,
		buttonPaddingVertical: 0,
		borderRadius: token$1.borderRadiusSM,
		buttonIconOnlyFontSize: token$1.onlyIconSizeSM
	});
	return genButtonStyle(smallToken, `${token$1.componentCls}-sm`);
};
var genSizeLargeButtonStyle = (token$1) => {
	const largeToken = merge(token$1, {
		controlHeight: token$1.controlHeightLG,
		fontSize: token$1.contentFontSizeLG,
		buttonPaddingHorizontal: token$1.paddingInlineLG,
		buttonPaddingVertical: 0,
		borderRadius: token$1.borderRadiusLG,
		buttonIconOnlyFontSize: token$1.onlyIconSizeLG
	});
	return genButtonStyle(largeToken, `${token$1.componentCls}-lg`);
};
var genBlockButtonStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: { [`&${componentCls}-block`]: { width: "100%" } } };
};
var style_default$57 = genStyleHooks("Button", (token$1) => {
	const buttonToken = prepareToken$5(token$1);
	return [
		genSharedButtonStyle(buttonToken),
		genSizeBaseButtonStyle(buttonToken),
		genSizeSmallButtonStyle(buttonToken),
		genSizeLargeButtonStyle(buttonToken),
		genBlockButtonStyle(buttonToken),
		genColorButtonStyle(buttonToken),
		genCompatibleButtonStyle(buttonToken),
		group_default$1(buttonToken)
	];
}, prepareComponentToken$52, { unitless: {
	fontWeight: true,
	contentLineHeight: true,
	contentLineHeightSM: true,
	contentLineHeightLG: true
} });

//#endregion
//#region node_modules/antd/es/style/compact-item.js
function compactItemBorder(token$1, parentCls, options, prefixCls) {
	const { focusElCls, focus, borderElCls } = options;
	const childCombinator = borderElCls ? "> *" : "";
	const hoverEffects = [
		"hover",
		focus ? "focus" : null,
		"active"
	].filter(Boolean).map((n$1) => `&:${n$1} ${childCombinator}`).join(",");
	return {
		[`&-item:not(${parentCls}-last-item)`]: { marginInlineEnd: token$1.calc(token$1.lineWidth).mul(-1).equal() },
		[`&-item:not(${prefixCls}-status-success)`]: { zIndex: 2 },
		"&-item": Object.assign(Object.assign({ [hoverEffects]: { zIndex: 3 } }, focusElCls ? { [`&${focusElCls}`]: { zIndex: 3 } } : {}), { [`&[disabled] ${childCombinator}`]: { zIndex: 0 } })
	};
}
function compactItemBorderRadius(prefixCls, parentCls, options) {
	const { borderElCls } = options;
	const childCombinator = borderElCls ? `> ${borderElCls}` : "";
	return {
		[`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: { borderRadius: 0 },
		[`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: { [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
			borderStartEndRadius: 0,
			borderEndEndRadius: 0
		} },
		[`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: { [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0
		} }
	};
}
function genCompactItemStyle(token$1, options = { focus: true }) {
	const { componentCls } = token$1;
	const compactCls = `${componentCls}-compact`;
	return { [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token$1, compactCls, options, componentCls)), compactItemBorderRadius(componentCls, compactCls, options)) };
}

//#endregion
//#region node_modules/antd/es/style/compact-item-vertical.js
function compactItemVerticalBorder(token$1, parentCls, prefixCls) {
	return {
		[`&-item:not(${parentCls}-last-item)`]: { marginBottom: token$1.calc(token$1.lineWidth).mul(-1).equal() },
		[`&-item:not(${prefixCls}-status-success)`]: { zIndex: 2 },
		"&-item": {
			"&:hover,&:focus,&:active": { zIndex: 3 },
			"&[disabled]": { zIndex: 0 }
		}
	};
}
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
	return {
		[`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: { borderRadius: 0 },
		[`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: { [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
			borderEndEndRadius: 0,
			borderEndStartRadius: 0
		} },
		[`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: { [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
			borderStartStartRadius: 0,
			borderStartEndRadius: 0
		} }
	};
}
function genCompactItemVerticalStyle(token$1) {
	const compactCls = `${token$1.componentCls}-compact-vertical`;
	return { [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token$1, compactCls, token$1.componentCls)), compactItemBorderVerticalRadius(token$1.componentCls, compactCls)) };
}

//#endregion
//#region node_modules/antd/es/button/style/compact.js
var genButtonCompactStyle = (token$1) => {
	const { componentCls, colorPrimaryHover, lineWidth, calc } = token$1;
	const insetOffset = calc(lineWidth).mul(-1).equal();
	const getCompactBorderStyle = (vertical) => {
		const selector = `${componentCls}-compact${vertical ? "-vertical" : ""}-item${componentCls}-primary:not([disabled])`;
		return { [`${selector} + ${selector}::before`]: {
			position: "absolute",
			top: vertical ? insetOffset : 0,
			insetInlineStart: vertical ? 0 : insetOffset,
			backgroundColor: colorPrimaryHover,
			content: "\"\"",
			width: vertical ? "100%" : lineWidth,
			height: vertical ? lineWidth : "100%"
		} };
	};
	return Object.assign(Object.assign({}, getCompactBorderStyle()), getCompactBorderStyle(true));
};
var compact_default$1 = genSubStyleComponent(["Button", "compact"], (token$1) => {
	const buttonToken = prepareToken$5(token$1);
	return [
		genCompactItemStyle(buttonToken),
		genCompactItemVerticalStyle(buttonToken),
		genButtonCompactStyle(buttonToken)
	];
}, prepareComponentToken$52);

//#endregion
//#region node_modules/antd/es/button/button.js
var import_classnames$253 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$105 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function getLoadingConfig(loading) {
	if (typeof loading === "object" && loading) {
		let delay = loading === null || loading === void 0 ? void 0 : loading.delay;
		delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
		return {
			loading: delay <= 0,
			delay
		};
	}
	return {
		loading: !!loading,
		delay: 0
	};
}
var ButtonTypeMap = {
	default: ["default", "outlined"],
	primary: ["primary", "solid"],
	dashed: ["default", "dashed"],
	link: ["link", "link"],
	text: ["default", "text"]
};
var Button = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a, _b;
	const { loading = false, prefixCls: customizePrefixCls, color, variant, type: type$2, danger = false, shape: customizeShape, size: customizeSize, styles, disabled: customDisabled, className, rootClassName, children, icon, iconPosition = "start", ghost = false, block = false, htmlType = "button", classNames: customClassNames, style: customStyle = {}, autoInsertSpace, autoFocus } = props, rest = __rest$105(props, [
		"loading",
		"prefixCls",
		"color",
		"variant",
		"type",
		"danger",
		"shape",
		"size",
		"styles",
		"disabled",
		"className",
		"rootClassName",
		"children",
		"icon",
		"iconPosition",
		"ghost",
		"block",
		"htmlType",
		"classNames",
		"style",
		"autoInsertSpace",
		"autoFocus"
	]);
	const mergedType = type$2 || "default";
	const { button } = import_react.useContext(ConfigContext);
	const shape = customizeShape || (button === null || button === void 0 ? void 0 : button.shape) || "default";
	const [mergedColor, mergedVariant] = (0, import_react.useMemo)(() => {
		if (color && variant) return [color, variant];
		if (type$2 || danger) {
			const colorVariantPair = ButtonTypeMap[mergedType] || [];
			if (danger) return ["danger", colorVariantPair[1]];
			return colorVariantPair;
		}
		if ((button === null || button === void 0 ? void 0 : button.color) && (button === null || button === void 0 ? void 0 : button.variant)) return [button.color, button.variant];
		return ["default", "outlined"];
	}, [
		type$2,
		color,
		variant,
		danger,
		button === null || button === void 0 ? void 0 : button.variant,
		button === null || button === void 0 ? void 0 : button.color
	]);
	const mergedColorText = mergedColor === "danger" ? "dangerous" : mergedColor;
	const { getPrefixCls, direction, autoInsertSpace: contextAutoInsertSpace, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("button");
	const mergedInsertSpace = (_a = autoInsertSpace !== null && autoInsertSpace !== void 0 ? autoInsertSpace : contextAutoInsertSpace) !== null && _a !== void 0 ? _a : true;
	const prefixCls = getPrefixCls("btn", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$57(prefixCls);
	const disabled = (0, import_react.useContext)(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const groupSize = (0, import_react.useContext)(GroupSizeContext);
	const loadingOrDelay = (0, import_react.useMemo)(() => getLoadingConfig(loading), [loading]);
	const [innerLoading, setLoading] = (0, import_react.useState)(loadingOrDelay.loading);
	const [hasTwoCNChar, setHasTwoCNChar] = (0, import_react.useState)(false);
	const buttonRef = (0, import_react.useRef)(null);
	const mergedRef = useComposeRef(ref, buttonRef);
	const needInserted = import_react.Children.count(children) === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
	const isMountRef = (0, import_react.useRef)(true);
	import_react.useEffect(() => {
		isMountRef.current = false;
		return () => {
			isMountRef.current = true;
		};
	}, []);
	useLayoutEffect_default(() => {
		let delayTimer = null;
		if (loadingOrDelay.delay > 0) delayTimer = setTimeout(() => {
			delayTimer = null;
			setLoading(true);
		}, loadingOrDelay.delay);
		else setLoading(loadingOrDelay.loading);
		function cleanupTimer() {
			if (delayTimer) {
				clearTimeout(delayTimer);
				delayTimer = null;
			}
		}
		return cleanupTimer;
	}, [loadingOrDelay.delay, loadingOrDelay.loading]);
	(0, import_react.useEffect)(() => {
		if (!buttonRef.current || !mergedInsertSpace) return;
		const buttonText = buttonRef.current.textContent || "";
		if (needInserted && isTwoCNChar(buttonText)) {
			if (!hasTwoCNChar) setHasTwoCNChar(true);
		} else if (hasTwoCNChar) setHasTwoCNChar(false);
	});
	(0, import_react.useEffect)(() => {
		if (autoFocus && buttonRef.current) buttonRef.current.focus();
	}, []);
	const handleClick = import_react.useCallback((e$2) => {
		var _a$1;
		if (innerLoading || mergedDisabled) {
			e$2.preventDefault();
			return;
		}
		(_a$1 = props.onClick) === null || _a$1 === void 0 || _a$1.call(props, "href" in props ? e$2 : e$2);
	}, [
		props.onClick,
		innerLoading,
		mergedDisabled
	]);
	{
		const warning$4 = devUseWarning("Button");
		warning$4(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`);
		warning$4(!(ghost && isUnBorderedButtonVariant(mergedVariant)), "usage", "`link` or `text` button can't be a `ghost` button.");
	}
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const sizeClassNameMap$1 = {
		large: "lg",
		small: "sm",
		middle: void 0
	};
	const sizeFullName = useSize_default((ctxSize) => {
		var _a$1, _b$1;
		return (_b$1 = (_a$1 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a$1 !== void 0 ? _a$1 : groupSize) !== null && _b$1 !== void 0 ? _b$1 : ctxSize;
	});
	const sizeCls = sizeFullName ? (_b = sizeClassNameMap$1[sizeFullName]) !== null && _b !== void 0 ? _b : "" : "";
	const iconType = innerLoading ? "loading" : icon;
	const linkButtonRestProps = omit(rest, ["navigate"]);
	const classes = (0, import_classnames$253.default)(prefixCls, hashId, cssVarCls, {
		[`${prefixCls}-${shape}`]: shape !== "default" && shape,
		[`${prefixCls}-${mergedType}`]: mergedType,
		[`${prefixCls}-dangerous`]: danger,
		[`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
		[`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
		[`${prefixCls}-${sizeCls}`]: sizeCls,
		[`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
		[`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
		[`${prefixCls}-loading`]: innerLoading,
		[`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
		[`${prefixCls}-block`]: block,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-icon-end`]: iconPosition === "end"
	}, compactItemClassnames, className, rootClassName, contextClassName);
	const fullStyle = Object.assign(Object.assign({}, contextStyle), customStyle);
	const iconClasses = (0, import_classnames$253.default)(customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.icon, contextClassNames.icon);
	const iconStyle = Object.assign(Object.assign({}, (styles === null || styles === void 0 ? void 0 : styles.icon) || {}), contextStyles.icon || {});
	const iconNode = icon && !innerLoading ? /* @__PURE__ */ import_react.createElement(IconWrapper_default, {
		prefixCls,
		className: iconClasses,
		style: iconStyle
	}, icon) : loading && typeof loading === "object" && loading.icon ? /* @__PURE__ */ import_react.createElement(IconWrapper_default, {
		prefixCls,
		className: iconClasses,
		style: iconStyle
	}, loading.icon) : /* @__PURE__ */ import_react.createElement(DefaultLoadingIcon_default, {
		existIcon: !!icon,
		prefixCls,
		loading: innerLoading,
		mount: isMountRef.current
	});
	const kids = children || children === 0 ? spaceChildren(children, needInserted && mergedInsertSpace) : null;
	if (linkButtonRestProps.href !== void 0) return wrapCSSVar(/* @__PURE__ */ import_react.createElement("a", Object.assign({}, linkButtonRestProps, {
		className: (0, import_classnames$253.default)(classes, { [`${prefixCls}-disabled`]: mergedDisabled }),
		href: mergedDisabled ? void 0 : linkButtonRestProps.href,
		style: fullStyle,
		onClick: handleClick,
		ref: mergedRef,
		tabIndex: mergedDisabled ? -1 : 0,
		"aria-disabled": mergedDisabled
	}), iconNode, kids));
	let buttonNode = /* @__PURE__ */ import_react.createElement("button", Object.assign({}, rest, {
		type: htmlType,
		className: classes,
		style: fullStyle,
		onClick: handleClick,
		disabled: mergedDisabled,
		ref: mergedRef
	}), iconNode, kids, compactItemClassnames && /* @__PURE__ */ import_react.createElement(compact_default$1, { prefixCls }));
	if (!isUnBorderedButtonVariant(mergedVariant)) buttonNode = /* @__PURE__ */ import_react.createElement(wave_default, {
		component: "Button",
		disabled: innerLoading
	}, buttonNode);
	return wrapCSSVar(buttonNode);
});
Button.Group = button_group_default;
Button.__ANT_BUTTON = true;
Button.displayName = "Button";
var button_default$1 = Button;

//#endregion
//#region node_modules/antd/es/button/index.js
var button_default = button_default$1;

//#endregion
//#region node_modules/antd/es/_util/ActionButton.js
var isThenable = (thing) => {
	return typeof (thing === null || thing === void 0 ? void 0 : thing.then) === "function";
};
var ActionButton = (props) => {
	const { type: type$2, children, prefixCls, buttonProps, close, autoFocus, emitEvent, isSilent, quitOnNullishReturnValue, actionFn } = props;
	const clickedRef = import_react.useRef(false);
	const buttonRef = import_react.useRef(null);
	const [loading, setLoading] = useSafeState(false);
	const onInternalClose = (...args) => {
		close === null || close === void 0 || close.apply(void 0, args);
	};
	import_react.useEffect(() => {
		let timeoutId = null;
		if (autoFocus) timeoutId = setTimeout(() => {
			var _a;
			(_a = buttonRef.current) === null || _a === void 0 || _a.focus({ preventScroll: true });
		});
		return () => {
			if (timeoutId) clearTimeout(timeoutId);
		};
	}, []);
	const handlePromiseOnOk = (returnValueOfOnOk) => {
		if (!isThenable(returnValueOfOnOk)) return;
		setLoading(true);
		returnValueOfOnOk.then((...args) => {
			setLoading(false, true);
			onInternalClose.apply(void 0, args);
			clickedRef.current = false;
		}, (e$2) => {
			setLoading(false, true);
			clickedRef.current = false;
			if (isSilent === null || isSilent === void 0 ? void 0 : isSilent()) return;
			return Promise.reject(e$2);
		});
	};
	const onClick = (e$2) => {
		if (clickedRef.current) return;
		clickedRef.current = true;
		if (!actionFn) {
			onInternalClose();
			return;
		}
		let returnValueOfOnOk;
		if (emitEvent) {
			returnValueOfOnOk = actionFn(e$2);
			if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
				clickedRef.current = false;
				onInternalClose(e$2);
				return;
			}
		} else if (actionFn.length) {
			returnValueOfOnOk = actionFn(close);
			clickedRef.current = false;
		} else {
			returnValueOfOnOk = actionFn();
			if (!isThenable(returnValueOfOnOk)) {
				onInternalClose();
				return;
			}
		}
		handlePromiseOnOk(returnValueOfOnOk);
	};
	return /* @__PURE__ */ import_react.createElement(button_default, Object.assign({}, convertLegacyProps(type$2), {
		onClick,
		loading,
		prefixCls
	}, buttonProps, { ref: buttonRef }), children);
};
var ActionButton_default = ActionButton;

//#endregion
//#region node_modules/antd/es/modal/context.js
const ModalContext = /* @__PURE__ */ import_react.createContext({});
const { Provider: ModalContextProvider } = ModalContext;

//#endregion
//#region node_modules/antd/es/modal/components/ConfirmCancelBtn.js
var ConfirmCancelBtn = () => {
	const { autoFocusButton, cancelButtonProps, cancelTextLocale, isSilent, mergedOkCancel, rootPrefixCls, close, onCancel, onConfirm } = (0, import_react.useContext)(ModalContext);
	return mergedOkCancel ? /* @__PURE__ */ import_react.createElement(ActionButton_default, {
		isSilent,
		actionFn: onCancel,
		close: (...args) => {
			close === null || close === void 0 || close.apply(void 0, args);
			onConfirm === null || onConfirm === void 0 || onConfirm(false);
		},
		autoFocus: autoFocusButton === "cancel",
		buttonProps: cancelButtonProps,
		prefixCls: `${rootPrefixCls}-btn`
	}, cancelTextLocale) : null;
};
var ConfirmCancelBtn_default = ConfirmCancelBtn;

//#endregion
//#region node_modules/antd/es/modal/components/ConfirmOkBtn.js
var ConfirmOkBtn = () => {
	const { autoFocusButton, close, isSilent, okButtonProps, rootPrefixCls, okTextLocale, okType, onConfirm, onOk } = (0, import_react.useContext)(ModalContext);
	return /* @__PURE__ */ import_react.createElement(ActionButton_default, {
		isSilent,
		type: okType || "primary",
		actionFn: onOk,
		close: (...args) => {
			close === null || close === void 0 || close.apply(void 0, args);
			onConfirm === null || onConfirm === void 0 || onConfirm(true);
		},
		autoFocus: autoFocusButton === "ok",
		buttonProps: okButtonProps,
		prefixCls: `${rootPrefixCls}-btn`
	}, okTextLocale);
};
var ConfirmOkBtn_default = ConfirmOkBtn;

//#endregion
//#region node_modules/@rc-component/portal/es/Context.js
var OrderContext = /* @__PURE__ */ import_react.createContext(null);
var Context_default$1 = OrderContext;

//#endregion
//#region node_modules/@rc-component/portal/es/useDom.js
var EMPTY_LIST$5 = [];
/**
* Will add `div` to document. Nest call will keep order
* @param render Render DOM in document
*/
function useDom(render$1, debug) {
	var _React$useState = import_react.useState(function() {
		if (!canUseDom()) return null;
		var defaultEle = document.createElement("div");
		if (debug) defaultEle.setAttribute("data-debug", debug);
		return defaultEle;
	}), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
	var appendedRef = import_react.useRef(false);
	var queueCreate = import_react.useContext(Context_default$1);
	var _React$useState3 = import_react.useState(EMPTY_LIST$5), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
	var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
		setQueue(function(origin) {
			return [appendFn].concat(_toConsumableArray(origin));
		});
	});
	function append$1() {
		if (!ele.parentElement) document.body.appendChild(ele);
		appendedRef.current = true;
	}
	function cleanup$1() {
		var _ele$parentElement;
		(_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 || _ele$parentElement.removeChild(ele);
		appendedRef.current = false;
	}
	useLayoutEffect_default(function() {
		if (render$1) if (queueCreate) queueCreate(append$1);
		else append$1();
		else cleanup$1();
		return cleanup$1;
	}, [render$1]);
	useLayoutEffect_default(function() {
		if (queue.length) {
			queue.forEach(function(appendFn) {
				return appendFn();
			});
			setQueue(EMPTY_LIST$5);
		}
	}, [queue]);
	return [ele, mergedQueueCreate];
}

//#endregion
//#region node_modules/rc-util/es/getScrollBarSize.js
var cached;
function measureScrollbarSize(ele) {
	var randomId = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7));
	var measureEle = document.createElement("div");
	measureEle.id = randomId;
	var measureStyle = measureEle.style;
	measureStyle.position = "absolute";
	measureStyle.left = "0";
	measureStyle.top = "0";
	measureStyle.width = "100px";
	measureStyle.height = "100px";
	measureStyle.overflow = "scroll";
	var fallbackWidth;
	var fallbackHeight;
	if (ele) {
		var targetStyle = getComputedStyle(ele);
		measureStyle.scrollbarColor = targetStyle.scrollbarColor;
		measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
		var webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
		var width = parseInt(webkitScrollbarStyle.width, 10);
		var height = parseInt(webkitScrollbarStyle.height, 10);
		try {
			var widthStyle = width ? "width: ".concat(webkitScrollbarStyle.width, ";") : "";
			var heightStyle = height ? "height: ".concat(webkitScrollbarStyle.height, ";") : "";
			updateCSS("\n#".concat(randomId, "::-webkit-scrollbar {\n").concat(widthStyle, "\n").concat(heightStyle, "\n}"), randomId);
		} catch (e$2) {
			console.error(e$2);
			fallbackWidth = width;
			fallbackHeight = height;
		}
	}
	document.body.appendChild(measureEle);
	var scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
	var scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
	document.body.removeChild(measureEle);
	removeCSS(randomId);
	return {
		width: scrollWidth,
		height: scrollHeight
	};
}
function getScrollBarSize(fresh) {
	if (typeof document === "undefined") return 0;
	if (fresh || cached === void 0) cached = measureScrollbarSize();
	return cached.width;
}
function getTargetScrollBarSize(target) {
	if (typeof document === "undefined" || !target || !(target instanceof Element)) return {
		width: 0,
		height: 0
	};
	return measureScrollbarSize(target);
}

//#endregion
//#region node_modules/@rc-component/portal/es/util.js
/**
* Test usage export. Do not use in your production
*/
function isBodyOverflowing() {
	return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}

//#endregion
//#region node_modules/@rc-component/portal/es/useScrollLocker.js
var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
var uuid$5 = 0;
function useScrollLocker(lock) {
	var mergedLock = !!lock;
	var _React$useState = import_react.useState(function() {
		uuid$5 += 1;
		return "".concat(UNIQUE_ID, "_").concat(uuid$5);
	}), _React$useState2 = _slicedToArray(_React$useState, 1), id = _React$useState2[0];
	useLayoutEffect_default(function() {
		if (mergedLock) {
			var scrollbarSize = getTargetScrollBarSize(document.body).width;
			var isOverflow = isBodyOverflowing();
			updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
		} else removeCSS(id);
		return function() {
			removeCSS(id);
		};
	}, [mergedLock, id]);
}

//#endregion
//#region node_modules/@rc-component/portal/es/mock.js
var inline = false;
function inlineMock(nextInline) {
	if (typeof nextInline === "boolean") inline = nextInline;
	return inline;
}

//#endregion
//#region node_modules/@rc-component/portal/es/Portal.js
var import_react_dom$7 = /* @__PURE__ */ __toESM(require_react_dom());
var getPortalContainer = function getPortalContainer$1(getContainer$1) {
	if (getContainer$1 === false) return false;
	if (!canUseDom() || !getContainer$1) return null;
	if (typeof getContainer$1 === "string") return document.querySelector(getContainer$1);
	if (typeof getContainer$1 === "function") return getContainer$1();
	return getContainer$1;
};
var Portal = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var open$2 = props.open, autoLock = props.autoLock, getContainer$1 = props.getContainer, debug = props.debug, _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
	var _React$useState = import_react.useState(open$2), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
	var mergedRender = shouldRender || open$2;
	warning_default(canUseDom() || !open$2, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR.");
	import_react.useEffect(function() {
		if (autoDestroy || open$2) setShouldRender(open$2);
	}, [open$2, autoDestroy]);
	var _React$useState3 = import_react.useState(function() {
		return getPortalContainer(getContainer$1);
	}), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
	import_react.useEffect(function() {
		var customizeContainer = getPortalContainer(getContainer$1);
		setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
	});
	var _useDom = useDom(mergedRender && !innerContainer, debug), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer$1 = _useDom2[0], queueCreate = _useDom2[1];
	var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer$1;
	useScrollLocker(autoLock && open$2 && canUseDom() && (mergedContainer === defaultContainer$1 || mergedContainer === document.body));
	var childRef = null;
	if (children && supportRef(children) && ref) childRef = children.ref;
	var mergedRef = useComposeRef(childRef, ref);
	if (!mergedRender || !canUseDom() || innerContainer === void 0) return null;
	var renderInline = mergedContainer === false || inlineMock();
	var reffedChildren = children;
	if (ref) reffedChildren = /* @__PURE__ */ import_react.cloneElement(children, { ref: mergedRef });
	return /* @__PURE__ */ import_react.createElement(Context_default$1.Provider, { value: queueCreate }, renderInline ? reffedChildren : /* @__PURE__ */ (0, import_react_dom$7.createPortal)(reffedChildren, mergedContainer));
});
Portal.displayName = "Portal";
var Portal_default = Portal;

//#endregion
//#region node_modules/@rc-component/portal/es/index.js
var es_default$6 = Portal_default;

//#endregion
//#region node_modules/rc-dialog/es/context.js
var RefContext$1 = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/rc-util/es/hooks/useId.js
function getUseId() {
	return _objectSpread2({}, import_react).useId;
}
var uuid$4 = 0;
var useOriginId = getUseId();
var useId_default = useOriginId ? function useId$2(id) {
	var reactId = useOriginId();
	if (id) return id;
	return reactId;
} : function useCompatId(id) {
	var _React$useState = import_react.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
	import_react.useEffect(function() {
		var nextId = uuid$4;
		uuid$4 += 1;
		setInnerId("rc_unique_".concat(nextId));
	}, []);
	if (id) return id;
	return innerId;
};

//#endregion
//#region node_modules/rc-dialog/es/util.js
function getMotionName(prefixCls, transitionName, animationName) {
	var motionName = transitionName;
	if (!motionName && animationName) motionName = "".concat(prefixCls, "-").concat(animationName);
	return motionName;
}
function getScroll$1(w, top) {
	var ret = w["page".concat(top ? "Y" : "X", "Offset")];
	var method$1 = "scroll".concat(top ? "Top" : "Left");
	if (typeof ret !== "number") {
		var d = w.document;
		ret = d.documentElement[method$1];
		if (typeof ret !== "number") ret = d.body[method$1];
	}
	return ret;
}
function offset$1(el) {
	var rect = el.getBoundingClientRect();
	var pos = {
		left: rect.left,
		top: rect.top
	};
	var doc = el.ownerDocument;
	var w = doc.defaultView || doc.parentWindow;
	pos.left += getScroll$1(w);
	pos.top += getScroll$1(w, true);
	return pos;
}

//#endregion
//#region node_modules/rc-dialog/es/Dialog/Content/MemoChildren.js
var MemoChildren_default = /* @__PURE__ */ import_react.memo(function(_ref) {
	return _ref.children;
}, function(_, _ref2) {
	return !_ref2.shouldUpdate;
});

//#endregion
//#region node_modules/rc-dialog/es/Dialog/Content/Panel.js
var import_classnames$252 = /* @__PURE__ */ __toESM(require_classnames());
var sentinelStyle$1 = {
	width: 0,
	height: 0,
	overflow: "hidden",
	outline: "none"
};
var entityStyle = { outline: "none" };
var Panel$3 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, className = props.className, style$1 = props.style, title = props.title, ariaId = props.ariaId, footer = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height, modalClassNames = props.classNames, modalStyles = props.styles;
	var _React$useContext = import_react.useContext(RefContext$1), panelRef = _React$useContext.panel;
	var mergedRef = useComposeRef(holderRef, panelRef);
	var sentinelStartRef = (0, import_react.useRef)();
	var sentinelEndRef = (0, import_react.useRef)();
	import_react.useImperativeHandle(ref, function() {
		return {
			focus: function focus() {
				var _sentinelStartRef$cur;
				(_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 || _sentinelStartRef$cur.focus({ preventScroll: true });
			},
			changeActive: function changeActive(next$1) {
				var _document = document, activeElement = _document.activeElement;
				if (next$1 && activeElement === sentinelEndRef.current) sentinelStartRef.current.focus({ preventScroll: true });
				else if (!next$1 && activeElement === sentinelStartRef.current) sentinelEndRef.current.focus({ preventScroll: true });
			}
		};
	});
	var contentStyle = {};
	if (width !== void 0) contentStyle.width = width;
	if (height !== void 0) contentStyle.height = height;
	var footerNode = footer ? /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$252.default)("".concat(prefixCls, "-footer"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.footer),
		style: _objectSpread2({}, modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.footer)
	}, footer) : null;
	var headerNode = title ? /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$252.default)("".concat(prefixCls, "-header"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.header),
		style: _objectSpread2({}, modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.header)
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-title"),
		id: ariaId
	}, title)) : null;
	var closableObj = (0, import_react.useMemo)(function() {
		if (_typeof(closable) === "object" && closable !== null) return closable;
		if (closable) return { closeIcon: closeIcon !== null && closeIcon !== void 0 ? closeIcon : /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-close-x") }) };
		return {};
	}, [
		closable,
		closeIcon,
		prefixCls
	]);
	var ariaProps = pickAttrs(closableObj, true);
	var closeBtnIsDisabled = _typeof(closable) === "object" && closable.disabled;
	var closerNode = closable ? /* @__PURE__ */ import_react.createElement("button", _extends({
		type: "button",
		onClick: onClose,
		"aria-label": "Close"
	}, ariaProps, {
		className: "".concat(prefixCls, "-close"),
		disabled: closeBtnIsDisabled
	}), closableObj.closeIcon) : null;
	var content = /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$252.default)("".concat(prefixCls, "-content"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.content),
		style: modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.content
	}, closerNode, headerNode, /* @__PURE__ */ import_react.createElement("div", _extends({
		className: (0, import_classnames$252.default)("".concat(prefixCls, "-body"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.body),
		style: _objectSpread2(_objectSpread2({}, bodyStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.body)
	}, bodyProps), children), footerNode);
	return /* @__PURE__ */ import_react.createElement("div", {
		key: "dialog-element",
		role: "dialog",
		"aria-labelledby": title ? ariaId : null,
		"aria-modal": "true",
		ref: mergedRef,
		style: _objectSpread2(_objectSpread2({}, style$1), contentStyle),
		className: (0, import_classnames$252.default)(prefixCls, className),
		onMouseDown,
		onMouseUp
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: sentinelStartRef,
		tabIndex: 0,
		style: entityStyle
	}, /* @__PURE__ */ import_react.createElement(MemoChildren_default, { shouldUpdate: visible || forceRender }, modalRender ? modalRender(content) : content)), /* @__PURE__ */ import_react.createElement("div", {
		tabIndex: 0,
		ref: sentinelEndRef,
		style: sentinelStyle$1
	}));
});
Panel$3.displayName = "Panel";
var Panel_default$2 = Panel$3;

//#endregion
//#region node_modules/rc-dialog/es/Dialog/Content/index.js
var import_classnames$251 = /* @__PURE__ */ __toESM(require_classnames());
var Content$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, title = props.title, style$1 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition$1 = props.mousePosition;
	var dialogRef = (0, import_react.useRef)();
	var _React$useState = import_react.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
	var contentStyle = {};
	if (transformOrigin) contentStyle.transformOrigin = transformOrigin;
	function onPrepare() {
		var elementOffset = offset$1(dialogRef.current);
		setTransformOrigin(mousePosition$1 && (mousePosition$1.x || mousePosition$1.y) ? "".concat(mousePosition$1.x - elementOffset.left, "px ").concat(mousePosition$1.y - elementOffset.top, "px") : "");
	}
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible,
		onVisibleChanged,
		onAppearPrepare: onPrepare,
		onEnterPrepare: onPrepare,
		forceRender,
		motionName,
		removeOnLeave: destroyOnClose,
		ref: dialogRef
	}, function(_ref, motionRef) {
		var motionClassName = _ref.className, motionStyle = _ref.style;
		return /* @__PURE__ */ import_react.createElement(Panel_default$2, _extends({}, props, {
			ref,
			title,
			ariaId,
			prefixCls,
			holderRef: motionRef,
			style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), style$1), contentStyle),
			className: (0, import_classnames$251.default)(className, motionClassName)
		}));
	});
});
Content$1.displayName = "Content";
var Content_default = Content$1;

//#endregion
//#region node_modules/rc-dialog/es/Dialog/Mask.js
var import_classnames$250 = /* @__PURE__ */ __toESM(require_classnames());
var Mask$2 = function Mask$3(props) {
	var prefixCls = props.prefixCls, style$1 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName, className = props.className;
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		key: "mask",
		visible,
		motionName,
		leavedClassName: "".concat(prefixCls, "-mask-hidden")
	}, function(_ref, ref) {
		var motionClassName = _ref.className, motionStyle = _ref.style;
		return /* @__PURE__ */ import_react.createElement("div", _extends({
			ref,
			style: _objectSpread2(_objectSpread2({}, motionStyle), style$1),
			className: (0, import_classnames$250.default)("".concat(prefixCls, "-mask"), motionClassName, className)
		}, maskProps));
	});
};
var Mask_default$1 = Mask$2;

//#endregion
//#region node_modules/rc-dialog/es/Dialog/index.js
var import_classnames$249 = /* @__PURE__ */ __toESM(require_classnames());
var Dialog = function Dialog$1(props) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose = props.onClose, afterOpenChange = props.afterOpenChange, afterClose = props.afterClose, transitionName = props.transitionName, animation = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName, modalClassNames = props.classNames, modalStyles = props.styles;
	[
		"wrapStyle",
		"bodyStyle",
		"maskStyle"
	].forEach(function(prop) {
		warning(!(prop in props), "".concat(prop, " is deprecated, please use styles instead."));
	});
	if ("wrapClassName" in props) warning(false, "wrapClassName is deprecated, please use classNames instead.");
	var lastOutSideActiveElementRef = (0, import_react.useRef)();
	var wrapperRef = (0, import_react.useRef)();
	var contentRef = (0, import_react.useRef)();
	var _React$useState = import_react.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
	var ariaId = useId_default();
	function saveLastOutSideActiveElementRef() {
		if (!contains(wrapperRef.current, document.activeElement)) lastOutSideActiveElementRef.current = document.activeElement;
	}
	function focusDialogContent() {
		if (!contains(wrapperRef.current, document.activeElement)) {
			var _contentRef$current;
			(_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
		}
	}
	function onDialogVisibleChanged(newVisible) {
		if (newVisible) focusDialogContent();
		else {
			setAnimatedVisible(false);
			if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
				try {
					lastOutSideActiveElementRef.current.focus({ preventScroll: true });
				} catch (e$2) {}
				lastOutSideActiveElementRef.current = null;
			}
			if (animatedVisible) afterClose === null || afterClose === void 0 || afterClose();
		}
		afterOpenChange === null || afterOpenChange === void 0 || afterOpenChange(newVisible);
	}
	function onInternalClose(e$2) {
		onClose === null || onClose === void 0 || onClose(e$2);
	}
	var contentClickRef = (0, import_react.useRef)(false);
	var contentTimeoutRef = (0, import_react.useRef)();
	var onContentMouseDown = function onContentMouseDown$1() {
		clearTimeout(contentTimeoutRef.current);
		contentClickRef.current = true;
	};
	var onContentMouseUp = function onContentMouseUp$1() {
		contentTimeoutRef.current = setTimeout(function() {
			contentClickRef.current = false;
		});
	};
	var onWrapperClick = null;
	if (maskClosable) onWrapperClick = function onWrapperClick$1(e$2) {
		if (contentClickRef.current) contentClickRef.current = false;
		else if (wrapperRef.current === e$2.target) onInternalClose(e$2);
	};
	function onWrapperKeyDown(e$2) {
		if (keyboard && e$2.keyCode === KeyCode_default.ESC) {
			e$2.stopPropagation();
			onInternalClose(e$2);
			return;
		}
		if (visible && e$2.keyCode === KeyCode_default.TAB) contentRef.current.changeActive(!e$2.shiftKey);
	}
	(0, import_react.useEffect)(function() {
		if (visible) {
			setAnimatedVisible(true);
			saveLastOutSideActiveElementRef();
		}
	}, [visible]);
	(0, import_react.useEffect)(function() {
		return function() {
			clearTimeout(contentTimeoutRef.current);
		};
	}, []);
	var mergedStyle = _objectSpread2(_objectSpread2(_objectSpread2({ zIndex }, wrapStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.wrapper), {}, { display: !animatedVisible ? "none" : null });
	return /* @__PURE__ */ import_react.createElement("div", _extends({ className: (0, import_classnames$249.default)("".concat(prefixCls, "-root"), rootClassName) }, pickAttrs(props, { data: true })), /* @__PURE__ */ import_react.createElement(Mask_default$1, {
		prefixCls,
		visible: mask && visible,
		motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
		style: _objectSpread2(_objectSpread2({ zIndex }, maskStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.mask),
		maskProps,
		className: modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.mask
	}), /* @__PURE__ */ import_react.createElement("div", _extends({
		tabIndex: -1,
		onKeyDown: onWrapperKeyDown,
		className: (0, import_classnames$249.default)("".concat(prefixCls, "-wrap"), wrapClassName, modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.wrapper),
		ref: wrapperRef,
		onClick: onWrapperClick,
		style: mergedStyle
	}, wrapProps), /* @__PURE__ */ import_react.createElement(Content_default, _extends({}, props, {
		onMouseDown: onContentMouseDown,
		onMouseUp: onContentMouseUp,
		ref: contentRef,
		closable,
		ariaId,
		prefixCls,
		visible: visible && animatedVisible,
		onClose: onInternalClose,
		onVisibleChanged: onDialogVisibleChanged,
		motionName: getMotionName(prefixCls, transitionName, animation)
	}))));
};
var Dialog_default = Dialog;

//#endregion
//#region node_modules/rc-dialog/es/DialogWrap.js
var DialogWrap = function DialogWrap$1(props) {
	var visible = props.visible, getContainer$1 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose, panelRef = props.panelRef;
	var _React$useState = import_react.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
	var refContext = import_react.useMemo(function() {
		return { panel: panelRef };
	}, [panelRef]);
	import_react.useEffect(function() {
		if (visible) setAnimatedVisible(true);
	}, [visible]);
	if (!forceRender && destroyOnClose && !animatedVisible) return null;
	return /* @__PURE__ */ import_react.createElement(RefContext$1.Provider, { value: refContext }, /* @__PURE__ */ import_react.createElement(es_default$6, {
		open: visible || forceRender || animatedVisible,
		autoDestroy: false,
		getContainer: getContainer$1,
		autoLock: visible || animatedVisible
	}, /* @__PURE__ */ import_react.createElement(Dialog_default, _extends({}, props, {
		destroyOnClose,
		afterClose: function afterClose() {
			_afterClose === null || _afterClose === void 0 || _afterClose();
			setAnimatedVisible(false);
		}
	}))));
};
DialogWrap.displayName = "Dialog";
var DialogWrap_default = DialogWrap;

//#endregion
//#region node_modules/rc-dialog/es/index.js
var es_default$16 = DialogWrap_default;

//#endregion
//#region node_modules/rc-field-form/es/FieldContext.js
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = function warningFunc$1() {
	warning_default(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
var Context = /* @__PURE__ */ import_react.createContext({
	getFieldValue: warningFunc,
	getFieldsValue: warningFunc,
	getFieldError: warningFunc,
	getFieldWarning: warningFunc,
	getFieldsError: warningFunc,
	isFieldsTouched: warningFunc,
	isFieldTouched: warningFunc,
	isFieldValidating: warningFunc,
	isFieldsValidating: warningFunc,
	resetFields: warningFunc,
	setFields: warningFunc,
	setFieldValue: warningFunc,
	setFieldsValue: warningFunc,
	validateFields: warningFunc,
	submit: warningFunc,
	getInternalHooks: function getInternalHooks() {
		warningFunc();
		return {
			dispatch: warningFunc,
			initEntityValue: warningFunc,
			registerField: warningFunc,
			useSubscribe: warningFunc,
			setInitialValues: warningFunc,
			destroyForm: warningFunc,
			setCallbacks: warningFunc,
			registerWatch: warningFunc,
			getFields: warningFunc,
			setValidateMessages: warningFunc,
			setPreserve: warningFunc,
			getInitialValue: warningFunc
		};
	}
});
var FieldContext_default = Context;

//#endregion
//#region node_modules/rc-field-form/es/ListContext.js
var ListContext$1 = /* @__PURE__ */ import_react.createContext(null);
var ListContext_default = ListContext$1;

//#endregion
//#region node_modules/rc-field-form/es/utils/typeUtil.js
function toArray$8(value) {
	if (value === void 0 || value === null) return [];
	return Array.isArray(value) ? value : [value];
}
function isFormInstance(form) {
	return form && !!form._init;
}

//#endregion
//#region node_modules/@rc-component/async-validator/es/messages.js
function newMessages() {
	return {
		default: "Validation error on field %s",
		required: "%s is required",
		enum: "%s must be one of %s",
		whitespace: "%s cannot be empty",
		date: {
			format: "%s date %s is invalid for format %s",
			parse: "%s date could not be parsed, %s is invalid ",
			invalid: "%s date %s is invalid"
		},
		types: {
			string: "%s is not a %s",
			method: "%s is not a %s (function)",
			array: "%s is not an %s",
			object: "%s is not an %s",
			number: "%s is not a %s",
			date: "%s is not a %s",
			boolean: "%s is not a %s",
			integer: "%s is not an %s",
			float: "%s is not a %s",
			regexp: "%s is not a valid %s",
			email: "%s is not a valid %s",
			url: "%s is not a valid %s",
			hex: "%s is not a valid %s"
		},
		string: {
			len: "%s must be exactly %s characters",
			min: "%s must be at least %s characters",
			max: "%s cannot be longer than %s characters",
			range: "%s must be between %s and %s characters"
		},
		number: {
			len: "%s must equal %s",
			min: "%s cannot be less than %s",
			max: "%s cannot be greater than %s",
			range: "%s must be between %s and %s"
		},
		array: {
			len: "%s must be exactly %s in length",
			min: "%s cannot be less than %s in length",
			max: "%s cannot be greater than %s in length",
			range: "%s must be between %s and %s in length"
		},
		pattern: { mismatch: "%s value %s does not match pattern %s" },
		clone: function clone() {
			var cloned = JSON.parse(JSON.stringify(this));
			cloned.clone = this.clone;
			return cloned;
		}
	};
}
var messages = newMessages();

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t$1) {
	try {
		return -1 !== Function.toString.call(t$1).indexOf("[native code]");
	} catch (n$1) {
		return "function" == typeof t$1;
	}
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t$1, e$2, r$1) {
	if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
	var o$2 = [null];
	o$2.push.apply(o$2, e$2);
	var p = new (t$1.bind.apply(t$1, o$2))();
	return r$1 && _setPrototypeOf(p, r$1.prototype), p;
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t$1) {
	var r$1 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
	return _wrapNativeSuper = function _wrapNativeSuper$1(t$2) {
		if (null === t$2 || !_isNativeFunction(t$2)) return t$2;
		if ("function" != typeof t$2) throw new TypeError("Super expression must either be null or a function");
		if (void 0 !== r$1) {
			if (r$1.has(t$2)) return r$1.get(t$2);
			r$1.set(t$2, Wrapper$2);
		}
		function Wrapper$2() {
			return _construct(t$2, arguments, _getPrototypeOf(this).constructor);
		}
		return Wrapper$2.prototype = Object.create(t$2.prototype, { constructor: {
			value: Wrapper$2,
			enumerable: !1,
			writable: !0,
			configurable: !0
		} }), _setPrototypeOf(Wrapper$2, t$2);
	}, _wrapNativeSuper(t$1);
}

//#endregion
//#region node_modules/@rc-component/async-validator/es/util.js
var formatRegExp = /%[sdj%]/g;
var warning$1 = function warning$4() {};
if (typeof process !== "undefined" && process.env && typeof window !== "undefined" && typeof document !== "undefined") warning$1 = function warning$4(type$2, errors) {
	if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
		if (errors.every(function(e$2) {
			return typeof e$2 === "string";
		})) console.warn(type$2, errors);
	}
};
function convertFieldsError(errors) {
	if (!errors || !errors.length) return null;
	var fields = {};
	errors.forEach(function(error) {
		var field = error.field;
		fields[field] = fields[field] || [];
		fields[field].push(error);
	});
	return fields;
}
function format$1(template) {
	for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
	var i = 0;
	var len = args.length;
	if (typeof template === "function") return template.apply(null, args);
	if (typeof template === "string") return template.replace(formatRegExp, function(x) {
		if (x === "%%") return "%";
		if (i >= len) return x;
		switch (x) {
			case "%s": return String(args[i++]);
			case "%d": return Number(args[i++]);
			case "%j":
				try {
					return JSON.stringify(args[i++]);
				} catch (_) {
					return "[Circular]";
				}
				break;
			default: return x;
		}
	});
	return template;
}
function isNativeStringType(type$2) {
	return type$2 === "string" || type$2 === "url" || type$2 === "hex" || type$2 === "email" || type$2 === "date" || type$2 === "pattern";
}
function isEmptyValue(value, type$2) {
	if (value === void 0 || value === null) return true;
	if (type$2 === "array" && Array.isArray(value) && !value.length) return true;
	if (isNativeStringType(type$2) && typeof value === "string" && !value) return true;
	return false;
}
function asyncParallelArray(arr, func, callback) {
	var results = [];
	var total = 0;
	var arrLength = arr.length;
	function count(errors) {
		results.push.apply(results, _toConsumableArray(errors || []));
		total++;
		if (total === arrLength) callback(results);
	}
	arr.forEach(function(a) {
		func(a, count);
	});
}
function asyncSerialArray(arr, func, callback) {
	var index$2 = 0;
	var arrLength = arr.length;
	function next$1(errors) {
		if (errors && errors.length) {
			callback(errors);
			return;
		}
		var original = index$2;
		index$2 = index$2 + 1;
		if (original < arrLength) func(arr[original], next$1);
		else callback([]);
	}
	next$1([]);
}
function flattenObjArr(objArr) {
	var ret = [];
	Object.keys(objArr).forEach(function(k) {
		ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
	});
	return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
	_inherits(AsyncValidationError$1, _Error);
	var _super = _createSuper(AsyncValidationError$1);
	function AsyncValidationError$1(errors, fields) {
		var _this;
		_classCallCheck(this, AsyncValidationError$1);
		_this = _super.call(this, "Async Validation Error");
		_defineProperty(_assertThisInitialized(_this), "errors", void 0);
		_defineProperty(_assertThisInitialized(_this), "fields", void 0);
		_this.errors = errors;
		_this.fields = fields;
		return _this;
	}
	return _createClass(AsyncValidationError$1);
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
	if (option.first) {
		var _pending = new Promise(function(resolve, reject) {
			var next$1 = function next$2(errors) {
				callback(errors);
				return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
			};
			var flattenArr = flattenObjArr(objArr);
			asyncSerialArray(flattenArr, func, next$1);
		});
		_pending.catch(function(e$2) {
			return e$2;
		});
		return _pending;
	}
	var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
	var objArrKeys = Object.keys(objArr);
	var objArrLength = objArrKeys.length;
	var total = 0;
	var results = [];
	var pending = new Promise(function(resolve, reject) {
		var next$1 = function next$2(errors) {
			results.push.apply(results, errors);
			total++;
			if (total === objArrLength) {
				callback(results);
				return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
			}
		};
		if (!objArrKeys.length) {
			callback(results);
			resolve(source);
		}
		objArrKeys.forEach(function(key) {
			var arr = objArr[key];
			if (firstFields.indexOf(key) !== -1) asyncSerialArray(arr, func, next$1);
			else asyncParallelArray(arr, func, next$1);
		});
	});
	pending.catch(function(e$2) {
		return e$2;
	});
	return pending;
}
function isErrorObj(obj) {
	return !!(obj && obj.message !== void 0);
}
function getValue(value, path$1) {
	var v = value;
	for (var i = 0; i < path$1.length; i++) {
		if (v == void 0) return v;
		v = v[path$1[i]];
	}
	return v;
}
function complementError(rule, source) {
	return function(oe) {
		var fieldValue;
		if (rule.fullFields) fieldValue = getValue(source, rule.fullFields);
		else fieldValue = source[oe.field || rule.fullField];
		if (isErrorObj(oe)) {
			oe.field = oe.field || rule.fullField;
			oe.fieldValue = fieldValue;
			return oe;
		}
		return {
			message: typeof oe === "function" ? oe() : oe,
			fieldValue,
			field: oe.field || rule.fullField
		};
	};
}
function deepMerge(target, source) {
	if (source) {
		for (var s in source) if (source.hasOwnProperty(s)) {
			var value = source[s];
			if (_typeof(value) === "object" && _typeof(target[s]) === "object") target[s] = _objectSpread2(_objectSpread2({}, target[s]), value);
			else target[s] = value;
		}
	}
	return target;
}

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/enum.js
var ENUM$1 = "enum";
var enumerable$1 = function enumerable$2(rule, value, source, errors, options) {
	rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
	if (rule[ENUM$1].indexOf(value) === -1) errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
};
var enum_default$1 = enumerable$1;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/pattern.js
var pattern$2 = function pattern$3(rule, value, source, errors, options) {
	if (rule.pattern) {
		if (rule.pattern instanceof RegExp) {
			rule.pattern.lastIndex = 0;
			if (!rule.pattern.test(value)) errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
		} else if (typeof rule.pattern === "string") {
			if (!new RegExp(rule.pattern).test(value)) errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
		}
	}
};
var pattern_default$1 = pattern$2;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/range.js
var range = function range$1(rule, value, source, errors, options) {
	var len = typeof rule.len === "number";
	var min = typeof rule.min === "number";
	var max = typeof rule.max === "number";
	var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	var val = value;
	var key = null;
	var num = typeof value === "number";
	var str = typeof value === "string";
	var arr = Array.isArray(value);
	if (num) key = "number";
	else if (str) key = "string";
	else if (arr) key = "array";
	if (!key) return false;
	if (arr) val = value.length;
	if (str) val = value.replace(spRegexp, "_").length;
	if (len) {
		if (val !== rule.len) errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
	} else if (min && !max && val < rule.min) errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
	else if (max && !min && val > rule.max) errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
	else if (min && max && (val < rule.min || val > rule.max)) errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
};
var range_default = range;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/required.js
var required$1 = function required$2(rule, value, source, errors, options, type$2) {
	if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type$2 || rule.type))) errors.push(format$1(options.messages.required, rule.fullField));
};
var required_default$1 = required$1;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/url.js
var urlReg;
var url_default = (function() {
	if (urlReg) return urlReg;
	var word = "[a-fA-F\\d:]";
	var b = function b$1(options) {
		return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
	};
	var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
	var v6seg = "[a-fA-F\\d]{1,4}";
	var v6List = [
		"(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
		"(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
		"(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
		"(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
		"(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
		"(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
		"(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
		"(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
	];
	var v6 = "(?:".concat(v6List.join("|"), ")").concat("(?:%[0-9a-zA-Z]{1,})?");
	var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
	var v4exact = new RegExp("^".concat(v4, "$"));
	var v6exact = new RegExp("^".concat(v6, "$"));
	var ip = function ip$1(options) {
		return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), "g");
	};
	ip.v4 = function(options) {
		return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), "g");
	};
	ip.v6 = function(options) {
		return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), "g");
	};
	var protocol = "(?:(?:[a-z]+:)?//)";
	var auth = "(?:\\S+(?::\\S*)?@)?";
	var ipv4 = ip.v4().source;
	var ipv6 = ip.v6().source;
	var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat("(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)").concat("(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*").concat("(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", ")").concat("(?::\\d{2,5})?").concat("(?:[/?#][^\\s\"]*)?");
	urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
	return urlReg;
});

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/type.js
var pattern$1 = {
	email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
	hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
	integer: function integer$1(value) {
		return types.number(value) && parseInt(value, 10) === value;
	},
	float: function float(value) {
		return types.number(value) && !types.integer(value);
	},
	array: function array$1(value) {
		return Array.isArray(value);
	},
	regexp: function regexp$3(value) {
		if (value instanceof RegExp) return true;
		try {
			return true;
		} catch (e$2) {
			return false;
		}
	},
	date: function date$1(value) {
		return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
	},
	number: function number$1(value) {
		if (isNaN(value)) return false;
		return typeof value === "number";
	},
	object: function object$1(value) {
		return _typeof(value) === "object" && !types.array(value);
	},
	method: function method$1(value) {
		return typeof value === "function";
	},
	email: function email(value) {
		return typeof value === "string" && value.length <= 320 && !!value.match(pattern$1.email);
	},
	url: function url(value) {
		return typeof value === "string" && value.length <= 2048 && !!value.match(url_default());
	},
	hex: function hex(value) {
		return typeof value === "string" && !!value.match(pattern$1.hex);
	}
};
var type$1 = function type$2(rule, value, source, errors, options) {
	if (rule.required && value === void 0) {
		required_default$1(rule, value, source, errors, options);
		return;
	}
	var custom = [
		"integer",
		"float",
		"array",
		"regexp",
		"object",
		"method",
		"email",
		"number",
		"date",
		"url",
		"hex"
	];
	var ruleType = rule.type;
	if (custom.indexOf(ruleType) > -1) {
		if (!types[ruleType](value)) errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
	} else if (ruleType && _typeof(value) !== rule.type) errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
};
var type_default$1 = type$1;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/whitespace.js
/**
*  Rule for validating whitespace.
*
*  @param rule The validation rule.
*  @param value The value of the field on the source object.
*  @param source The source object being validated.
*  @param errors An array of errors that this rule may add
*  validation errors to.
*  @param options The validation options.
*  @param options.messages The validation messages.
*/
var whitespace = function whitespace$2(rule, value, source, errors, options) {
	if (/^\s+$/.test(value) || value === "") errors.push(format$1(options.messages.whitespace, rule.fullField));
};
var whitespace_default = whitespace;

//#endregion
//#region node_modules/@rc-component/async-validator/es/rule/index.js
var rule_default = {
	required: required_default$1,
	whitespace: whitespace_default,
	type: type_default$1,
	range: range_default,
	enum: enum_default$1,
	pattern: pattern_default$1
};

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/any.js
var any = function any$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
	}
	callback(errors);
};
var any_default = any;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/array.js
var array = function array$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if ((value === void 0 || value === null) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options, "array");
		if (value !== void 0 && value !== null) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var array_default = array;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/boolean.js
var boolean = function boolean$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var boolean_default = boolean;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/date.js
var date = function date$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value, "date") && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (!isEmptyValue(value, "date")) {
			var dateObject;
			if (value instanceof Date) dateObject = value;
			else dateObject = new Date(value);
			rule_default.type(rule, dateObject, source, errors, options);
			if (dateObject) rule_default.range(rule, dateObject.getTime(), source, errors, options);
		}
	}
	callback(errors);
};
var date_default = date;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/enum.js
var ENUM = "enum";
var enumerable = function enumerable$2(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) rule_default[ENUM](rule, value, source, errors, options);
	}
	callback(errors);
};
var enum_default = enumerable;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/float.js
var floatFn = function floatFn$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var float_default = floatFn;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/integer.js
var integer = function integer$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var integer_default = integer;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/method.js
var method = function method$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var method_default = method;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/number.js
var number = function number$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (value === "") value = void 0;
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var number_default = number;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/object.js
var object = function object$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (value !== void 0) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var object_default = object;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/pattern.js
var pattern = function pattern$3(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value, "string") && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (!isEmptyValue(value, "string")) rule_default.pattern(rule, value, source, errors, options);
	}
	callback(errors);
};
var pattern_default = pattern;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/regexp.js
var regexp = function regexp$3(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options);
		if (!isEmptyValue(value)) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var regexp_default = regexp;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/required.js
var required = function required$2(rule, value, callback, source, options) {
	var errors = [];
	var type$2 = Array.isArray(value) ? "array" : _typeof(value);
	rule_default.required(rule, value, source, errors, options, type$2);
	callback(errors);
};
var required_default = required;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/string.js
var string = function string$1(rule, value, callback, source, options) {
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value, "string") && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options, "string");
		if (!isEmptyValue(value, "string")) {
			rule_default.type(rule, value, source, errors, options);
			rule_default.range(rule, value, source, errors, options);
			rule_default.pattern(rule, value, source, errors, options);
			if (rule.whitespace === true) rule_default.whitespace(rule, value, source, errors, options);
		}
	}
	callback(errors);
};
var string_default = string;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/type.js
var type = function type$2(rule, value, callback, source, options) {
	var ruleType = rule.type;
	var errors = [];
	if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
		if (isEmptyValue(value, ruleType) && !rule.required) return callback();
		rule_default.required(rule, value, source, errors, options, ruleType);
		if (!isEmptyValue(value, ruleType)) rule_default.type(rule, value, source, errors, options);
	}
	callback(errors);
};
var type_default = type;

//#endregion
//#region node_modules/@rc-component/async-validator/es/validator/index.js
var validator_default = {
	string: string_default,
	method: method_default,
	number: number_default,
	boolean: boolean_default,
	regexp: regexp_default,
	integer: integer_default,
	float: float_default,
	array: array_default,
	object: object_default,
	enum: enum_default,
	pattern: pattern_default,
	date: date_default,
	url: type_default,
	hex: type_default,
	email: type_default,
	required: required_default,
	any: any_default
};

//#endregion
//#region node_modules/@rc-component/async-validator/es/index.js
/**
*  Encapsulates a validation schema.
*
*  @param descriptor An object declaring validation rules
*  for this schema.
*/
var Schema = /* @__PURE__ */ function() {
	function Schema$1(descriptor) {
		_classCallCheck(this, Schema$1);
		_defineProperty(this, "rules", null);
		_defineProperty(this, "_messages", messages);
		this.define(descriptor);
	}
	_createClass(Schema$1, [
		{
			key: "define",
			value: function define$1(rules) {
				var _this = this;
				if (!rules) throw new Error("Cannot configure a schema with no rules");
				if (_typeof(rules) !== "object" || Array.isArray(rules)) throw new Error("Rules must be an object");
				this.rules = {};
				Object.keys(rules).forEach(function(name) {
					var item = rules[name];
					_this.rules[name] = Array.isArray(item) ? item : [item];
				});
			}
		},
		{
			key: "messages",
			value: function messages$1(_messages) {
				if (_messages) this._messages = deepMerge(newMessages(), _messages);
				return this._messages;
			}
		},
		{
			key: "validate",
			value: function validate(source_) {
				var _this2 = this;
				var o$2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
				var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {};
				var source = source_;
				var options = o$2;
				var callback = oc;
				if (typeof options === "function") {
					callback = options;
					options = {};
				}
				if (!this.rules || Object.keys(this.rules).length === 0) {
					if (callback) callback(null, source);
					return Promise.resolve(source);
				}
				function complete(results) {
					var errors = [];
					var fields = {};
					function add(e$2) {
						if (Array.isArray(e$2)) {
							var _errors;
							errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e$2));
						} else errors.push(e$2);
					}
					for (var i = 0; i < results.length; i++) add(results[i]);
					if (!errors.length) callback(null, source);
					else {
						fields = convertFieldsError(errors);
						callback(errors, fields);
					}
				}
				if (options.messages) {
					var messages$1 = this.messages();
					if (messages$1 === messages) messages$1 = newMessages();
					deepMerge(messages$1, options.messages);
					options.messages = messages$1;
				} else options.messages = this.messages();
				var series = {};
				(options.keys || Object.keys(this.rules)).forEach(function(z) {
					var arr = _this2.rules[z];
					var value = source[z];
					arr.forEach(function(r$1) {
						var rule = r$1;
						if (typeof rule.transform === "function") {
							if (source === source_) source = _objectSpread2({}, source);
							value = source[z] = rule.transform(value);
							if (value !== void 0 && value !== null) rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof(value));
						}
						if (typeof rule === "function") rule = { validator: rule };
						else rule = _objectSpread2({}, rule);
						rule.validator = _this2.getValidationMethod(rule);
						if (!rule.validator) return;
						rule.field = z;
						rule.fullField = rule.fullField || z;
						rule.type = _this2.getType(rule);
						series[z] = series[z] || [];
						series[z].push({
							rule,
							value,
							source,
							field: z
						});
					});
				});
				var errorFields = {};
				return asyncMap(series, options, function(data, doIt) {
					var rule = data.rule;
					var deep = (rule.type === "object" || rule.type === "array") && (_typeof(rule.fields) === "object" || _typeof(rule.defaultField) === "object");
					deep = deep && (rule.required || !rule.required && data.value);
					rule.field = data.field;
					function addFullField(key, schema) {
						return _objectSpread2(_objectSpread2({}, schema), {}, {
							fullField: "".concat(rule.fullField, ".").concat(key),
							fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
						});
					}
					function cb() {
						var e$2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
						var errorList = Array.isArray(e$2) ? e$2 : [e$2];
						if (!options.suppressWarning && errorList.length) Schema$1.warning("async-validator:", errorList);
						if (errorList.length && rule.message !== void 0) errorList = [].concat(rule.message);
						var filledErrors = errorList.map(complementError(rule, source));
						if (options.first && filledErrors.length) {
							errorFields[rule.field] = 1;
							return doIt(filledErrors);
						}
						if (!deep) doIt(filledErrors);
						else {
							if (rule.required && !data.value) {
								if (rule.message !== void 0) filledErrors = [].concat(rule.message).map(complementError(rule, source));
								else if (options.error) filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
								return doIt(filledErrors);
							}
							var fieldsSchema = {};
							if (rule.defaultField) Object.keys(data.value).map(function(key) {
								fieldsSchema[key] = rule.defaultField;
							});
							fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data.rule.fields);
							var paredFieldsSchema = {};
							Object.keys(fieldsSchema).forEach(function(field) {
								var fieldSchema = fieldsSchema[field];
								paredFieldsSchema[field] = (Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema]).map(addFullField.bind(null, field));
							});
							var schema = new Schema$1(paredFieldsSchema);
							schema.messages(options.messages);
							if (data.rule.options) {
								data.rule.options.messages = options.messages;
								data.rule.options.error = options.error;
							}
							schema.validate(data.value, data.rule.options || options, function(errs) {
								var finalErrors = [];
								if (filledErrors && filledErrors.length) finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
								if (errs && errs.length) finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
								doIt(finalErrors.length ? finalErrors : null);
							});
						}
					}
					var res;
					if (rule.asyncValidator) res = rule.asyncValidator(rule, data.value, cb, data.source, options);
					else if (rule.validator) {
						try {
							res = rule.validator(rule, data.value, cb, data.source, options);
						} catch (error) {
							var _console$error, _console;
							(_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
							if (!options.suppressValidatorError) setTimeout(function() {
								throw error;
							}, 0);
							cb(error.message);
						}
						if (res === true) cb();
						else if (res === false) cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
						else if (res instanceof Array) cb(res);
						else if (res instanceof Error) cb(res.message);
					}
					if (res && res.then) res.then(function() {
						return cb();
					}, function(e$2) {
						return cb(e$2);
					});
				}, function(results) {
					complete(results);
				}, source);
			}
		},
		{
			key: "getType",
			value: function getType(rule) {
				if (rule.type === void 0 && rule.pattern instanceof RegExp) rule.type = "pattern";
				if (typeof rule.validator !== "function" && rule.type && !validator_default.hasOwnProperty(rule.type)) throw new Error(format$1("Unknown rule type %s", rule.type));
				return rule.type || "string";
			}
		},
		{
			key: "getValidationMethod",
			value: function getValidationMethod(rule) {
				if (typeof rule.validator === "function") return rule.validator;
				var keys$1 = Object.keys(rule);
				var messageIndex = keys$1.indexOf("message");
				if (messageIndex !== -1) keys$1.splice(messageIndex, 1);
				if (keys$1.length === 1 && keys$1[0] === "required") return validator_default.required;
				return validator_default[this.getType(rule)] || void 0;
			}
		}
	]);
	return Schema$1;
}();
_defineProperty(Schema, "register", function register(type$2, validator) {
	if (typeof validator !== "function") throw new Error("Cannot register a validator by type, validator is not a function");
	validator_default[type$2] = validator;
});
_defineProperty(Schema, "warning", warning$1);
_defineProperty(Schema, "messages", messages);
_defineProperty(Schema, "validators", validator_default);
var es_default$34 = Schema;

//#endregion
//#region node_modules/rc-field-form/es/utils/messages.js
var typeTemplate = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
	default: "Validation error on field '${name}'",
	required: "'${name}' is required",
	enum: "'${name}' must be one of [${enum}]",
	whitespace: "'${name}' cannot be empty",
	date: {
		format: "'${name}' is invalid for format date",
		parse: "'${name}' could not be parsed as date",
		invalid: "'${name}' is invalid date"
	},
	types: {
		string: typeTemplate,
		method: typeTemplate,
		array: typeTemplate,
		object: typeTemplate,
		number: typeTemplate,
		date: typeTemplate,
		boolean: typeTemplate,
		integer: typeTemplate,
		float: typeTemplate,
		regexp: typeTemplate,
		email: typeTemplate,
		url: typeTemplate,
		hex: typeTemplate
	},
	string: {
		len: "'${name}' must be exactly ${len} characters",
		min: "'${name}' must be at least ${min} characters",
		max: "'${name}' cannot be longer than ${max} characters",
		range: "'${name}' must be between ${min} and ${max} characters"
	},
	number: {
		len: "'${name}' must equal ${len}",
		min: "'${name}' cannot be less than ${min}",
		max: "'${name}' cannot be greater than ${max}",
		range: "'${name}' must be between ${min} and ${max}"
	},
	array: {
		len: "'${name}' must be exactly ${len} in length",
		min: "'${name}' cannot be less than ${min} in length",
		max: "'${name}' cannot be greater than ${max} in length",
		range: "'${name}' must be between ${min} and ${max} in length"
	},
	pattern: { mismatch: "'${name}' does not match pattern ${pattern}" }
};

//#endregion
//#region node_modules/rc-field-form/es/utils/validateUtil.js
var AsyncValidator = es_default$34;
/**
* Replace with template.
*   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo
*/
function replaceMessage(template, kv) {
	return template.replace(/\\?\$\{\w+\}/g, function(str) {
		if (str.startsWith("\\")) return str.slice(1);
		var key = str.slice(2, -1);
		return kv[key];
	});
}
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
function validateRule(_x, _x2, _x3, _x4, _x5) {
	return _validateRule.apply(this, arguments);
}
/**
* We use `async-validator` to validate the value.
* But only check one value in a time to avoid namePath validate issue.
*/
function _validateRule() {
	_validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
		var cloneRule, originValidator, subRuleField, validator, messages$1, result, subResults, kv, fillVariableResult;
		return _regeneratorRuntime().wrap(function _callee2$(_context2) {
			while (1) switch (_context2.prev = _context2.next) {
				case 0:
					cloneRule = _objectSpread2({}, rule);
					delete cloneRule.ruleIndex;
					AsyncValidator.warning = function() {};
					if (cloneRule.validator) {
						originValidator = cloneRule.validator;
						cloneRule.validator = function() {
							try {
								return originValidator.apply(void 0, arguments);
							} catch (error) {
								console.error(error);
								return Promise.reject(CODE_LOGIC_ERROR);
							}
						};
					}
					subRuleField = null;
					if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
						subRuleField = cloneRule.defaultField;
						delete cloneRule.defaultField;
					}
					validator = new AsyncValidator(_defineProperty({}, name, [cloneRule]));
					messages$1 = merge$1(defaultValidateMessages, options.validateMessages);
					validator.messages(messages$1);
					result = [];
					_context2.prev = 10;
					_context2.next = 13;
					return Promise.resolve(validator.validate(_defineProperty({}, name, value), _objectSpread2({}, options)));
				case 13:
					_context2.next = 18;
					break;
				case 15:
					_context2.prev = 15;
					_context2.t0 = _context2["catch"](10);
					if (_context2.t0.errors) result = _context2.t0.errors.map(function(_ref4, index$2) {
						var message$1 = _ref4.message;
						var mergedMessage = message$1 === CODE_LOGIC_ERROR ? messages$1.default : message$1;
						return /* @__PURE__ */ import_react.isValidElement(mergedMessage) ? /* @__PURE__ */ import_react.cloneElement(mergedMessage, { key: "error_".concat(index$2) }) : mergedMessage;
					});
				case 18:
					if (!(!result.length && subRuleField)) {
						_context2.next = 23;
						break;
					}
					_context2.next = 21;
					return Promise.all(value.map(function(subValue, i) {
						return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
					}));
				case 21:
					subResults = _context2.sent;
					return _context2.abrupt("return", subResults.reduce(function(prev$1, errors) {
						return [].concat(_toConsumableArray(prev$1), _toConsumableArray(errors));
					}, []));
				case 23:
					kv = _objectSpread2(_objectSpread2({}, rule), {}, {
						name,
						enum: (rule.enum || []).join(", ")
					}, messageVariables);
					fillVariableResult = result.map(function(error) {
						if (typeof error === "string") return replaceMessage(error, kv);
						return error;
					});
					return _context2.abrupt("return", fillVariableResult);
				case 26:
				case "end": return _context2.stop();
			}
		}, _callee2, null, [[10, 15]]);
	}));
	return _validateRule.apply(this, arguments);
}
function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
	var name = namePath.join(".");
	var filledRules = rules.map(function(currentRule, ruleIndex) {
		var originValidatorFunc = currentRule.validator;
		var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, { ruleIndex });
		if (originValidatorFunc) cloneRule.validator = function(rule, val, callback) {
			var hasPromise = false;
			var promise = originValidatorFunc(rule, val, function wrappedCallback() {
				for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
				Promise.resolve().then(function() {
					warning_default(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
					if (!hasPromise) callback.apply(void 0, args);
				});
			});
			hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
			/**
			* 1. Use promise as the first priority.
			* 2. If promise not exist, use callback with warning instead
			*/
			warning_default(hasPromise, "`callback` is deprecated. Please return a promise instead.");
			if (hasPromise) promise.then(function() {
				callback();
			}).catch(function(err) {
				callback(err || " ");
			});
		};
		return cloneRule;
	}).sort(function(_ref, _ref2) {
		var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
		var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
		if (!!w1 === !!w2) return i1 - i2;
		if (w1) return 1;
		return -1;
	});
	var summaryPromise;
	if (validateFirst === true) summaryPromise = new Promise(/* @__PURE__ */ function() {
		var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
			var i, rule, errors;
			return _regeneratorRuntime().wrap(function _callee$(_context) {
				while (1) switch (_context.prev = _context.next) {
					case 0: i = 0;
					case 1:
						if (!(i < filledRules.length)) {
							_context.next = 12;
							break;
						}
						rule = filledRules[i];
						_context.next = 5;
						return validateRule(name, value, rule, options, messageVariables);
					case 5:
						errors = _context.sent;
						if (!errors.length) {
							_context.next = 9;
							break;
						}
						reject([{
							errors,
							rule
						}]);
						return _context.abrupt("return");
					case 9:
						i += 1;
						_context.next = 1;
						break;
					case 12: resolve([]);
					case 13:
					case "end": return _context.stop();
				}
			}, _callee);
		}));
		return function(_x6, _x7) {
			return _ref3.apply(this, arguments);
		};
	}());
	else {
		var rulePromises = filledRules.map(function(rule) {
			return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
				return {
					errors,
					rule
				};
			});
		});
		summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
			return Promise.reject(errors);
		});
	}
	summaryPromise.catch(function(e$2) {
		return e$2;
	});
	return summaryPromise;
}
function finishOnAllFailed(_x8) {
	return _finishOnAllFailed.apply(this, arguments);
}
function _finishOnAllFailed() {
	_finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
		return _regeneratorRuntime().wrap(function _callee3$(_context3) {
			while (1) switch (_context3.prev = _context3.next) {
				case 0: return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
					var _ref5;
					return (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
				}));
				case 1:
				case "end": return _context3.stop();
			}
		}, _callee3);
	}));
	return _finishOnAllFailed.apply(this, arguments);
}
function finishOnFirstFailed(_x9) {
	return _finishOnFirstFailed.apply(this, arguments);
}
function _finishOnFirstFailed() {
	_finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
		var count;
		return _regeneratorRuntime().wrap(function _callee4$(_context4) {
			while (1) switch (_context4.prev = _context4.next) {
				case 0:
					count = 0;
					return _context4.abrupt("return", new Promise(function(resolve) {
						rulePromises.forEach(function(promise) {
							promise.then(function(ruleError) {
								if (ruleError.errors.length) resolve([ruleError]);
								count += 1;
								if (count === rulePromises.length) resolve([]);
							});
						});
					}));
				case 2:
				case "end": return _context4.stop();
			}
		}, _callee4);
	}));
	return _finishOnFirstFailed.apply(this, arguments);
}

//#endregion
//#region node_modules/rc-field-form/es/utils/valueUtil.js
/**
* Convert name to internal supported format.
* This function should keep since we still thinking if need support like `a.b.c` format.
* 'a' => ['a']
* 123 => [123]
* ['a', 123] => ['a', 123]
*/
function getNamePath(path$1) {
	return toArray$8(path$1);
}
function cloneByNamePathList(store, namePathList) {
	var newStore = {};
	namePathList.forEach(function(namePath) {
		var value = get(store, namePath);
		newStore = set(newStore, namePath, value);
	});
	return newStore;
}
/**
* Check if `namePathList` includes `namePath`.
* @param namePathList A list of `InternalNamePath[]`
* @param namePath Compare `InternalNamePath`
* @param partialMatch True will make `[a, b]` match `[a, b, c]`
*/
function containsNamePath(namePathList, namePath) {
	var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
	return namePathList && namePathList.some(function(path$1) {
		return matchNamePath(namePath, path$1, partialMatch);
	});
}
/**
* Check if `namePath` is super set or equal of `subNamePath`.
* @param namePath A list of `InternalNamePath[]`
* @param subNamePath Compare `InternalNamePath`
* @param partialMatch True will make `[a, b]` match `[a, b, c]`
*/
function matchNamePath(namePath, subNamePath) {
	var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
	if (!namePath || !subNamePath) return false;
	if (!partialMatch && namePath.length !== subNamePath.length) return false;
	return subNamePath.every(function(nameUnit, i) {
		return namePath[i] === nameUnit;
	});
}
function isSimilar(source, target) {
	if (source === target) return true;
	if (!source && target || source && !target) return false;
	if (!source || !target || _typeof(source) !== "object" || _typeof(target) !== "object") return false;
	var sourceKeys = Object.keys(source);
	var targetKeys = Object.keys(target);
	var keys$1 = new Set([].concat(sourceKeys, targetKeys));
	return _toConsumableArray(keys$1).every(function(key) {
		var sourceValue = source[key];
		var targetValue = target[key];
		if (typeof sourceValue === "function" && typeof targetValue === "function") return true;
		return sourceValue === targetValue;
	});
}
function defaultGetValueFromEvent(valuePropName) {
	var event = arguments.length <= 1 ? void 0 : arguments[1];
	if (event && event.target && _typeof(event.target) === "object" && valuePropName in event.target) return event.target[valuePropName];
	return event;
}
/**
* Moves an array item from one position in an array to another.
*
* Note: This is a pure function so a new array will be returned, instead
* of altering the array argument.
*
* @param array         Array in which to move an item.         (required)
* @param moveIndex     The index of the item to move.          (required)
* @param toIndex       The index to move item at moveIndex to. (required)
*/
function move(array$1, moveIndex, toIndex) {
	var length$1 = array$1.length;
	if (moveIndex < 0 || moveIndex >= length$1 || toIndex < 0 || toIndex >= length$1) return array$1;
	var item = array$1[moveIndex];
	var diff = moveIndex - toIndex;
	if (diff > 0) return [].concat(_toConsumableArray(array$1.slice(0, toIndex)), [item], _toConsumableArray(array$1.slice(toIndex, moveIndex)), _toConsumableArray(array$1.slice(moveIndex + 1, length$1)));
	if (diff < 0) return [].concat(_toConsumableArray(array$1.slice(0, moveIndex)), _toConsumableArray(array$1.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array$1.slice(toIndex + 1, length$1)));
	return array$1;
}

//#endregion
//#region node_modules/rc-field-form/es/Field.js
var _excluded$68 = ["name"];
var EMPTY_ERRORS = [];
function requireUpdate(shouldUpdate, prev$1, next$1, prevValue, nextValue, info) {
	if (typeof shouldUpdate === "function") return shouldUpdate(prev$1, next$1, "source" in info ? { source: info.source } : {});
	return prevValue !== nextValue;
}
var Field = /* @__PURE__ */ function(_React$Component) {
	_inherits(Field$1, _React$Component);
	var _super = _createSuper(Field$1);
	function Field$1(props) {
		var _this;
		_classCallCheck(this, Field$1);
		_this = _super.call(this, props);
		_defineProperty(_assertThisInitialized(_this), "state", { resetCount: 0 });
		_defineProperty(_assertThisInitialized(_this), "cancelRegisterFunc", null);
		_defineProperty(_assertThisInitialized(_this), "mounted", false);
		/**
		* Follow state should not management in State since it will async update by React.
		* This makes first render of form can not get correct state value.
		*/
		_defineProperty(_assertThisInitialized(_this), "touched", false);
		/**
		* Mark when touched & validated. Currently only used for `dependencies`.
		* Note that we do not think field with `initialValue` is dirty
		* but this will be by `isFieldDirty` func.
		*/
		_defineProperty(_assertThisInitialized(_this), "dirty", false);
		_defineProperty(_assertThisInitialized(_this), "validatePromise", void 0);
		_defineProperty(_assertThisInitialized(_this), "prevValidating", void 0);
		_defineProperty(_assertThisInitialized(_this), "errors", EMPTY_ERRORS);
		_defineProperty(_assertThisInitialized(_this), "warnings", EMPTY_ERRORS);
		_defineProperty(_assertThisInitialized(_this), "cancelRegister", function() {
			var _this$props = _this.props, preserve$1 = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
			if (_this.cancelRegisterFunc) _this.cancelRegisterFunc(isListField, preserve$1, getNamePath(name));
			_this.cancelRegisterFunc = null;
		});
		_defineProperty(_assertThisInitialized(_this), "getNamePath", function() {
			var _this$props2 = _this.props, name = _this$props2.name;
			var _fieldContext$prefixN = _this$props2.fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
			return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
		});
		_defineProperty(_assertThisInitialized(_this), "getRules", function() {
			var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
			return rules.map(function(rule) {
				if (typeof rule === "function") return rule(fieldContext);
				return rule;
			});
		});
		_defineProperty(_assertThisInitialized(_this), "refresh", function() {
			if (!_this.mounted) return;
			/**
			* Clean up current node.
			*/
			_this.setState(function(_ref) {
				return { resetCount: _ref.resetCount + 1 };
			});
		});
		_defineProperty(_assertThisInitialized(_this), "metaCache", null);
		_defineProperty(_assertThisInitialized(_this), "triggerMetaEvent", function(destroy$2) {
			var onMetaChange = _this.props.onMetaChange;
			if (onMetaChange) {
				var _meta = _objectSpread2(_objectSpread2({}, _this.getMeta()), {}, { destroy: destroy$2 });
				if (!isEqual_default(_this.metaCache, _meta)) onMetaChange(_meta);
				_this.metaCache = _meta;
			} else _this.metaCache = null;
		});
		_defineProperty(_assertThisInitialized(_this), "onStoreChange", function(prevStore, namePathList, info) {
			var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
			var store = info.store;
			var namePath = _this.getNamePath();
			var prevValue = _this.getValue(prevStore);
			var curValue = _this.getValue(store);
			var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
			if (info.type === "valueUpdate" && info.source === "external" && !isEqual_default(prevValue, curValue)) {
				_this.touched = true;
				_this.dirty = true;
				_this.validatePromise = null;
				_this.errors = EMPTY_ERRORS;
				_this.warnings = EMPTY_ERRORS;
				_this.triggerMetaEvent();
			}
			switch (info.type) {
				case "reset":
					if (!namePathList || namePathMatch) {
						_this.touched = false;
						_this.dirty = false;
						_this.validatePromise = void 0;
						_this.errors = EMPTY_ERRORS;
						_this.warnings = EMPTY_ERRORS;
						_this.triggerMetaEvent();
						onReset === null || onReset === void 0 || onReset();
						_this.refresh();
						return;
					}
					break;
				case "remove":
					if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
						_this.reRender();
						return;
					}
					break;
				case "setField":
					var data = info.data;
					if (namePathMatch) {
						if ("touched" in data) _this.touched = data.touched;
						if ("validating" in data && !("originRCField" in data)) _this.validatePromise = data.validating ? Promise.resolve([]) : null;
						if ("errors" in data) _this.errors = data.errors || EMPTY_ERRORS;
						if ("warnings" in data) _this.warnings = data.warnings || EMPTY_ERRORS;
						_this.dirty = true;
						_this.triggerMetaEvent();
						_this.reRender();
						return;
					} else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
						_this.reRender();
						return;
					}
					if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
						_this.reRender();
						return;
					}
					break;
				case "dependenciesUpdate":
					if (dependencies.map(getNamePath).some(function(dependency) {
						return containsNamePath(info.relatedFields, dependency);
					})) {
						_this.reRender();
						return;
					}
					break;
				default:
					if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
						_this.reRender();
						return;
					}
					break;
			}
			if (shouldUpdate === true) _this.reRender();
		});
		_defineProperty(_assertThisInitialized(_this), "validateRules", function(options) {
			var namePath = _this.getNamePath();
			var currentValue = _this.getValue();
			var _ref2 = options || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;
			var rootPromise = Promise.resolve().then(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
				var _this$props5, _this$props5$validate, validateFirst, messageVariables, validateDebounce, filteredRules, promise;
				return _regeneratorRuntime().wrap(function _callee$(_context) {
					while (1) switch (_context.prev = _context.next) {
						case 0:
							if (_this.mounted) {
								_context.next = 2;
								break;
							}
							return _context.abrupt("return", []);
						case 2:
							_this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables, validateDebounce = _this$props5.validateDebounce;
							filteredRules = _this.getRules();
							if (triggerName) filteredRules = filteredRules.filter(function(rule) {
								return rule;
							}).filter(function(rule) {
								var validateTrigger = rule.validateTrigger;
								if (!validateTrigger) return true;
								return toArray$8(validateTrigger).includes(triggerName);
							});
							if (!(validateDebounce && triggerName)) {
								_context.next = 10;
								break;
							}
							_context.next = 8;
							return new Promise(function(resolve) {
								setTimeout(resolve, validateDebounce);
							});
						case 8:
							if (!(_this.validatePromise !== rootPromise)) {
								_context.next = 10;
								break;
							}
							return _context.abrupt("return", []);
						case 10:
							promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
							promise.catch(function(e$2) {
								return e$2;
							}).then(function() {
								var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
								if (_this.validatePromise === rootPromise) {
									var _ruleErrors$forEach;
									_this.validatePromise = null;
									var nextErrors = [];
									var nextWarnings = [];
									(_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref4) {
										var warningOnly = _ref4.rule.warningOnly, _ref4$errors = _ref4.errors, errors = _ref4$errors === void 0 ? EMPTY_ERRORS : _ref4$errors;
										if (warningOnly) nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
										else nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
									});
									_this.errors = nextErrors;
									_this.warnings = nextWarnings;
									_this.triggerMetaEvent();
									_this.reRender();
								}
							});
							return _context.abrupt("return", promise);
						case 13:
						case "end": return _context.stop();
					}
				}, _callee);
			})));
			if (validateOnly) return rootPromise;
			_this.validatePromise = rootPromise;
			_this.dirty = true;
			_this.errors = EMPTY_ERRORS;
			_this.warnings = EMPTY_ERRORS;
			_this.triggerMetaEvent();
			_this.reRender();
			return rootPromise;
		});
		_defineProperty(_assertThisInitialized(_this), "isFieldValidating", function() {
			return !!_this.validatePromise;
		});
		_defineProperty(_assertThisInitialized(_this), "isFieldTouched", function() {
			return _this.touched;
		});
		_defineProperty(_assertThisInitialized(_this), "isFieldDirty", function() {
			if (_this.dirty || _this.props.initialValue !== void 0) return true;
			var _fieldContext$getInte = _this.props.fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
			if (getInitialValue(_this.getNamePath()) !== void 0) return true;
			return false;
		});
		_defineProperty(_assertThisInitialized(_this), "getErrors", function() {
			return _this.errors;
		});
		_defineProperty(_assertThisInitialized(_this), "getWarnings", function() {
			return _this.warnings;
		});
		_defineProperty(_assertThisInitialized(_this), "isListField", function() {
			return _this.props.isListField;
		});
		_defineProperty(_assertThisInitialized(_this), "isList", function() {
			return _this.props.isList;
		});
		_defineProperty(_assertThisInitialized(_this), "isPreserve", function() {
			return _this.props.preserve;
		});
		_defineProperty(_assertThisInitialized(_this), "getMeta", function() {
			_this.prevValidating = _this.isFieldValidating();
			return {
				touched: _this.isFieldTouched(),
				validating: _this.prevValidating,
				errors: _this.errors,
				warnings: _this.warnings,
				name: _this.getNamePath(),
				validated: _this.validatePromise === null
			};
		});
		_defineProperty(_assertThisInitialized(_this), "getOnlyChild", function(children) {
			if (typeof children === "function") {
				var _meta2 = _this.getMeta();
				return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), _meta2, _this.props.fieldContext))), {}, { isFunction: true });
			}
			var childList = toArray(children);
			if (childList.length !== 1 || !/* @__PURE__ */ import_react.isValidElement(childList[0])) return {
				child: childList,
				isFunction: false
			};
			return {
				child: childList[0],
				isFunction: false
			};
		});
		_defineProperty(_assertThisInitialized(_this), "getValue", function(store) {
			var getFieldsValue = _this.props.fieldContext.getFieldsValue;
			var namePath = _this.getNamePath();
			return get(store || getFieldsValue(true), namePath);
		});
		_defineProperty(_assertThisInitialized(_this), "getControlled", function() {
			var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
			var _this$props6 = _this.props, name = _this$props6.name, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize$1 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
			var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
			var namePath = _this.getNamePath();
			var getInternalHooks$1 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
			var _getInternalHooks = getInternalHooks$1(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
			var value = _this.getValue();
			var mergedGetValueProps = getValueProps || function(val) {
				return _defineProperty({}, valuePropName, val);
			};
			var originTriggerFunc = childProps[trigger];
			var valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
			if (valueProps) Object.keys(valueProps).forEach(function(key) {
				warning_default(typeof valueProps[key] !== "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(key, ")"));
			});
			var control = _objectSpread2(_objectSpread2({}, childProps), valueProps);
			control[trigger] = function() {
				_this.touched = true;
				_this.dirty = true;
				_this.triggerMetaEvent();
				var newValue;
				for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
				if (getValueFromEvent) newValue = getValueFromEvent.apply(void 0, args);
				else newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
				if (normalize$1) newValue = normalize$1(newValue, value, getFieldsValue(true));
				if (newValue !== value) dispatch({
					type: "updateValue",
					namePath,
					value: newValue
				});
				if (originTriggerFunc) originTriggerFunc.apply(void 0, args);
			};
			toArray$8(mergedValidateTrigger || []).forEach(function(triggerName) {
				var originTrigger = control[triggerName];
				control[triggerName] = function() {
					if (originTrigger) originTrigger.apply(void 0, arguments);
					var rules = _this.props.rules;
					if (rules && rules.length) dispatch({
						type: "validateField",
						namePath,
						triggerName
					});
				};
			});
			return control;
		});
		if (props.fieldContext) {
			var getInternalHooks = props.fieldContext.getInternalHooks;
			var _getInternalHooks2 = getInternalHooks(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
			initEntityValue(_assertThisInitialized(_this));
		}
		return _this;
	}
	_createClass(Field$1, [
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
				this.mounted = true;
				if (fieldContext) {
					var getInternalHooks = fieldContext.getInternalHooks;
					var _getInternalHooks3 = getInternalHooks(HOOK_MARK), registerField = _getInternalHooks3.registerField;
					this.cancelRegisterFunc = registerField(this);
				}
				if (shouldUpdate === true) this.reRender();
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				this.cancelRegister();
				this.triggerMetaEvent(true);
				this.mounted = false;
			}
		},
		{
			key: "reRender",
			value: function reRender() {
				if (!this.mounted) return;
				this.forceUpdate();
			}
		},
		{
			key: "render",
			value: function render$1() {
				var resetCount = this.state.resetCount;
				var children = this.props.children;
				var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction = _this$getOnlyChild.isFunction;
				var returnChildNode;
				if (isFunction) returnChildNode = child;
				else if (/* @__PURE__ */ import_react.isValidElement(child)) returnChildNode = /* @__PURE__ */ import_react.cloneElement(child, this.getControlled(child.props));
				else {
					warning_default(!child, "`children` of Field is not validate ReactElement.");
					returnChildNode = child;
				}
				return /* @__PURE__ */ import_react.createElement(import_react.Fragment, { key: resetCount }, returnChildNode);
			}
		}
	]);
	return Field$1;
}(import_react.Component);
_defineProperty(Field, "contextType", FieldContext_default);
_defineProperty(Field, "defaultProps", {
	trigger: "onChange",
	valuePropName: "value"
});
function WrapperField(_ref6) {
	var _restProps$isListFiel;
	var name = _ref6.name, restProps = _objectWithoutProperties(_ref6, _excluded$68);
	var fieldContext = import_react.useContext(FieldContext_default);
	var listContext = import_react.useContext(ListContext_default);
	var namePath = name !== void 0 ? getNamePath(name) : void 0;
	var isMergedListField = (_restProps$isListFiel = restProps.isListField) !== null && _restProps$isListFiel !== void 0 ? _restProps$isListFiel : !!listContext;
	var key = "keep";
	if (!isMergedListField) key = "_".concat((namePath || []).join("_"));
	if (restProps.preserve === false && isMergedListField && namePath.length <= 1) warning_default(false, "`preserve` should not apply on Form.List fields.");
	return /* @__PURE__ */ import_react.createElement(Field, _extends({
		key,
		name: namePath,
		isListField: isMergedListField
	}, restProps, { fieldContext }));
}
var Field_default = WrapperField;

//#endregion
//#region node_modules/rc-field-form/es/List.js
function List$2(_ref) {
	var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField;
	var context = import_react.useContext(FieldContext_default);
	var wrapperListContext = import_react.useContext(ListContext_default);
	var keyManager = import_react.useRef({
		keys: [],
		id: 0
	}).current;
	var prefixName = import_react.useMemo(function() {
		var parentPrefixName = getNamePath(context.prefixName) || [];
		return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
	}, [context.prefixName, name]);
	var fieldContext = import_react.useMemo(function() {
		return _objectSpread2(_objectSpread2({}, context), {}, { prefixName });
	}, [context, prefixName]);
	var listContext = import_react.useMemo(function() {
		return { getKey: function getKey$3(namePath) {
			var len = prefixName.length;
			var pathName = namePath[len];
			return [keyManager.keys[pathName], namePath.slice(len + 1)];
		} };
	}, [prefixName]);
	if (typeof children !== "function") {
		warning_default(false, "Form.List only accepts function as children.");
		return null;
	}
	return /* @__PURE__ */ import_react.createElement(ListContext_default.Provider, { value: listContext }, /* @__PURE__ */ import_react.createElement(FieldContext_default.Provider, { value: fieldContext }, /* @__PURE__ */ import_react.createElement(Field_default, {
		name: [],
		shouldUpdate: function shouldUpdate(prevValue, nextValue, _ref2) {
			if (_ref2.source === "internal") return false;
			return prevValue !== nextValue;
		},
		rules,
		validateTrigger,
		initialValue,
		isList: true,
		isListField: isListField !== null && isListField !== void 0 ? isListField : !!wrapperListContext
	}, function(_ref3, meta) {
		var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
		var getFieldValue = context.getFieldValue;
		var getNewValue = function getNewValue$1() {
			return getFieldValue(prefixName || []) || [];
		};
		/**
		* Always get latest value in case user update fields by `form` api.
		*/
		var operations = {
			add: function add(defaultValue, index$2) {
				var newValue = getNewValue();
				if (index$2 >= 0 && index$2 <= newValue.length) {
					keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index$2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index$2)));
					onChange([].concat(_toConsumableArray(newValue.slice(0, index$2)), [defaultValue], _toConsumableArray(newValue.slice(index$2))));
				} else {
					if (index$2 < 0 || index$2 > newValue.length) warning_default(false, "The second parameter of the add function should be a valid positive number.");
					keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
					onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
				}
				keyManager.id += 1;
			},
			remove: function remove(index$2) {
				var newValue = getNewValue();
				var indexSet = new Set(Array.isArray(index$2) ? index$2 : [index$2]);
				if (indexSet.size <= 0) return;
				keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
					return !indexSet.has(keysIndex);
				});
				onChange(newValue.filter(function(_, valueIndex) {
					return !indexSet.has(valueIndex);
				}));
			},
			move: function move$1(from$1, to) {
				if (from$1 === to) return;
				var newValue = getNewValue();
				if (from$1 < 0 || from$1 >= newValue.length || to < 0 || to >= newValue.length) return;
				keyManager.keys = move(keyManager.keys, from$1, to);
				onChange(move(newValue, from$1, to));
			}
		};
		var listValue = value || [];
		if (!Array.isArray(listValue)) {
			listValue = [];
			warning_default(false, "Current value of '".concat(prefixName.join(" > "), "' is not an array type."));
		}
		return children(listValue.map(function(__, index$2) {
			var key = keyManager.keys[index$2];
			if (key === void 0) {
				keyManager.keys[index$2] = keyManager.id;
				key = keyManager.keys[index$2];
				keyManager.id += 1;
			}
			return {
				name: index$2,
				key,
				isListField: true
			};
		}), operations, meta);
	})));
}
var List_default = List$2;

//#endregion
//#region node_modules/rc-field-form/es/utils/asyncUtil.js
function allPromiseFinish(promiseList) {
	var hasError = false;
	var count = promiseList.length;
	var results = [];
	if (!promiseList.length) return Promise.resolve([]);
	return new Promise(function(resolve, reject) {
		promiseList.forEach(function(promise, index$2) {
			promise.catch(function(e$2) {
				hasError = true;
				return e$2;
			}).then(function(result) {
				count -= 1;
				results[index$2] = result;
				if (count > 0) return;
				if (hasError) reject(results);
				resolve(results);
			});
		});
	});
}

//#endregion
//#region node_modules/rc-field-form/es/utils/NameMap.js
var SPLIT = "__@field_split__";
/**
* Convert name path into string to fast the fetch speed of Map.
*/
function normalize(namePath) {
	return namePath.map(function(cell) {
		return "".concat(_typeof(cell), ":").concat(cell);
	}).join(SPLIT);
}
/**
* NameMap like a `Map` but accepts `string[]` as key.
*/
var NameMap = /* @__PURE__ */ function() {
	function NameMap$1() {
		_classCallCheck(this, NameMap$1);
		_defineProperty(this, "kvs", /* @__PURE__ */ new Map());
	}
	_createClass(NameMap$1, [
		{
			key: "set",
			value: function set$1(key, value) {
				this.kvs.set(normalize(key), value);
			}
		},
		{
			key: "get",
			value: function get$1(key) {
				return this.kvs.get(normalize(key));
			}
		},
		{
			key: "update",
			value: function update(key, updater) {
				var origin = this.get(key);
				var next$1 = updater(origin);
				if (!next$1) this.delete(key);
				else this.set(key, next$1);
			}
		},
		{
			key: "delete",
			value: function _delete(key) {
				this.kvs.delete(normalize(key));
			}
		},
		{
			key: "map",
			value: function map(callback) {
				return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
					var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
					var cells = key.split(SPLIT);
					return callback({
						key: cells.map(function(cell) {
							var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type$2 = _cell$match2[1], unit$2 = _cell$match2[2];
							return type$2 === "number" ? Number(unit$2) : unit$2;
						}),
						value
					});
				});
			}
		},
		{
			key: "toJSON",
			value: function toJSON() {
				var json = {};
				this.map(function(_ref3) {
					var key = _ref3.key, value = _ref3.value;
					json[key.join(".")] = value;
					return null;
				});
				return json;
			}
		}
	]);
	return NameMap$1;
}();
var NameMap_default = NameMap;

//#endregion
//#region node_modules/rc-field-form/es/useForm.js
var _excluded$67 = ["name"];
var FormStore = /* @__PURE__ */ _createClass(function FormStore$1(forceRootUpdate) {
	var _this = this;
	_classCallCheck(this, FormStore$1);
	_defineProperty(this, "formHooked", false);
	_defineProperty(this, "forceRootUpdate", void 0);
	_defineProperty(this, "subscribable", true);
	_defineProperty(this, "store", {});
	_defineProperty(this, "fieldEntities", []);
	_defineProperty(this, "initialValues", {});
	_defineProperty(this, "callbacks", {});
	_defineProperty(this, "validateMessages", null);
	_defineProperty(this, "preserve", null);
	_defineProperty(this, "lastValidatePromise", null);
	_defineProperty(this, "getForm", function() {
		return {
			getFieldValue: _this.getFieldValue,
			getFieldsValue: _this.getFieldsValue,
			getFieldError: _this.getFieldError,
			getFieldWarning: _this.getFieldWarning,
			getFieldsError: _this.getFieldsError,
			isFieldsTouched: _this.isFieldsTouched,
			isFieldTouched: _this.isFieldTouched,
			isFieldValidating: _this.isFieldValidating,
			isFieldsValidating: _this.isFieldsValidating,
			resetFields: _this.resetFields,
			setFields: _this.setFields,
			setFieldValue: _this.setFieldValue,
			setFieldsValue: _this.setFieldsValue,
			validateFields: _this.validateFields,
			submit: _this.submit,
			_init: true,
			getInternalHooks: _this.getInternalHooks
		};
	});
	_defineProperty(this, "getInternalHooks", function(key) {
		if (key === HOOK_MARK) {
			_this.formHooked = true;
			return {
				dispatch: _this.dispatch,
				initEntityValue: _this.initEntityValue,
				registerField: _this.registerField,
				useSubscribe: _this.useSubscribe,
				setInitialValues: _this.setInitialValues,
				destroyForm: _this.destroyForm,
				setCallbacks: _this.setCallbacks,
				setValidateMessages: _this.setValidateMessages,
				getFields: _this.getFields,
				setPreserve: _this.setPreserve,
				getInitialValue: _this.getInitialValue,
				registerWatch: _this.registerWatch
			};
		}
		warning_default(false, "`getInternalHooks` is internal usage. Should not call directly.");
		return null;
	});
	_defineProperty(this, "useSubscribe", function(subscribable) {
		_this.subscribable = subscribable;
	});
	/**
	* Record prev Form unmount fieldEntities which config preserve false.
	* This need to be refill with initialValues instead of store value.
	*/
	_defineProperty(this, "prevWithoutPreserves", null);
	/**
	* First time `setInitialValues` should update store with initial value
	*/
	_defineProperty(this, "setInitialValues", function(initialValues, init) {
		_this.initialValues = initialValues || {};
		if (init) {
			var _this$prevWithoutPres;
			var nextStore = merge$1(initialValues, _this.store);
			(_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(function(_ref) {
				var namePath = _ref.key;
				nextStore = set(nextStore, namePath, get(initialValues, namePath));
			});
			_this.prevWithoutPreserves = null;
			_this.updateStore(nextStore);
		}
	});
	_defineProperty(this, "destroyForm", function(clearOnDestroy) {
		if (clearOnDestroy) _this.updateStore({});
		else {
			var prevWithoutPreserves = new NameMap_default();
			_this.getFieldEntities(true).forEach(function(entity) {
				if (!_this.isMergedPreserve(entity.isPreserve())) prevWithoutPreserves.set(entity.getNamePath(), true);
			});
			_this.prevWithoutPreserves = prevWithoutPreserves;
		}
	});
	_defineProperty(this, "getInitialValue", function(namePath) {
		var initValue = get(_this.initialValues, namePath);
		return namePath.length ? merge$1(initValue) : initValue;
	});
	_defineProperty(this, "setCallbacks", function(callbacks) {
		_this.callbacks = callbacks;
	});
	_defineProperty(this, "setValidateMessages", function(validateMessages) {
		_this.validateMessages = validateMessages;
	});
	_defineProperty(this, "setPreserve", function(preserve$1) {
		_this.preserve = preserve$1;
	});
	_defineProperty(this, "watchList", []);
	_defineProperty(this, "registerWatch", function(callback) {
		_this.watchList.push(callback);
		return function() {
			_this.watchList = _this.watchList.filter(function(fn) {
				return fn !== callback;
			});
		};
	});
	_defineProperty(this, "notifyWatch", function() {
		var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
		if (_this.watchList.length) {
			var values = _this.getFieldsValue();
			var allValues = _this.getFieldsValue(true);
			_this.watchList.forEach(function(callback) {
				callback(values, allValues, namePath);
			});
		}
	});
	_defineProperty(this, "timeoutId", null);
	_defineProperty(this, "warningUnhooked", function() {
		if (!_this.timeoutId && typeof window !== "undefined") _this.timeoutId = setTimeout(function() {
			_this.timeoutId = null;
			if (!_this.formHooked) warning_default(false, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
		});
	});
	_defineProperty(this, "updateStore", function(nextStore) {
		_this.store = nextStore;
	});
	/**
	* Get registered field entities.
	* @param pure Only return field which has a `name`. Default: false
	*/
	_defineProperty(this, "getFieldEntities", function() {
		if (!(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false)) return _this.fieldEntities;
		return _this.fieldEntities.filter(function(field) {
			return field.getNamePath().length;
		});
	});
	_defineProperty(this, "getFieldsMap", function() {
		var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
		var cache = new NameMap_default();
		_this.getFieldEntities(pure).forEach(function(field) {
			var namePath = field.getNamePath();
			cache.set(namePath, field);
		});
		return cache;
	});
	_defineProperty(this, "getFieldEntitiesForNamePathList", function(nameList) {
		if (!nameList) return _this.getFieldEntities(true);
		var cache = _this.getFieldsMap(true);
		return nameList.map(function(name) {
			var namePath = getNamePath(name);
			return cache.get(namePath) || { INVALIDATE_NAME_PATH: getNamePath(name) };
		});
	});
	_defineProperty(this, "getFieldsValue", function(nameList, filterFunc) {
		_this.warningUnhooked();
		var mergedNameList;
		var mergedFilterFunc;
		var mergedStrict;
		if (nameList === true || Array.isArray(nameList)) {
			mergedNameList = nameList;
			mergedFilterFunc = filterFunc;
		} else if (nameList && _typeof(nameList) === "object") {
			mergedStrict = nameList.strict;
			mergedFilterFunc = nameList.filter;
		}
		if (mergedNameList === true && !mergedFilterFunc) return _this.store;
		var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);
		var filteredNameList = [];
		fieldEntities.forEach(function(entity) {
			var _isListField, _ref3;
			var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
			if (mergedStrict) {
				var _isList, _ref2;
				if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2)) return;
			} else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3)) return;
			if (!mergedFilterFunc) filteredNameList.push(namePath);
			else {
				var meta = "getMeta" in entity ? entity.getMeta() : null;
				if (mergedFilterFunc(meta)) filteredNameList.push(namePath);
			}
		});
		return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
	});
	_defineProperty(this, "getFieldValue", function(name) {
		_this.warningUnhooked();
		var namePath = getNamePath(name);
		return get(_this.store, namePath);
	});
	_defineProperty(this, "getFieldsError", function(nameList) {
		_this.warningUnhooked();
		return _this.getFieldEntitiesForNamePathList(nameList).map(function(entity, index$2) {
			if (entity && !("INVALIDATE_NAME_PATH" in entity)) return {
				name: entity.getNamePath(),
				errors: entity.getErrors(),
				warnings: entity.getWarnings()
			};
			return {
				name: getNamePath(nameList[index$2]),
				errors: [],
				warnings: []
			};
		});
	});
	_defineProperty(this, "getFieldError", function(name) {
		_this.warningUnhooked();
		var namePath = getNamePath(name);
		return _this.getFieldsError([namePath])[0].errors;
	});
	_defineProperty(this, "getFieldWarning", function(name) {
		_this.warningUnhooked();
		var namePath = getNamePath(name);
		return _this.getFieldsError([namePath])[0].warnings;
	});
	_defineProperty(this, "isFieldsTouched", function() {
		_this.warningUnhooked();
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		var arg0 = args[0], arg1 = args[1];
		var namePathList;
		var isAllFieldsTouched = false;
		if (args.length === 0) namePathList = null;
		else if (args.length === 1) if (Array.isArray(arg0)) {
			namePathList = arg0.map(getNamePath);
			isAllFieldsTouched = false;
		} else {
			namePathList = null;
			isAllFieldsTouched = arg0;
		}
		else {
			namePathList = arg0.map(getNamePath);
			isAllFieldsTouched = arg1;
		}
		var fieldEntities = _this.getFieldEntities(true);
		var isFieldTouched = function isFieldTouched$1(field) {
			return field.isFieldTouched();
		};
		if (!namePathList) return isAllFieldsTouched ? fieldEntities.every(function(entity) {
			return isFieldTouched(entity) || entity.isList();
		}) : fieldEntities.some(isFieldTouched);
		var map = new NameMap_default();
		namePathList.forEach(function(shortNamePath) {
			map.set(shortNamePath, []);
		});
		fieldEntities.forEach(function(field) {
			var fieldNamePath = field.getNamePath();
			namePathList.forEach(function(shortNamePath) {
				if (shortNamePath.every(function(nameUnit, i) {
					return fieldNamePath[i] === nameUnit;
				})) map.update(shortNamePath, function(list) {
					return [].concat(_toConsumableArray(list), [field]);
				});
			});
		});
		var isNamePathListTouched = function isNamePathListTouched$1(entities) {
			return entities.some(isFieldTouched);
		};
		var namePathListEntities = map.map(function(_ref4) {
			return _ref4.value;
		});
		return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
	});
	_defineProperty(this, "isFieldTouched", function(name) {
		_this.warningUnhooked();
		return _this.isFieldsTouched([name]);
	});
	_defineProperty(this, "isFieldsValidating", function(nameList) {
		_this.warningUnhooked();
		var fieldEntities = _this.getFieldEntities();
		if (!nameList) return fieldEntities.some(function(testField) {
			return testField.isFieldValidating();
		});
		var namePathList = nameList.map(getNamePath);
		return fieldEntities.some(function(testField) {
			var fieldNamePath = testField.getNamePath();
			return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
		});
	});
	_defineProperty(this, "isFieldValidating", function(name) {
		_this.warningUnhooked();
		return _this.isFieldsValidating([name]);
	});
	/**
	* Reset Field with field `initialValue` prop.
	* Can pass `entities` or `namePathList` or just nothing.
	*/
	_defineProperty(this, "resetWithFieldInitialValue", function() {
		var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		var cache = new NameMap_default();
		var fieldEntities = _this.getFieldEntities(true);
		fieldEntities.forEach(function(field) {
			var initialValue = field.props.initialValue;
			var namePath = field.getNamePath();
			if (initialValue !== void 0) {
				var records = cache.get(namePath) || /* @__PURE__ */ new Set();
				records.add({
					entity: field,
					value: initialValue
				});
				cache.set(namePath, records);
			}
		});
		var resetWithFields = function resetWithFields$1(entities) {
			entities.forEach(function(field) {
				if (field.props.initialValue !== void 0) {
					var namePath = field.getNamePath();
					if (_this.getInitialValue(namePath) !== void 0) warning_default(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
					else {
						var records = cache.get(namePath);
						if (records && records.size > 1) warning_default(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
						else if (records) {
							var originValue = _this.getFieldValue(namePath);
							if (!field.isListField() && (!info.skipExist || originValue === void 0)) _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
						}
					}
				}
			});
		};
		var requiredFieldEntities;
		if (info.entities) requiredFieldEntities = info.entities;
		else if (info.namePathList) {
			requiredFieldEntities = [];
			info.namePathList.forEach(function(namePath) {
				var records = cache.get(namePath);
				if (records) {
					var _requiredFieldEntitie;
					(_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r$1) {
						return r$1.entity;
					})));
				}
			});
		} else requiredFieldEntities = fieldEntities;
		resetWithFields(requiredFieldEntities);
	});
	_defineProperty(this, "resetFields", function(nameList) {
		_this.warningUnhooked();
		var prevStore = _this.store;
		if (!nameList) {
			_this.updateStore(merge$1(_this.initialValues));
			_this.resetWithFieldInitialValue();
			_this.notifyObservers(prevStore, null, { type: "reset" });
			_this.notifyWatch();
			return;
		}
		var namePathList = nameList.map(getNamePath);
		namePathList.forEach(function(namePath) {
			var initialValue = _this.getInitialValue(namePath);
			_this.updateStore(set(_this.store, namePath, initialValue));
		});
		_this.resetWithFieldInitialValue({ namePathList });
		_this.notifyObservers(prevStore, namePathList, { type: "reset" });
		_this.notifyWatch(namePathList);
	});
	_defineProperty(this, "setFields", function(fields) {
		_this.warningUnhooked();
		var prevStore = _this.store;
		var namePathList = [];
		fields.forEach(function(fieldData) {
			var name = fieldData.name, data = _objectWithoutProperties(fieldData, _excluded$67);
			var namePath = getNamePath(name);
			namePathList.push(namePath);
			if ("value" in data) _this.updateStore(set(_this.store, namePath, data.value));
			_this.notifyObservers(prevStore, [namePath], {
				type: "setField",
				data: fieldData
			});
		});
		_this.notifyWatch(namePathList);
	});
	_defineProperty(this, "getFields", function() {
		return _this.getFieldEntities(true).map(function(field) {
			var namePath = field.getNamePath();
			var meta = field.getMeta();
			var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
				name: namePath,
				value: _this.getFieldValue(namePath)
			});
			Object.defineProperty(fieldData, "originRCField", { value: true });
			return fieldData;
		});
	});
	/**
	* This only trigger when a field is on constructor to avoid we get initialValue too late
	*/
	_defineProperty(this, "initEntityValue", function(entity) {
		var initialValue = entity.props.initialValue;
		if (initialValue !== void 0) {
			var namePath = entity.getNamePath();
			if (get(_this.store, namePath) === void 0) _this.updateStore(set(_this.store, namePath, initialValue));
		}
	});
	_defineProperty(this, "isMergedPreserve", function(fieldPreserve) {
		var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
		return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
	});
	_defineProperty(this, "registerField", function(entity) {
		_this.fieldEntities.push(entity);
		var namePath = entity.getNamePath();
		_this.notifyWatch([namePath]);
		if (entity.props.initialValue !== void 0) {
			var prevStore = _this.store;
			_this.resetWithFieldInitialValue({
				entities: [entity],
				skipExist: true
			});
			_this.notifyObservers(prevStore, [entity.getNamePath()], {
				type: "valueUpdate",
				source: "internal"
			});
		}
		return function(isListField, preserve$1) {
			var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
			_this.fieldEntities = _this.fieldEntities.filter(function(item) {
				return item !== entity;
			});
			if (!_this.isMergedPreserve(preserve$1) && (!isListField || subNamePath.length > 1)) {
				var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
				if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
					return !matchNamePath(field.getNamePath(), namePath);
				})) {
					var _prevStore = _this.store;
					_this.updateStore(set(_prevStore, namePath, defaultValue, true));
					_this.notifyObservers(_prevStore, [namePath], { type: "remove" });
					_this.triggerDependenciesUpdate(_prevStore, namePath);
				}
			}
			_this.notifyWatch([namePath]);
		};
	});
	_defineProperty(this, "dispatch", function(action) {
		switch (action.type) {
			case "updateValue":
				var namePath = action.namePath, value = action.value;
				_this.updateValue(namePath, value);
				break;
			case "validateField":
				var _namePath = action.namePath, triggerName = action.triggerName;
				_this.validateFields([_namePath], { triggerName });
				break;
			default:
		}
	});
	_defineProperty(this, "notifyObservers", function(prevStore, namePathList, info) {
		if (_this.subscribable) {
			var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, { store: _this.getFieldsValue(true) });
			_this.getFieldEntities().forEach(function(_ref5) {
				var onStoreChange = _ref5.onStoreChange;
				onStoreChange(prevStore, namePathList, mergedInfo);
			});
		} else _this.forceRootUpdate();
	});
	/**
	* Notify dependencies children with parent update
	* We need delay to trigger validate in case Field is under render props
	*/
	_defineProperty(this, "triggerDependenciesUpdate", function(prevStore, namePath) {
		var childrenFields = _this.getDependencyChildrenFields(namePath);
		if (childrenFields.length) _this.validateFields(childrenFields);
		_this.notifyObservers(prevStore, childrenFields, {
			type: "dependenciesUpdate",
			relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
		});
		return childrenFields;
	});
	_defineProperty(this, "updateValue", function(name, value) {
		var namePath = getNamePath(name);
		var prevStore = _this.store;
		_this.updateStore(set(_this.store, namePath, value));
		_this.notifyObservers(prevStore, [namePath], {
			type: "valueUpdate",
			source: "internal"
		});
		_this.notifyWatch([namePath]);
		var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
		var onValuesChange = _this.callbacks.onValuesChange;
		if (onValuesChange) {
			var changedValues = cloneByNamePathList(_this.store, [namePath]);
			onValuesChange(changedValues, _this.getFieldsValue());
		}
		_this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
	});
	_defineProperty(this, "setFieldsValue", function(store) {
		_this.warningUnhooked();
		var prevStore = _this.store;
		if (store) {
			var nextStore = merge$1(_this.store, store);
			_this.updateStore(nextStore);
		}
		_this.notifyObservers(prevStore, null, {
			type: "valueUpdate",
			source: "external"
		});
		_this.notifyWatch();
	});
	_defineProperty(this, "setFieldValue", function(name, value) {
		_this.setFields([{
			name,
			value,
			errors: [],
			warnings: []
		}]);
	});
	_defineProperty(this, "getDependencyChildrenFields", function(rootNamePath) {
		var children = /* @__PURE__ */ new Set();
		var childrenFields = [];
		var dependencies2fields = new NameMap_default();
		/**
		* Generate maps
		* Can use cache to save perf if user report performance issue with this
		*/
		_this.getFieldEntities().forEach(function(field) {
			(field.props.dependencies || []).forEach(function(dependency) {
				var dependencyNamePath = getNamePath(dependency);
				dependencies2fields.update(dependencyNamePath, function() {
					var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
					fields.add(field);
					return fields;
				});
			});
		});
		(function fillChildren(namePath) {
			(dependencies2fields.get(namePath) || /* @__PURE__ */ new Set()).forEach(function(field) {
				if (!children.has(field)) {
					children.add(field);
					var fieldNamePath = field.getNamePath();
					if (field.isFieldDirty() && fieldNamePath.length) {
						childrenFields.push(fieldNamePath);
						fillChildren(fieldNamePath);
					}
				}
			});
		})(rootNamePath);
		return childrenFields;
	});
	_defineProperty(this, "triggerOnFieldsChange", function(namePathList, filedErrors) {
		var onFieldsChange = _this.callbacks.onFieldsChange;
		if (onFieldsChange) {
			var fields = _this.getFields();
			/**
			* Fill errors since `fields` may be replaced by controlled fields
			*/
			if (filedErrors) {
				var cache = new NameMap_default();
				filedErrors.forEach(function(_ref6) {
					var name = _ref6.name, errors = _ref6.errors;
					cache.set(name, errors);
				});
				fields.forEach(function(field) {
					field.errors = cache.get(field.name) || field.errors;
				});
			}
			var changedFields = fields.filter(function(_ref7) {
				var fieldName = _ref7.name;
				return containsNamePath(namePathList, fieldName);
			});
			if (changedFields.length) onFieldsChange(changedFields, fields);
		}
	});
	_defineProperty(this, "validateFields", function(arg1, arg2) {
		_this.warningUnhooked();
		var nameList;
		var options;
		if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
			nameList = arg1;
			options = arg2;
		} else options = arg1;
		var provideNameList = !!nameList;
		var namePathList = provideNameList ? nameList.map(getNamePath) : [];
		var promiseList = [];
		var TMP_SPLIT = String(Date.now());
		var validateNamePathList = /* @__PURE__ */ new Set();
		var _ref8 = options || {}, recursive = _ref8.recursive, dirty = _ref8.dirty;
		_this.getFieldEntities(true).forEach(function(field) {
			if (!provideNameList) namePathList.push(field.getNamePath());
			if (!field.props.rules || !field.props.rules.length) return;
			if (dirty && !field.isFieldDirty()) return;
			var fieldNamePath = field.getNamePath();
			validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
			if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
				var promise = field.validateRules(_objectSpread2({ validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages) }, options));
				promiseList.push(promise.then(function() {
					return {
						name: fieldNamePath,
						errors: [],
						warnings: []
					};
				}).catch(function(ruleErrors) {
					var _ruleErrors$forEach;
					var mergedErrors = [];
					var mergedWarnings = [];
					(_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref9) {
						var warningOnly = _ref9.rule.warningOnly, errors = _ref9.errors;
						if (warningOnly) mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
						else mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
					});
					if (mergedErrors.length) return Promise.reject({
						name: fieldNamePath,
						errors: mergedErrors,
						warnings: mergedWarnings
					});
					return {
						name: fieldNamePath,
						errors: mergedErrors,
						warnings: mergedWarnings
					};
				}));
			}
		});
		var summaryPromise = allPromiseFinish(promiseList);
		_this.lastValidatePromise = summaryPromise;
		summaryPromise.catch(function(results) {
			return results;
		}).then(function(results) {
			var resultNamePathList = results.map(function(_ref10) {
				return _ref10.name;
			});
			_this.notifyObservers(_this.store, resultNamePathList, { type: "validateFinish" });
			_this.triggerOnFieldsChange(resultNamePathList, results);
		});
		var returnPromise = summaryPromise.then(function() {
			if (_this.lastValidatePromise === summaryPromise) return Promise.resolve(_this.getFieldsValue(namePathList));
			return Promise.reject([]);
		}).catch(function(results) {
			var errorList = results.filter(function(result) {
				return result && result.errors.length;
			});
			return Promise.reject({
				values: _this.getFieldsValue(namePathList),
				errorFields: errorList,
				outOfDate: _this.lastValidatePromise !== summaryPromise
			});
		});
		returnPromise.catch(function(e$2) {
			return e$2;
		});
		var triggerNamePathList = namePathList.filter(function(namePath) {
			return validateNamePathList.has(namePath.join(TMP_SPLIT));
		});
		_this.triggerOnFieldsChange(triggerNamePathList);
		return returnPromise;
	});
	_defineProperty(this, "submit", function() {
		_this.warningUnhooked();
		_this.validateFields().then(function(values) {
			var onFinish = _this.callbacks.onFinish;
			if (onFinish) try {
				onFinish(values);
			} catch (err) {
				console.error(err);
			}
		}).catch(function(e$2) {
			var onFinishFailed = _this.callbacks.onFinishFailed;
			if (onFinishFailed) onFinishFailed(e$2);
		});
	});
	this.forceRootUpdate = forceRootUpdate;
});
function useForm$1(form) {
	var formRef = import_react.useRef();
	var _React$useState = import_react.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
	if (!formRef.current) if (form) formRef.current = form;
	else formRef.current = new FormStore(function forceReRender() {
		forceUpdate({});
	}).getForm();
	return [formRef.current];
}
var useForm_default = useForm$1;

//#endregion
//#region node_modules/rc-field-form/es/FormContext.js
var FormContext$1 = /* @__PURE__ */ import_react.createContext({
	triggerFormChange: function triggerFormChange() {},
	triggerFormFinish: function triggerFormFinish() {},
	registerForm: function registerForm() {},
	unregisterForm: function unregisterForm() {}
});
var FormProvider$1 = function FormProvider$2(_ref) {
	var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
	var formContext = import_react.useContext(FormContext$1);
	var formsRef = import_react.useRef({});
	return /* @__PURE__ */ import_react.createElement(FormContext$1.Provider, { value: _objectSpread2(_objectSpread2({}, formContext), {}, {
		validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
		triggerFormChange: function triggerFormChange(name, changedFields) {
			if (onFormChange) onFormChange(name, {
				changedFields,
				forms: formsRef.current
			});
			formContext.triggerFormChange(name, changedFields);
		},
		triggerFormFinish: function triggerFormFinish(name, values) {
			if (onFormFinish) onFormFinish(name, {
				values,
				forms: formsRef.current
			});
			formContext.triggerFormFinish(name, values);
		},
		registerForm: function registerForm(name, form) {
			if (name) formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty({}, name, form));
			formContext.registerForm(name, form);
		},
		unregisterForm: function unregisterForm(name) {
			var newForms = _objectSpread2({}, formsRef.current);
			delete newForms[name];
			formsRef.current = newForms;
			formContext.unregisterForm(name);
		}
	}) }, children);
};
var FormContext_default = FormContext$1;

//#endregion
//#region node_modules/rc-field-form/es/Form.js
var _excluded$66 = [
	"name",
	"initialValues",
	"fields",
	"form",
	"preserve",
	"children",
	"component",
	"validateMessages",
	"validateTrigger",
	"onValuesChange",
	"onFieldsChange",
	"onFinish",
	"onFinishFailed",
	"clearOnDestroy"
];
var Form$2 = function Form$3(_ref, ref) {
	var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve$1 = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component$2 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, clearOnDestroy = _ref.clearOnDestroy, restProps = _objectWithoutProperties(_ref, _excluded$66);
	var nativeElementRef = import_react.useRef(null);
	var formContext = import_react.useContext(FormContext_default);
	var _useForm = useForm_default(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
	var _getInternalHooks = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _getInternalHooks.useSubscribe, setInitialValues = _getInternalHooks.setInitialValues, setCallbacks = _getInternalHooks.setCallbacks, setValidateMessages = _getInternalHooks.setValidateMessages, setPreserve = _getInternalHooks.setPreserve, destroyForm = _getInternalHooks.destroyForm;
	import_react.useImperativeHandle(ref, function() {
		return _objectSpread2(_objectSpread2({}, formInstance), {}, { nativeElement: nativeElementRef.current });
	});
	import_react.useEffect(function() {
		formContext.registerForm(name, formInstance);
		return function() {
			formContext.unregisterForm(name);
		};
	}, [
		formContext,
		formInstance,
		name
	]);
	setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
	setCallbacks({
		onValuesChange,
		onFieldsChange: function onFieldsChange(changedFields) {
			formContext.triggerFormChange(name, changedFields);
			if (_onFieldsChange) {
				for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) rest[_key - 1] = arguments[_key];
				_onFieldsChange.apply(void 0, [changedFields].concat(rest));
			}
		},
		onFinish: function onFinish(values) {
			formContext.triggerFormFinish(name, values);
			if (_onFinish) _onFinish(values);
		},
		onFinishFailed
	});
	setPreserve(preserve$1);
	var mountRef = import_react.useRef(null);
	setInitialValues(initialValues, !mountRef.current);
	if (!mountRef.current) mountRef.current = true;
	import_react.useEffect(function() {
		return function() {
			return destroyForm(clearOnDestroy);
		};
	}, []);
	var childrenNode;
	var childrenRenderProps = typeof children === "function";
	if (childrenRenderProps) {
		var _values = formInstance.getFieldsValue(true);
		childrenNode = children(_values, formInstance);
	} else childrenNode = children;
	useSubscribe(!childrenRenderProps);
	var prevFieldsRef = import_react.useRef();
	import_react.useEffect(function() {
		if (!isSimilar(prevFieldsRef.current || [], fields || [])) formInstance.setFields(fields || []);
		prevFieldsRef.current = fields;
	}, [fields, formInstance]);
	var formContextValue = import_react.useMemo(function() {
		return _objectSpread2(_objectSpread2({}, formInstance), {}, { validateTrigger });
	}, [formInstance, validateTrigger]);
	var wrapperNode = /* @__PURE__ */ import_react.createElement(ListContext_default.Provider, { value: null }, /* @__PURE__ */ import_react.createElement(FieldContext_default.Provider, { value: formContextValue }, childrenNode));
	if (Component$2 === false) return wrapperNode;
	return /* @__PURE__ */ import_react.createElement(Component$2, _extends({}, restProps, {
		ref: nativeElementRef,
		onSubmit: function onSubmit(event) {
			event.preventDefault();
			event.stopPropagation();
			formInstance.submit();
		},
		onReset: function onReset(event) {
			var _restProps$onReset;
			event.preventDefault();
			formInstance.resetFields();
			(_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 || _restProps$onReset.call(restProps, event);
		}
	}), wrapperNode);
};
var Form_default$1 = Form$2;

//#endregion
//#region node_modules/rc-field-form/es/useWatch.js
function stringify$1(value) {
	try {
		return JSON.stringify(value);
	} catch (err) {
		return Math.random();
	}
}
var useWatchWarning = function(namePath) {
	var fullyStr = namePath.join("__RC_FIELD_FORM_SPLIT__");
	var nameStrRef = (0, import_react.useRef)(fullyStr);
	warning_default(nameStrRef.current === fullyStr, "`useWatch` is not support dynamic `namePath`. Please provide static instead.");
};
function useWatch$1() {
	for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
	var dependencies = args[0], _args$ = args[1], _form = _args$ === void 0 ? {} : _args$;
	var options = isFormInstance(_form) ? { form: _form } : _form;
	var form = options.form;
	var _useState = (0, import_react.useState)(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
	var valueStr = (0, import_react.useMemo)(function() {
		return stringify$1(value);
	}, [value]);
	var valueStrRef = (0, import_react.useRef)(valueStr);
	valueStrRef.current = valueStr;
	var fieldContext = (0, import_react.useContext)(FieldContext_default);
	var formInstance = form || fieldContext;
	var isValidForm = formInstance && formInstance._init;
	warning_default(args.length === 2 ? form ? isValidForm : true : isValidForm, "useWatch requires a form instance since it can not auto detect from context.");
	var namePath = getNamePath(dependencies);
	var namePathRef = (0, import_react.useRef)(namePath);
	namePathRef.current = namePath;
	useWatchWarning(namePath);
	(0, import_react.useEffect)(function() {
		if (!isValidForm) return;
		var getFieldsValue = formInstance.getFieldsValue, getInternalHooks = formInstance.getInternalHooks;
		var _getInternalHooks = getInternalHooks(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
		var getWatchValue = function getWatchValue$1(values, allValues) {
			var watchValue = options.preserve ? allValues : values;
			return typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, namePathRef.current);
		};
		var cancelRegister = registerWatch(function(values, allValues) {
			var newValue = getWatchValue(values, allValues);
			var nextValueStr = stringify$1(newValue);
			if (valueStrRef.current !== nextValueStr) {
				valueStrRef.current = nextValueStr;
				setValue(newValue);
			}
		});
		var initialValue = getWatchValue(getFieldsValue(), getFieldsValue(true));
		if (value !== initialValue) setValue(initialValue);
		return cancelRegister;
	}, [isValidForm]);
	return value;
}
var useWatch_default = useWatch$1;

//#endregion
//#region node_modules/rc-field-form/es/index.js
var RefForm = /* @__PURE__ */ import_react.forwardRef(Form_default$1);
RefForm.FormProvider = FormProvider$1;
RefForm.Field = Field_default;
RefForm.List = List_default;
RefForm.useForm = useForm_default;
RefForm.useWatch = useWatch_default;
var es_default$17 = RefForm;

//#endregion
//#region node_modules/antd/es/form/context.js
const FormContext = /* @__PURE__ */ import_react.createContext({
	labelAlign: "right",
	layout: "horizontal",
	itemRef: () => {}
});
const NoStyleItemContext = /* @__PURE__ */ import_react.createContext(null);
const FormProvider = (props) => {
	const providerProps = omit(props, ["prefixCls"]);
	return /* @__PURE__ */ import_react.createElement(FormProvider$1, Object.assign({}, providerProps));
};
const FormItemPrefixContext = /* @__PURE__ */ import_react.createContext({ prefixCls: "" });
const FormItemInputContext = /* @__PURE__ */ import_react.createContext({});
FormItemInputContext.displayName = "FormItemInputContext";
const NoFormStyle = ({ children, status, override }) => {
	const formItemInputContext = import_react.useContext(FormItemInputContext);
	const newFormItemInputContext = import_react.useMemo(() => {
		const newContext = Object.assign({}, formItemInputContext);
		if (override) delete newContext.isFormItemInput;
		if (status) {
			delete newContext.status;
			delete newContext.hasFeedback;
			delete newContext.feedbackIcon;
		}
		return newContext;
	}, [
		status,
		override,
		formItemInputContext
	]);
	return /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: newFormItemInputContext }, children);
};
const VariantContext = /* @__PURE__ */ import_react.createContext(void 0);

//#endregion
//#region node_modules/antd/es/_util/ContextIsolator.js
var ContextIsolator = (props) => {
	const { space, form, children } = props;
	if (children === void 0 || children === null) return null;
	let result = children;
	if (form) result = /* @__PURE__ */ import_react.createElement(NoFormStyle, {
		override: true,
		status: true
	}, result);
	if (space) result = /* @__PURE__ */ import_react.createElement(NoCompactStyle, null, result);
	return result;
};
var ContextIsolator_default = ContextIsolator;

//#endregion
//#region node_modules/antd/es/_util/extendsObject.js
function mergeProps$1(...items) {
	const ret = {};
	items.forEach((item) => {
		if (item) Object.keys(item).forEach((key) => {
			if (item[key] !== void 0) ret[key] = item[key];
		});
	});
	return ret;
}
var extendsObject_default = mergeProps$1;

//#endregion
//#region node_modules/antd/es/_util/hooks/useClosable.js
function pickClosable(context) {
	if (!context) return;
	const { closable, closeIcon } = context;
	return {
		closable,
		closeIcon
	};
}
/** Convert `closable` and `closeIcon` to config object */
function useClosableConfig(closableCollection) {
	const { closable, closeIcon } = closableCollection || {};
	return import_react.useMemo(() => {
		if (!closable && (closable === false || closeIcon === false || closeIcon === null)) return false;
		if (closable === void 0 && closeIcon === void 0) return null;
		let closableConfig = { closeIcon: typeof closeIcon !== "boolean" && closeIcon !== null ? closeIcon : void 0 };
		if (closable && typeof closable === "object") closableConfig = Object.assign(Object.assign({}, closableConfig), closable);
		return closableConfig;
	}, [closable, closeIcon]);
}
/** Use same object to support `useMemo` optimization */
var EmptyFallbackCloseCollection = {};
function useClosable(propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection) {
	const propCloseConfig = useClosableConfig(propCloseCollection);
	const contextCloseConfig = useClosableConfig(contextCloseCollection);
	const [contextLocale] = useLocale_default("global", en_US_default.global);
	const closeBtnIsDisabled = typeof propCloseConfig !== "boolean" ? !!(propCloseConfig === null || propCloseConfig === void 0 ? void 0 : propCloseConfig.disabled) : false;
	const mergedFallbackCloseCollection = import_react.useMemo(() => Object.assign({ closeIcon: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null) }, fallbackCloseCollection), [fallbackCloseCollection]);
	const mergedClosableConfig = import_react.useMemo(() => {
		if (propCloseConfig === false) return false;
		if (propCloseConfig) return extendsObject_default(mergedFallbackCloseCollection, contextCloseConfig, propCloseConfig);
		if (contextCloseConfig === false) return false;
		if (contextCloseConfig) return extendsObject_default(mergedFallbackCloseCollection, contextCloseConfig);
		return !mergedFallbackCloseCollection.closable ? false : mergedFallbackCloseCollection;
	}, [
		propCloseConfig,
		contextCloseConfig,
		mergedFallbackCloseCollection
	]);
	return import_react.useMemo(() => {
		var _a, _b;
		if (mergedClosableConfig === false) return [
			false,
			null,
			closeBtnIsDisabled,
			{}
		];
		const { closeIconRender } = mergedFallbackCloseCollection;
		const { closeIcon } = mergedClosableConfig;
		let mergedCloseIcon = closeIcon;
		const ariaOrDataProps = pickAttrs(mergedClosableConfig, true);
		if (mergedCloseIcon !== null && mergedCloseIcon !== void 0) {
			if (closeIconRender) mergedCloseIcon = closeIconRender(closeIcon);
			mergedCloseIcon = /* @__PURE__ */ import_react.isValidElement(mergedCloseIcon) ? /* @__PURE__ */ import_react.cloneElement(mergedCloseIcon, Object.assign(Object.assign(Object.assign({}, mergedCloseIcon.props), { "aria-label": (_b = (_a = mergedCloseIcon.props) === null || _a === void 0 ? void 0 : _a["aria-label"]) !== null && _b !== void 0 ? _b : contextLocale.close }), ariaOrDataProps)) : /* @__PURE__ */ import_react.createElement("span", Object.assign({ "aria-label": contextLocale.close }, ariaOrDataProps), mergedCloseIcon);
		}
		return [
			true,
			mergedCloseIcon,
			closeBtnIsDisabled,
			ariaOrDataProps
		];
	}, [mergedClosableConfig, mergedFallbackCloseCollection]);
}

//#endregion
//#region node_modules/rc-util/es/Dom/styleChecker.js
var isStyleNameSupport = function isStyleNameSupport$1(styleName) {
	if (canUseDom() && window.document.documentElement) {
		var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
		var documentElement = window.document.documentElement;
		return styleNameList.some(function(name) {
			return name in documentElement.style;
		});
	}
	return false;
};
var isStyleValueSupport = function isStyleValueSupport$1(styleName, value) {
	if (!isStyleNameSupport(styleName)) return false;
	var ele = document.createElement("div");
	var origin = ele.style[styleName];
	ele.style[styleName] = value;
	return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
	if (!Array.isArray(styleName) && styleValue !== void 0) return isStyleValueSupport(styleName, styleValue);
	return isStyleNameSupport(styleName);
}

//#endregion
//#region node_modules/antd/es/_util/styleChecker.js
const canUseDocElement = () => canUseDom() && window.document.documentElement;

//#endregion
//#region node_modules/antd/es/skeleton/Element.js
var import_classnames$248 = /* @__PURE__ */ __toESM(require_classnames());
var Element$1 = (props) => {
	const { prefixCls, className, style: style$1, size, shape } = props;
	const sizeCls = (0, import_classnames$248.default)({
		[`${prefixCls}-lg`]: size === "large",
		[`${prefixCls}-sm`]: size === "small"
	});
	const shapeCls = (0, import_classnames$248.default)({
		[`${prefixCls}-circle`]: shape === "circle",
		[`${prefixCls}-square`]: shape === "square",
		[`${prefixCls}-round`]: shape === "round"
	});
	const sizeStyle = import_react.useMemo(() => typeof size === "number" ? {
		width: size,
		height: size,
		lineHeight: `${size}px`
	} : {}, [size]);
	return /* @__PURE__ */ import_react.createElement("span", {
		className: (0, import_classnames$248.default)(prefixCls, sizeCls, shapeCls, className),
		style: Object.assign(Object.assign({}, sizeStyle), style$1)
	});
};
var Element_default = Element$1;

//#endregion
//#region node_modules/antd/es/skeleton/style/index.js
var skeletonClsLoading = new Keyframes_default(`ant-skeleton-loading`, {
	"0%": { backgroundPosition: "100% 50%" },
	"100%": { backgroundPosition: "0 50%" }
});
var genSkeletonElementCommonSize = (size) => ({
	height: size,
	lineHeight: unit(size)
});
var genSkeletonElementAvatarSize = (size) => Object.assign({ width: size }, genSkeletonElementCommonSize(size));
var genSkeletonColor = (token$1) => ({
	background: token$1.skeletonLoadingBackground,
	backgroundSize: "400% 100%",
	animationName: skeletonClsLoading,
	animationDuration: token$1.skeletonLoadingMotionDuration,
	animationTimingFunction: "ease",
	animationIterationCount: "infinite"
});
var genSkeletonElementInputSize = (size, calc) => Object.assign({
	width: calc(size).mul(5).equal(),
	minWidth: calc(size).mul(5).equal()
}, genSkeletonElementCommonSize(size));
var genSkeletonElementAvatar = (token$1) => {
	const { skeletonAvatarCls, gradientFromColor, controlHeight, controlHeightLG, controlHeightSM } = token$1;
	return {
		[skeletonAvatarCls]: Object.assign({
			display: "inline-block",
			verticalAlign: "top",
			background: gradientFromColor
		}, genSkeletonElementAvatarSize(controlHeight)),
		[`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: { borderRadius: "50%" },
		[`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
		[`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
	};
};
var genSkeletonElementInput = (token$1) => {
	const { controlHeight, borderRadiusSM, skeletonInputCls, controlHeightLG, controlHeightSM, gradientFromColor, calc } = token$1;
	return {
		[skeletonInputCls]: Object.assign({
			display: "inline-block",
			verticalAlign: "top",
			background: gradientFromColor,
			borderRadius: borderRadiusSM
		}, genSkeletonElementInputSize(controlHeight, calc)),
		[`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG, calc)),
		[`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM, calc))
	};
};
var genSkeletonElementImageSize = (size) => Object.assign({ width: size }, genSkeletonElementCommonSize(size));
var genSkeletonElementImage = (token$1) => {
	const { skeletonImageCls, imageSizeBase, gradientFromColor, borderRadiusSM, calc } = token$1;
	return {
		[skeletonImageCls]: Object.assign(Object.assign({
			display: "inline-flex",
			alignItems: "center",
			justifyContent: "center",
			verticalAlign: "middle",
			background: gradientFromColor,
			borderRadius: borderRadiusSM
		}, genSkeletonElementImageSize(calc(imageSizeBase).mul(2).equal())), {
			[`${skeletonImageCls}-path`]: { fill: "#bfbfbf" },
			[`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
				maxWidth: calc(imageSizeBase).mul(4).equal(),
				maxHeight: calc(imageSizeBase).mul(4).equal()
			}),
			[`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: { borderRadius: "50%" }
		}),
		[`${skeletonImageCls}${skeletonImageCls}-circle`]: { borderRadius: "50%" }
	};
};
var genSkeletonElementButtonShape = (token$1, size, buttonCls) => {
	const { skeletonButtonCls } = token$1;
	return {
		[`${buttonCls}${skeletonButtonCls}-circle`]: {
			width: size,
			minWidth: size,
			borderRadius: "50%"
		},
		[`${buttonCls}${skeletonButtonCls}-round`]: { borderRadius: size }
	};
};
var genSkeletonElementButtonSize = (size, calc) => Object.assign({
	width: calc(size).mul(2).equal(),
	minWidth: calc(size).mul(2).equal()
}, genSkeletonElementCommonSize(size));
var genSkeletonElementButton = (token$1) => {
	const { borderRadiusSM, skeletonButtonCls, controlHeight, controlHeightLG, controlHeightSM, gradientFromColor, calc } = token$1;
	return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ [skeletonButtonCls]: Object.assign({
		display: "inline-block",
		verticalAlign: "top",
		background: gradientFromColor,
		borderRadius: borderRadiusSM,
		width: calc(controlHeight).mul(2).equal(),
		minWidth: calc(controlHeight).mul(2).equal()
	}, genSkeletonElementButtonSize(controlHeight, calc)) }, genSkeletonElementButtonShape(token$1, controlHeight, skeletonButtonCls)), { [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG, calc)) }), genSkeletonElementButtonShape(token$1, controlHeightLG, `${skeletonButtonCls}-lg`)), { [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM, calc)) }), genSkeletonElementButtonShape(token$1, controlHeightSM, `${skeletonButtonCls}-sm`));
};
var genBaseStyle$16 = (token$1) => {
	const { componentCls, skeletonAvatarCls, skeletonTitleCls, skeletonParagraphCls, skeletonButtonCls, skeletonInputCls, skeletonImageCls, controlHeight, controlHeightLG, controlHeightSM, gradientFromColor, padding, marginSM, borderRadius, titleHeight, blockRadius, paragraphLiHeight, controlHeightXS, paragraphMarginTop } = token$1;
	return {
		[componentCls]: {
			display: "table",
			width: "100%",
			[`${componentCls}-header`]: {
				display: "table-cell",
				paddingInlineEnd: padding,
				verticalAlign: "top",
				[skeletonAvatarCls]: Object.assign({
					display: "inline-block",
					verticalAlign: "top",
					background: gradientFromColor
				}, genSkeletonElementAvatarSize(controlHeight)),
				[`${skeletonAvatarCls}-circle`]: { borderRadius: "50%" },
				[`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
				[`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
			},
			[`${componentCls}-content`]: {
				display: "table-cell",
				width: "100%",
				verticalAlign: "top",
				[skeletonTitleCls]: {
					width: "100%",
					height: titleHeight,
					background: gradientFromColor,
					borderRadius: blockRadius,
					[`+ ${skeletonParagraphCls}`]: { marginBlockStart: controlHeightSM }
				},
				[skeletonParagraphCls]: {
					padding: 0,
					"> li": {
						width: "100%",
						height: paragraphLiHeight,
						listStyle: "none",
						background: gradientFromColor,
						borderRadius: blockRadius,
						"+ li": { marginBlockStart: controlHeightXS }
					}
				},
				[`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: { width: "61%" }
			},
			[`&-round ${componentCls}-content`]: { [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: { borderRadius } }
		},
		[`${componentCls}-with-avatar ${componentCls}-content`]: { [skeletonTitleCls]: {
			marginBlockStart: marginSM,
			[`+ ${skeletonParagraphCls}`]: { marginBlockStart: paragraphMarginTop }
		} },
		[`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
			display: "inline-block",
			width: "auto"
		}, genSkeletonElementButton(token$1)), genSkeletonElementAvatar(token$1)), genSkeletonElementInput(token$1)), genSkeletonElementImage(token$1)),
		[`${componentCls}${componentCls}-block`]: {
			width: "100%",
			[skeletonButtonCls]: { width: "100%" },
			[skeletonInputCls]: { width: "100%" }
		},
		[`${componentCls}${componentCls}-active`]: { [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token$1)) }
	};
};
const prepareComponentToken$51 = (token$1) => {
	const { colorFillContent, colorFill } = token$1;
	const gradientFromColor = colorFillContent;
	const gradientToColor = colorFill;
	return {
		color: gradientFromColor,
		colorGradientEnd: gradientToColor,
		gradientFromColor,
		gradientToColor,
		titleHeight: token$1.controlHeight / 2,
		blockRadius: token$1.borderRadiusSM,
		paragraphMarginTop: token$1.marginLG + token$1.marginXXS,
		paragraphLiHeight: token$1.controlHeight / 2
	};
};
var style_default$56 = genStyleHooks("Skeleton", (token$1) => {
	const { componentCls, calc } = token$1;
	const skeletonToken = merge(token$1, {
		skeletonAvatarCls: `${componentCls}-avatar`,
		skeletonTitleCls: `${componentCls}-title`,
		skeletonParagraphCls: `${componentCls}-paragraph`,
		skeletonButtonCls: `${componentCls}-button`,
		skeletonInputCls: `${componentCls}-input`,
		skeletonImageCls: `${componentCls}-image`,
		imageSizeBase: calc(token$1.controlHeight).mul(1.5).equal(),
		borderRadius: 100,
		skeletonLoadingBackground: `linear-gradient(90deg, ${token$1.gradientFromColor} 25%, ${token$1.gradientToColor} 37%, ${token$1.gradientFromColor} 63%)`,
		skeletonLoadingMotionDuration: "1.4s"
	});
	return genBaseStyle$16(skeletonToken);
}, prepareComponentToken$51, { deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]] });

//#endregion
//#region node_modules/antd/es/skeleton/Avatar.js
var import_classnames$247 = /* @__PURE__ */ __toESM(require_classnames());
var SkeletonAvatar = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, active, shape = "circle", size = "default" } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$56(prefixCls);
	const otherProps = omit(props, ["prefixCls", "className"]);
	const cls$12 = (0, import_classnames$247.default)(prefixCls, `${prefixCls}-element`, { [`${prefixCls}-active`]: active }, className, rootClassName, hashId, cssVarCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", { className: cls$12 }, /* @__PURE__ */ import_react.createElement(Element_default, Object.assign({
		prefixCls: `${prefixCls}-avatar`,
		shape,
		size
	}, otherProps))));
};
var Avatar_default$1 = SkeletonAvatar;

//#endregion
//#region node_modules/antd/es/skeleton/Button.js
var import_classnames$246 = /* @__PURE__ */ __toESM(require_classnames());
var SkeletonButton = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, active, block = false, size = "default" } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$56(prefixCls);
	const otherProps = omit(props, ["prefixCls"]);
	const cls$12 = (0, import_classnames$246.default)(prefixCls, `${prefixCls}-element`, {
		[`${prefixCls}-active`]: active,
		[`${prefixCls}-block`]: block
	}, className, rootClassName, hashId, cssVarCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", { className: cls$12 }, /* @__PURE__ */ import_react.createElement(Element_default, Object.assign({
		prefixCls: `${prefixCls}-button`,
		size
	}, otherProps))));
};
var Button_default = SkeletonButton;

//#endregion
//#region node_modules/antd/es/skeleton/Image.js
var import_classnames$245 = /* @__PURE__ */ __toESM(require_classnames());
var path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
var SkeletonImage = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, active } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$56(prefixCls);
	const cls$12 = (0, import_classnames$245.default)(prefixCls, `${prefixCls}-element`, { [`${prefixCls}-active`]: active }, className, rootClassName, hashId, cssVarCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", { className: cls$12 }, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$245.default)(`${prefixCls}-image`, className),
		style: style$1
	}, /* @__PURE__ */ import_react.createElement("svg", {
		viewBox: "0 0 1098 1024",
		xmlns: "http://www.w3.org/2000/svg",
		className: `${prefixCls}-image-svg`
	}, /* @__PURE__ */ import_react.createElement("title", null, "Image placeholder"), /* @__PURE__ */ import_react.createElement("path", {
		d: path,
		className: `${prefixCls}-image-path`
	})))));
};
var Image_default$1 = SkeletonImage;

//#endregion
//#region node_modules/antd/es/skeleton/Input.js
var import_classnames$244 = /* @__PURE__ */ __toESM(require_classnames());
var SkeletonInput = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, active, block, size = "default" } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$56(prefixCls);
	const otherProps = omit(props, ["prefixCls"]);
	const cls$12 = (0, import_classnames$244.default)(prefixCls, `${prefixCls}-element`, {
		[`${prefixCls}-active`]: active,
		[`${prefixCls}-block`]: block
	}, className, rootClassName, hashId, cssVarCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", { className: cls$12 }, /* @__PURE__ */ import_react.createElement(Element_default, Object.assign({
		prefixCls: `${prefixCls}-input`,
		size
	}, otherProps))));
};
var Input_default$4 = SkeletonInput;

//#endregion
//#region node_modules/antd/es/skeleton/Node.js
var import_classnames$243 = /* @__PURE__ */ __toESM(require_classnames());
var SkeletonNode = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, active, children } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$56(prefixCls);
	const cls$12 = (0, import_classnames$243.default)(prefixCls, `${prefixCls}-element`, { [`${prefixCls}-active`]: active }, hashId, className, rootClassName, cssVarCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", { className: cls$12 }, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$243.default)(`${prefixCls}-image`, className),
		style: style$1
	}, children)));
};
var Node_default = SkeletonNode;

//#endregion
//#region node_modules/antd/es/skeleton/Paragraph.js
var import_classnames$242 = /* @__PURE__ */ __toESM(require_classnames());
var getWidth$1 = (index$2, props) => {
	const { width, rows = 2 } = props;
	if (Array.isArray(width)) return width[index$2];
	if (rows - 1 === index$2) return width;
};
var Paragraph$1 = (props) => {
	const { prefixCls, className, style: style$1, rows = 0 } = props;
	const rowList = Array.from({ length: rows }).map((_, index$2) => /* @__PURE__ */ import_react.createElement("li", {
		key: index$2,
		style: { width: getWidth$1(index$2, props) }
	}));
	return /* @__PURE__ */ import_react.createElement("ul", {
		className: (0, import_classnames$242.default)(prefixCls, className),
		style: style$1
	}, rowList);
};
var Paragraph_default$1 = Paragraph$1;

//#endregion
//#region node_modules/antd/es/skeleton/Title.js
var import_classnames$241 = /* @__PURE__ */ __toESM(require_classnames());
var Title$1 = ({ prefixCls, className, width, style: style$1 }) => /* @__PURE__ */ import_react.createElement("h3", {
	className: (0, import_classnames$241.default)(prefixCls, className),
	style: Object.assign({ width }, style$1)
});
var Title_default$1 = Title$1;

//#endregion
//#region node_modules/antd/es/skeleton/Skeleton.js
var import_classnames$240 = /* @__PURE__ */ __toESM(require_classnames());
function getComponentProps(prop) {
	if (prop && typeof prop === "object") return prop;
	return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
	if (hasTitle && !hasParagraph) return {
		size: "large",
		shape: "square"
	};
	return {
		size: "large",
		shape: "circle"
	};
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
	if (!hasAvatar && hasParagraph) return { width: "38%" };
	if (hasAvatar && hasParagraph) return { width: "50%" };
	return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
	const basicProps = {};
	if (!hasAvatar || !hasTitle) basicProps.width = "61%";
	if (!hasAvatar && hasTitle) basicProps.rows = 3;
	else basicProps.rows = 2;
	return basicProps;
}
var Skeleton = (props) => {
	const { prefixCls: customizePrefixCls, loading, className, rootClassName, style: style$1, children, avatar = false, title = true, paragraph = true, active, round: round$2 } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("skeleton");
	const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$56(prefixCls);
	if (loading || !("loading" in props)) {
		const hasAvatar = !!avatar;
		const hasTitle = !!title;
		const hasParagraph = !!paragraph;
		let avatarNode;
		if (hasAvatar) {
			const avatarProps = Object.assign(Object.assign({ prefixCls: `${prefixCls}-avatar` }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
			avatarNode = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-header` }, /* @__PURE__ */ import_react.createElement(Element_default, Object.assign({}, avatarProps)));
		}
		let contentNode;
		if (hasTitle || hasParagraph) {
			let $title;
			if (hasTitle) {
				const titleProps = Object.assign(Object.assign({ prefixCls: `${prefixCls}-title` }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
				$title = /* @__PURE__ */ import_react.createElement(Title_default$1, Object.assign({}, titleProps));
			}
			let paragraphNode;
			if (hasParagraph) {
				const paragraphProps = Object.assign(Object.assign({ prefixCls: `${prefixCls}-paragraph` }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
				paragraphNode = /* @__PURE__ */ import_react.createElement(Paragraph_default$1, Object.assign({}, paragraphProps));
			}
			contentNode = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-content` }, $title, paragraphNode);
		}
		const cls$12 = (0, import_classnames$240.default)(prefixCls, {
			[`${prefixCls}-with-avatar`]: hasAvatar,
			[`${prefixCls}-active`]: active,
			[`${prefixCls}-rtl`]: direction === "rtl",
			[`${prefixCls}-round`]: round$2
		}, contextClassName, className, rootClassName, hashId, cssVarCls);
		return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
			className: cls$12,
			style: Object.assign(Object.assign({}, contextStyle), style$1)
		}, avatarNode, contentNode));
	}
	return children !== null && children !== void 0 ? children : null;
};
Skeleton.Button = Button_default;
Skeleton.Avatar = Avatar_default$1;
Skeleton.Input = Input_default$4;
Skeleton.Image = Image_default$1;
Skeleton.Node = Node_default;
Skeleton.displayName = "Skeleton";
var Skeleton_default = Skeleton;

//#endregion
//#region node_modules/antd/es/skeleton/index.js
var skeleton_default = Skeleton_default;

//#endregion
//#region node_modules/antd/es/watermark/context.js
function voidFunc() {}
var WatermarkContext = /* @__PURE__ */ import_react.createContext({
	add: voidFunc,
	remove: voidFunc
});
function usePanelRef(panelSelector) {
	const watermark = import_react.useContext(WatermarkContext);
	const panelEleRef = import_react.useRef(null);
	return useEvent((ele) => {
		if (ele) {
			const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
			watermark.add(innerContentEle);
			panelEleRef.current = innerContentEle;
		} else watermark.remove(panelEleRef.current);
	});
}
var context_default = WatermarkContext;

//#endregion
//#region node_modules/antd/es/modal/components/NormalCancelBtn.js
var NormalCancelBtn = () => {
	const { cancelButtonProps, cancelTextLocale, onCancel } = (0, import_react.useContext)(ModalContext);
	return /* @__PURE__ */ import_react.createElement(button_default, Object.assign({ onClick: onCancel }, cancelButtonProps), cancelTextLocale);
};
var NormalCancelBtn_default = NormalCancelBtn;

//#endregion
//#region node_modules/antd/es/modal/components/NormalOkBtn.js
var NormalOkBtn = () => {
	const { confirmLoading, okButtonProps, okType, okTextLocale, onOk } = (0, import_react.useContext)(ModalContext);
	return /* @__PURE__ */ import_react.createElement(button_default, Object.assign({}, convertLegacyProps(okType), {
		loading: confirmLoading,
		onClick: onOk
	}, okButtonProps), okTextLocale);
};
var NormalOkBtn_default = NormalOkBtn;

//#endregion
//#region node_modules/antd/es/modal/shared.js
function renderCloseIcon(prefixCls, closeIcon) {
	return /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-close-x` }, closeIcon || /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` }));
}
const Footer$1 = (props) => {
	const { okText, okType = "primary", cancelText, confirmLoading, onOk, onCancel, okButtonProps, cancelButtonProps, footer } = props;
	const [locale$5] = useLocale_default("Modal", getConfirmLocale());
	const okTextLocale = okText || (locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.okText);
	const cancelTextLocale = cancelText || (locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.cancelText);
	const btnCtxValue = {
		confirmLoading,
		okButtonProps,
		cancelButtonProps,
		okTextLocale,
		cancelTextLocale,
		okType,
		onOk,
		onCancel
	};
	const btnCtxValueMemo = import_react.useMemo(() => btnCtxValue, _toConsumableArray(Object.values(btnCtxValue)));
	let footerNode;
	if (typeof footer === "function" || typeof footer === "undefined") {
		footerNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(NormalCancelBtn_default, null), /* @__PURE__ */ import_react.createElement(NormalOkBtn_default, null));
		if (typeof footer === "function") footerNode = footer(footerNode, {
			OkBtn: NormalOkBtn_default,
			CancelBtn: NormalCancelBtn_default
		});
		footerNode = /* @__PURE__ */ import_react.createElement(ModalContextProvider, { value: btnCtxValueMemo }, footerNode);
	} else footerNode = footer;
	return /* @__PURE__ */ import_react.createElement(DisabledContextProvider, { disabled: false }, footerNode);
};

//#endregion
//#region node_modules/antd/es/grid/style/index.js
var genGridRowStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		display: "flex",
		flexFlow: "row wrap",
		minWidth: 0,
		"&::before, &::after": { display: "flex" },
		"&-no-wrap": { flexWrap: "nowrap" },
		"&-start": { justifyContent: "flex-start" },
		"&-center": { justifyContent: "center" },
		"&-end": { justifyContent: "flex-end" },
		"&-space-between": { justifyContent: "space-between" },
		"&-space-around": { justifyContent: "space-around" },
		"&-space-evenly": { justifyContent: "space-evenly" },
		"&-top": { alignItems: "flex-start" },
		"&-middle": { alignItems: "center" },
		"&-bottom": { alignItems: "flex-end" }
	} };
};
var genGridColStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		position: "relative",
		maxWidth: "100%",
		minHeight: 1
	} };
};
var genLoopGridColumnsStyle = (token$1, sizeCls) => {
	const { prefixCls, componentCls, gridColumns } = token$1;
	const gridColumnsStyle = {};
	for (let i = gridColumns; i >= 0; i--) if (i === 0) {
		gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = { display: "none" };
		gridColumnsStyle[`${componentCls}-push-${i}`] = { insetInlineStart: "auto" };
		gridColumnsStyle[`${componentCls}-pull-${i}`] = { insetInlineEnd: "auto" };
		gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = { insetInlineStart: "auto" };
		gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = { insetInlineEnd: "auto" };
		gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = { marginInlineStart: 0 };
		gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = { order: 0 };
	} else {
		gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = [{
			["--ant-display"]: "block",
			display: "block"
		}, {
			display: "var(--ant-display)",
			flex: `0 0 ${i / gridColumns * 100}%`,
			maxWidth: `${i / gridColumns * 100}%`
		}];
		gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = { insetInlineStart: `${i / gridColumns * 100}%` };
		gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = { insetInlineEnd: `${i / gridColumns * 100}%` };
		gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = { marginInlineStart: `${i / gridColumns * 100}%` };
		gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = { order: i };
	}
	gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = { flex: `var(--${prefixCls}${sizeCls}-flex)` };
	return gridColumnsStyle;
};
var genGridStyle = (token$1, sizeCls) => genLoopGridColumnsStyle(token$1, sizeCls);
var genGridMediaStyle = (token$1, screenSize, sizeCls) => ({ [`@media (min-width: ${unit(screenSize)})`]: Object.assign({}, genGridStyle(token$1, sizeCls)) });
const prepareRowComponentToken = () => ({});
const prepareColComponentToken = () => ({});
const useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
const getMediaSize = (token$1) => {
	return {
		xs: token$1.screenXSMin,
		sm: token$1.screenSMMin,
		md: token$1.screenMDMin,
		lg: token$1.screenLGMin,
		xl: token$1.screenXLMin,
		xxl: token$1.screenXXLMin
	};
};
const useColStyle = genStyleHooks("Grid", (token$1) => {
	const gridToken = merge(token$1, { gridColumns: 24 });
	const gridMediaSizesMap = getMediaSize(gridToken);
	delete gridMediaSizesMap.xs;
	return [
		genGridColStyle(gridToken),
		genGridStyle(gridToken, ""),
		genGridStyle(gridToken, "-xs"),
		Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], `-${key}`)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})
	];
}, prepareColComponentToken);

//#endregion
//#region node_modules/antd/es/modal/style/index.js
function box(position$2) {
	return {
		position: position$2,
		inset: 0
	};
}
const genModalMaskStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	return [{ [`${componentCls}-root`]: {
		[`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
			transform: "none",
			opacity: 0,
			animationDuration: token$1.motionDurationSlow,
			userSelect: "none"
		},
		[`${componentCls}${antCls}-zoom-leave ${componentCls}-content`]: { pointerEvents: "none" },
		[`${componentCls}-mask`]: Object.assign(Object.assign({}, box("fixed")), {
			zIndex: token$1.zIndexPopupBase,
			height: "100%",
			backgroundColor: token$1.colorBgMask,
			pointerEvents: "none",
			[`${componentCls}-hidden`]: { display: "none" }
		}),
		[`${componentCls}-wrap`]: Object.assign(Object.assign({}, box("fixed")), {
			zIndex: token$1.zIndexPopupBase,
			overflow: "auto",
			outline: 0,
			WebkitOverflowScrolling: "touch"
		})
	} }, { [`${componentCls}-root`]: initFadeMotion(token$1) }];
};
var genModalStyle = (token$1) => {
	const { componentCls } = token$1;
	return [
		{ [`${componentCls}-root`]: {
			[`${componentCls}-wrap-rtl`]: { direction: "rtl" },
			[`${componentCls}-centered`]: {
				textAlign: "center",
				"&::before": {
					display: "inline-block",
					width: 0,
					height: "100%",
					verticalAlign: "middle",
					content: "\"\""
				},
				[componentCls]: {
					top: 0,
					display: "inline-block",
					paddingBottom: 0,
					textAlign: "start",
					verticalAlign: "middle"
				}
			},
			[`@media (max-width: ${token$1.screenSMMax}px)`]: {
				[componentCls]: {
					maxWidth: "calc(100vw - 16px)",
					margin: `${unit(token$1.marginXS)} auto`
				},
				[`${componentCls}-centered`]: { [componentCls]: { flex: 1 } }
			}
		} },
		{ [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			pointerEvents: "none",
			position: "relative",
			top: 100,
			width: "auto",
			maxWidth: `calc(100vw - ${unit(token$1.calc(token$1.margin).mul(2).equal())})`,
			margin: "0 auto",
			paddingBottom: token$1.paddingLG,
			[`${componentCls}-title`]: {
				margin: 0,
				color: token$1.titleColor,
				fontWeight: token$1.fontWeightStrong,
				fontSize: token$1.titleFontSize,
				lineHeight: token$1.titleLineHeight,
				wordWrap: "break-word"
			},
			[`${componentCls}-content`]: {
				position: "relative",
				backgroundColor: token$1.contentBg,
				backgroundClip: "padding-box",
				border: 0,
				borderRadius: token$1.borderRadiusLG,
				boxShadow: token$1.boxShadow,
				pointerEvents: "auto",
				padding: token$1.contentPadding
			},
			[`${componentCls}-close`]: Object.assign({
				position: "absolute",
				top: token$1.calc(token$1.modalHeaderHeight).sub(token$1.modalCloseBtnSize).div(2).equal(),
				insetInlineEnd: token$1.calc(token$1.modalHeaderHeight).sub(token$1.modalCloseBtnSize).div(2).equal(),
				zIndex: token$1.calc(token$1.zIndexPopupBase).add(10).equal(),
				padding: 0,
				color: token$1.modalCloseIconColor,
				fontWeight: token$1.fontWeightStrong,
				lineHeight: 1,
				textDecoration: "none",
				background: "transparent",
				borderRadius: token$1.borderRadiusSM,
				width: token$1.modalCloseBtnSize,
				height: token$1.modalCloseBtnSize,
				border: 0,
				outline: 0,
				cursor: "pointer",
				transition: `color ${token$1.motionDurationMid}, background-color ${token$1.motionDurationMid}`,
				"&-x": {
					display: "flex",
					fontSize: token$1.fontSizeLG,
					fontStyle: "normal",
					lineHeight: unit(token$1.modalCloseBtnSize),
					justifyContent: "center",
					textTransform: "none",
					textRendering: "auto"
				},
				"&:disabled": { pointerEvents: "none" },
				"&:hover": {
					color: token$1.modalCloseIconHoverColor,
					backgroundColor: token$1.colorBgTextHover,
					textDecoration: "none"
				},
				"&:active": { backgroundColor: token$1.colorBgTextActive }
			}, genFocusStyle(token$1)),
			[`${componentCls}-header`]: {
				color: token$1.colorText,
				background: token$1.headerBg,
				borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0`,
				marginBottom: token$1.headerMarginBottom,
				padding: token$1.headerPadding,
				borderBottom: token$1.headerBorderBottom
			},
			[`${componentCls}-body`]: {
				fontSize: token$1.fontSize,
				lineHeight: token$1.lineHeight,
				wordWrap: "break-word",
				padding: token$1.bodyPadding,
				[`${componentCls}-body-skeleton`]: {
					width: "100%",
					height: "100%",
					display: "flex",
					justifyContent: "center",
					alignItems: "center",
					margin: `${unit(token$1.margin)} auto`
				}
			},
			[`${componentCls}-footer`]: {
				textAlign: "end",
				background: token$1.footerBg,
				marginTop: token$1.footerMarginTop,
				padding: token$1.footerPadding,
				borderTop: token$1.footerBorderTop,
				borderRadius: token$1.footerBorderRadius,
				[`> ${token$1.antCls}-btn + ${token$1.antCls}-btn`]: { marginInlineStart: token$1.marginXS }
			},
			[`${componentCls}-open`]: { overflow: "hidden" }
		}) },
		{ [`${componentCls}-pure-panel`]: {
			top: "auto",
			padding: 0,
			display: "flex",
			flexDirection: "column",
			[`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
				display: "flex",
				flexDirection: "column",
				flex: "auto"
			},
			[`${componentCls}-confirm-body`]: { marginBottom: "auto" }
		} }
	];
};
var genRTLStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-root`]: { [`${componentCls}-wrap-rtl`]: {
		direction: "rtl",
		[`${componentCls}-confirm-body`]: { direction: "rtl" }
	} } };
};
var genResponsiveWidthStyle = (token$1) => {
	const { componentCls } = token$1;
	const oriGridMediaSizesMap = getMediaSize(token$1);
	const gridMediaSizesMap = Object.assign({}, oriGridMediaSizesMap);
	delete gridMediaSizesMap.xs;
	const cssVarPrefix = `--${componentCls.replace(".", "")}-`;
	const responsiveStyles = Object.keys(gridMediaSizesMap).map((key) => ({ [`@media (min-width: ${unit(gridMediaSizesMap[key])})`]: { width: `var(${cssVarPrefix}${key}-width)` } }));
	return { [`${componentCls}-root`]: { [componentCls]: [].concat(_toConsumableArray(Object.keys(oriGridMediaSizesMap).map((currentKey, index$2) => {
		const previousKey = Object.keys(oriGridMediaSizesMap)[index$2 - 1];
		return previousKey ? { [`${cssVarPrefix}${currentKey}-width`]: `var(${cssVarPrefix}${previousKey}-width)` } : null;
	})), [{ width: `var(${cssVarPrefix}xs-width)` }], _toConsumableArray(responsiveStyles)) } };
};
const prepareToken$4 = (token$1) => {
	const headerPaddingVertical = token$1.padding;
	const headerFontSize = token$1.fontSizeHeading5;
	const headerLineHeight = token$1.lineHeightHeading5;
	return merge(token$1, {
		modalHeaderHeight: token$1.calc(token$1.calc(headerLineHeight).mul(headerFontSize).equal()).add(token$1.calc(headerPaddingVertical).mul(2).equal()).equal(),
		modalFooterBorderColorSplit: token$1.colorSplit,
		modalFooterBorderStyle: token$1.lineType,
		modalFooterBorderWidth: token$1.lineWidth,
		modalCloseIconColor: token$1.colorIcon,
		modalCloseIconHoverColor: token$1.colorIconHover,
		modalCloseBtnSize: token$1.controlHeight,
		modalConfirmIconSize: token$1.fontHeight,
		modalTitleHeight: token$1.calc(token$1.titleFontSize).mul(token$1.titleLineHeight).equal()
	});
};
const prepareComponentToken$50 = (token$1) => ({
	footerBg: "transparent",
	headerBg: token$1.colorBgElevated,
	titleLineHeight: token$1.lineHeightHeading5,
	titleFontSize: token$1.fontSizeHeading5,
	contentBg: token$1.colorBgElevated,
	titleColor: token$1.colorTextHeading,
	contentPadding: token$1.wireframe ? 0 : `${unit(token$1.paddingMD)} ${unit(token$1.paddingContentHorizontalLG)}`,
	headerPadding: token$1.wireframe ? `${unit(token$1.padding)} ${unit(token$1.paddingLG)}` : 0,
	headerBorderBottom: token$1.wireframe ? `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` : "none",
	headerMarginBottom: token$1.wireframe ? 0 : token$1.marginXS,
	bodyPadding: token$1.wireframe ? token$1.paddingLG : 0,
	footerPadding: token$1.wireframe ? `${unit(token$1.paddingXS)} ${unit(token$1.padding)}` : 0,
	footerBorderTop: token$1.wireframe ? `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` : "none",
	footerBorderRadius: token$1.wireframe ? `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}` : 0,
	footerMarginTop: token$1.wireframe ? 0 : token$1.marginSM,
	confirmBodyPadding: token$1.wireframe ? `${unit(token$1.padding * 2)} ${unit(token$1.padding * 2)} ${unit(token$1.paddingLG)}` : 0,
	confirmIconMarginInlineEnd: token$1.wireframe ? token$1.margin : token$1.marginSM,
	confirmBtnsMarginTop: token$1.wireframe ? token$1.marginLG : token$1.marginSM
});
var style_default$18 = genStyleHooks("Modal", (token$1) => {
	const modalToken = prepareToken$4(token$1);
	return [
		genModalStyle(modalToken),
		genRTLStyle(modalToken),
		genModalMaskStyle(modalToken),
		initZoomMotion(modalToken, "zoom"),
		genResponsiveWidthStyle(modalToken)
	];
}, prepareComponentToken$50, { unitless: { titleLineHeight: true } });

//#endregion
//#region node_modules/antd/es/modal/Modal.js
var import_classnames$239 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$104 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var mousePosition;
var getClickPosition = (e$2) => {
	mousePosition = {
		x: e$2.pageX,
		y: e$2.pageY
	};
	setTimeout(() => {
		mousePosition = null;
	}, 100);
};
if (canUseDocElement()) document.documentElement.addEventListener("click", getClickPosition, true);
var Modal$1 = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, open: open$2, wrapClassName, centered, getContainer: getContainer$1, focusTriggerAfterClose = true, style: style$1, visible, width = 520, footer, classNames: modalClassNames, styles: modalStyles, children, loading, confirmLoading, zIndex: customizeZIndex, mousePosition: customizeMousePosition, onOk, onCancel, destroyOnHidden, destroyOnClose, panelRef = null } = props, restProps = __rest$104(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"open",
		"wrapClassName",
		"centered",
		"getContainer",
		"focusTriggerAfterClose",
		"style",
		"visible",
		"width",
		"footer",
		"classNames",
		"styles",
		"children",
		"loading",
		"confirmLoading",
		"zIndex",
		"mousePosition",
		"onOk",
		"onCancel",
		"destroyOnHidden",
		"destroyOnClose",
		"panelRef"
	]);
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, direction, modal: modalContext } = import_react.useContext(ConfigContext);
	const handleCancel = (e$2) => {
		if (confirmLoading) return;
		onCancel === null || onCancel === void 0 || onCancel(e$2);
	};
	const handleOk = (e$2) => {
		onOk === null || onOk === void 0 || onOk(e$2);
	};
	{
		const warning$4 = devUseWarning("Modal");
		[
			["visible", "open"],
			["bodyStyle", "styles.body"],
			["maskStyle", "styles.mask"],
			["destroyOnClose", "destroyOnHidden"]
		].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const prefixCls = getPrefixCls("modal", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$18(prefixCls, rootCls);
	const wrapClassNameExtended = (0, import_classnames$239.default)(wrapClassName, {
		[`${prefixCls}-centered`]: centered !== null && centered !== void 0 ? centered : modalContext === null || modalContext === void 0 ? void 0 : modalContext.centered,
		[`${prefixCls}-wrap-rtl`]: direction === "rtl"
	});
	const dialogFooter = footer !== null && !loading ? /* @__PURE__ */ import_react.createElement(Footer$1, Object.assign({}, props, {
		onOk: handleOk,
		onCancel: handleCancel
	})) : null;
	const [mergedClosable, mergedCloseIcon, closeBtnIsDisabled, ariaProps] = useClosable(pickClosable(props), pickClosable(modalContext), {
		closable: true,
		closeIcon: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` }),
		closeIconRender: (icon) => renderCloseIcon(prefixCls, icon)
	});
	const innerPanelRef = usePanelRef(`.${prefixCls}-content`);
	const mergedPanelRef = composeRef(panelRef, innerPanelRef);
	const [zIndex, contextZIndex] = useZIndex("Modal", customizeZIndex);
	const [numWidth, responsiveWidth] = import_react.useMemo(() => {
		if (width && typeof width === "object") return [void 0, width];
		return [width, void 0];
	}, [width]);
	const responsiveWidthVars = import_react.useMemo(() => {
		const vars = {};
		if (responsiveWidth) Object.keys(responsiveWidth).forEach((breakpoint) => {
			const breakpointWidth = responsiveWidth[breakpoint];
			if (breakpointWidth !== void 0) vars[`--${prefixCls}-${breakpoint}-width`] = typeof breakpointWidth === "number" ? `${breakpointWidth}px` : breakpointWidth;
		});
		return vars;
	}, [responsiveWidth]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
		form: true,
		space: true
	}, /* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ import_react.createElement(es_default$16, Object.assign({ width: numWidth }, restProps, {
		zIndex,
		getContainer: getContainer$1 === void 0 ? getContextPopupContainer : getContainer$1,
		prefixCls,
		rootClassName: (0, import_classnames$239.default)(hashId, rootClassName, cssVarCls, rootCls),
		footer: dialogFooter,
		visible: open$2 !== null && open$2 !== void 0 ? open$2 : visible,
		mousePosition: customizeMousePosition !== null && customizeMousePosition !== void 0 ? customizeMousePosition : mousePosition,
		onClose: handleCancel,
		closable: mergedClosable ? Object.assign({
			disabled: closeBtnIsDisabled,
			closeIcon: mergedCloseIcon
		}, ariaProps) : mergedClosable,
		closeIcon: mergedCloseIcon,
		focusTriggerAfterClose,
		transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
		maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
		className: (0, import_classnames$239.default)(hashId, className, modalContext === null || modalContext === void 0 ? void 0 : modalContext.className),
		style: Object.assign(Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.style), style$1), responsiveWidthVars),
		classNames: Object.assign(Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.classNames), modalClassNames), { wrapper: (0, import_classnames$239.default)(wrapClassNameExtended, modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.wrapper) }),
		styles: Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.styles), modalStyles),
		panelRef: mergedPanelRef,
		destroyOnClose: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyOnClose
	}), loading ? /* @__PURE__ */ import_react.createElement(skeleton_default, {
		active: true,
		title: false,
		paragraph: { rows: 4 },
		className: `${prefixCls}-body-skeleton`
	}) : children))));
};
var Modal_default = Modal$1;

//#endregion
//#region node_modules/antd/es/modal/style/confirm.js
var genModalConfirmStyle = (token$1) => {
	const { componentCls, titleFontSize, titleLineHeight, modalConfirmIconSize, fontSize, lineHeight, modalTitleHeight, fontHeight, confirmBodyPadding } = token$1;
	const confirmComponentCls = `${componentCls}-confirm`;
	return {
		[confirmComponentCls]: {
			"&-rtl": { direction: "rtl" },
			[`${token$1.antCls}-modal-header`]: { display: "none" },
			[`${confirmComponentCls}-body-wrapper`]: Object.assign({}, clearFix()),
			[`&${componentCls} ${componentCls}-body`]: { padding: confirmBodyPadding },
			[`${confirmComponentCls}-body`]: {
				display: "flex",
				flexWrap: "nowrap",
				alignItems: "start",
				[`> ${token$1.iconCls}`]: {
					flex: "none",
					fontSize: modalConfirmIconSize,
					marginInlineEnd: token$1.confirmIconMarginInlineEnd,
					marginTop: token$1.calc(token$1.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
				},
				[`&-has-title > ${token$1.iconCls}`]: { marginTop: token$1.calc(token$1.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal() }
			},
			[`${confirmComponentCls}-paragraph`]: {
				display: "flex",
				flexDirection: "column",
				flex: "auto",
				rowGap: token$1.marginXS,
				maxWidth: `calc(100% - ${unit(token$1.marginSM)})`
			},
			[`${token$1.iconCls} + ${confirmComponentCls}-paragraph`]: { maxWidth: `calc(100% - ${unit(token$1.calc(token$1.modalConfirmIconSize).add(token$1.marginSM).equal())})` },
			[`${confirmComponentCls}-title`]: {
				color: token$1.colorTextHeading,
				fontWeight: token$1.fontWeightStrong,
				fontSize: titleFontSize,
				lineHeight: titleLineHeight
			},
			[`${confirmComponentCls}-content`]: {
				color: token$1.colorText,
				fontSize,
				lineHeight
			},
			[`${confirmComponentCls}-btns`]: {
				textAlign: "end",
				marginTop: token$1.confirmBtnsMarginTop,
				[`${token$1.antCls}-btn + ${token$1.antCls}-btn`]: {
					marginBottom: 0,
					marginInlineStart: token$1.marginXS
				}
			}
		},
		[`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token$1.iconCls}`]: { color: token$1.colorError },
		[`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token$1.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token$1.iconCls}`]: { color: token$1.colorWarning },
		[`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token$1.iconCls}`]: { color: token$1.colorInfo },
		[`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token$1.iconCls}`]: { color: token$1.colorSuccess }
	};
};
var confirm_default = genSubStyleComponent(["Modal", "confirm"], (token$1) => {
	const modalToken = prepareToken$4(token$1);
	return genModalConfirmStyle(modalToken);
}, prepareComponentToken$50, { order: -1e3 });

//#endregion
//#region node_modules/antd/es/modal/ConfirmDialog.js
var import_classnames$238 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$103 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function ConfirmContent(props) {
	const { prefixCls, icon, okText, cancelText, confirmPrefixCls, type: type$2, okCancel, footer, locale: staticLocale } = props, resetProps = __rest$103(props, [
		"prefixCls",
		"icon",
		"okText",
		"cancelText",
		"confirmPrefixCls",
		"type",
		"okCancel",
		"footer",
		"locale"
	]);
	devUseWarning("Modal")(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`);
	let mergedIcon = icon;
	if (!icon && icon !== null) switch (type$2) {
		case "info":
			mergedIcon = /* @__PURE__ */ import_react.createElement(InfoCircleFilled_default, null);
			break;
		case "success":
			mergedIcon = /* @__PURE__ */ import_react.createElement(CheckCircleFilled_default, null);
			break;
		case "error":
			mergedIcon = /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null);
			break;
		default: mergedIcon = /* @__PURE__ */ import_react.createElement(ExclamationCircleFilled_default, null);
	}
	const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type$2 === "confirm";
	const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
	const [locale$5] = useLocale_default("Modal");
	const mergedLocale = staticLocale || locale$5;
	const okTextLocale = okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText);
	const cancelTextLocale = cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText);
	const btnCtxValue = Object.assign({
		autoFocusButton,
		cancelTextLocale,
		okTextLocale,
		mergedOkCancel
	}, resetProps);
	const btnCtxValueMemo = import_react.useMemo(() => btnCtxValue, _toConsumableArray(Object.values(btnCtxValue)));
	const footerOriginNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ConfirmCancelBtn_default, null), /* @__PURE__ */ import_react.createElement(ConfirmOkBtn_default, null));
	const hasTitle = props.title !== void 0 && props.title !== null;
	const bodyCls = `${confirmPrefixCls}-body`;
	return /* @__PURE__ */ import_react.createElement("div", { className: `${confirmPrefixCls}-body-wrapper` }, /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$238.default)(bodyCls, { [`${bodyCls}-has-title`]: hasTitle }) }, mergedIcon, /* @__PURE__ */ import_react.createElement("div", { className: `${confirmPrefixCls}-paragraph` }, hasTitle && /* @__PURE__ */ import_react.createElement("span", { className: `${confirmPrefixCls}-title` }, props.title), /* @__PURE__ */ import_react.createElement("div", { className: `${confirmPrefixCls}-content` }, props.content))), footer === void 0 || typeof footer === "function" ? /* @__PURE__ */ import_react.createElement(ModalContextProvider, { value: btnCtxValueMemo }, /* @__PURE__ */ import_react.createElement("div", { className: `${confirmPrefixCls}-btns` }, typeof footer === "function" ? footer(footerOriginNode, {
		OkBtn: ConfirmOkBtn_default,
		CancelBtn: ConfirmCancelBtn_default
	}) : footerOriginNode)) : footer, /* @__PURE__ */ import_react.createElement(confirm_default, { prefixCls }));
}
var ConfirmDialog = (props) => {
	const { close, zIndex, maskStyle, direction, prefixCls, wrapClassName, rootPrefixCls, bodyStyle, closable = false, onConfirm, styles } = props;
	{
		const warning$4 = devUseWarning("Modal");
		[
			["visible", "open"],
			["bodyStyle", "styles.body"],
			["maskStyle", "styles.mask"]
		].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const confirmPrefixCls = `${prefixCls}-confirm`;
	const width = props.width || 416;
	const style$1 = props.style || {};
	const mask = props.mask === void 0 ? true : props.mask;
	const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
	const classString = (0, import_classnames$238.default)(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, { [`${confirmPrefixCls}-rtl`]: direction === "rtl" }, props.className);
	const [, token$1] = useToken();
	const mergedZIndex = import_react.useMemo(() => {
		if (zIndex !== void 0) return zIndex;
		return token$1.zIndexPopupBase + CONTAINER_MAX_OFFSET;
	}, [zIndex, token$1]);
	return /* @__PURE__ */ import_react.createElement(Modal_default, Object.assign({}, props, {
		className: classString,
		wrapClassName: (0, import_classnames$238.default)({ [`${confirmPrefixCls}-centered`]: !!props.centered }, wrapClassName),
		onCancel: () => {
			close === null || close === void 0 || close({ triggerCancel: true });
			onConfirm === null || onConfirm === void 0 || onConfirm(false);
		},
		title: "",
		footer: null,
		transitionName: getTransitionName(rootPrefixCls || "", "zoom", props.transitionName),
		maskTransitionName: getTransitionName(rootPrefixCls || "", "fade", props.maskTransitionName),
		mask,
		maskClosable,
		style: style$1,
		styles: Object.assign({
			body: bodyStyle,
			mask: maskStyle
		}, styles),
		width,
		zIndex: mergedZIndex,
		closable
	}), /* @__PURE__ */ import_react.createElement(ConfirmContent, Object.assign({}, props, { confirmPrefixCls })));
};
var ConfirmDialogWrapper$1 = (props) => {
	const { rootPrefixCls, iconPrefixCls, direction, theme } = props;
	return /* @__PURE__ */ import_react.createElement(config_provider_default, {
		prefixCls: rootPrefixCls,
		iconPrefixCls,
		direction,
		theme
	}, /* @__PURE__ */ import_react.createElement(ConfirmDialog, Object.assign({}, props)));
};
ConfirmDialog.displayName = "ConfirmDialog";
ConfirmDialogWrapper$1.displayName = "ConfirmDialogWrapper";
var ConfirmDialog_default = ConfirmDialogWrapper$1;

//#endregion
//#region node_modules/antd/es/modal/destroyFns.js
var destroyFns = [];
var destroyFns_default = destroyFns;

//#endregion
//#region node_modules/antd/es/modal/confirm.js
var defaultRootPrefixCls = "";
function getRootPrefixCls() {
	return defaultRootPrefixCls;
}
var ConfirmDialogWrapper = (props) => {
	var _a, _b;
	const { prefixCls: customizePrefixCls, getContainer: getContainer$1, direction } = props;
	const runtimeLocale$1 = getConfirmLocale();
	const config = (0, import_react.useContext)(ConfigContext);
	const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();
	const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
	let mergedGetContainer = getContainer$1;
	if (mergedGetContainer === false) {
		mergedGetContainer = void 0;
		warning_default$1(false, "Modal", "Static method not support `getContainer` to be `false` since it do not have context env.");
	}
	return /* @__PURE__ */ import_react.createElement(ConfirmDialog_default, Object.assign({}, props, {
		rootPrefixCls,
		prefixCls,
		iconPrefixCls: config.iconPrefixCls,
		theme: config.theme,
		direction: direction !== null && direction !== void 0 ? direction : config.direction,
		locale: (_b = (_a = config.locale) === null || _a === void 0 ? void 0 : _a.Modal) !== null && _b !== void 0 ? _b : runtimeLocale$1,
		getContainer: mergedGetContainer
	}));
};
function confirm(config) {
	const global$2 = globalConfig();
	if (!global$2.holderRender) warnContext("Modal");
	const container = document.createDocumentFragment();
	let currentConfig = Object.assign(Object.assign({}, config), {
		close,
		open: true
	});
	let timeoutId;
	let reactUnmount;
	function destroy$2(...args) {
		var _a;
		if (args.some((param) => param === null || param === void 0 ? void 0 : param.triggerCancel)) {
			var _a2;
			(_a = config.onCancel) === null || _a === void 0 || (_a2 = _a).call.apply(_a2, [config, () => {}].concat(_toConsumableArray(args.slice(1))));
		}
		for (let i = 0; i < destroyFns_default.length; i++) if (destroyFns_default[i] === close) {
			destroyFns_default.splice(i, 1);
			break;
		}
		reactUnmount();
	}
	function render$1(props) {
		clearTimeout(timeoutId);
		/**
		* https://github.com/ant-design/ant-design/issues/23623
		*
		* Sync render blocks React event. Let's make this async.
		*/
		timeoutId = setTimeout(() => {
			const rootPrefixCls = global$2.getPrefixCls(void 0, getRootPrefixCls());
			const iconPrefixCls = global$2.getIconPrefixCls();
			const theme = global$2.getTheme();
			const dom = /* @__PURE__ */ import_react.createElement(ConfirmDialogWrapper, Object.assign({}, props));
			reactUnmount = unstableSetRender()(/* @__PURE__ */ import_react.createElement(config_provider_default, {
				prefixCls: rootPrefixCls,
				iconPrefixCls,
				theme
			}, global$2.holderRender ? global$2.holderRender(dom) : dom), container);
		});
	}
	function close(...args) {
		currentConfig = Object.assign(Object.assign({}, currentConfig), {
			open: false,
			afterClose: () => {
				if (typeof config.afterClose === "function") config.afterClose();
				destroy$2.apply(this, args);
			}
		});
		if (currentConfig.visible) delete currentConfig.visible;
		render$1(currentConfig);
	}
	function update(configUpdate) {
		if (typeof configUpdate === "function") currentConfig = configUpdate(currentConfig);
		else currentConfig = Object.assign(Object.assign({}, currentConfig), configUpdate);
		render$1(currentConfig);
	}
	render$1(currentConfig);
	destroyFns_default.push(close);
	return {
		destroy: close,
		update
	};
}
function withWarn(props) {
	return Object.assign(Object.assign({}, props), { type: "warning" });
}
function withInfo(props) {
	return Object.assign(Object.assign({}, props), { type: "info" });
}
function withSuccess(props) {
	return Object.assign(Object.assign({}, props), { type: "success" });
}
function withError(props) {
	return Object.assign(Object.assign({}, props), { type: "error" });
}
function withConfirm(props) {
	return Object.assign(Object.assign({}, props), { type: "confirm" });
}
function modalGlobalConfig({ rootPrefixCls }) {
	warning_default$1(false, "Modal", "Modal.config is deprecated. Please use ConfigProvider.config instead.");
	defaultRootPrefixCls = rootPrefixCls;
}

//#endregion
//#region node_modules/antd/es/modal/useModal/HookModal.js
var __rest$102 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var HookModal = (_a, ref) => {
	var _b;
	var { afterClose: hookAfterClose, config } = _a, restProps = __rest$102(_a, ["afterClose", "config"]);
	const [open$2, setOpen] = import_react.useState(true);
	const [innerConfig, setInnerConfig] = import_react.useState(config);
	const { direction, getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("modal");
	const rootPrefixCls = getPrefixCls();
	const afterClose = () => {
		var _a$1;
		hookAfterClose();
		(_a$1 = innerConfig.afterClose) === null || _a$1 === void 0 || _a$1.call(innerConfig);
	};
	const close = (...args) => {
		var _a$1;
		setOpen(false);
		if (args.some((param) => param === null || param === void 0 ? void 0 : param.triggerCancel)) {
			var _a2;
			(_a$1 = innerConfig.onCancel) === null || _a$1 === void 0 || (_a2 = _a$1).call.apply(_a2, [innerConfig, () => {}].concat(_toConsumableArray(args.slice(1))));
		}
	};
	import_react.useImperativeHandle(ref, () => ({
		destroy: close,
		update: (newConfig) => {
			setInnerConfig((originConfig) => {
				const nextConfig = typeof newConfig === "function" ? newConfig(originConfig) : newConfig;
				return Object.assign(Object.assign({}, originConfig), nextConfig);
			});
		}
	}));
	const mergedOkCancel = (_b = innerConfig.okCancel) !== null && _b !== void 0 ? _b : innerConfig.type === "confirm";
	const [contextLocale] = useLocale_default("Modal", en_US_default.Modal);
	return /* @__PURE__ */ import_react.createElement(ConfirmDialog_default, Object.assign({
		prefixCls,
		rootPrefixCls
	}, innerConfig, {
		close,
		open: open$2,
		afterClose,
		okText: innerConfig.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.justOkText),
		direction: innerConfig.direction || direction,
		cancelText: innerConfig.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)
	}, restProps));
};
var HookModal_default = /* @__PURE__ */ import_react.forwardRef(HookModal);

//#endregion
//#region node_modules/antd/es/modal/useModal/index.js
var uuid$3 = 0;
var ElementsHolder = /* @__PURE__ */ import_react.memo(/* @__PURE__ */ import_react.forwardRef((_props, ref) => {
	const [elements, patchElement] = usePatchElement();
	import_react.useImperativeHandle(ref, () => ({ patchElement }), []);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, elements);
}));
function useModal() {
	const holderRef = import_react.useRef(null);
	const [actionQueue, setActionQueue] = import_react.useState([]);
	import_react.useEffect(() => {
		if (actionQueue.length) {
			_toConsumableArray(actionQueue).forEach((action) => {
				action();
			});
			setActionQueue([]);
		}
	}, [actionQueue]);
	const getConfirmFunc = import_react.useCallback((withFunc) => function hookConfirm(config) {
		var _a;
		uuid$3 += 1;
		const modalRef = /* @__PURE__ */ import_react.createRef();
		let resolvePromise;
		const promise = new Promise((resolve) => {
			resolvePromise = resolve;
		});
		let silent = false;
		let closeFunc;
		const modal = /* @__PURE__ */ import_react.createElement(HookModal_default, {
			key: `modal-${uuid$3}`,
			config: withFunc(config),
			ref: modalRef,
			afterClose: () => {
				closeFunc === null || closeFunc === void 0 || closeFunc();
			},
			isSilent: () => silent,
			onConfirm: (confirmed) => {
				resolvePromise(confirmed);
			}
		});
		closeFunc = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.patchElement(modal);
		if (closeFunc) destroyFns_default.push(closeFunc);
		return {
			destroy: () => {
				function destroyAction() {
					var _a$1;
					(_a$1 = modalRef.current) === null || _a$1 === void 0 || _a$1.destroy();
				}
				if (modalRef.current) destroyAction();
				else setActionQueue((prev$1) => [].concat(_toConsumableArray(prev$1), [destroyAction]));
			},
			update: (newConfig) => {
				function updateAction() {
					var _a$1;
					(_a$1 = modalRef.current) === null || _a$1 === void 0 || _a$1.update(newConfig);
				}
				if (modalRef.current) updateAction();
				else setActionQueue((prev$1) => [].concat(_toConsumableArray(prev$1), [updateAction]));
			},
			then: (resolve) => {
				silent = true;
				return promise.then(resolve);
			}
		};
	}, []);
	return [import_react.useMemo(() => ({
		info: getConfirmFunc(withInfo),
		success: getConfirmFunc(withSuccess),
		error: getConfirmFunc(withError),
		warning: getConfirmFunc(withWarn),
		confirm: getConfirmFunc(withConfirm)
	}), []), /* @__PURE__ */ import_react.createElement(ElementsHolder, {
		key: "modal-holder",
		ref: holderRef
	})];
}
var useModal_default = useModal;

//#endregion
//#region node_modules/antd/es/notification/style/placement.js
var genNotificationPlacementStyle = (token$1) => {
	const { componentCls, notificationMarginEdge, animationMaxHeight } = token$1;
	const noticeCls = `${componentCls}-notice`;
	const rightFadeIn = new Keyframes_default("antNotificationFadeIn", {
		"0%": {
			transform: `translate3d(100%, 0, 0)`,
			opacity: 0
		},
		"100%": {
			transform: `translate3d(0, 0, 0)`,
			opacity: 1
		}
	});
	const topFadeIn = new Keyframes_default("antNotificationTopFadeIn", {
		"0%": {
			top: -animationMaxHeight,
			opacity: 0
		},
		"100%": {
			top: 0,
			opacity: 1
		}
	});
	const bottomFadeIn = new Keyframes_default("antNotificationBottomFadeIn", {
		"0%": {
			bottom: token$1.calc(animationMaxHeight).mul(-1).equal(),
			opacity: 0
		},
		"100%": {
			bottom: 0,
			opacity: 1
		}
	});
	const leftFadeIn = new Keyframes_default("antNotificationLeftFadeIn", {
		"0%": {
			transform: `translate3d(-100%, 0, 0)`,
			opacity: 0
		},
		"100%": {
			transform: `translate3d(0, 0, 0)`,
			opacity: 1
		}
	});
	return { [componentCls]: {
		[`&${componentCls}-top, &${componentCls}-bottom`]: {
			marginInline: 0,
			[noticeCls]: { marginInline: "auto auto" }
		},
		[`&${componentCls}-top`]: { [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationName: topFadeIn } },
		[`&${componentCls}-bottom`]: { [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationName: bottomFadeIn } },
		[`&${componentCls}-topRight, &${componentCls}-bottomRight`]: { [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationName: rightFadeIn } },
		[`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
			marginRight: {
				value: 0,
				_skip_check_: true
			},
			marginLeft: {
				value: notificationMarginEdge,
				_skip_check_: true
			},
			[noticeCls]: {
				marginInlineEnd: "auto",
				marginInlineStart: 0
			},
			[`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationName: leftFadeIn }
		}
	} };
};
var placement_default = genNotificationPlacementStyle;

//#endregion
//#region node_modules/antd/es/notification/interface.js
const NotificationPlacements = [
	"top",
	"topLeft",
	"topRight",
	"bottom",
	"bottomLeft",
	"bottomRight"
];

//#endregion
//#region node_modules/antd/es/notification/style/stack.js
var placementAlignProperty = {
	topLeft: "left",
	topRight: "right",
	bottomLeft: "left",
	bottomRight: "right",
	top: "left",
	bottom: "left"
};
var genPlacementStackStyle = (token$1, placement) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-${placement}`]: { [`&${componentCls}-stack > ${componentCls}-notice-wrapper`]: {
		[placement.startsWith("top") ? "top" : "bottom"]: 0,
		[placementAlignProperty[placement]]: {
			value: 0,
			_skip_check_: true
		}
	} } };
};
var genStackChildrenStyle = (token$1) => {
	const childrenStyle = {};
	for (let i = 1; i < token$1.notificationStackLayer; i++) childrenStyle[`&:nth-last-child(${i + 1})`] = {
		overflow: "hidden",
		[`& > ${token$1.componentCls}-notice`]: {
			opacity: 0,
			transition: `opacity ${token$1.motionDurationMid}`
		}
	};
	return Object.assign({ [`&:not(:nth-last-child(-n+${token$1.notificationStackLayer}))`]: {
		opacity: 0,
		overflow: "hidden",
		color: "transparent",
		pointerEvents: "none"
	} }, childrenStyle);
};
var genStackedNoticeStyle = (token$1) => {
	const childrenStyle = {};
	for (let i = 1; i < token$1.notificationStackLayer; i++) childrenStyle[`&:nth-last-child(${i + 1})`] = {
		background: token$1.colorBgBlur,
		backdropFilter: "blur(10px)",
		"-webkit-backdrop-filter": "blur(10px)"
	};
	return Object.assign({}, childrenStyle);
};
var genStackStyle = (token$1) => {
	const { componentCls } = token$1;
	return Object.assign({
		[`${componentCls}-stack`]: { [`& > ${componentCls}-notice-wrapper`]: Object.assign({
			transition: `transform ${token$1.motionDurationSlow}, backdrop-filter 0s`,
			willChange: "transform, opacity",
			position: "absolute"
		}, genStackChildrenStyle(token$1)) },
		[`${componentCls}-stack:not(${componentCls}-stack-expanded)`]: { [`& > ${componentCls}-notice-wrapper`]: Object.assign({}, genStackedNoticeStyle(token$1)) },
		[`${componentCls}-stack${componentCls}-stack-expanded`]: { [`& > ${componentCls}-notice-wrapper`]: {
			"&:not(:nth-last-child(-n + 1))": {
				opacity: 1,
				overflow: "unset",
				color: "inherit",
				pointerEvents: "auto",
				[`& > ${token$1.componentCls}-notice`]: { opacity: 1 }
			},
			"&:after": {
				content: "\"\"",
				position: "absolute",
				height: token$1.margin,
				width: "100%",
				insetInline: 0,
				bottom: token$1.calc(token$1.margin).mul(-1).equal(),
				background: "transparent",
				pointerEvents: "auto"
			}
		} }
	}, NotificationPlacements.map((placement) => genPlacementStackStyle(token$1, placement)).reduce((acc, cur) => Object.assign(Object.assign({}, acc), cur), {}));
};
var stack_default = genStackStyle;

//#endregion
//#region node_modules/antd/es/notification/style/index.js
const genNoticeStyle = (token$1) => {
	const { iconCls, componentCls, boxShadow, fontSizeLG, notificationMarginBottom, borderRadiusLG, colorSuccess, colorInfo, colorWarning, colorError, colorTextHeading, notificationBg, notificationPadding, notificationMarginEdge, notificationProgressBg, notificationProgressHeight, fontSize, lineHeight, width, notificationIconSize, colorText } = token$1;
	const noticeCls = `${componentCls}-notice`;
	return {
		position: "relative",
		marginBottom: notificationMarginBottom,
		marginInlineStart: "auto",
		background: notificationBg,
		borderRadius: borderRadiusLG,
		boxShadow,
		[noticeCls]: {
			padding: notificationPadding,
			width,
			maxWidth: `calc(100vw - ${unit(token$1.calc(notificationMarginEdge).mul(2).equal())})`,
			overflow: "hidden",
			lineHeight,
			wordWrap: "break-word"
		},
		[`${noticeCls}-message`]: {
			color: colorTextHeading,
			fontSize: fontSizeLG,
			lineHeight: token$1.lineHeightLG
		},
		[`${noticeCls}-description`]: {
			fontSize,
			color: colorText,
			marginTop: token$1.marginXS
		},
		[`${noticeCls}-closable ${noticeCls}-message`]: { paddingInlineEnd: token$1.paddingLG },
		[`${noticeCls}-with-icon ${noticeCls}-message`]: {
			marginInlineStart: token$1.calc(token$1.marginSM).add(notificationIconSize).equal(),
			fontSize: fontSizeLG
		},
		[`${noticeCls}-with-icon ${noticeCls}-description`]: {
			marginInlineStart: token$1.calc(token$1.marginSM).add(notificationIconSize).equal(),
			fontSize
		},
		[`${noticeCls}-icon`]: {
			position: "absolute",
			fontSize: notificationIconSize,
			lineHeight: 1,
			[`&-success${iconCls}`]: { color: colorSuccess },
			[`&-info${iconCls}`]: { color: colorInfo },
			[`&-warning${iconCls}`]: { color: colorWarning },
			[`&-error${iconCls}`]: { color: colorError }
		},
		[`${noticeCls}-close`]: Object.assign({
			position: "absolute",
			top: token$1.notificationPaddingVertical,
			insetInlineEnd: token$1.notificationPaddingHorizontal,
			color: token$1.colorIcon,
			outline: "none",
			width: token$1.notificationCloseButtonSize,
			height: token$1.notificationCloseButtonSize,
			borderRadius: token$1.borderRadiusSM,
			transition: `background-color ${token$1.motionDurationMid}, color ${token$1.motionDurationMid}`,
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			background: "none",
			border: "none",
			"&:hover": {
				color: token$1.colorIconHover,
				backgroundColor: token$1.colorBgTextHover
			},
			"&:active": { backgroundColor: token$1.colorBgTextActive }
		}, genFocusStyle(token$1)),
		[`${noticeCls}-progress`]: {
			position: "absolute",
			display: "block",
			appearance: "none",
			inlineSize: `calc(100% - ${unit(borderRadiusLG)} * 2)`,
			left: {
				_skip_check_: true,
				value: borderRadiusLG
			},
			right: {
				_skip_check_: true,
				value: borderRadiusLG
			},
			bottom: 0,
			blockSize: notificationProgressHeight,
			border: 0,
			"&, &::-webkit-progress-bar": {
				borderRadius: borderRadiusLG,
				backgroundColor: `rgba(0, 0, 0, 0.04)`
			},
			"&::-moz-progress-bar": { background: notificationProgressBg },
			"&::-webkit-progress-value": {
				borderRadius: borderRadiusLG,
				background: notificationProgressBg
			}
		},
		[`${noticeCls}-actions`]: {
			float: "right",
			marginTop: token$1.marginSM
		}
	};
};
var genNotificationStyle = (token$1) => {
	const { componentCls, notificationMarginBottom, notificationMarginEdge, motionDurationMid, motionEaseInOut } = token$1;
	const noticeCls = `${componentCls}-notice`;
	const fadeOut$1 = new Keyframes_default("antNotificationFadeOut", {
		"0%": {
			maxHeight: token$1.animationMaxHeight,
			marginBottom: notificationMarginBottom
		},
		"100%": {
			maxHeight: 0,
			marginBottom: 0,
			paddingTop: 0,
			paddingBottom: 0,
			opacity: 0
		}
	});
	return [{ [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "fixed",
		zIndex: token$1.zIndexPopup,
		marginRight: {
			value: notificationMarginEdge,
			_skip_check_: true
		},
		[`${componentCls}-hook-holder`]: { position: "relative" },
		[`${componentCls}-fade-appear-prepare`]: { opacity: "0 !important" },
		[`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
			animationDuration: token$1.motionDurationMid,
			animationTimingFunction: motionEaseInOut,
			animationFillMode: "both",
			opacity: 0,
			animationPlayState: "paused"
		},
		[`${componentCls}-fade-leave`]: {
			animationTimingFunction: motionEaseInOut,
			animationFillMode: "both",
			animationDuration: motionDurationMid,
			animationPlayState: "paused"
		},
		[`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: { animationPlayState: "running" },
		[`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
			animationName: fadeOut$1,
			animationPlayState: "running"
		},
		"&-rtl": {
			direction: "rtl",
			[`${noticeCls}-actions`]: { float: "left" }
		}
	}) }, { [componentCls]: { [`${noticeCls}-wrapper`]: Object.assign({}, genNoticeStyle(token$1)) } }];
};
const prepareComponentToken$49 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + CONTAINER_MAX_OFFSET + 50,
	width: 384
});
const prepareNotificationToken = (token$1) => {
	const notificationPaddingVertical = token$1.paddingMD;
	const notificationPaddingHorizontal = token$1.paddingLG;
	return merge(token$1, {
		notificationBg: token$1.colorBgElevated,
		notificationPaddingVertical,
		notificationPaddingHorizontal,
		notificationIconSize: token$1.calc(token$1.fontSizeLG).mul(token$1.lineHeightLG).equal(),
		notificationCloseButtonSize: token$1.calc(token$1.controlHeightLG).mul(.55).equal(),
		notificationMarginBottom: token$1.margin,
		notificationPadding: `${unit(token$1.paddingMD)} ${unit(token$1.paddingContentHorizontalLG)}`,
		notificationMarginEdge: token$1.marginLG,
		animationMaxHeight: 150,
		notificationStackLayer: 3,
		notificationProgressHeight: 2,
		notificationProgressBg: `linear-gradient(90deg, ${token$1.colorPrimaryBorderHover}, ${token$1.colorPrimary})`
	});
};
var style_default$55 = genStyleHooks("Notification", (token$1) => {
	const notificationToken = prepareNotificationToken(token$1);
	return [
		genNotificationStyle(notificationToken),
		placement_default(notificationToken),
		stack_default(notificationToken)
	];
}, prepareComponentToken$49);

//#endregion
//#region node_modules/antd/es/notification/style/pure-panel.js
var pure_panel_default = genSubStyleComponent(["Notification", "PurePanel"], (token$1) => {
	const noticeCls = `${token$1.componentCls}-notice`;
	const notificationToken = prepareNotificationToken(token$1);
	return { [`${noticeCls}-pure-panel`]: Object.assign(Object.assign({}, genNoticeStyle(notificationToken)), {
		width: notificationToken.width,
		maxWidth: `calc(100vw - ${unit(token$1.calc(notificationToken.notificationMarginEdge).mul(2).equal())})`,
		margin: 0
	}) };
}, prepareComponentToken$49);

//#endregion
//#region node_modules/antd/es/notification/PurePanel.js
var import_classnames$237 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$101 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function getCloseIcon(prefixCls, closeIcon) {
	if (closeIcon === null || closeIcon === false) return null;
	return closeIcon || /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` });
}
var typeToIcon = {
	success: CheckCircleFilled_default,
	info: InfoCircleFilled_default,
	error: CloseCircleFilled_default,
	warning: ExclamationCircleFilled_default
};
const PureContent = (props) => {
	const { prefixCls, icon, type: type$2, message: message$1, description, actions, role = "alert" } = props;
	let iconNode = null;
	if (icon) iconNode = /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-icon` }, icon);
	else if (type$2) iconNode = /* @__PURE__ */ import_react.createElement(typeToIcon[type$2] || null, { className: (0, import_classnames$237.default)(`${prefixCls}-icon`, `${prefixCls}-icon-${type$2}`) });
	return /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$237.default)({ [`${prefixCls}-with-icon`]: iconNode }),
		role
	}, iconNode, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-message` }, message$1), description && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-description` }, description), actions && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-actions` }, actions));
};
/** @private Internal Component. Do not use in your production. */
var PurePanel$13 = (props) => {
	const { prefixCls: staticPrefixCls, className, icon, type: type$2, message: message$1, description, btn, actions, closable = true, closeIcon, className: notificationClassName } = props, restProps = __rest$101(props, [
		"prefixCls",
		"className",
		"icon",
		"type",
		"message",
		"description",
		"btn",
		"actions",
		"closable",
		"closeIcon",
		"className"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const mergedActions = actions !== null && actions !== void 0 ? actions : btn;
	devUseWarning("Notification").deprecated(!btn, "btn", "actions");
	const prefixCls = staticPrefixCls || getPrefixCls("notification");
	const noticePrefixCls = `${prefixCls}-notice`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$55(prefixCls, rootCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$237.default)(`${noticePrefixCls}-pure-panel`, hashId, className, cssVarCls, rootCls) }, /* @__PURE__ */ import_react.createElement(pure_panel_default, { prefixCls }), /* @__PURE__ */ import_react.createElement(Notice_default, Object.assign({}, restProps, {
		prefixCls,
		eventKey: "pure",
		duration: null,
		closable,
		className: (0, import_classnames$237.default)({ notificationClassName }),
		closeIcon: getCloseIcon(prefixCls, closeIcon),
		content: /* @__PURE__ */ import_react.createElement(PureContent, {
			prefixCls: noticePrefixCls,
			icon,
			type: type$2,
			message: message$1,
			description,
			actions: mergedActions
		})
	}))));
};
var PurePanel_default$4 = PurePanel$13;

//#endregion
//#region node_modules/antd/es/notification/util.js
function getPlacementStyle(placement, top, bottom) {
	let style$1;
	switch (placement) {
		case "top":
			style$1 = {
				left: "50%",
				transform: "translateX(-50%)",
				right: "auto",
				top,
				bottom: "auto"
			};
			break;
		case "topLeft":
			style$1 = {
				left: 0,
				top,
				bottom: "auto"
			};
			break;
		case "topRight":
			style$1 = {
				right: 0,
				top,
				bottom: "auto"
			};
			break;
		case "bottom":
			style$1 = {
				left: "50%",
				transform: "translateX(-50%)",
				right: "auto",
				top: "auto",
				bottom
			};
			break;
		case "bottomLeft":
			style$1 = {
				left: 0,
				top: "auto",
				bottom
			};
			break;
		default:
			style$1 = {
				right: 0,
				top: "auto",
				bottom
			};
			break;
	}
	return style$1;
}
function getMotion$2(prefixCls) {
	return { motionName: `${prefixCls}-fade` };
}
function getCloseIconConfig(closeIcon, notificationConfig, notification$1) {
	if (typeof closeIcon !== "undefined") return closeIcon;
	if (typeof (notificationConfig === null || notificationConfig === void 0 ? void 0 : notificationConfig.closeIcon) !== "undefined") return notificationConfig.closeIcon;
	return notification$1 === null || notification$1 === void 0 ? void 0 : notification$1.closeIcon;
}

//#endregion
//#region node_modules/antd/es/notification/useNotification.js
var import_classnames$236 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$100 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var DEFAULT_OFFSET = 24;
var DEFAULT_DURATION = 4.5;
var DEFAULT_PLACEMENT = "topRight";
var Wrapper = ({ children, prefixCls }) => {
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$55(prefixCls, rootCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(NotificationProvider_default, { classNames: { list: (0, import_classnames$236.default)(hashId, cssVarCls, rootCls) } }, children));
};
var renderNotifications = (node$1, { prefixCls, key }) => /* @__PURE__ */ import_react.createElement(Wrapper, {
	prefixCls,
	key
}, node$1);
var Holder = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { top, bottom, prefixCls: staticPrefixCls, getContainer: staticGetContainer, maxCount, rtl, onAllRemoved, stack, duration, pauseOnHover = true, showProgress } = props;
	const { getPrefixCls, getPopupContainer, notification: notification$1, direction } = (0, import_react.useContext)(ConfigContext);
	const [, token$1] = useToken();
	const prefixCls = staticPrefixCls || getPrefixCls("notification");
	const getStyle$3 = (placement) => getPlacementStyle(placement, top !== null && top !== void 0 ? top : DEFAULT_OFFSET, bottom !== null && bottom !== void 0 ? bottom : DEFAULT_OFFSET);
	const getClassName = () => (0, import_classnames$236.default)({ [`${prefixCls}-rtl`]: rtl !== null && rtl !== void 0 ? rtl : direction === "rtl" });
	const getNotificationMotion = () => getMotion$2(prefixCls);
	const [api, holder] = useNotification$1({
		prefixCls,
		style: getStyle$3,
		className: getClassName,
		motion: getNotificationMotion,
		closable: true,
		closeIcon: getCloseIcon(prefixCls),
		duration: duration !== null && duration !== void 0 ? duration : DEFAULT_DURATION,
		getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
		maxCount,
		pauseOnHover,
		showProgress,
		onAllRemoved,
		renderNotifications,
		stack: stack === false ? false : {
			threshold: typeof stack === "object" ? stack === null || stack === void 0 ? void 0 : stack.threshold : void 0,
			offset: 8,
			gap: token$1.margin
		}
	});
	import_react.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
		prefixCls,
		notification: notification$1
	}));
	return holder;
});
function useInternalNotification(notificationConfig) {
	const holderRef = import_react.useRef(null);
	const warning$4 = devUseWarning("Notification");
	return [import_react.useMemo(() => {
		const open$2 = (config) => {
			var _a;
			if (!holderRef.current) {
				warning$4(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.");
				return;
			}
			const { open: originOpen, prefixCls, notification: notification$1 } = holderRef.current;
			const noticePrefixCls = `${prefixCls}-notice`;
			const { message: message$1, description, icon, type: type$2, btn, actions, className, style: style$1, role = "alert", closeIcon, closable } = config, restConfig = __rest$100(config, [
				"message",
				"description",
				"icon",
				"type",
				"btn",
				"actions",
				"className",
				"style",
				"role",
				"closeIcon",
				"closable"
			]);
			warning$4.deprecated(!btn, "btn", "actions");
			const mergedActions = actions !== null && actions !== void 0 ? actions : btn;
			const realCloseIcon = getCloseIcon(noticePrefixCls, getCloseIconConfig(closeIcon, notificationConfig, notification$1));
			return originOpen(Object.assign(Object.assign({ placement: (_a = notificationConfig === null || notificationConfig === void 0 ? void 0 : notificationConfig.placement) !== null && _a !== void 0 ? _a : DEFAULT_PLACEMENT }, restConfig), {
				content: /* @__PURE__ */ import_react.createElement(PureContent, {
					prefixCls: noticePrefixCls,
					icon,
					type: type$2,
					message: message$1,
					description,
					actions: mergedActions,
					role
				}),
				className: (0, import_classnames$236.default)(type$2 && `${noticePrefixCls}-${type$2}`, className, notification$1 === null || notification$1 === void 0 ? void 0 : notification$1.className),
				style: Object.assign(Object.assign({}, notification$1 === null || notification$1 === void 0 ? void 0 : notification$1.style), style$1),
				closeIcon: realCloseIcon,
				closable: closable !== null && closable !== void 0 ? closable : !!realCloseIcon
			}));
		};
		const destroy$2 = (key) => {
			var _a, _b;
			if (key !== void 0) (_a = holderRef.current) === null || _a === void 0 || _a.close(key);
			else (_b = holderRef.current) === null || _b === void 0 || _b.destroy();
		};
		const clone = {
			open: open$2,
			destroy: destroy$2
		};
		[
			"success",
			"info",
			"warning",
			"error"
		].forEach((type$2) => {
			clone[type$2] = (config) => open$2(Object.assign(Object.assign({}, config), { type: type$2 }));
		});
		return clone;
	}, []), /* @__PURE__ */ import_react.createElement(Holder, Object.assign({ key: "notification-holder" }, notificationConfig, { ref: holderRef }))];
}
function useNotification(notificationConfig) {
	return useInternalNotification(notificationConfig);
}

//#endregion
//#region node_modules/antd/es/app/context.js
const AppConfigContext = /* @__PURE__ */ import_react.createContext({});
var AppContext = /* @__PURE__ */ import_react.createContext({
	message: {},
	notification: {},
	modal: {}
});
var context_default$8 = AppContext;

//#endregion
//#region node_modules/antd/es/app/style/index.js
var genBaseStyle$15 = (token$1) => {
	const { componentCls, colorText, fontSize, lineHeight, fontFamily } = token$1;
	return { [componentCls]: {
		color: colorText,
		fontSize,
		lineHeight,
		fontFamily,
		[`&${componentCls}-rtl`]: { direction: "rtl" }
	} };
};
const prepareComponentToken$48 = () => ({});
var style_default$54 = genStyleHooks("App", genBaseStyle$15, prepareComponentToken$48);

//#endregion
//#region node_modules/antd/es/app/App.js
var import_classnames$235 = /* @__PURE__ */ __toESM(require_classnames());
var App$1 = (props) => {
	const { prefixCls: customizePrefixCls, children, className, rootClassName, message: message$1, notification: notification$1, style: style$1, component = "div" } = props;
	const { direction, getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("app", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$54(prefixCls);
	const customClassName = (0, import_classnames$235.default)(hashId, prefixCls, className, rootClassName, cssVarCls, { [`${prefixCls}-rtl`]: direction === "rtl" });
	const appConfig = (0, import_react.useContext)(AppConfigContext);
	const mergedAppConfig = import_react.useMemo(() => ({
		message: Object.assign(Object.assign({}, appConfig.message), message$1),
		notification: Object.assign(Object.assign({}, appConfig.notification), notification$1)
	}), [
		message$1,
		notification$1,
		appConfig.message,
		appConfig.notification
	]);
	const [messageApi, messageContextHolder] = useMessage(mergedAppConfig.message);
	const [notificationApi, notificationContextHolder] = useNotification(mergedAppConfig.notification);
	const [ModalApi, ModalContextHolder] = useModal_default();
	const memoizedContextValue = import_react.useMemo(() => ({
		message: messageApi,
		notification: notificationApi,
		modal: ModalApi
	}), [
		messageApi,
		notificationApi,
		ModalApi
	]);
	devUseWarning("App")(!(cssVarCls && component === false), "usage", "When using cssVar, ensure `component` is assigned a valid React component string.");
	const Component$2 = component === false ? import_react.Fragment : component;
	const rootProps = {
		className: customClassName,
		style: style$1
	};
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(context_default$8.Provider, { value: memoizedContextValue }, /* @__PURE__ */ import_react.createElement(AppConfigContext.Provider, { value: mergedAppConfig }, /* @__PURE__ */ import_react.createElement(Component$2, Object.assign({}, component === false ? void 0 : rootProps), ModalContextHolder, messageContextHolder, notificationContextHolder, children))));
};
App$1.displayName = "App";
var App_default = App$1;

//#endregion
//#region node_modules/antd/es/app/useApp.js
var useApp = () => import_react.useContext(context_default$8);
var useApp_default = useApp;

//#endregion
//#region node_modules/antd/es/app/index.js
var App = App_default;
App.useApp = useApp_default;
var app_default = App;

//#endregion
//#region node_modules/antd/es/_util/PurePanel.js
function withPureRenderTheme(Component$2) {
	return (props) => /* @__PURE__ */ import_react.createElement(config_provider_default, { theme: { token: {
		motion: false,
		zIndexPopupBase: 0
	} } }, /* @__PURE__ */ import_react.createElement(Component$2, Object.assign({}, props)));
}
/* istanbul ignore next */
var genPurePanel = (Component$2, alignPropName, postProps, defaultPrefixCls$1, getDropdownCls) => {
	const PurePanel$15 = (props) => {
		const { prefixCls: customizePrefixCls, style: style$1 } = props;
		const holderRef = import_react.useRef(null);
		const [popupHeight, setPopupHeight] = import_react.useState(0);
		const [popupWidth, setPopupWidth] = import_react.useState(0);
		const [open$2, setOpen] = useMergedState(false, { value: props.open });
		const { getPrefixCls } = import_react.useContext(ConfigContext);
		const prefixCls = getPrefixCls(defaultPrefixCls$1 || "select", customizePrefixCls);
		import_react.useEffect(() => {
			setOpen(true);
			if (typeof ResizeObserver !== "undefined") {
				const resizeObserver$1 = new ResizeObserver((entries) => {
					const element = entries[0].target;
					setPopupHeight(element.offsetHeight + 8);
					setPopupWidth(element.offsetWidth);
				});
				const interval = setInterval(() => {
					var _a;
					const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
					const popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
					if (popup) {
						clearInterval(interval);
						resizeObserver$1.observe(popup);
					}
				}, 10);
				return () => {
					clearInterval(interval);
					resizeObserver$1.disconnect();
				};
			}
		}, []);
		let mergedProps = Object.assign(Object.assign({}, props), {
			style: Object.assign(Object.assign({}, style$1), { margin: 0 }),
			open: open$2,
			visible: open$2,
			getPopupContainer: () => holderRef.current
		});
		if (postProps) mergedProps = postProps(mergedProps);
		if (alignPropName) Object.assign(mergedProps, { [alignPropName]: { overflow: {
			adjustX: false,
			adjustY: false
		} } });
		const mergedStyle = {
			paddingBottom: popupHeight,
			position: "relative",
			minWidth: popupWidth
		};
		return /* @__PURE__ */ import_react.createElement("div", {
			ref: holderRef,
			style: mergedStyle
		}, /* @__PURE__ */ import_react.createElement(Component$2, Object.assign({}, mergedProps)));
	};
	return withPureRenderTheme(PurePanel$15);
};
var PurePanel_default = genPurePanel;

//#endregion
//#region node_modules/rc-util/es/isMobile.js
var isMobile_default = (function() {
	if (typeof navigator === "undefined" || typeof window === "undefined") return false;
	var agent = navigator.userAgent || navigator.vendor || window.opera;
	return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
});

//#endregion
//#region node_modules/rc-select/es/TransBtn.js
var import_classnames$234 = /* @__PURE__ */ __toESM(require_classnames());
var TransBtn = function TransBtn$1(props) {
	var className = props.className, customizeIcon = props.customizeIcon, customizeIconProps = props.customizeIconProps, children = props.children, _onMouseDown = props.onMouseDown, onClick = props.onClick;
	var icon = typeof customizeIcon === "function" ? customizeIcon(customizeIconProps) : customizeIcon;
	return /* @__PURE__ */ import_react.createElement("span", {
		className,
		onMouseDown: function onMouseDown(event) {
			event.preventDefault();
			_onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(event);
		},
		style: {
			userSelect: "none",
			WebkitUserSelect: "none"
		},
		unselectable: "on",
		onClick,
		"aria-hidden": true
	}, icon !== void 0 ? icon : /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$234.default)(className.split(/\s+/).map(function(cls$12) {
		return "".concat(cls$12, "-icon");
	})) }, children));
};
var TransBtn_default = TransBtn;

//#endregion
//#region node_modules/rc-select/es/hooks/useAllowClear.js
var useAllowClear = function useAllowClear$1(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon) {
	var disabled = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
	var mergedSearchValue = arguments.length > 6 ? arguments[6] : void 0;
	var mode = arguments.length > 7 ? arguments[7] : void 0;
	var mergedClearIcon = import_react.useMemo(function() {
		if (_typeof(allowClear) === "object") return allowClear.clearIcon;
		if (clearIcon) return clearIcon;
	}, [allowClear, clearIcon]);
	return {
		allowClear: import_react.useMemo(function() {
			if (!disabled && !!allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) return true;
			return false;
		}, [
			allowClear,
			disabled,
			displayValues.length,
			mergedSearchValue,
			mode
		]),
		clearIcon: /* @__PURE__ */ import_react.createElement(TransBtn_default, {
			className: "".concat(prefixCls, "-clear"),
			onMouseDown: onClearMouseDown,
			customizeIcon: mergedClearIcon
		}, "")
	};
};

//#endregion
//#region node_modules/rc-select/es/hooks/useBaseProps.js
var BaseSelectContext = /* @__PURE__ */ import_react.createContext(null);
function useBaseProps() {
	return import_react.useContext(BaseSelectContext);
}

//#endregion
//#region node_modules/rc-select/es/hooks/useDelayReset.js
/**
* Similar with `useLock`, but this hook will always execute last value.
* When set to `true`, it will keep `true` for a short time even if `false` is set.
*/
function useDelayReset() {
	var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
	var delayRef = import_react.useRef(null);
	var cancelLatest = function cancelLatest$1() {
		window.clearTimeout(delayRef.current);
	};
	import_react.useEffect(function() {
		return cancelLatest;
	}, []);
	return [
		bool,
		function delaySetBool(value, callback) {
			cancelLatest();
			delayRef.current = window.setTimeout(function() {
				setBool(value);
				if (callback) callback();
			}, timeout);
		},
		cancelLatest
	];
}

//#endregion
//#region node_modules/rc-select/es/hooks/useLock.js
/**
* Locker return cached mark.
* If set to `true`, will return `true` in a short time even if set `false`.
* If set to `false` and then set to `true`, will change to `true`.
* And after time duration, it will back to `null` automatically.
*/
function useLock() {
	var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
	var lockRef = import_react.useRef(null);
	var timeoutRef = import_react.useRef(null);
	import_react.useEffect(function() {
		return function() {
			window.clearTimeout(timeoutRef.current);
		};
	}, []);
	function doLock(locked) {
		if (locked || lockRef.current === null) lockRef.current = locked;
		window.clearTimeout(timeoutRef.current);
		timeoutRef.current = window.setTimeout(function() {
			lockRef.current = null;
		}, duration);
	}
	return [function() {
		return lockRef.current;
	}, doLock];
}

//#endregion
//#region node_modules/rc-select/es/hooks/useSelectTriggerControl.js
function useSelectTriggerControl(elements, open$2, triggerOpen, customizedTrigger) {
	var propsRef = import_react.useRef(null);
	propsRef.current = {
		open: open$2,
		triggerOpen,
		customizedTrigger
	};
	import_react.useEffect(function() {
		function onGlobalMouseDown(event) {
			var _propsRef$current;
			if ((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger) return;
			var target = event.target;
			if (target.shadowRoot && event.composed) target = event.composedPath()[0] || target;
			if (propsRef.current.open && elements().filter(function(element) {
				return element;
			}).every(function(element) {
				return !element.contains(target) && element !== target;
			})) propsRef.current.triggerOpen(false);
		}
		window.addEventListener("mousedown", onGlobalMouseDown);
		return function() {
			return window.removeEventListener("mousedown", onGlobalMouseDown);
		};
	}, []);
}

//#endregion
//#region node_modules/rc-select/es/utils/keyUtil.js
/** keyCode Judgment function */
function isValidateOpenKey(currentKeyCode) {
	return currentKeyCode && ![
		KeyCode_default.ESC,
		KeyCode_default.SHIFT,
		KeyCode_default.BACKSPACE,
		KeyCode_default.TAB,
		KeyCode_default.WIN_KEY,
		KeyCode_default.ALT,
		KeyCode_default.META,
		KeyCode_default.WIN_KEY_RIGHT,
		KeyCode_default.CTRL,
		KeyCode_default.SEMICOLON,
		KeyCode_default.EQUALS,
		KeyCode_default.CAPS_LOCK,
		KeyCode_default.CONTEXT_MENU,
		KeyCode_default.F1,
		KeyCode_default.F2,
		KeyCode_default.F3,
		KeyCode_default.F4,
		KeyCode_default.F5,
		KeyCode_default.F6,
		KeyCode_default.F7,
		KeyCode_default.F8,
		KeyCode_default.F9,
		KeyCode_default.F10,
		KeyCode_default.F11,
		KeyCode_default.F12
	].includes(currentKeyCode);
}

//#endregion
//#region node_modules/rc-overflow/es/Item.js
var import_classnames$233 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$65 = [
	"prefixCls",
	"invalidate",
	"item",
	"renderItem",
	"responsive",
	"responsiveDisabled",
	"registerSize",
	"itemKey",
	"className",
	"style",
	"children",
	"display",
	"order",
	"component"
];
var UNDEFINED = void 0;
function InternalItem(props, ref) {
	var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem$1 = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey$2 = props.itemKey, className = props.className, style$1 = props.style, children = props.children, display = props.display, order = props.order, _props$component = props.component, Component$2 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties(props, _excluded$65);
	var mergedHidden = responsive && !display;
	function internalRegisterSize(width) {
		registerSize(itemKey$2, width);
	}
	import_react.useEffect(function() {
		return function() {
			internalRegisterSize(null);
		};
	}, []);
	var childNode = renderItem$1 && item !== UNDEFINED ? renderItem$1(item, { index: order }) : children;
	var overflowStyle;
	if (!invalidate) overflowStyle = {
		opacity: mergedHidden ? 0 : 1,
		height: mergedHidden ? 0 : UNDEFINED,
		overflowY: mergedHidden ? "hidden" : UNDEFINED,
		order: responsive ? order : UNDEFINED,
		pointerEvents: mergedHidden ? "none" : UNDEFINED,
		position: mergedHidden ? "absolute" : UNDEFINED
	};
	var overflowProps = {};
	if (mergedHidden) overflowProps["aria-hidden"] = true;
	var itemNode = /* @__PURE__ */ import_react.createElement(Component$2, _extends({
		className: (0, import_classnames$233.default)(!invalidate && prefixCls, className),
		style: _objectSpread2(_objectSpread2({}, overflowStyle), style$1)
	}, overflowProps, restProps, { ref }), childNode);
	if (responsive) itemNode = /* @__PURE__ */ import_react.createElement(es_default, {
		onResize: function onResize$1(_ref) {
			var offsetWidth = _ref.offsetWidth;
			internalRegisterSize(offsetWidth);
		},
		disabled: responsiveDisabled
	}, itemNode);
	return itemNode;
}
var Item$3 = /* @__PURE__ */ import_react.forwardRef(InternalItem);
Item$3.displayName = "Item";
var Item_default$3 = Item$3;

//#endregion
//#region node_modules/rc-overflow/es/hooks/channelUpdate.js
function channelUpdate(callback) {
	if (typeof MessageChannel === "undefined") raf_default(callback);
	else {
		var channel = new MessageChannel();
		channel.port1.onmessage = function() {
			return callback();
		};
		channel.port2.postMessage(void 0);
	}
}

//#endregion
//#region node_modules/rc-overflow/es/hooks/useEffectState.js
var import_react_dom$6 = /* @__PURE__ */ __toESM(require_react_dom());
/**
* Batcher for record any `useEffectState` need update.
*/
function useBatcher() {
	var updateFuncRef = import_react.useRef(null);
	return function notifyEffectUpdate(callback) {
		if (!updateFuncRef.current) {
			updateFuncRef.current = [];
			channelUpdate(function() {
				(0, import_react_dom$6.unstable_batchedUpdates)(function() {
					updateFuncRef.current.forEach(function(fn) {
						fn();
					});
					updateFuncRef.current = null;
				});
			});
		}
		updateFuncRef.current.push(callback);
	};
}
/**
* Trigger state update by `useLayoutEffect` to save perf.
*/
function useEffectState$1(notifyEffectUpdate, defaultValue) {
	var _React$useState = import_react.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1];
	var setEffectVal = useEvent(function(nextValue) {
		notifyEffectUpdate(function() {
			setStateValue(nextValue);
		});
	});
	return [stateValue, setEffectVal];
}

//#endregion
//#region node_modules/rc-overflow/es/context.js
var OverflowContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/rc-overflow/es/RawItem.js
var import_classnames$232 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$64 = ["component"], _excluded2$12 = ["className"], _excluded3$1 = ["className"];
var RawItem = /* @__PURE__ */ import_react.forwardRef(function InternalRawItem(props, ref) {
	var context = import_react.useContext(OverflowContext);
	if (!context) {
		var _props$component = props.component, Component$2 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties(props, _excluded$64);
		return /* @__PURE__ */ import_react.createElement(Component$2, _extends({}, _restProps, { ref }));
	}
	var contextClassName = context.className, restContext = _objectWithoutProperties(context, _excluded2$12);
	var className = props.className, restProps = _objectWithoutProperties(props, _excluded3$1);
	return /* @__PURE__ */ import_react.createElement(OverflowContext.Provider, { value: null }, /* @__PURE__ */ import_react.createElement(Item_default$3, _extends({
		ref,
		className: (0, import_classnames$232.default)(contextClassName, className)
	}, restContext, restProps)));
});
RawItem.displayName = "RawItem";
var RawItem_default = RawItem;

//#endregion
//#region node_modules/rc-overflow/es/Overflow.js
var import_classnames$231 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$63 = [
	"prefixCls",
	"data",
	"renderItem",
	"renderRawItem",
	"itemKey",
	"itemWidth",
	"ssr",
	"style",
	"className",
	"maxCount",
	"renderRest",
	"renderRawRest",
	"suffix",
	"component",
	"itemComponent",
	"onVisibleChange"
];
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
	return "+ ".concat(omittedItems.length, " ...");
}
function Overflow(props, ref) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, renderItem$1 = props.renderItem, renderRawItem = props.renderRawItem, itemKey$2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style$1 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component$2 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded$63);
	var fullySSR = ssr === "full";
	var notifyEffectUpdate = useBatcher();
	var _useEffectState = useEffectState$1(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1];
	var mergedContainerWidth = containerWidth || 0;
	var _useEffectState3 = useEffectState$1(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1];
	var _useEffectState5 = useEffectState$1(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1];
	var _useEffectState7 = useEffectState$1(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1];
	var _useEffectState9 = useEffectState$1(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1];
	var _useState = (0, import_react.useState)(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
	var _useState3 = (0, import_react.useState)(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
	var mergedDisplayCount = import_react.useMemo(function() {
		if (displayCount === null && fullySSR) return Number.MAX_SAFE_INTEGER;
		return displayCount || 0;
	}, [displayCount, containerWidth]);
	var _useState5 = (0, import_react.useState)(false), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
	var itemPrefixCls = "".concat(prefixCls, "-item");
	var mergedRestWidth = Math.max(prevRestWidth, restWidth);
	var isResponsive = maxCount === RESPONSIVE;
	var shouldResponsive = data.length && isResponsive;
	var invalidate = maxCount === INVALIDATE;
	/**
	* When is `responsive`, we will always render rest node to get the real width of it for calculation
	*/
	var showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
	var mergedData = (0, import_react.useMemo)(function() {
		var items = data;
		if (shouldResponsive) if (containerWidth === null && fullySSR) items = data;
		else items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
		else if (typeof maxCount === "number") items = data.slice(0, maxCount);
		return items;
	}, [
		data,
		itemWidth,
		containerWidth,
		maxCount,
		shouldResponsive
	]);
	var omittedItems = (0, import_react.useMemo)(function() {
		if (shouldResponsive) return data.slice(mergedDisplayCount + 1);
		return data.slice(mergedData.length);
	}, [
		data,
		mergedData,
		shouldResponsive,
		mergedDisplayCount
	]);
	var getKey$3 = (0, import_react.useCallback)(function(item, index$2) {
		var _ref;
		if (typeof itemKey$2 === "function") return itemKey$2(item);
		return (_ref = itemKey$2 && (item === null || item === void 0 ? void 0 : item[itemKey$2])) !== null && _ref !== void 0 ? _ref : index$2;
	}, [itemKey$2]);
	var mergedRenderItem = (0, import_react.useCallback)(renderItem$1 || function(item) {
		return item;
	}, [renderItem$1]);
	function updateDisplayCount(count, suffixFixedStartVal, notReady) {
		if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) return;
		setDisplayCount(count);
		if (!notReady) {
			setRestReady(count < data.length - 1);
			onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(count);
		}
		if (suffixFixedStartVal !== void 0) setSuffixFixedStart(suffixFixedStartVal);
	}
	function onOverflowResize(_, element) {
		setContainerWidth(element.clientWidth);
	}
	function registerSize(key, width) {
		setItemWidths(function(origin) {
			var clone = new Map(origin);
			if (width === null) clone.delete(key);
			else clone.set(key, width);
			return clone;
		});
	}
	function registerOverflowSize(_, width) {
		setRestWidth(width);
		setPrevRestWidth(restWidth);
	}
	function registerSuffixSize(_, width) {
		setSuffixWidth(width);
	}
	function getItemWidth(index$2) {
		return itemWidths.get(getKey$3(mergedData[index$2], index$2));
	}
	useLayoutEffect_default(function() {
		if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
			var totalWidth = suffixWidth;
			var len = mergedData.length;
			var lastIndex = len - 1;
			if (!len) {
				updateDisplayCount(0, null);
				return;
			}
			for (var i = 0; i < len; i += 1) {
				var currentItemWidth = getItemWidth(i);
				if (fullySSR) currentItemWidth = currentItemWidth || 0;
				if (currentItemWidth === void 0) {
					updateDisplayCount(i - 1, void 0, true);
					break;
				}
				totalWidth += currentItemWidth;
				if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
					updateDisplayCount(lastIndex, null);
					break;
				} else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
					updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
					break;
				}
			}
			if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) setSuffixFixedStart(null);
		}
	}, [
		mergedContainerWidth,
		itemWidths,
		restWidth,
		suffixWidth,
		getKey$3,
		mergedData
	]);
	var displayRest = restReady && !!omittedItems.length;
	var suffixStyle = {};
	if (suffixFixedStart !== null && shouldResponsive) suffixStyle = {
		position: "absolute",
		left: suffixFixedStart,
		top: 0
	};
	var itemSharedProps = {
		prefixCls: itemPrefixCls,
		responsive: shouldResponsive,
		component: itemComponent,
		invalidate
	};
	var internalRenderItemNode = renderRawItem ? function(item, index$2) {
		var key = getKey$3(item, index$2);
		return /* @__PURE__ */ import_react.createElement(OverflowContext.Provider, {
			key,
			value: _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
				order: index$2,
				item,
				itemKey: key,
				registerSize,
				display: index$2 <= mergedDisplayCount
			})
		}, renderRawItem(item, index$2));
	} : function(item, index$2) {
		var key = getKey$3(item, index$2);
		return /* @__PURE__ */ import_react.createElement(Item_default$3, _extends({}, itemSharedProps, {
			order: index$2,
			key,
			item,
			renderItem: mergedRenderItem,
			itemKey: key,
			registerSize,
			display: index$2 <= mergedDisplayCount
		}));
	};
	var restContextProps = {
		order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
		className: "".concat(itemPrefixCls, "-rest"),
		registerSize: registerOverflowSize,
		display: displayRest
	};
	var mergedRenderRest = renderRest || defaultRenderRest;
	var restNode = renderRawRest ? /* @__PURE__ */ import_react.createElement(OverflowContext.Provider, { value: _objectSpread2(_objectSpread2({}, itemSharedProps), restContextProps) }, renderRawRest(omittedItems)) : /* @__PURE__ */ import_react.createElement(Item_default$3, _extends({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
	var overflowNode = /* @__PURE__ */ import_react.createElement(Component$2, _extends({
		className: (0, import_classnames$231.default)(!invalidate && prefixCls, className),
		style: style$1,
		ref
	}, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ import_react.createElement(Item_default$3, _extends({}, itemSharedProps, {
		responsive: isResponsive,
		responsiveDisabled: !shouldResponsive,
		order: mergedDisplayCount,
		className: "".concat(itemPrefixCls, "-suffix"),
		registerSize: registerSuffixSize,
		display: true,
		style: suffixStyle
	}), suffix));
	return isResponsive ? /* @__PURE__ */ import_react.createElement(es_default, {
		onResize: onOverflowResize,
		disabled: !shouldResponsive
	}, overflowNode) : overflowNode;
}
var ForwardOverflow = /* @__PURE__ */ import_react.forwardRef(Overflow);
ForwardOverflow.displayName = "Overflow";
ForwardOverflow.Item = RawItem_default;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
var Overflow_default = ForwardOverflow;

//#endregion
//#region node_modules/rc-overflow/es/index.js
var es_default$31 = Overflow_default;

//#endregion
//#region node_modules/rc-util/es/composeProps.js
function composeProps(originProps, patchProps, isAll) {
	var composedProps = _objectSpread2(_objectSpread2({}, originProps), isAll ? patchProps : {});
	Object.keys(patchProps).forEach(function(key) {
		var func = patchProps[key];
		if (typeof func === "function") composedProps[key] = function() {
			var _originProps$key;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			func.apply(void 0, args);
			return (_originProps$key = originProps[key]) === null || _originProps$key === void 0 ? void 0 : _originProps$key.call.apply(_originProps$key, [originProps].concat(args));
		};
	});
	return composedProps;
}
var composeProps_default = composeProps;

//#endregion
//#region node_modules/rc-select/es/Selector/Input.js
var import_classnames$230 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$62 = [
	"prefixCls",
	"id",
	"inputElement",
	"autoFocus",
	"autoComplete",
	"editable",
	"activeDescendantId",
	"value",
	"open",
	"attrs"
];
var RefInput = /* @__PURE__ */ import_react.forwardRef(function Input$4(props, ref) {
	var prefixCls = props.prefixCls, id = props.id, inputElement = props.inputElement, autoFocus = props.autoFocus, autoComplete = props.autoComplete, editable = props.editable, activeDescendantId = props.activeDescendantId, value = props.value, open$2 = props.open, attrs = props.attrs, restProps = _objectWithoutProperties(props, _excluded$62);
	var inputNode = inputElement || /* @__PURE__ */ import_react.createElement("input", null);
	var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
	warning(!("maxLength" in inputNode.props), "Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled.");
	inputNode = /* @__PURE__ */ import_react.cloneElement(inputNode, _objectSpread2(_objectSpread2(_objectSpread2({ type: "search" }, composeProps_default(restProps, originProps, true)), {}, {
		id,
		ref: composeRef(ref, originRef),
		autoComplete: autoComplete || "off",
		autoFocus,
		className: (0, import_classnames$230.default)("".concat(prefixCls, "-selection-search-input"), originProps === null || originProps === void 0 ? void 0 : originProps.className),
		role: "combobox",
		"aria-expanded": open$2 || false,
		"aria-haspopup": "listbox",
		"aria-owns": "".concat(id, "_list"),
		"aria-autocomplete": "list",
		"aria-controls": "".concat(id, "_list"),
		"aria-activedescendant": open$2 ? activeDescendantId : void 0
	}, attrs), {}, {
		value: editable ? value : "",
		readOnly: !editable,
		unselectable: !editable ? "on" : null,
		style: _objectSpread2(_objectSpread2({}, originProps.style), {}, { opacity: editable ? null : 0 })
	}));
	return inputNode;
});
RefInput.displayName = "Input";
var Input_default$3 = RefInput;

//#endregion
//#region node_modules/rc-select/es/utils/commonUtil.js
function toArray$6(value) {
	if (Array.isArray(value)) return value;
	return value !== void 0 ? [value] : [];
}
var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
/** Is client side and not jsdom */
var isBrowserClient$2 = isClient;
function hasValue(value) {
	return value !== void 0 && value !== null;
}
/** combo mode no value judgment function */
function isComboNoValue(value) {
	return !value && value !== 0;
}
function isTitleType$1(title) {
	return ["string", "number"].includes(_typeof(title));
}
function getTitle(item) {
	var title = void 0;
	if (item) {
		if (isTitleType$1(item.title)) title = item.title.toString();
		else if (isTitleType$1(item.label)) title = item.label.toString();
	}
	return title;
}

//#endregion
//#region node_modules/rc-select/es/hooks/useLayoutEffect.js
/**
* Wrap `React.useLayoutEffect` which will not throw warning message in test env
*/
function useLayoutEffect(effect, deps) {
	if (isBrowserClient$2)
 /* istanbul ignore next */
	import_react.useLayoutEffect(effect, deps);
	else import_react.useEffect(effect, deps);
}

//#endregion
//#region node_modules/rc-select/es/Selector/MultipleSelector.js
var import_classnames$229 = /* @__PURE__ */ __toESM(require_classnames());
function itemKey$1(value) {
	var _value$key;
	return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
}
var onPreventMouseDown = function onPreventMouseDown$1(event) {
	event.preventDefault();
	event.stopPropagation();
};
var SelectSelector = function SelectSelector$1(props) {
	var id = props.id, prefixCls = props.prefixCls, values = props.values, open$2 = props.open, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
		return "+ ".concat(omittedValues.length, " ...");
	} : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, onInputBlur = props.onInputBlur;
	var measureRef = import_react.useRef(null);
	var _useState = (0, import_react.useState)(0), _useState2 = _slicedToArray(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
	var _useState3 = (0, import_react.useState)(false), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
	var selectionPrefixCls = "".concat(prefixCls, "-selection");
	var inputValue = open$2 || mode === "multiple" && autoClearSearchValue === false || mode === "tags" ? searchValue : "";
	var inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === false || showSearch && (open$2 || focused);
	useLayoutEffect(function() {
		setInputWidth(measureRef.current.scrollWidth);
	}, [inputValue]);
	var defaultRenderSelector = function defaultRenderSelector$1(item, content, itemDisabled, closable, onClose) {
		return /* @__PURE__ */ import_react.createElement("span", {
			title: getTitle(item),
			className: (0, import_classnames$229.default)("".concat(selectionPrefixCls, "-item"), _defineProperty({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled))
		}, /* @__PURE__ */ import_react.createElement("span", { className: "".concat(selectionPrefixCls, "-item-content") }, content), closable && /* @__PURE__ */ import_react.createElement(TransBtn_default, {
			className: "".concat(selectionPrefixCls, "-item-remove"),
			onMouseDown: onPreventMouseDown,
			onClick: onClose,
			customizeIcon: removeIcon
		}, ""));
	};
	var customizeRenderSelector = function customizeRenderSelector$1(value, content, itemDisabled, closable, onClose, isMaxTag) {
		return /* @__PURE__ */ import_react.createElement("span", { onMouseDown: function onMouseDown(e$2) {
			onPreventMouseDown(e$2);
			onToggleOpen(!open$2);
		} }, tagRender({
			label: content,
			value,
			disabled: itemDisabled,
			closable,
			onClose,
			isMaxTag: !!isMaxTag
		}));
	};
	var renderItem$1 = function renderItem$2(valueItem) {
		var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value;
		var closable = !disabled && !itemDisabled;
		var displayLabel = label;
		if (typeof maxTagTextLength === "number") {
			if (typeof label === "string" || typeof label === "number") {
				var strLabel = String(displayLabel);
				if (strLabel.length > maxTagTextLength) displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
			}
		}
		var onClose = function onClose$1(event) {
			if (event) event.stopPropagation();
			onRemove(valueItem);
		};
		return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
	};
	var renderRest = function renderRest$1(omittedValues) {
		if (!values.length) return null;
		var content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
		return typeof tagRender === "function" ? customizeRenderSelector(void 0, content, false, false, void 0, true) : defaultRenderSelector({ title: content }, content, false);
	};
	var inputNode = /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(selectionPrefixCls, "-search"),
		style: { width: inputWidth },
		onFocus: function onFocus() {
			setFocused(true);
		},
		onBlur: function onBlur() {
			setFocused(false);
		}
	}, /* @__PURE__ */ import_react.createElement(Input_default$3, {
		ref: inputRef,
		open: open$2,
		prefixCls,
		id,
		inputElement: null,
		disabled,
		autoFocus,
		autoComplete,
		editable: inputEditable,
		activeDescendantId,
		value: inputValue,
		onKeyDown: onInputKeyDown,
		onMouseDown: onInputMouseDown,
		onChange: onInputChange,
		onPaste: onInputPaste,
		onCompositionStart: onInputCompositionStart,
		onCompositionEnd: onInputCompositionEnd,
		onBlur: onInputBlur,
		tabIndex,
		attrs: pickAttrs(props, true)
	}), /* @__PURE__ */ import_react.createElement("span", {
		ref: measureRef,
		className: "".concat(selectionPrefixCls, "-search-mirror"),
		"aria-hidden": true
	}, inputValue, "\xA0"));
	var selectionNode = /* @__PURE__ */ import_react.createElement(es_default$31, {
		prefixCls: "".concat(selectionPrefixCls, "-overflow"),
		data: values,
		renderItem: renderItem$1,
		renderRest,
		suffix: inputNode,
		itemKey: itemKey$1,
		maxCount: maxTagCount
	});
	return /* @__PURE__ */ import_react.createElement("span", { className: "".concat(selectionPrefixCls, "-wrap") }, selectionNode, !values.length && !inputValue && /* @__PURE__ */ import_react.createElement("span", { className: "".concat(selectionPrefixCls, "-placeholder") }, placeholder));
};
var MultipleSelector_default = SelectSelector;

//#endregion
//#region node_modules/rc-select/es/Selector/SingleSelector.js
var SingleSelector$1 = function SingleSelector$2(props) {
	var inputElement = props.inputElement, prefixCls = props.prefixCls, id = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open$2 = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, onInputBlur = props.onInputBlur, title = props.title;
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
	var combobox = mode === "combobox";
	var inputEditable = combobox || showSearch;
	var item = values[0];
	var inputValue = searchValue || "";
	if (combobox && activeValue && !inputChanged) inputValue = activeValue;
	import_react.useEffect(function() {
		if (combobox) setInputChanged(false);
	}, [combobox, activeValue]);
	var hasTextInput = mode !== "combobox" && !open$2 && !showSearch ? false : !!inputValue;
	var selectionTitle = title === void 0 ? getTitle(item) : title;
	var placeholderNode = import_react.useMemo(function() {
		if (item) return null;
		return /* @__PURE__ */ import_react.createElement("span", {
			className: "".concat(prefixCls, "-selection-placeholder"),
			style: hasTextInput ? { visibility: "hidden" } : void 0
		}, placeholder);
	}, [
		item,
		hasTextInput,
		placeholder,
		prefixCls
	]);
	return /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-selection-wrap") }, /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-selection-search") }, /* @__PURE__ */ import_react.createElement(Input_default$3, {
		ref: inputRef,
		prefixCls,
		id,
		open: open$2,
		inputElement,
		disabled,
		autoFocus,
		autoComplete,
		editable: inputEditable,
		activeDescendantId,
		value: inputValue,
		onKeyDown: onInputKeyDown,
		onMouseDown: onInputMouseDown,
		onChange: function onChange(e$2) {
			setInputChanged(true);
			onInputChange(e$2);
		},
		onPaste: onInputPaste,
		onCompositionStart: onInputCompositionStart,
		onCompositionEnd: onInputCompositionEnd,
		onBlur: onInputBlur,
		tabIndex,
		attrs: pickAttrs(props, true),
		maxLength: combobox ? maxLength : void 0
	})), !combobox && item ? /* @__PURE__ */ import_react.createElement("span", {
		className: "".concat(prefixCls, "-selection-item"),
		title: selectionTitle,
		style: hasTextInput ? { visibility: "hidden" } : void 0
	}, item.label) : null, placeholderNode);
};
var SingleSelector_default$1 = SingleSelector$1;

//#endregion
//#region node_modules/rc-select/es/Selector/index.js
var ForwardSelector = /* @__PURE__ */ import_react.forwardRef(function Selector(props, ref) {
	var inputRef = (0, import_react.useRef)(null);
	var compositionStatusRef = (0, import_react.useRef)(false);
	var prefixCls = props.prefixCls, open$2 = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, disabled = props.disabled, prefix = props.prefix, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, onInputBlur = props.onInputBlur, domRef = props.domRef;
	import_react.useImperativeHandle(ref, function() {
		return {
			focus: function focus(options) {
				inputRef.current.focus(options);
			},
			blur: function blur() {
				inputRef.current.blur();
			}
		};
	});
	var _useLock = useLock(0), _useLock2 = _slicedToArray(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
	var onInternalInputKeyDown = function onInternalInputKeyDown$1(event) {
		var which = event.which;
		var isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
		if (!isTextAreaElement && open$2 && (which === KeyCode_default.UP || which === KeyCode_default.DOWN)) event.preventDefault();
		if (onInputKeyDown) onInputKeyDown(event);
		if (which === KeyCode_default.ENTER && mode === "tags" && !compositionStatusRef.current && !open$2) onSearchSubmit === null || onSearchSubmit === void 0 || onSearchSubmit(event.target.value);
		if (isTextAreaElement && !open$2 && ~[
			KeyCode_default.UP,
			KeyCode_default.DOWN,
			KeyCode_default.LEFT,
			KeyCode_default.RIGHT
		].indexOf(which)) return;
		if (isValidateOpenKey(which)) onToggleOpen(true);
	};
	/**
	* We can not use `findDOMNode` sine it will get warning,
	* have to use timer to check if is input element.
	*/
	var onInternalInputMouseDown = function onInternalInputMouseDown$1() {
		setInputMouseDown(true);
	};
	var pastedTextRef = (0, import_react.useRef)(null);
	var triggerOnSearch = function triggerOnSearch$1(value) {
		if (onSearch(value, true, compositionStatusRef.current) !== false) onToggleOpen(true);
	};
	var onInputCompositionStart = function onInputCompositionStart$1() {
		compositionStatusRef.current = true;
	};
	var onInputCompositionEnd = function onInputCompositionEnd$1(e$2) {
		compositionStatusRef.current = false;
		if (mode !== "combobox") triggerOnSearch(e$2.target.value);
	};
	var onInputChange = function onInputChange$1(event) {
		var value = event.target.value;
		if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
			var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
			value = value.replace(replacedText, pastedTextRef.current);
		}
		pastedTextRef.current = null;
		triggerOnSearch(value);
	};
	var onInputPaste = function onInputPaste$1(e$2) {
		var clipboardData = e$2.clipboardData;
		pastedTextRef.current = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData("text")) || "";
	};
	var onClick = function onClick$1(_ref) {
		if (_ref.target !== inputRef.current) if (document.body.style.msTouchAction !== void 0) setTimeout(function() {
			inputRef.current.focus();
		});
		else inputRef.current.focus();
	};
	var onMouseDown = function onMouseDown$1(event) {
		var inputMouseDown = getInputMouseDown();
		if (event.target !== inputRef.current && !inputMouseDown && !(mode === "combobox" && disabled)) event.preventDefault();
		if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open$2) {
			if (open$2 && autoClearSearchValue !== false) onSearch("", true, false);
			onToggleOpen();
		}
	};
	var sharedProps = {
		inputRef,
		onInputKeyDown: onInternalInputKeyDown,
		onInputMouseDown: onInternalInputMouseDown,
		onInputChange,
		onInputPaste,
		onInputCompositionStart,
		onInputCompositionEnd,
		onInputBlur
	};
	var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ import_react.createElement(MultipleSelector_default, _extends({}, props, sharedProps)) : /* @__PURE__ */ import_react.createElement(SingleSelector_default$1, _extends({}, props, sharedProps));
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: domRef,
		className: "".concat(prefixCls, "-selector"),
		onClick,
		onMouseDown
	}, prefix && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-prefix") }, prefix), selectNode);
});
ForwardSelector.displayName = "Selector";
var Selector_default = ForwardSelector;

//#endregion
//#region node_modules/@rc-component/trigger/es/Popup/Arrow.js
var import_classnames$228 = /* @__PURE__ */ __toESM(require_classnames());
function Arrow(props) {
	var prefixCls = props.prefixCls, align = props.align, arrow = props.arrow, arrowPos = props.arrowPos;
	var _ref = arrow || {}, className = _ref.className, content = _ref.content;
	var _arrowPos$x = arrowPos.x, x = _arrowPos$x === void 0 ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y = _arrowPos$y === void 0 ? 0 : _arrowPos$y;
	var arrowRef = import_react.useRef();
	if (!align || !align.points) return null;
	var alignStyle = { position: "absolute" };
	if (align.autoArrow !== false) {
		var popupPoints = align.points[0];
		var targetPoints = align.points[1];
		var popupTB = popupPoints[0];
		var popupLR = popupPoints[1];
		var targetTB = targetPoints[0];
		var targetLR = targetPoints[1];
		if (popupTB === targetTB || !["t", "b"].includes(popupTB)) alignStyle.top = y;
		else if (popupTB === "t") alignStyle.top = 0;
		else alignStyle.bottom = 0;
		if (popupLR === targetLR || !["l", "r"].includes(popupLR)) alignStyle.left = x;
		else if (popupLR === "l") alignStyle.left = 0;
		else alignStyle.right = 0;
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: arrowRef,
		className: (0, import_classnames$228.default)("".concat(prefixCls, "-arrow"), className),
		style: alignStyle
	}, content);
}

//#endregion
//#region node_modules/@rc-component/trigger/es/Popup/Mask.js
var import_classnames$227 = /* @__PURE__ */ __toESM(require_classnames());
function Mask$1(props) {
	var prefixCls = props.prefixCls, open$2 = props.open, zIndex = props.zIndex, mask = props.mask, motion$1 = props.motion;
	if (!mask) return null;
	return /* @__PURE__ */ import_react.createElement(es_default$2, _extends({}, motion$1, {
		motionAppear: true,
		visible: open$2,
		removeOnLeave: true
	}), function(_ref) {
		var className = _ref.className;
		return /* @__PURE__ */ import_react.createElement("div", {
			style: { zIndex },
			className: (0, import_classnames$227.default)("".concat(prefixCls, "-mask"), className)
		});
	});
}

//#endregion
//#region node_modules/@rc-component/trigger/es/Popup/PopupContent.js
var PopupContent = /* @__PURE__ */ import_react.memo(function(_ref) {
	return _ref.children;
}, function(_, next$1) {
	return next$1.cache;
});
PopupContent.displayName = "PopupContent";
var PopupContent_default = PopupContent;

//#endregion
//#region node_modules/@rc-component/trigger/es/Popup/index.js
var import_classnames$226 = /* @__PURE__ */ __toESM(require_classnames());
var Popup$2 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style$1 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open$2 = props.open, keepDom = props.keepDom, fresh = props.fresh, onClick = props.onClick, mask = props.mask, arrow = props.arrow, arrowPos = props.arrowPos, align = props.align, motion$1 = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal$1 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onPointerEnter = props.onPointerEnter, onPointerDownCapture = props.onPointerDownCapture, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
	var childNode = typeof popup === "function" ? popup() : popup;
	var isNodeVisible = open$2 || keepDom;
	var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
	var _React$useState = import_react.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
	useLayoutEffect_default(function() {
		if (!show && getPopupContainerNeedParams && target) setShow(true);
	}, [
		show,
		getPopupContainerNeedParams,
		target
	]);
	if (!show) return null;
	var AUTO = "auto";
	var offsetStyle = {
		left: "-1000vw",
		top: "-1000vh",
		right: AUTO,
		bottom: AUTO
	};
	if (ready || !open$2) {
		var _experimental;
		var points = align.points;
		var dynamicInset = align.dynamicInset || ((_experimental = align._experimental) === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset);
		var alignRight = dynamicInset && points[0][1] === "r";
		var alignBottom = dynamicInset && points[0][0] === "b";
		if (alignRight) {
			offsetStyle.right = offsetR;
			offsetStyle.left = AUTO;
		} else {
			offsetStyle.left = offsetX;
			offsetStyle.right = AUTO;
		}
		if (alignBottom) {
			offsetStyle.bottom = offsetB;
			offsetStyle.top = AUTO;
		} else {
			offsetStyle.top = offsetY;
			offsetStyle.bottom = AUTO;
		}
	}
	var miscStyle = {};
	if (stretch) {
		if (stretch.includes("height") && targetHeight) miscStyle.height = targetHeight;
		else if (stretch.includes("minHeight") && targetHeight) miscStyle.minHeight = targetHeight;
		if (stretch.includes("width") && targetWidth) miscStyle.width = targetWidth;
		else if (stretch.includes("minWidth") && targetWidth) miscStyle.minWidth = targetWidth;
	}
	if (!open$2) miscStyle.pointerEvents = "none";
	return /* @__PURE__ */ import_react.createElement(Portal$1, {
		open: forceRender || isNodeVisible,
		getContainer: getPopupContainer && function() {
			return getPopupContainer(target);
		},
		autoDestroy
	}, /* @__PURE__ */ import_react.createElement(Mask$1, {
		prefixCls,
		open: open$2,
		zIndex,
		mask,
		motion: maskMotion
	}), /* @__PURE__ */ import_react.createElement(es_default, {
		onResize: onAlign,
		disabled: !open$2
	}, function(resizeObserverRef) {
		return /* @__PURE__ */ import_react.createElement(es_default$2, _extends({
			motionAppear: true,
			motionEnter: true,
			motionLeave: true,
			removeOnLeave: false,
			forceRender,
			leavedClassName: "".concat(prefixCls, "-hidden")
		}, motion$1, {
			onAppearPrepare: onPrepare,
			onEnterPrepare: onPrepare,
			visible: open$2,
			onVisibleChanged: function onVisibleChanged(nextVisible) {
				var _motion$onVisibleChan;
				motion$1 === null || motion$1 === void 0 || (_motion$onVisibleChan = motion$1.onVisibleChanged) === null || _motion$onVisibleChan === void 0 || _motion$onVisibleChan.call(motion$1, nextVisible);
				_onVisibleChanged(nextVisible);
			}
		}), function(_ref, motionRef) {
			var motionClassName = _ref.className, motionStyle = _ref.style;
			var cls$12 = (0, import_classnames$226.default)(prefixCls, motionClassName, className);
			return /* @__PURE__ */ import_react.createElement("div", {
				ref: composeRef(resizeObserverRef, ref, motionRef),
				className: cls$12,
				style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
					"--arrow-x": "".concat(arrowPos.x || 0, "px"),
					"--arrow-y": "".concat(arrowPos.y || 0, "px")
				}, offsetStyle), miscStyle), motionStyle), {}, {
					boxSizing: "border-box",
					zIndex
				}, style$1),
				onMouseEnter,
				onMouseLeave,
				onPointerEnter,
				onClick,
				onPointerDownCapture
			}, arrow && /* @__PURE__ */ import_react.createElement(Arrow, {
				prefixCls,
				arrow,
				arrowPos,
				align
			}), /* @__PURE__ */ import_react.createElement(PopupContent_default, { cache: !open$2 && !fresh }, childNode));
		});
	}));
});
Popup$2.displayName = "Popup";
var Popup_default = Popup$2;

//#endregion
//#region node_modules/@rc-component/trigger/es/TriggerWrapper.js
var TriggerWrapper = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
	var canUseRef = supportRef(children);
	var setRef = import_react.useCallback(function(node$1) {
		fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node$1) : node$1);
	}, [getTriggerDOMNode]);
	var mergedRef = useComposeRef(setRef, getNodeRef(children));
	return canUseRef ? /* @__PURE__ */ import_react.cloneElement(children, { ref: mergedRef }) : children;
});
TriggerWrapper.displayName = "TriggerWrapper";
var TriggerWrapper_default = TriggerWrapper;

//#endregion
//#region node_modules/@rc-component/trigger/es/context.js
var TriggerContext = /* @__PURE__ */ import_react.createContext(null);
var context_default$7 = TriggerContext;

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useAction.js
function toArray$7(val) {
	return val ? Array.isArray(val) ? val : [val] : [];
}
function useAction(mobile, action, showAction, hideAction) {
	return import_react.useMemo(function() {
		var mergedShowAction = toArray$7(showAction !== null && showAction !== void 0 ? showAction : action);
		var mergedHideAction = toArray$7(hideAction !== null && hideAction !== void 0 ? hideAction : action);
		var showActionSet = new Set(mergedShowAction);
		var hideActionSet = new Set(mergedHideAction);
		if (mobile) {
			if (showActionSet.has("hover")) {
				showActionSet.delete("hover");
				showActionSet.add("click");
			}
			if (hideActionSet.has("hover")) {
				hideActionSet.delete("hover");
				hideActionSet.add("click");
			}
		}
		return [showActionSet, hideActionSet];
	}, [
		mobile,
		action,
		showAction,
		hideAction
	]);
}

//#endregion
//#region node_modules/@rc-component/trigger/es/util.js
function isPointsEq() {
	var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
	var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	if (arguments.length > 2 ? arguments[2] : void 0) return a1[0] === a2[0];
	return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
	var points = align.points;
	var placements$4 = Object.keys(builtinPlacements);
	for (var i = 0; i < placements$4.length; i += 1) {
		var _builtinPlacements$pl;
		var placement = placements$4[i];
		if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) return "".concat(prefixCls, "-placement-").concat(placement);
	}
	return "";
}
/** @deprecated We should not use this if we can refactor all deps */
function getMotion$1(prefixCls, motion$1, animation, transitionName) {
	if (motion$1) return motion$1;
	if (animation) return { motionName: "".concat(prefixCls, "-").concat(animation) };
	if (transitionName) return { motionName: transitionName };
	return null;
}
function getWin(ele) {
	return ele.ownerDocument.defaultView;
}
/**
* Get all the scrollable parent elements of the element
* @param ele       The element to be detected
* @param areaOnly  Only return the parent which will cut visible area
*/
function collectScroller(ele) {
	var scrollerList = [];
	var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
	var scrollStyle = [
		"hidden",
		"scroll",
		"clip",
		"auto"
	];
	while (current) {
		var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY, overflow = _getWin$getComputedSt.overflow;
		if ([
			overflowX,
			overflowY,
			overflow
		].some(function(o$2) {
			return scrollStyle.includes(o$2);
		})) scrollerList.push(current);
		current = current.parentElement;
	}
	return scrollerList;
}
function toNum(num) {
	var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
	return Number.isNaN(num) ? defaultValue : num;
}
function getPxValue(val) {
	return toNum(parseFloat(val), 0);
}
/**
*
*
*  **************************************
*  *              Border                *
*  *     **************************     *
*  *     *                  *     *     *
*  *  B  *                  *  S  *  B  *
*  *  o  *                  *  c  *  o  *
*  *  r  *      Content     *  r  *  r  *
*  *  d  *                  *  o  *  d  *
*  *  e  *                  *  l  *  e  *
*  *  r  ********************  l  *  r  *
*  *     *        Scroll          *     *
*  *     **************************     *
*  *              Border                *
*  **************************************
*
*/
/**
* Get visible area of element
*/
function getVisibleArea(initArea, scrollerList) {
	var visibleArea = _objectSpread2({}, initArea);
	(scrollerList || []).forEach(function(ele) {
		if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) return;
		var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth;
		var eleRect = ele.getBoundingClientRect();
		var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
		var borderTopNum = getPxValue(borderTopWidth);
		var borderBottomNum = getPxValue(borderBottomWidth);
		var borderLeftNum = getPxValue(borderLeftWidth);
		var borderRightNum = getPxValue(borderRightWidth);
		var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
		var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
		var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
		var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
		var scaledBorderTopWidth = borderTopNum * scaleY;
		var scaledBorderBottomWidth = borderBottomNum * scaleY;
		var scaledBorderLeftWidth = borderLeftNum * scaleX;
		var scaledBorderRightWidth = borderRightNum * scaleX;
		var clipMarginWidth = 0;
		var clipMarginHeight = 0;
		if (overflow === "clip") {
			var clipNum = getPxValue(overflowClipMargin);
			clipMarginWidth = clipNum * scaleX;
			clipMarginHeight = clipNum * scaleY;
		}
		var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
		var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
		var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
		var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
		visibleArea.left = Math.max(visibleArea.left, eleLeft);
		visibleArea.top = Math.max(visibleArea.top, eleTop);
		visibleArea.right = Math.min(visibleArea.right, eleRight);
		visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
	});
	return visibleArea;
}

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useAlign.js
function getUnitOffset(size) {
	var offset$2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var offsetStr = "".concat(offset$2);
	var cells = offsetStr.match(/^(.*)\%$/);
	if (cells) return size * (parseFloat(cells[1]) / 100);
	return parseFloat(offsetStr);
}
function getNumberOffset(rect, offset$2) {
	var _ref = offset$2 || [], _ref2 = _slicedToArray(_ref, 2), offsetX = _ref2[0], offsetY = _ref2[1];
	return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
}
function splitPoints() {
	var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
	return [points[0], points[1]];
}
function getAlignPoint(rect, points) {
	var topBottom = points[0];
	var leftRight = points[1];
	var x;
	var y;
	if (topBottom === "t") y = rect.y;
	else if (topBottom === "b") y = rect.y + rect.height;
	else y = rect.y + rect.height / 2;
	if (leftRight === "l") x = rect.x;
	else if (leftRight === "r") x = rect.x + rect.width;
	else x = rect.x + rect.width / 2;
	return {
		x,
		y
	};
}
function reversePoints(points, index$2) {
	var reverseMap = {
		t: "b",
		b: "t",
		l: "r",
		r: "l"
	};
	return points.map(function(point, i) {
		if (i === index$2) return reverseMap[point] || "c";
		return point;
	}).join("");
}
function useAlign(open$2, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
	var _React$useState = import_react.useState({
		ready: false,
		offsetX: 0,
		offsetY: 0,
		offsetR: 0,
		offsetB: 0,
		arrowX: 0,
		arrowY: 0,
		scaleX: 1,
		scaleY: 1,
		align: builtinPlacements[placement] || {}
	}), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
	var alignCountRef = import_react.useRef(0);
	var scrollerList = import_react.useMemo(function() {
		if (!popupEle) return [];
		return collectScroller(popupEle);
	}, [popupEle]);
	var prevFlipRef = import_react.useRef({});
	var resetFlipCache = function resetFlipCache$1() {
		prevFlipRef.current = {};
	};
	if (!open$2) resetFlipCache();
	var onAlign = useEvent(function() {
		if (popupEle && target && open$2) {
			var _popupElement$parentE, _popupRect$x, _popupRect$y, _popupElement$parentE2;
			var popupElement = popupEle;
			var doc = popupElement.ownerDocument;
			var win$1 = getWin(popupElement);
			var _win$getComputedStyle = win$1.getComputedStyle(popupElement), popupPosition = _win$getComputedStyle.position;
			var originLeft = popupElement.style.left;
			var originTop = popupElement.style.top;
			var originRight = popupElement.style.right;
			var originBottom = popupElement.style.bottom;
			var originOverflow = popupElement.style.overflow;
			var placementInfo = _objectSpread2(_objectSpread2({}, builtinPlacements[placement]), popupAlign);
			var placeholderElement = doc.createElement("div");
			(_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);
			placeholderElement.style.left = "".concat(popupElement.offsetLeft, "px");
			placeholderElement.style.top = "".concat(popupElement.offsetTop, "px");
			placeholderElement.style.position = popupPosition;
			placeholderElement.style.height = "".concat(popupElement.offsetHeight, "px");
			placeholderElement.style.width = "".concat(popupElement.offsetWidth, "px");
			popupElement.style.left = "0";
			popupElement.style.top = "0";
			popupElement.style.right = "auto";
			popupElement.style.bottom = "auto";
			popupElement.style.overflow = "hidden";
			var targetRect;
			if (Array.isArray(target)) targetRect = {
				x: target[0],
				y: target[1],
				width: 0,
				height: 0
			};
			else {
				var _rect$x, _rect$y;
				var rect = target.getBoundingClientRect();
				rect.x = (_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left;
				rect.y = (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top;
				targetRect = {
					x: rect.x,
					y: rect.y,
					width: rect.width,
					height: rect.height
				};
			}
			var popupRect = popupElement.getBoundingClientRect();
			var _win$getComputedStyle2 = win$1.getComputedStyle(popupElement), height = _win$getComputedStyle2.height, width = _win$getComputedStyle2.width;
			popupRect.x = (_popupRect$x = popupRect.x) !== null && _popupRect$x !== void 0 ? _popupRect$x : popupRect.left;
			popupRect.y = (_popupRect$y = popupRect.y) !== null && _popupRect$y !== void 0 ? _popupRect$y : popupRect.top;
			var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
			var popupHeight = popupRect.height;
			var popupWidth = popupRect.width;
			var targetHeight = targetRect.height;
			var targetWidth = targetRect.width;
			var visibleRegion = {
				left: 0,
				top: 0,
				right: clientWidth,
				bottom: clientHeight
			};
			var scrollRegion = {
				left: -scrollLeft,
				top: -scrollTop,
				right: scrollWidth - scrollLeft,
				bottom: scrollHeight - scrollTop
			};
			var htmlRegion = placementInfo.htmlRegion;
			var VISIBLE = "visible";
			var VISIBLE_FIRST = "visibleFirst";
			if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) htmlRegion = VISIBLE;
			var isVisibleFirst = htmlRegion === VISIBLE_FIRST;
			var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
			var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
			var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
			var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
			popupElement.style.left = "auto";
			popupElement.style.top = "auto";
			popupElement.style.right = "0";
			popupElement.style.bottom = "0";
			var popupMirrorRect = popupElement.getBoundingClientRect();
			popupElement.style.left = originLeft;
			popupElement.style.top = originTop;
			popupElement.style.right = originRight;
			popupElement.style.bottom = originBottom;
			popupElement.style.overflow = originOverflow;
			(_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);
			var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
			var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
			if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible_default(target)) return;
			var offset$2 = placementInfo.offset, targetOffset$3 = placementInfo.targetOffset;
			var _getNumberOffset = getNumberOffset(popupRect, offset$2), _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1];
			var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset$3), _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
			targetRect.x -= targetOffsetX;
			targetRect.y -= targetOffsetY;
			var _ref3 = placementInfo.points || [], _ref4 = _slicedToArray(_ref3, 2), popupPoint = _ref4[0], targetPoint = _ref4[1];
			var targetPoints = splitPoints(targetPoint);
			var popupPoints = splitPoints(popupPoint);
			var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
			var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
			var nextAlignInfo = _objectSpread2({}, placementInfo);
			var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
			var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
			function getIntersectionVisibleArea(offsetX, offsetY) {
				var area = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : visibleArea;
				var l$1 = popupRect.x + offsetX;
				var t$1 = popupRect.y + offsetY;
				var r$1 = l$1 + popupWidth;
				var b = t$1 + popupHeight;
				var visibleL = Math.max(l$1, area.left);
				var visibleT = Math.max(t$1, area.top);
				var visibleR = Math.min(r$1, area.right);
				var visibleB = Math.min(b, area.bottom);
				return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
			}
			var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
			var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
			var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
			var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
			var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
			var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
			var overflow = placementInfo.overflow || {};
			var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
			var supportAdjust = function supportAdjust$1(val) {
				if (typeof val === "boolean") return val;
				return val >= 0;
			};
			var nextPopupY;
			var nextPopupBottom;
			var nextPopupX;
			var nextPopupRight;
			function syncNextPopupPosition() {
				nextPopupY = popupRect.y + nextOffsetY;
				nextPopupBottom = nextPopupY + popupHeight;
				nextPopupX = popupRect.x + nextOffsetX;
				nextPopupRight = nextPopupX + popupWidth;
			}
			syncNextPopupPosition();
			var needAdjustY = supportAdjust(adjustY);
			var sameTB = popupPoints[0] === targetPoints[0];
			if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
				var tmpNextOffsetY = nextOffsetY;
				if (sameTB) tmpNextOffsetY -= popupHeight - targetHeight;
				else tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
				var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
				var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
				if (newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.bt = true;
					nextOffsetY = tmpNextOffsetY;
					popupOffsetY = -popupOffsetY;
					nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
				} else prevFlipRef.current.bt = false;
			}
			if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
				var _tmpNextOffsetY = nextOffsetY;
				if (sameTB) _tmpNextOffsetY += popupHeight - targetHeight;
				else _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
				var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);
				var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
				if (_newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || _newVisibleRecommendArea >= originIntersectionRecommendArea)) {
					prevFlipRef.current.tb = true;
					nextOffsetY = _tmpNextOffsetY;
					popupOffsetY = -popupOffsetY;
					nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
				} else prevFlipRef.current.tb = false;
			}
			var needAdjustX = supportAdjust(adjustX);
			var sameLR = popupPoints[1] === targetPoints[1];
			if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
				var tmpNextOffsetX = nextOffsetX;
				if (sameLR) tmpNextOffsetX -= popupWidth - targetWidth;
				else tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
				var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
				var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
				if (_newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || _newVisibleRecommendArea2 >= originIntersectionRecommendArea)) {
					prevFlipRef.current.rl = true;
					nextOffsetX = tmpNextOffsetX;
					popupOffsetX = -popupOffsetX;
					nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
				} else prevFlipRef.current.rl = false;
			}
			if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
				var _tmpNextOffsetX = nextOffsetX;
				if (sameLR) _tmpNextOffsetX += popupWidth - targetWidth;
				else _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
				var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);
				var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
				if (_newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || _newVisibleRecommendArea3 >= originIntersectionRecommendArea)) {
					prevFlipRef.current.lr = true;
					nextOffsetX = _tmpNextOffsetX;
					popupOffsetX = -popupOffsetX;
					nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
				} else prevFlipRef.current.lr = false;
			}
			syncNextPopupPosition();
			var numShiftX = shiftX === true ? 0 : shiftX;
			if (typeof numShiftX === "number") {
				if (nextPopupX < visibleRegionArea.left) {
					nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
					if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
				}
				if (nextPopupRight > visibleRegionArea.right) {
					nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
					if (targetRect.x > visibleRegionArea.right - numShiftX) nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
				}
			}
			var numShiftY = shiftY === true ? 0 : shiftY;
			if (typeof numShiftY === "number") {
				if (nextPopupY < visibleRegionArea.top) {
					nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
					if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
				}
				if (nextPopupBottom > visibleRegionArea.bottom) {
					nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
					if (targetRect.y > visibleRegionArea.bottom - numShiftY) nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
				}
			}
			var popupLeft = popupRect.x + nextOffsetX;
			var popupRight = popupLeft + popupWidth;
			var popupTop = popupRect.y + nextOffsetY;
			var popupBottom = popupTop + popupHeight;
			var targetLeft = targetRect.x;
			var targetRight = targetLeft + targetWidth;
			var targetTop = targetRect.y;
			var targetBottom = targetTop + targetHeight;
			var nextArrowX = (Math.max(popupLeft, targetLeft) + Math.min(popupRight, targetRight)) / 2 - popupLeft;
			var nextArrowY = (Math.max(popupTop, targetTop) + Math.min(popupBottom, targetBottom)) / 2 - popupTop;
			onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);
			var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
			var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
			if (_scaleX === 1) {
				nextOffsetX = Math.round(nextOffsetX);
				offsetX4Right = Math.round(offsetX4Right);
			}
			if (_scaleY === 1) {
				nextOffsetY = Math.round(nextOffsetY);
				offsetY4Bottom = Math.round(offsetY4Bottom);
			}
			var nextOffsetInfo = {
				ready: true,
				offsetX: nextOffsetX / _scaleX,
				offsetY: nextOffsetY / _scaleY,
				offsetR: offsetX4Right / _scaleX,
				offsetB: offsetY4Bottom / _scaleY,
				arrowX: nextArrowX / _scaleX,
				arrowY: nextArrowY / _scaleY,
				scaleX: _scaleX,
				scaleY: _scaleY,
				align: nextAlignInfo
			};
			setOffsetInfo(nextOffsetInfo);
		}
	});
	var triggerAlign = function triggerAlign$1() {
		alignCountRef.current += 1;
		var id = alignCountRef.current;
		Promise.resolve().then(function() {
			if (alignCountRef.current === id) onAlign();
		});
	};
	var resetReady = function resetReady$1() {
		setOffsetInfo(function(ori) {
			return _objectSpread2(_objectSpread2({}, ori), {}, { ready: false });
		});
	};
	useLayoutEffect_default(resetReady, [placement]);
	useLayoutEffect_default(function() {
		if (!open$2) resetReady();
	}, [open$2]);
	return [
		offsetInfo.ready,
		offsetInfo.offsetX,
		offsetInfo.offsetY,
		offsetInfo.offsetR,
		offsetInfo.offsetB,
		offsetInfo.arrowX,
		offsetInfo.arrowY,
		offsetInfo.scaleX,
		offsetInfo.scaleY,
		offsetInfo.align,
		triggerAlign
	];
}

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useWatch.js
function useWatch(open$2, target, popup, onAlign, onScroll) {
	useLayoutEffect_default(function() {
		if (open$2 && target && popup) {
			var targetElement = target;
			var popupElement = popup;
			var targetScrollList = collectScroller(targetElement);
			var popupScrollList = collectScroller(popupElement);
			var win$1 = getWin(popupElement);
			var mergedList = new Set([win$1].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
			function notifyScroll() {
				onAlign();
				onScroll();
			}
			mergedList.forEach(function(scroller) {
				scroller.addEventListener("scroll", notifyScroll, { passive: true });
			});
			win$1.addEventListener("resize", notifyScroll, { passive: true });
			onAlign();
			return function() {
				mergedList.forEach(function(scroller) {
					scroller.removeEventListener("scroll", notifyScroll);
					win$1.removeEventListener("resize", notifyScroll);
				});
			};
		}
	}, [
		open$2,
		target,
		popup
	]);
}

//#endregion
//#region node_modules/@rc-component/trigger/es/hooks/useWinClick.js
function useWinClick(open$2, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
	var openRef = import_react.useRef(open$2);
	openRef.current = open$2;
	var popupPointerDownRef = import_react.useRef(false);
	import_react.useEffect(function() {
		if (clickToHide && popupEle && (!mask || maskClosable)) {
			var onPointerDown = function onPointerDown$1() {
				popupPointerDownRef.current = false;
			};
			var onTriggerClose = function onTriggerClose$1(e$2) {
				var _e$composedPath;
				if (openRef.current && !inPopupOrChild(((_e$composedPath = e$2.composedPath) === null || _e$composedPath === void 0 || (_e$composedPath = _e$composedPath.call(e$2)) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath[0]) || e$2.target) && !popupPointerDownRef.current) triggerOpen(false);
			};
			var win$1 = getWin(popupEle);
			win$1.addEventListener("pointerdown", onPointerDown, true);
			win$1.addEventListener("mousedown", onTriggerClose, true);
			win$1.addEventListener("contextmenu", onTriggerClose, true);
			var targetShadowRoot = getShadowRoot(targetEle);
			if (targetShadowRoot) {
				targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
				targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
			}
			var _targetEle$getRootNod, _popupEle$getRootNode;
			var targetRoot = targetEle === null || targetEle === void 0 || (_targetEle$getRootNod = targetEle.getRootNode) === null || _targetEle$getRootNod === void 0 ? void 0 : _targetEle$getRootNod.call(targetEle);
			var popupRoot = (_popupEle$getRootNode = popupEle.getRootNode) === null || _popupEle$getRootNode === void 0 ? void 0 : _popupEle$getRootNode.call(popupEle);
			warning(targetRoot === popupRoot, "trigger element and popup element should in same shadow root.");
			return function() {
				win$1.removeEventListener("pointerdown", onPointerDown, true);
				win$1.removeEventListener("mousedown", onTriggerClose, true);
				win$1.removeEventListener("contextmenu", onTriggerClose, true);
				if (targetShadowRoot) {
					targetShadowRoot.removeEventListener("mousedown", onTriggerClose, true);
					targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, true);
				}
			};
		}
	}, [
		clickToHide,
		targetEle,
		popupEle,
		mask,
		maskClosable
	]);
	function onPopupPointerDown() {
		popupPointerDownRef.current = true;
	}
	return onPopupPointerDown;
}

//#endregion
//#region node_modules/@rc-component/trigger/es/index.js
var import_classnames$225 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$61 = [
	"prefixCls",
	"children",
	"action",
	"showAction",
	"hideAction",
	"popupVisible",
	"defaultPopupVisible",
	"onPopupVisibleChange",
	"afterPopupVisibleChange",
	"mouseEnterDelay",
	"mouseLeaveDelay",
	"focusDelay",
	"blurDelay",
	"mask",
	"maskClosable",
	"getPopupContainer",
	"forceRender",
	"autoDestroy",
	"destroyPopupOnHide",
	"popup",
	"popupClassName",
	"popupStyle",
	"popupPlacement",
	"builtinPlacements",
	"popupAlign",
	"zIndex",
	"stretch",
	"getPopupClassNameFromAlign",
	"fresh",
	"alignPoint",
	"onPopupClick",
	"onPopupAlign",
	"arrow",
	"popupMotion",
	"maskMotion",
	"popupTransitionName",
	"popupAnimation",
	"maskTransitionName",
	"maskAnimation",
	"className",
	"getTriggerDOMNode"
];
function generateTrigger() {
	var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : es_default$6;
	var Trigger = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
		var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? .1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, fresh = props.fresh, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties(props, _excluded$61);
		var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
		var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
		useLayoutEffect_default(function() {
			setMobile(isMobile_default());
		}, []);
		var subPopupElements = import_react.useRef({});
		var parentContext = import_react.useContext(context_default$7);
		var context = import_react.useMemo(function() {
			return { registerSubPopup: function registerSubPopup(id$1, subPopupEle) {
				subPopupElements.current[id$1] = subPopupEle;
				parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id$1, subPopupEle);
			} };
		}, [parentContext]);
		var id = useId_default();
		var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
		var externalPopupRef = import_react.useRef(null);
		var setPopupRef = useEvent(function(node$1) {
			externalPopupRef.current = node$1;
			if (isDOM(node$1) && popupEle !== node$1) setPopupEle(node$1);
			parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id, node$1);
		});
		var _React$useState5 = import_react.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
		var externalForwardRef = import_react.useRef(null);
		var setTargetRef = useEvent(function(node$1) {
			if (isDOM(node$1) && targetEle !== node$1) {
				setTargetEle(node$1);
				externalForwardRef.current = node$1;
			}
		});
		var child = import_react.Children.only(children);
		var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
		var cloneProps = {};
		var inPopupOrChild = useEvent(function(ele) {
			var _getShadowRoot, _getShadowRoot2;
			var childDOM = targetEle;
			return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = getShadowRoot(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = getShadowRoot(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
				return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
			});
		});
		var mergePopupMotion = getMotion$1(prefixCls, popupMotion, popupAnimation, popupTransitionName);
		var mergeMaskMotion = getMotion$1(prefixCls, maskMotion, maskAnimation, maskTransitionName);
		var _React$useState7 = import_react.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
		var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
		var setMergedOpen = useEvent(function(nextOpen) {
			if (popupVisible === void 0) setInternalOpen(nextOpen);
		});
		useLayoutEffect_default(function() {
			setInternalOpen(popupVisible || false);
		}, [popupVisible]);
		var openRef = import_react.useRef(mergedOpen);
		openRef.current = mergedOpen;
		var lastTriggerRef = import_react.useRef([]);
		lastTriggerRef.current = [];
		var internalTriggerOpen = useEvent(function(nextOpen) {
			var _lastTriggerRef$curre;
			setMergedOpen(nextOpen);
			if (((_lastTriggerRef$curre = lastTriggerRef.current[lastTriggerRef.current.length - 1]) !== null && _lastTriggerRef$curre !== void 0 ? _lastTriggerRef$curre : mergedOpen) !== nextOpen) {
				lastTriggerRef.current.push(nextOpen);
				onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextOpen);
			}
		});
		var delayRef = import_react.useRef();
		var clearDelay = function clearDelay$1() {
			clearTimeout(delayRef.current);
		};
		var triggerOpen = function triggerOpen$1(nextOpen) {
			var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
			clearDelay();
			if (delay === 0) internalTriggerOpen(nextOpen);
			else delayRef.current = setTimeout(function() {
				internalTriggerOpen(nextOpen);
			}, delay * 1e3);
		};
		import_react.useEffect(function() {
			return clearDelay;
		}, []);
		var _React$useState9 = import_react.useState(false), _React$useState10 = _slicedToArray(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
		useLayoutEffect_default(function(firstMount) {
			if (!firstMount || mergedOpen) setInMotion(true);
		}, [mergedOpen]);
		var _React$useState11 = import_react.useState(null), _React$useState12 = _slicedToArray(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
		var _React$useState13 = import_react.useState(null), _React$useState14 = _slicedToArray(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
		var setMousePosByEvent = function setMousePosByEvent$1(event) {
			setMousePos([event.clientX, event.clientY]);
		};
		var _useAlign = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10];
		var _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
		var clickToShow = showActions.has("click");
		var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
		var triggerAlign = useEvent(function() {
			if (!inMotion) onAlign();
		});
		useWatch(mergedOpen, targetEle, popupEle, triggerAlign, function onScroll() {
			if (openRef.current && alignPoint && clickToHide) triggerOpen(false);
		});
		useLayoutEffect_default(function() {
			triggerAlign();
		}, [mousePos, popupPlacement]);
		useLayoutEffect_default(function() {
			if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) triggerAlign();
		}, [JSON.stringify(popupAlign)]);
		var alignedClassName = import_react.useMemo(function() {
			var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
			return (0, import_classnames$225.default)(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
		}, [
			alignInfo,
			getPopupClassNameFromAlign,
			builtinPlacements,
			prefixCls,
			alignPoint
		]);
		import_react.useImperativeHandle(ref, function() {
			return {
				nativeElement: externalForwardRef.current,
				popupElement: externalPopupRef.current,
				forceAlign: triggerAlign
			};
		});
		var _React$useState15 = import_react.useState(0), _React$useState16 = _slicedToArray(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
		var _React$useState17 = import_react.useState(0), _React$useState18 = _slicedToArray(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
		var syncTargetSize = function syncTargetSize$1() {
			if (stretch && targetEle) {
				var rect = targetEle.getBoundingClientRect();
				setTargetWidth(rect.width);
				setTargetHeight(rect.height);
			}
		};
		var onTargetResize = function onTargetResize$1() {
			syncTargetSize();
			triggerAlign();
		};
		var onVisibleChanged = function onVisibleChanged$1(visible) {
			setInMotion(false);
			onAlign();
			afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 || afterPopupVisibleChange(visible);
		};
		var onPrepare = function onPrepare$1() {
			return new Promise(function(resolve) {
				syncTargetSize();
				setMotionPrepareResolve(function() {
					return resolve;
				});
			});
		};
		useLayoutEffect_default(function() {
			if (motionPrepareResolve) {
				onAlign();
				motionPrepareResolve();
				setMotionPrepareResolve(null);
			}
		}, [motionPrepareResolve]);
		/**
		* Util wrapper for trigger action
		*/
		function wrapperAction(eventName, nextOpen, delay, preEvent) {
			cloneProps[eventName] = function(event) {
				var _originChildProps$eve;
				preEvent === null || preEvent === void 0 || preEvent(event);
				triggerOpen(nextOpen, delay);
				for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
				(_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 || _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
			};
		}
		if (clickToShow || clickToHide) cloneProps.onClick = function(event) {
			var _originChildProps$onC;
			if (openRef.current && clickToHide) triggerOpen(false);
			else if (!openRef.current && clickToShow) {
				setMousePosByEvent(event);
				triggerOpen(true);
			}
			for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];
			(_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 || _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
		};
		var onPopupPointerDown = useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
		var hoverToShow = showActions.has("hover");
		var hoverToHide = hideActions.has("hover");
		var onPopupMouseEnter;
		var onPopupMouseLeave;
		if (hoverToShow) {
			wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
				setMousePosByEvent(event);
			});
			wrapperAction("onPointerEnter", true, mouseEnterDelay, function(event) {
				setMousePosByEvent(event);
			});
			onPopupMouseEnter = function onPopupMouseEnter$1(event) {
				if ((mergedOpen || inMotion) && popupEle !== null && popupEle !== void 0 && popupEle.contains(event.target)) triggerOpen(true, mouseEnterDelay);
			};
			if (alignPoint) cloneProps.onMouseMove = function(event) {
				var _originChildProps$onM;
				(_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 || _originChildProps$onM.call(originChildProps, event);
			};
		}
		if (hoverToHide) {
			wrapperAction("onMouseLeave", false, mouseLeaveDelay);
			wrapperAction("onPointerLeave", false, mouseLeaveDelay);
			onPopupMouseLeave = function onPopupMouseLeave$1() {
				triggerOpen(false, mouseLeaveDelay);
			};
		}
		if (showActions.has("focus")) wrapperAction("onFocus", true, focusDelay);
		if (hideActions.has("focus")) wrapperAction("onBlur", false, blurDelay);
		if (showActions.has("contextMenu")) cloneProps.onContextMenu = function(event) {
			var _originChildProps$onC2;
			if (openRef.current && hideActions.has("contextMenu")) triggerOpen(false);
			else {
				setMousePosByEvent(event);
				triggerOpen(true);
			}
			event.preventDefault();
			for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];
			(_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 || _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
		};
		if (className) cloneProps.className = (0, import_classnames$225.default)(originChildProps.className, className);
		var renderedRef = import_react.useRef(false);
		renderedRef.current || (renderedRef.current = forceRender || mergedOpen || inMotion);
		var mergedChildrenProps = _objectSpread2(_objectSpread2({}, originChildProps), cloneProps);
		var passedProps = {};
		[
			"onContextMenu",
			"onClick",
			"onMouseDown",
			"onTouchStart",
			"onMouseEnter",
			"onMouseLeave",
			"onFocus",
			"onBlur"
		].forEach(function(eventName) {
			if (restProps[eventName]) passedProps[eventName] = function() {
				var _mergedChildrenProps$;
				for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
				(_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 || _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
				restProps[eventName].apply(restProps, args);
			};
		});
		var triggerNode = /* @__PURE__ */ import_react.cloneElement(child, _objectSpread2(_objectSpread2({}, mergedChildrenProps), passedProps));
		var arrowPos = {
			x: arrowX,
			y: arrowY
		};
		var innerArrow = arrow ? _objectSpread2({}, arrow !== true ? arrow : {}) : null;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(es_default, {
			disabled: !mergedOpen,
			ref: setTargetRef,
			onResize: onTargetResize
		}, /* @__PURE__ */ import_react.createElement(TriggerWrapper_default, { getTriggerDOMNode }, triggerNode)), renderedRef.current && /* @__PURE__ */ import_react.createElement(context_default$7.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(Popup_default, {
			portal: PortalComponent,
			ref: setPopupRef,
			prefixCls,
			popup,
			className: (0, import_classnames$225.default)(popupClassName, alignedClassName),
			style: popupStyle,
			target: targetEle,
			onMouseEnter: onPopupMouseEnter,
			onMouseLeave: onPopupMouseLeave,
			onPointerEnter: onPopupMouseEnter,
			zIndex,
			open: mergedOpen,
			keepDom: inMotion,
			fresh,
			onClick: onPopupClick,
			onPointerDownCapture: onPopupPointerDown,
			mask,
			motion: mergePopupMotion,
			maskMotion: mergeMaskMotion,
			onVisibleChanged,
			onPrepare,
			forceRender,
			autoDestroy: mergedAutoDestroy,
			getPopupContainer,
			align: alignInfo,
			arrow: innerArrow,
			arrowPos,
			ready,
			offsetX,
			offsetY,
			offsetR,
			offsetB,
			onAlign: triggerAlign,
			stretch,
			targetWidth: targetWidth / scaleX,
			targetHeight: targetHeight / scaleY
		})));
	});
	Trigger.displayName = "Trigger";
	return Trigger;
}
var es_default$7 = generateTrigger(es_default$6);

//#endregion
//#region node_modules/rc-select/es/SelectTrigger.js
var import_classnames$224 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$60 = [
	"prefixCls",
	"disabled",
	"visible",
	"children",
	"popupElement",
	"animation",
	"transitionName",
	"dropdownStyle",
	"dropdownClassName",
	"direction",
	"placement",
	"builtinPlacements",
	"dropdownMatchSelectWidth",
	"dropdownRender",
	"dropdownAlign",
	"getPopupContainer",
	"empty",
	"getTriggerDOMNode",
	"onPopupVisibleChange",
	"onPopupMouseEnter"
];
var getBuiltInPlacements$1 = function getBuiltInPlacements$2(dropdownMatchSelectWidth) {
	var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
	return {
		bottomLeft: {
			points: ["tl", "bl"],
			offset: [0, 4],
			overflow: {
				adjustX,
				adjustY: 1
			},
			htmlRegion: "scroll"
		},
		bottomRight: {
			points: ["tr", "br"],
			offset: [0, 4],
			overflow: {
				adjustX,
				adjustY: 1
			},
			htmlRegion: "scroll"
		},
		topLeft: {
			points: ["bl", "tl"],
			offset: [0, -4],
			overflow: {
				adjustX,
				adjustY: 1
			},
			htmlRegion: "scroll"
		},
		topRight: {
			points: ["br", "tr"],
			offset: [0, -4],
			overflow: {
				adjustX,
				adjustY: 1
			},
			htmlRegion: "scroll"
		}
	};
};
var RefSelectTrigger = /* @__PURE__ */ import_react.forwardRef(function SelectTrigger(props, ref) {
	var prefixCls = props.prefixCls;
	props.disabled;
	var visible = props.visible, children = props.children, popupElement = props.popupElement, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, builtinPlacements = props.builtinPlacements, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty$1 = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties(props, _excluded$60);
	var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
	var popupNode = popupElement;
	if (dropdownRender) popupNode = dropdownRender(popupElement);
	var mergedBuiltinPlacements$1 = import_react.useMemo(function() {
		return builtinPlacements || getBuiltInPlacements$1(dropdownMatchSelectWidth);
	}, [builtinPlacements, dropdownMatchSelectWidth]);
	var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName;
	var isNumberPopupWidth = typeof dropdownMatchSelectWidth === "number";
	var stretch = import_react.useMemo(function() {
		if (isNumberPopupWidth) return null;
		return dropdownMatchSelectWidth === false ? "minWidth" : "width";
	}, [dropdownMatchSelectWidth, isNumberPopupWidth]);
	var popupStyle = dropdownStyle;
	if (isNumberPopupWidth) popupStyle = _objectSpread2(_objectSpread2({}, popupStyle), {}, { width: dropdownMatchSelectWidth });
	var triggerPopupRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, function() {
		return { getPopupElement: function getPopupElement() {
			var _triggerPopupRef$curr;
			return (_triggerPopupRef$curr = triggerPopupRef.current) === null || _triggerPopupRef$curr === void 0 ? void 0 : _triggerPopupRef$curr.popupElement;
		} };
	});
	return /* @__PURE__ */ import_react.createElement(es_default$7, _extends({}, restProps, {
		showAction: onPopupVisibleChange ? ["click"] : [],
		hideAction: onPopupVisibleChange ? ["click"] : [],
		popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
		builtinPlacements: mergedBuiltinPlacements$1,
		prefixCls: dropdownPrefixCls,
		popupTransitionName: mergedTransitionName,
		popup: /* @__PURE__ */ import_react.createElement("div", { onMouseEnter: onPopupMouseEnter }, popupNode),
		ref: triggerPopupRef,
		stretch,
		popupAlign: dropdownAlign,
		popupVisible: visible,
		getPopupContainer,
		popupClassName: (0, import_classnames$224.default)(dropdownClassName, _defineProperty({}, "".concat(dropdownPrefixCls, "-empty"), empty$1)),
		popupStyle,
		getTriggerDOMNode,
		onPopupVisibleChange
	}), children);
});
RefSelectTrigger.displayName = "SelectTrigger";
var SelectTrigger_default = RefSelectTrigger;

//#endregion
//#region node_modules/rc-select/es/utils/valueUtil.js
function getKey$2(data, index$2) {
	var key = data.key;
	var value;
	if ("value" in data) value = data.value;
	if (key !== null && key !== void 0) return key;
	if (value !== void 0) return value;
	return "rc-index-key-".concat(index$2);
}
function isValidCount(value) {
	return typeof value !== "undefined" && !Number.isNaN(value);
}
function fillFieldNames$3(fieldNames, childrenAsData) {
	var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, options = _ref.options, groupLabel = _ref.groupLabel;
	var mergedLabel = label || (childrenAsData ? "children" : "label");
	return {
		label: mergedLabel,
		value: value || "value",
		options: options || "options",
		groupLabel: groupLabel || mergedLabel
	};
}
/**
* Flat options into flatten list.
* We use `optionOnly` here is aim to avoid user use nested option group.
* Here is simply set `key` to the index if not provided.
*/
function flattenOptions(options) {
	var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
	var flattenList = [];
	var _fillFieldNames = fillFieldNames$3(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options, groupLabel = _fillFieldNames.groupLabel;
	function dig(list, isGroupOption) {
		if (!Array.isArray(list)) return;
		list.forEach(function(data) {
			if (isGroupOption || !(fieldOptions in data)) {
				var value = data[fieldValue];
				flattenList.push({
					key: getKey$2(data, flattenList.length),
					groupOption: isGroupOption,
					data,
					label: data[fieldLabel],
					value
				});
			} else {
				var grpLabel = data[groupLabel];
				if (grpLabel === void 0 && childrenAsData) grpLabel = data.label;
				flattenList.push({
					key: getKey$2(data, flattenList.length),
					group: true,
					data,
					label: grpLabel
				});
				dig(data[fieldOptions], true);
			}
		});
	}
	dig(options, false);
	return flattenList;
}
/**
* Inject `props` into `option` for legacy usage
*/
function injectPropsWithOption(option) {
	var newOption = _objectSpread2({}, option);
	if (!("props" in newOption)) Object.defineProperty(newOption, "props", { get: function get$1() {
		warning_default(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
		return newOption;
	} });
	return newOption;
}
var getSeparatedContent = function getSeparatedContent$1(text, tokens, end) {
	if (!tokens || !tokens.length) return null;
	var match$1 = false;
	var list = function separate(str, _ref3) {
		var _ref4 = _toArray(_ref3), token$1 = _ref4[0], restTokens = _ref4.slice(1);
		if (!token$1) return [str];
		var list$1 = str.split(token$1);
		match$1 = match$1 || list$1.length > 1;
		return list$1.reduce(function(prevList, unitStr) {
			return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
		}, []).filter(Boolean);
	}(text, tokens);
	if (match$1) return typeof end !== "undefined" ? list.slice(0, end) : list;
	else return null;
};

//#endregion
//#region node_modules/rc-select/es/SelectContext.js
var SelectContext = /* @__PURE__ */ import_react.createContext(null);
var SelectContext_default = SelectContext;

//#endregion
//#region node_modules/rc-select/es/BaseSelect/Polite.js
function Polite(props) {
	var visible = props.visible, values = props.values;
	if (!visible) return null;
	var MAX_COUNT = 50;
	return /* @__PURE__ */ import_react.createElement("span", {
		"aria-live": "polite",
		style: {
			width: 0,
			height: 0,
			position: "absolute",
			overflow: "hidden",
			opacity: 0
		}
	}, "".concat(values.slice(0, MAX_COUNT).map(function(_ref) {
		var label = _ref.label, value = _ref.value;
		return ["number", "string"].includes(_typeof(label)) ? label : value;
	}).join(", ")), values.length > MAX_COUNT ? ", ..." : null);
}

//#endregion
//#region node_modules/rc-select/es/BaseSelect/index.js
var import_classnames$223 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$59 = [
	"id",
	"prefixCls",
	"className",
	"showSearch",
	"tagRender",
	"direction",
	"omitDomProps",
	"displayValues",
	"onDisplayValuesChange",
	"emptyOptions",
	"notFoundContent",
	"onClear",
	"mode",
	"disabled",
	"loading",
	"getInputElement",
	"getRawInputElement",
	"open",
	"defaultOpen",
	"onDropdownVisibleChange",
	"activeValue",
	"onActiveValueChange",
	"activeDescendantId",
	"searchValue",
	"autoClearSearchValue",
	"onSearch",
	"onSearchSplit",
	"tokenSeparators",
	"allowClear",
	"prefix",
	"suffixIcon",
	"clearIcon",
	"OptionList",
	"animation",
	"transitionName",
	"dropdownStyle",
	"dropdownClassName",
	"dropdownMatchSelectWidth",
	"dropdownRender",
	"dropdownAlign",
	"placement",
	"builtinPlacements",
	"getPopupContainer",
	"showAction",
	"onFocus",
	"onBlur",
	"onKeyUp",
	"onKeyDown",
	"onMouseDown"
];
var DEFAULT_OMIT_PROPS = [
	"value",
	"onChange",
	"removeIcon",
	"placeholder",
	"autoFocus",
	"maxTagCount",
	"maxTagTextLength",
	"maxTagPlaceholder",
	"choiceTransitionName",
	"onInputKeyDown",
	"onPopupScroll",
	"tabIndex"
];
var isMultiple = function isMultiple$1(mode) {
	return mode === "tags" || mode === "multiple";
};
var BaseSelect = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _customizeRawInputEle;
	var id = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open$2 = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, prefix = props.prefix, suffixIcon = props.suffixIcon, clearIcon = props.clearIcon, OptionList = props.OptionList, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, builtinPlacements = props.builtinPlacements, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus = props.onFocus, onBlur = props.onBlur, onKeyUp = props.onKeyUp, onKeyDown$1 = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties(props, _excluded$59);
	var multiple = isMultiple(mode);
	var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
	var domProps = _objectSpread2({}, restProps);
	DEFAULT_OMIT_PROPS.forEach(function(propName) {
		delete domProps[propName];
	});
	omitDomProps === null || omitDomProps === void 0 || omitDomProps.forEach(function(propName) {
		delete domProps[propName];
	});
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
	import_react.useEffect(function() {
		setMobile(isMobile_default());
	}, []);
	var containerRef = import_react.useRef(null);
	var selectorDomRef = import_react.useRef(null);
	var triggerRef = import_react.useRef(null);
	var selectorRef = import_react.useRef(null);
	var listRef = import_react.useRef(null);
	var blurRef = import_react.useRef(false);
	/** Used for component focused management */
	var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
	import_react.useImperativeHandle(ref, function() {
		var _selectorRef$current, _selectorRef$current2;
		return {
			focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
			blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
			scrollTo: function scrollTo$1(arg) {
				var _listRef$current;
				return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
			},
			nativeElement: containerRef.current || selectorDomRef.current
		};
	});
	var mergedSearchValue = import_react.useMemo(function() {
		var _displayValues$;
		if (mode !== "combobox") return searchValue;
		var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
		return typeof val === "string" || typeof val === "number" ? String(val) : "";
	}, [
		searchValue,
		mode,
		displayValues
	]);
	var customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
	var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
	var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 || (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
	var _React$useState3 = import_react.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), rendered = _React$useState4[0], setRendered = _React$useState4[1];
	useLayoutEffect_default(function() {
		setRendered(true);
	}, []);
	var _useMergedState = useMergedState(false, {
		defaultValue: defaultOpen,
		value: open$2
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
	var mergedOpen = rendered ? innerOpen : false;
	var emptyListContent = !notFoundContent && emptyOptions;
	if (disabled || emptyListContent && mergedOpen && mode === "combobox") mergedOpen = false;
	var triggerOpen = emptyListContent ? false : mergedOpen;
	var onToggleOpen = import_react.useCallback(function(newOpen) {
		var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
		if (!disabled) {
			setInnerOpen(nextOpen);
			if (mergedOpen !== nextOpen) onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 || onDropdownVisibleChange(nextOpen);
		}
	}, [
		disabled,
		mergedOpen,
		setInnerOpen,
		onDropdownVisibleChange
	]);
	var tokenWithEnter = import_react.useMemo(function() {
		return (tokenSeparators || []).some(function(tokenSeparator) {
			return ["\n", "\r\n"].includes(tokenSeparator);
		});
	}, [tokenSeparators]);
	var _ref = import_react.useContext(SelectContext_default) || {}, maxCount = _ref.maxCount, rawValues = _ref.rawValues;
	var onInternalSearch = function onInternalSearch$1(searchText, fromTyping, isCompositing) {
		if (multiple && isValidCount(maxCount) && (rawValues === null || rawValues === void 0 ? void 0 : rawValues.size) >= maxCount) return;
		var ret = true;
		var newSearchText = searchText;
		onActiveValueChange === null || onActiveValueChange === void 0 || onActiveValueChange(null);
		var separatedList = getSeparatedContent(searchText, tokenSeparators, isValidCount(maxCount) ? maxCount - rawValues.size : void 0);
		var patchLabels = isCompositing ? null : separatedList;
		if (mode !== "combobox" && patchLabels) {
			newSearchText = "";
			onSearchSplit === null || onSearchSplit === void 0 || onSearchSplit(patchLabels);
			onToggleOpen(false);
			ret = false;
		}
		if (onSearch && mergedSearchValue !== newSearchText) onSearch(newSearchText, { source: fromTyping ? "typing" : "effect" });
		return ret;
	};
	var onInternalSearchSubmit = function onInternalSearchSubmit$1(searchText) {
		if (!searchText || !searchText.trim()) return;
		onSearch(searchText, { source: "submit" });
	};
	import_react.useEffect(function() {
		if (!mergedOpen && !multiple && mode !== "combobox") onInternalSearch("", false, false);
	}, [mergedOpen]);
	import_react.useEffect(function() {
		if (innerOpen && disabled) setInnerOpen(false);
		if (disabled && !blurRef.current) setMockFocused(false);
	}, [disabled]);
	/**
	* We record input value here to check if can press to clean up by backspace
	* - null: Key is not down, this is reset by key up
	* - true: Search text is empty when first time backspace down
	* - false: Search text is not empty when first time backspace down
	*/
	var _useLock = useLock(), _useLock2 = _slicedToArray(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
	var keyLockRef = import_react.useRef(false);
	var onInternalKeyDown = function onInternalKeyDown$1(event) {
		var clearLock = getClearLock();
		var key = event.key;
		var isEnterKey = key === "Enter";
		if (isEnterKey) {
			if (mode !== "combobox") event.preventDefault();
			if (!mergedOpen) onToggleOpen(true);
		}
		setClearLock(!!mergedSearchValue);
		if (key === "Backspace" && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
			var cloneDisplayValues = _toConsumableArray(displayValues);
			var removedDisplayValue = null;
			for (var i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
				var current = cloneDisplayValues[i];
				if (!current.disabled) {
					cloneDisplayValues.splice(i, 1);
					removedDisplayValue = current;
					break;
				}
			}
			if (removedDisplayValue) onDisplayValuesChange(cloneDisplayValues, {
				type: "remove",
				values: [removedDisplayValue]
			});
		}
		for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) rest[_key - 1] = arguments[_key];
		if (mergedOpen && (!isEnterKey || !keyLockRef.current)) {
			var _listRef$current2;
			if (isEnterKey) keyLockRef.current = true;
			(_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.onKeyDown.apply(_listRef$current2, [event].concat(rest));
		}
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1.apply(void 0, [event].concat(rest));
	};
	var onInternalKeyUp = function onInternalKeyUp$1(event) {
		for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) rest[_key2 - 1] = arguments[_key2];
		if (mergedOpen) {
			var _listRef$current3;
			(_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 || _listRef$current3.onKeyUp.apply(_listRef$current3, [event].concat(rest));
		}
		if (event.key === "Enter") keyLockRef.current = false;
		onKeyUp === null || onKeyUp === void 0 || onKeyUp.apply(void 0, [event].concat(rest));
	};
	var onSelectorRemove = function onSelectorRemove$1(val) {
		var newValues = displayValues.filter(function(i) {
			return i !== val;
		});
		onDisplayValuesChange(newValues, {
			type: "remove",
			values: [val]
		});
	};
	var onInputBlur = function onInputBlur$1() {
		keyLockRef.current = false;
	};
	/** Record real focus status */
	var focusRef = import_react.useRef(false);
	var onContainerFocus = function onContainerFocus$1() {
		setMockFocused(true);
		if (!disabled) {
			if (onFocus && !focusRef.current) onFocus.apply(void 0, arguments);
			if (showAction.includes("focus")) onToggleOpen(true);
		}
		focusRef.current = true;
	};
	var onContainerBlur = function onContainerBlur$1() {
		blurRef.current = true;
		setMockFocused(false, function() {
			focusRef.current = false;
			blurRef.current = false;
			onToggleOpen(false);
		});
		if (disabled) return;
		if (mergedSearchValue) {
			if (mode === "tags") onSearch(mergedSearchValue, { source: "submit" });
			else if (mode === "multiple") onSearch("", { source: "blur" });
		}
		if (onBlur) onBlur.apply(void 0, arguments);
	};
	var activeTimeoutIds = [];
	import_react.useEffect(function() {
		return function() {
			activeTimeoutIds.forEach(function(timeoutId) {
				return clearTimeout(timeoutId);
			});
			activeTimeoutIds.splice(0, activeTimeoutIds.length);
		};
	}, []);
	var onInternalMouseDown = function onInternalMouseDown$1(event) {
		var _triggerRef$current;
		var target = event.target;
		var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
		if (popupElement && popupElement.contains(target)) {
			var timeoutId = setTimeout(function() {
				var index$2 = activeTimeoutIds.indexOf(timeoutId);
				if (index$2 !== -1) activeTimeoutIds.splice(index$2, 1);
				cancelSetMockFocused();
				if (!mobile && !popupElement.contains(document.activeElement)) {
					var _selectorRef$current3;
					(_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.focus();
				}
			});
			activeTimeoutIds.push(timeoutId);
		}
		for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) restArgs[_key3 - 1] = arguments[_key3];
		onMouseDown === null || onMouseDown === void 0 || onMouseDown.apply(void 0, [event].concat(restArgs));
	};
	var _React$useState5 = import_react.useState({}), _React$useState6 = _slicedToArray(_React$useState5, 2), forceUpdate = _React$useState6[1];
	function onPopupMouseEnter() {
		forceUpdate({});
	}
	var onTriggerVisibleChange;
	if (customizeRawInputElement) onTriggerVisibleChange = function onTriggerVisibleChange$1(newOpen) {
		onToggleOpen(newOpen);
	};
	useSelectTriggerControl(function() {
		var _triggerRef$current2;
		return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
	}, triggerOpen, onToggleOpen, !!customizeRawInputElement);
	var baseSelectContext = import_react.useMemo(function() {
		return _objectSpread2(_objectSpread2({}, props), {}, {
			notFoundContent,
			open: mergedOpen,
			triggerOpen,
			id,
			showSearch: mergedShowSearch,
			multiple,
			toggleOpen: onToggleOpen
		});
	}, [
		props,
		notFoundContent,
		triggerOpen,
		mergedOpen,
		id,
		mergedShowSearch,
		multiple,
		onToggleOpen
	]);
	var showSuffixIcon = !!suffixIcon || loading;
	var arrowNode;
	if (showSuffixIcon) arrowNode = /* @__PURE__ */ import_react.createElement(TransBtn_default, {
		className: (0, import_classnames$223.default)("".concat(prefixCls, "-arrow"), _defineProperty({}, "".concat(prefixCls, "-arrow-loading"), loading)),
		customizeIcon: suffixIcon,
		customizeIconProps: {
			loading,
			searchValue: mergedSearchValue,
			open: mergedOpen,
			focused: mockFocused,
			showSearch: mergedShowSearch
		}
	});
	var _useAllowClear = useAllowClear(prefixCls, function onClearMouseDown() {
		var _selectorRef$current4;
		onClear === null || onClear === void 0 || onClear();
		(_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 || _selectorRef$current4.focus();
		onDisplayValuesChange([], {
			type: "clear",
			values: displayValues
		});
		onInternalSearch("", false, false);
	}, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode), mergedAllowClear = _useAllowClear.allowClear, clearNode = _useAllowClear.clearIcon;
	var optionList = /* @__PURE__ */ import_react.createElement(OptionList, { ref: listRef });
	var mergedClassName = (0, import_classnames$223.default)(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-focused"), mockFocused), "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-single"), !multiple), "".concat(prefixCls, "-allow-clear"), allowClear), "".concat(prefixCls, "-show-arrow"), showSuffixIcon), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-loading"), loading), "".concat(prefixCls, "-open"), mergedOpen), "".concat(prefixCls, "-customize-input"), customizeInputElement), "".concat(prefixCls, "-show-search"), mergedShowSearch));
	var selectorNode = /* @__PURE__ */ import_react.createElement(SelectTrigger_default, {
		ref: triggerRef,
		disabled,
		prefixCls,
		visible: triggerOpen,
		popupElement: optionList,
		animation,
		transitionName,
		dropdownStyle,
		dropdownClassName,
		direction,
		dropdownMatchSelectWidth,
		dropdownRender,
		dropdownAlign,
		placement,
		builtinPlacements,
		getPopupContainer,
		empty: emptyOptions,
		getTriggerDOMNode: function getTriggerDOMNode(node$1) {
			return selectorDomRef.current || node$1;
		},
		onPopupVisibleChange: onTriggerVisibleChange,
		onPopupMouseEnter
	}, customizeRawInputElement ? /* @__PURE__ */ import_react.cloneElement(customizeRawInputElement, { ref: customizeRawInputRef }) : /* @__PURE__ */ import_react.createElement(Selector_default, _extends({}, props, {
		domRef: selectorDomRef,
		prefixCls,
		inputElement: customizeInputElement,
		ref: selectorRef,
		id,
		prefix,
		showSearch: mergedShowSearch,
		autoClearSearchValue,
		mode,
		activeDescendantId,
		tagRender,
		values: displayValues,
		open: mergedOpen,
		onToggleOpen,
		activeValue,
		searchValue: mergedSearchValue,
		onSearch: onInternalSearch,
		onSearchSubmit: onInternalSearchSubmit,
		onRemove: onSelectorRemove,
		tokenWithEnter,
		onInputBlur
	})));
	var renderNode;
	if (customizeRawInputElement) renderNode = selectorNode;
	else renderNode = /* @__PURE__ */ import_react.createElement("div", _extends({ className: mergedClassName }, domProps, {
		ref: containerRef,
		onMouseDown: onInternalMouseDown,
		onKeyDown: onInternalKeyDown,
		onKeyUp: onInternalKeyUp,
		onFocus: onContainerFocus,
		onBlur: onContainerBlur
	}), /* @__PURE__ */ import_react.createElement(Polite, {
		visible: mockFocused && !mergedOpen,
		values: displayValues
	}), selectorNode, arrowNode, mergedAllowClear && clearNode);
	return /* @__PURE__ */ import_react.createElement(BaseSelectContext.Provider, { value: baseSelectContext }, renderNode);
});
BaseSelect.displayName = "BaseSelect";
var BaseSelect_default = BaseSelect;

//#endregion
//#region node_modules/rc-select/es/OptGroup.js
/* istanbul ignore file */
/** This is a placeholder, not real render in dom */
var OptGroup = function OptGroup$1() {
	return null;
};
OptGroup.isSelectOptGroup = true;
var OptGroup_default = OptGroup;

//#endregion
//#region node_modules/rc-select/es/Option.js
/* istanbul ignore file */
/** This is a placeholder, not real render in dom */
var Option$4 = function Option$5() {
	return null;
};
Option$4.isSelectOption = true;
var Option_default$1 = Option$4;

//#endregion
//#region node_modules/rc-virtual-list/es/Filler.js
var import_classnames$222 = /* @__PURE__ */ __toESM(require_classnames());
/**
* Fill component to provided the scroll content real height.
*/
var Filler = /* @__PURE__ */ import_react.forwardRef(function(_ref, ref) {
	var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
	var outerStyle = {};
	var innerStyle = {
		display: "flex",
		flexDirection: "column"
	};
	if (offsetY !== void 0) {
		outerStyle = {
			height,
			position: "relative",
			overflow: "hidden"
		};
		innerStyle = _objectSpread2(_objectSpread2({}, innerStyle), {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({ transform: "translateY(".concat(offsetY, "px)") }, rtl ? "marginRight" : "marginLeft", -offsetX), "position", "absolute"), "left", 0), "right", 0), "top", 0));
	}
	return /* @__PURE__ */ import_react.createElement("div", { style: outerStyle }, /* @__PURE__ */ import_react.createElement(es_default, { onResize: function onResize$1(_ref2) {
		if (_ref2.offsetHeight && onInnerResize) onInnerResize();
	} }, /* @__PURE__ */ import_react.createElement("div", _extends({
		style: innerStyle,
		className: (0, import_classnames$222.default)(_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
		ref
	}, innerProps), children, extra)));
});
Filler.displayName = "Filler";
var Filler_default = Filler;

//#endregion
//#region node_modules/rc-virtual-list/es/Item.js
function Item$2(_ref) {
	var children = _ref.children, setRef = _ref.setRef;
	var refFunc = import_react.useCallback(function(node$1) {
		setRef(node$1);
	}, []);
	return /* @__PURE__ */ import_react.cloneElement(children, { ref: refFunc });
}

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useChildren.js
function useChildren$1(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, _ref) {
	var getKey$3 = _ref.getKey;
	return list.slice(startIndex, endIndex + 1).map(function(item, index$2) {
		var eleIndex = startIndex + index$2;
		var node$1 = renderFunc(item, eleIndex, {
			style: { width: scrollWidth },
			offsetX
		});
		var key = getKey$3(item);
		return /* @__PURE__ */ import_react.createElement(Item$2, {
			key,
			setRef: function setRef(ele) {
				return setNodeRef(item, ele);
			}
		}, node$1);
	});
}

//#endregion
//#region node_modules/rc-virtual-list/es/utils/algorithmUtil.js
/**
* We assume that 2 list has only 1 item diff and others keeping the order.
* So we can use dichotomy algorithm to find changed one.
*/
function findListDiffIndex(originList, targetList, getKey$3) {
	var originLen = originList.length;
	var targetLen = targetList.length;
	var shortList;
	var longList;
	if (originLen === 0 && targetLen === 0) return null;
	if (originLen < targetLen) {
		shortList = originList;
		longList = targetList;
	} else {
		shortList = targetList;
		longList = originList;
	}
	var notExistKey = { __EMPTY_ITEM__: true };
	function getItemKey(item) {
		if (item !== void 0) return getKey$3(item);
		return notExistKey;
	}
	var diffIndex = null;
	var multiple = Math.abs(originLen - targetLen) !== 1;
	for (var i = 0; i < longList.length; i += 1) {
		var shortKey = getItemKey(shortList[i]);
		var longKey = getItemKey(longList[i]);
		if (shortKey !== longKey) {
			diffIndex = i;
			multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
			break;
		}
	}
	return diffIndex === null ? null : {
		index: diffIndex,
		multiple
	};
}

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useDiffItem.js
function useDiffItem(data, getKey$3, onDiff) {
	var _React$useState = import_react.useState(data), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
	var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
	import_react.useEffect(function() {
		var diff = findListDiffIndex(prevData || [], data || [], getKey$3);
		if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
			onDiff === null || onDiff === void 0 || onDiff(diff.index);
			setDiffItem(data[diff.index]);
		}
		setPrevData(data);
	}, [data]);
	return [diffItem];
}

//#endregion
//#region node_modules/rc-virtual-list/es/utils/isFirefox.js
var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
var isFirefox_default = isFF;

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useOriginScroll.js
var useOriginScroll_default = (function(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) {
	var lockRef = (0, import_react.useRef)(false);
	var lockTimeoutRef = (0, import_react.useRef)(null);
	function lockScroll() {
		clearTimeout(lockTimeoutRef.current);
		lockRef.current = true;
		lockTimeoutRef.current = setTimeout(function() {
			lockRef.current = false;
		}, 50);
	}
	var scrollPingRef = (0, import_react.useRef)({
		top: isScrollAtTop,
		bottom: isScrollAtBottom,
		left: isScrollAtLeft,
		right: isScrollAtRight
	});
	scrollPingRef.current.top = isScrollAtTop;
	scrollPingRef.current.bottom = isScrollAtBottom;
	scrollPingRef.current.left = isScrollAtLeft;
	scrollPingRef.current.right = isScrollAtRight;
	return function(isHorizontal, delta) {
		var smoothOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
		var originScroll = isHorizontal ? delta < 0 && scrollPingRef.current.left || delta > 0 && scrollPingRef.current.right : delta < 0 && scrollPingRef.current.top || delta > 0 && scrollPingRef.current.bottom;
		if (smoothOffset && originScroll) {
			clearTimeout(lockTimeoutRef.current);
			lockRef.current = false;
		} else if (!originScroll || lockRef.current) lockScroll();
		return !lockRef.current && originScroll;
	};
});

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useFrameWheel.js
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, onWheelDelta) {
	var offsetRef = (0, import_react.useRef)(0);
	var nextFrameRef = (0, import_react.useRef)(null);
	var wheelValueRef = (0, import_react.useRef)(null);
	var isMouseScrollRef = (0, import_react.useRef)(false);
	var originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
	function onWheelY(e$2, deltaY) {
		raf_default.cancel(nextFrameRef.current);
		if (originScroll(false, deltaY)) return;
		var event = e$2;
		if (!event._virtualHandled) event._virtualHandled = true;
		else return;
		offsetRef.current += deltaY;
		wheelValueRef.current = deltaY;
		if (!isFirefox_default) event.preventDefault();
		nextFrameRef.current = raf_default(function() {
			var patchMultiple = isMouseScrollRef.current ? 10 : 1;
			onWheelDelta(offsetRef.current * patchMultiple, false);
			offsetRef.current = 0;
		});
	}
	function onWheelX(event, deltaX) {
		onWheelDelta(deltaX, true);
		if (!isFirefox_default) event.preventDefault();
	}
	var wheelDirectionRef = (0, import_react.useRef)(null);
	var wheelDirectionCleanRef = (0, import_react.useRef)(null);
	function onWheel(event) {
		if (!inVirtual) return;
		raf_default.cancel(wheelDirectionCleanRef.current);
		wheelDirectionCleanRef.current = raf_default(function() {
			wheelDirectionRef.current = null;
		}, 2);
		var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
		var mergedDeltaX = deltaX;
		var mergedDeltaY = deltaY;
		if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
			mergedDeltaX = deltaY;
			mergedDeltaY = 0;
			wheelDirectionRef.current = "sx";
		}
		var absX = Math.abs(mergedDeltaX);
		var absY = Math.abs(mergedDeltaY);
		if (wheelDirectionRef.current === null) wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
		if (wheelDirectionRef.current === "y") onWheelY(event, mergedDeltaY);
		else onWheelX(event, mergedDeltaX);
	}
	function onFireFoxScroll(event) {
		if (!inVirtual) return;
		isMouseScrollRef.current = event.detail === wheelValueRef.current;
	}
	return [onWheel, onFireFoxScroll];
}

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useGetSize.js
/**
* Size info need loop query for the `heights` which will has the perf issue.
* Let cache result for each render phase.
*/
function useGetSize(mergedData, getKey$3, heights, itemHeight) {
	var _React$useMemo = import_react.useMemo(function() {
		return [/* @__PURE__ */ new Map(), []];
	}, [
		mergedData,
		heights.id,
		itemHeight
	]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
	return function getSize$2(startKey) {
		var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey;
		var startIndex = key2Index.get(startKey);
		var endIndex = key2Index.get(endKey);
		if (startIndex === void 0 || endIndex === void 0) {
			var dataLen = mergedData.length;
			for (var i = bottomList.length; i < dataLen; i += 1) {
				var _heights$get;
				var item = mergedData[i];
				var key = getKey$3(item);
				key2Index.set(key, i);
				var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
				bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
				if (key === startKey) startIndex = i;
				if (key === endKey) endIndex = i;
				if (startIndex !== void 0 && endIndex !== void 0) break;
			}
		}
		return {
			top: bottomList[startIndex - 1] || 0,
			bottom: bottomList[endIndex]
		};
	};
}

//#endregion
//#region node_modules/rc-virtual-list/es/utils/CacheMap.js
var CacheMap = /* @__PURE__ */ function() {
	function CacheMap$1() {
		_classCallCheck(this, CacheMap$1);
		_defineProperty(this, "maps", void 0);
		_defineProperty(this, "id", 0);
		_defineProperty(this, "diffRecords", /* @__PURE__ */ new Map());
		this.maps = Object.create(null);
	}
	_createClass(CacheMap$1, [
		{
			key: "set",
			value: function set$1(key, value) {
				this.diffRecords.set(key, this.maps[key]);
				this.maps[key] = value;
				this.id += 1;
			}
		},
		{
			key: "get",
			value: function get$1(key) {
				return this.maps[key];
			}
		},
		{
			key: "resetRecord",
			value: function resetRecord() {
				this.diffRecords.clear();
			}
		},
		{
			key: "getRecord",
			value: function getRecord() {
				return this.diffRecords;
			}
		}
	]);
	return CacheMap$1;
}();
var CacheMap_default = CacheMap;

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useHeights.js
function parseNumber(value) {
	var num = parseFloat(value);
	return isNaN(num) ? 0 : num;
}
function useHeights(getKey$3, onItemAdd, onItemRemove) {
	var _React$useState = import_react.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
	var instanceRef = (0, import_react.useRef)(/* @__PURE__ */ new Map());
	var heightsRef = (0, import_react.useRef)(new CacheMap_default());
	var promiseIdRef = (0, import_react.useRef)(0);
	function cancelRaf() {
		promiseIdRef.current += 1;
	}
	function collectHeight() {
		var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
		cancelRaf();
		var doCollect = function doCollect$1() {
			var changed = false;
			instanceRef.current.forEach(function(element, key) {
				if (element && element.offsetParent) {
					var offsetHeight = element.offsetHeight;
					var _getComputedStyle = getComputedStyle(element), marginTop = _getComputedStyle.marginTop, marginBottom = _getComputedStyle.marginBottom;
					var marginTopNum = parseNumber(marginTop);
					var marginBottomNum = parseNumber(marginBottom);
					var totalHeight = offsetHeight + marginTopNum + marginBottomNum;
					if (heightsRef.current.get(key) !== totalHeight) {
						heightsRef.current.set(key, totalHeight);
						changed = true;
					}
				}
			});
			if (changed) setUpdatedMark(function(c) {
				return c + 1;
			});
		};
		if (sync) doCollect();
		else {
			promiseIdRef.current += 1;
			var id = promiseIdRef.current;
			Promise.resolve().then(function() {
				if (id === promiseIdRef.current) doCollect();
			});
		}
	}
	function setInstanceRef(item, instance) {
		var key = getKey$3(item);
		var origin = instanceRef.current.get(key);
		if (instance) {
			instanceRef.current.set(key, instance);
			collectHeight();
		} else instanceRef.current.delete(key);
		if (!origin !== !instance) if (instance) onItemAdd === null || onItemAdd === void 0 || onItemAdd(item);
		else onItemRemove === null || onItemRemove === void 0 || onItemRemove(item);
	}
	(0, import_react.useEffect)(function() {
		return cancelRaf;
	}, []);
	return [
		setInstanceRef,
		collectHeight,
		heightsRef.current,
		updatedMark
	];
}

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useMobileTouchMove.js
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
	var touchedRef = (0, import_react.useRef)(false);
	var touchXRef = (0, import_react.useRef)(0);
	var touchYRef = (0, import_react.useRef)(0);
	var elementRef = (0, import_react.useRef)(null);
	var intervalRef = (0, import_react.useRef)(null);
	var cleanUpEvents;
	var onTouchMove = function onTouchMove$1(e$2) {
		if (touchedRef.current) {
			var currentX = Math.ceil(e$2.touches[0].pageX);
			var currentY = Math.ceil(e$2.touches[0].pageY);
			var offsetX = touchXRef.current - currentX;
			var offsetY = touchYRef.current - currentY;
			var _isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
			if (_isHorizontal) touchXRef.current = currentX;
			else touchYRef.current = currentY;
			var scrollHandled = callback(_isHorizontal, _isHorizontal ? offsetX : offsetY, false, e$2);
			if (scrollHandled) e$2.preventDefault();
			clearInterval(intervalRef.current);
			if (scrollHandled) intervalRef.current = setInterval(function() {
				if (_isHorizontal) offsetX *= SMOOTH_PTG;
				else offsetY *= SMOOTH_PTG;
				var offset$2 = Math.floor(_isHorizontal ? offsetX : offsetY);
				if (!callback(_isHorizontal, offset$2, true) || Math.abs(offset$2) <= .1) clearInterval(intervalRef.current);
			}, 16);
		}
	};
	var onTouchEnd = function onTouchEnd$1() {
		touchedRef.current = false;
		cleanUpEvents();
	};
	var onTouchStart = function onTouchStart$1(e$2) {
		cleanUpEvents();
		if (e$2.touches.length === 1 && !touchedRef.current) {
			touchedRef.current = true;
			touchXRef.current = Math.ceil(e$2.touches[0].pageX);
			touchYRef.current = Math.ceil(e$2.touches[0].pageY);
			elementRef.current = e$2.target;
			elementRef.current.addEventListener("touchmove", onTouchMove, { passive: false });
			elementRef.current.addEventListener("touchend", onTouchEnd, { passive: true });
		}
	};
	cleanUpEvents = function cleanUpEvents$1() {
		if (elementRef.current) {
			elementRef.current.removeEventListener("touchmove", onTouchMove);
			elementRef.current.removeEventListener("touchend", onTouchEnd);
		}
	};
	useLayoutEffect_default(function() {
		if (inVirtual) listRef.current.addEventListener("touchstart", onTouchStart, { passive: true });
		return function() {
			var _listRef$current;
			(_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.removeEventListener("touchstart", onTouchStart);
			cleanUpEvents();
			clearInterval(intervalRef.current);
		};
	}, [inVirtual]);
}

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useScrollDrag.js
function smoothScrollOffset(offset$2) {
	return Math.floor(Math.pow(offset$2, .5));
}
function getPageXY(e$2, horizontal) {
	return ("touches" in e$2 ? e$2.touches[0] : e$2)[horizontal ? "pageX" : "pageY"] - window[horizontal ? "scrollX" : "scrollY"];
}
function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
	import_react.useEffect(function() {
		var ele = componentRef.current;
		if (inVirtual && ele) {
			var mouseDownLock = false;
			var rafId;
			var _offset;
			var stopScroll = function stopScroll$1() {
				raf_default.cancel(rafId);
			};
			var continueScroll = function continueScroll$1() {
				stopScroll();
				rafId = raf_default(function() {
					onScrollOffset(_offset);
					continueScroll$1();
				});
			};
			var clearDragState = function clearDragState$1() {
				mouseDownLock = false;
				stopScroll();
			};
			var onMouseDown = function onMouseDown$1(e$2) {
				if (e$2.target.draggable || e$2.button !== 0) return;
				var event = e$2;
				if (!event._virtualHandled) {
					event._virtualHandled = true;
					mouseDownLock = true;
				}
			};
			var onMouseMove = function onMouseMove$1(e$2) {
				if (mouseDownLock) {
					var mouseY = getPageXY(e$2, false);
					var _ele$getBoundingClien = ele.getBoundingClientRect(), top = _ele$getBoundingClien.top, bottom = _ele$getBoundingClien.bottom;
					if (mouseY <= top) {
						var diff = top - mouseY;
						_offset = -smoothScrollOffset(diff);
						continueScroll();
					} else if (mouseY >= bottom) {
						var _diff = mouseY - bottom;
						_offset = smoothScrollOffset(_diff);
						continueScroll();
					} else stopScroll();
				}
			};
			ele.addEventListener("mousedown", onMouseDown);
			ele.ownerDocument.addEventListener("mouseup", clearDragState);
			ele.ownerDocument.addEventListener("mousemove", onMouseMove);
			ele.ownerDocument.addEventListener("dragend", clearDragState);
			return function() {
				ele.removeEventListener("mousedown", onMouseDown);
				ele.ownerDocument.removeEventListener("mouseup", clearDragState);
				ele.ownerDocument.removeEventListener("mousemove", onMouseMove);
				ele.ownerDocument.removeEventListener("dragend", clearDragState);
				stopScroll();
			};
		}
	}, [inVirtual]);
}

//#endregion
//#region node_modules/rc-virtual-list/es/hooks/useScrollTo.js
var MAX_TIMES = 10;
function useScrollTo$1(containerRef, data, heights, itemHeight, getKey$3, collectHeight, syncScrollTop, triggerFlash) {
	var scrollRef = import_react.useRef();
	var _React$useState = import_react.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
	useLayoutEffect_default(function() {
		if (syncState && syncState.times < MAX_TIMES) {
			if (!containerRef.current) {
				setSyncState(function(ori) {
					return _objectSpread2({}, ori);
				});
				return;
			}
			collectHeight();
			var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index$2 = syncState.index, offset$2 = syncState.offset;
			var height = containerRef.current.clientHeight;
			var needCollectHeight = false;
			var newTargetAlign = targetAlign;
			var targetTop = null;
			if (height) {
				var mergedAlign = targetAlign || originAlign;
				var stackTop = 0;
				var itemTop = 0;
				var itemBottom = 0;
				var maxLen = Math.min(data.length - 1, index$2);
				for (var i = 0; i <= maxLen; i += 1) {
					var key = getKey$3(data[i]);
					itemTop = stackTop;
					var cacheHeight = heights.get(key);
					itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
					stackTop = itemBottom;
				}
				var leftHeight = mergedAlign === "top" ? offset$2 : height - offset$2;
				for (var _i = maxLen; _i >= 0; _i -= 1) {
					var _key = getKey$3(data[_i]);
					var _cacheHeight = heights.get(_key);
					if (_cacheHeight === void 0) {
						needCollectHeight = true;
						break;
					}
					leftHeight -= _cacheHeight;
					if (leftHeight <= 0) break;
				}
				switch (mergedAlign) {
					case "top":
						targetTop = itemTop - offset$2;
						break;
					case "bottom":
						targetTop = itemBottom - height + offset$2;
						break;
					default:
						var scrollTop = containerRef.current.scrollTop;
						var scrollBottom = scrollTop + height;
						if (itemTop < scrollTop) newTargetAlign = "top";
						else if (itemBottom > scrollBottom) newTargetAlign = "bottom";
				}
				if (targetTop !== null) syncScrollTop(targetTop);
				if (targetTop !== syncState.lastTop) needCollectHeight = true;
			}
			if (needCollectHeight) setSyncState(_objectSpread2(_objectSpread2({}, syncState), {}, {
				times: syncState.times + 1,
				targetAlign: newTargetAlign,
				lastTop: targetTop
			}));
		} else if ((syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) warning_default(false, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
	}, [syncState, containerRef.current]);
	return function(arg) {
		if (arg === null || arg === void 0) {
			triggerFlash();
			return;
		}
		raf_default.cancel(scrollRef.current);
		if (typeof arg === "number") syncScrollTop(arg);
		else if (arg && _typeof(arg) === "object") {
			var index$2;
			var align = arg.align;
			if ("index" in arg) index$2 = arg.index;
			else index$2 = data.findIndex(function(item) {
				return getKey$3(item) === arg.key;
			});
			var _arg$offset = arg.offset;
			setSyncState({
				times: 0,
				index: index$2,
				offset: _arg$offset === void 0 ? 0 : _arg$offset,
				originAlign: align
			});
		}
	};
}

//#endregion
//#region node_modules/rc-virtual-list/es/ScrollBar.js
var import_classnames$221 = /* @__PURE__ */ __toESM(require_classnames());
var ScrollBar = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style$1 = props.style, propsThumbStyle = props.thumbStyle, showScrollBar = props.showScrollBar;
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
	var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
	var _React$useState5 = import_react.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
	var isLTR = !rtl;
	var scrollbarRef = import_react.useRef();
	var thumbRef = import_react.useRef();
	var _React$useState7 = import_react.useState(showScrollBar), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
	var visibleTimeoutRef = import_react.useRef();
	var delayHidden = function delayHidden$1() {
		if (showScrollBar === true || showScrollBar === false) return;
		clearTimeout(visibleTimeoutRef.current);
		setVisible(true);
		visibleTimeoutRef.current = setTimeout(function() {
			setVisible(false);
		}, 3e3);
	};
	var enableScrollRange = scrollRange - containerSize || 0;
	var enableOffsetRange = containerSize - spinSize || 0;
	var top = import_react.useMemo(function() {
		if (scrollOffset === 0 || enableScrollRange === 0) return 0;
		return scrollOffset / enableScrollRange * enableOffsetRange;
	}, [
		scrollOffset,
		enableScrollRange,
		enableOffsetRange
	]);
	var onContainerMouseDown = function onContainerMouseDown$1(e$2) {
		e$2.stopPropagation();
		e$2.preventDefault();
	};
	var stateRef = import_react.useRef({
		top,
		dragging,
		pageY: pageXY,
		startTop
	});
	stateRef.current = {
		top,
		dragging,
		pageY: pageXY,
		startTop
	};
	var onThumbMouseDown = function onThumbMouseDown$1(e$2) {
		setDragging(true);
		setPageXY(getPageXY(e$2, horizontal));
		setStartTop(stateRef.current.top);
		onStartMove();
		e$2.stopPropagation();
		e$2.preventDefault();
	};
	import_react.useEffect(function() {
		var onScrollbarTouchStart = function onScrollbarTouchStart$1(e$2) {
			e$2.preventDefault();
		};
		var scrollbarEle = scrollbarRef.current;
		var thumbEle = thumbRef.current;
		scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart, { passive: false });
		thumbEle.addEventListener("touchstart", onThumbMouseDown, { passive: false });
		return function() {
			scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
			thumbEle.removeEventListener("touchstart", onThumbMouseDown);
		};
	}, []);
	var enableScrollRangeRef = import_react.useRef();
	enableScrollRangeRef.current = enableScrollRange;
	var enableOffsetRangeRef = import_react.useRef();
	enableOffsetRangeRef.current = enableOffsetRange;
	import_react.useEffect(function() {
		if (dragging) {
			var moveRafId;
			var onMouseMove = function onMouseMove$1(e$2) {
				var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
				raf_default.cancel(moveRafId);
				var rect = scrollbarRef.current.getBoundingClientRect();
				var scale = containerSize / (horizontal ? rect.width : rect.height);
				if (stateDragging) {
					var offset$2 = (getPageXY(e$2, horizontal) - statePageY) * scale;
					var newTop = stateStartTop;
					if (!isLTR && horizontal) newTop -= offset$2;
					else newTop += offset$2;
					var tmpEnableScrollRange = enableScrollRangeRef.current;
					var tmpEnableOffsetRange = enableOffsetRangeRef.current;
					var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
					var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
					newScrollTop = Math.max(newScrollTop, 0);
					newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
					moveRafId = raf_default(function() {
						onScroll(newScrollTop, horizontal);
					});
				}
			};
			var onMouseUp = function onMouseUp$1() {
				setDragging(false);
				onStopMove();
			};
			window.addEventListener("mousemove", onMouseMove, { passive: true });
			window.addEventListener("touchmove", onMouseMove, { passive: true });
			window.addEventListener("mouseup", onMouseUp, { passive: true });
			window.addEventListener("touchend", onMouseUp, { passive: true });
			return function() {
				window.removeEventListener("mousemove", onMouseMove);
				window.removeEventListener("touchmove", onMouseMove);
				window.removeEventListener("mouseup", onMouseUp);
				window.removeEventListener("touchend", onMouseUp);
				raf_default.cancel(moveRafId);
			};
		}
	}, [dragging]);
	import_react.useEffect(function() {
		delayHidden();
		return function() {
			clearTimeout(visibleTimeoutRef.current);
		};
	}, [scrollOffset]);
	import_react.useImperativeHandle(ref, function() {
		return { delayHidden };
	});
	var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
	var containerStyle = {
		position: "absolute",
		visibility: visible ? null : "hidden"
	};
	var thumbStyle = {
		position: "absolute",
		borderRadius: 99,
		background: "var(--rc-virtual-list-scrollbar-bg, rgba(0, 0, 0, 0.5))",
		cursor: "pointer",
		userSelect: "none"
	};
	if (horizontal) {
		Object.assign(containerStyle, {
			height: 8,
			left: 0,
			right: 0,
			bottom: 0
		});
		Object.assign(thumbStyle, _defineProperty({
			height: "100%",
			width: spinSize
		}, isLTR ? "left" : "right", top));
	} else {
		Object.assign(containerStyle, _defineProperty({
			width: 8,
			top: 0,
			bottom: 0
		}, isLTR ? "right" : "left", 0));
		Object.assign(thumbStyle, {
			width: "100%",
			height: spinSize,
			top
		});
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: scrollbarRef,
		className: (0, import_classnames$221.default)(scrollbarPrefixCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), "".concat(scrollbarPrefixCls, "-visible"), visible)),
		style: _objectSpread2(_objectSpread2({}, containerStyle), style$1),
		onMouseDown: onContainerMouseDown,
		onMouseMove: delayHidden
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: thumbRef,
		className: (0, import_classnames$221.default)("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
		style: _objectSpread2(_objectSpread2({}, thumbStyle), propsThumbStyle),
		onMouseDown: onThumbMouseDown
	}));
});
ScrollBar.displayName = "ScrollBar";
var ScrollBar_default = ScrollBar;

//#endregion
//#region node_modules/rc-virtual-list/es/utils/scrollbarUtil.js
var MIN_SIZE = 20;
function getSpinSize() {
	var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
	var scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var baseSize = containerSize / scrollRange * containerSize;
	if (isNaN(baseSize)) baseSize = 0;
	baseSize = Math.max(baseSize, MIN_SIZE);
	return Math.floor(baseSize);
}

//#endregion
//#region node_modules/rc-virtual-list/es/List.js
var import_classnames$220 = /* @__PURE__ */ __toESM(require_classnames());
var import_react_dom$5 = /* @__PURE__ */ __toESM(require_react_dom());
var _excluded$58 = [
	"prefixCls",
	"className",
	"height",
	"itemHeight",
	"fullHeight",
	"style",
	"data",
	"children",
	"itemKey",
	"virtual",
	"direction",
	"scrollWidth",
	"component",
	"onScroll",
	"onVirtualScroll",
	"onVisibleChange",
	"innerProps",
	"extraRender",
	"styles",
	"showScrollBar"
];
var EMPTY_DATA$1 = [];
var ScrollStyle = {
	overflowY: "auto",
	overflowAnchor: "none"
};
function RawList(props, ref) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style$1 = props.style, data = props.data, children = props.children, itemKey$2 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component$2 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles = props.styles, _props$showScrollBar = props.showScrollBar, showScrollBar = _props$showScrollBar === void 0 ? "optional" : _props$showScrollBar, restProps = _objectWithoutProperties(props, _excluded$58);
	var getKey$3 = import_react.useCallback(function(item) {
		if (typeof itemKey$2 === "function") return itemKey$2(item);
		return item === null || item === void 0 ? void 0 : item[itemKey$2];
	}, [itemKey$2]);
	var _useHeights = useHeights(getKey$3, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
	var useVirtual = !!(virtual !== false && height && itemHeight);
	var containerHeight = import_react.useMemo(function() {
		return Object.values(heights.maps).reduce(function(total, curr) {
			return total + curr;
		}, 0);
	}, [heights.id, heights.maps]);
	var inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
	var isRTL = direction === "rtl";
	var mergedClassName = (0, import_classnames$220.default)(prefixCls, _defineProperty({}, "".concat(prefixCls, "-rtl"), isRTL), className);
	var mergedData = data || EMPTY_DATA$1;
	var componentRef = (0, import_react.useRef)();
	var fillerInnerRef = (0, import_react.useRef)();
	var containerRef = (0, import_react.useRef)();
	var _useState = (0, import_react.useState)(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
	var _useState3 = (0, import_react.useState)(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
	var _useState5 = (0, import_react.useState)(false), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
	var onScrollbarStartMove = function onScrollbarStartMove$1() {
		setScrollMoving(true);
	};
	var onScrollbarStopMove = function onScrollbarStopMove$1() {
		setScrollMoving(false);
	};
	var sharedConfig = { getKey: getKey$3 };
	function syncScrollTop(newTop) {
		setOffsetTop(function(origin) {
			var value;
			if (typeof newTop === "function") value = newTop(origin);
			else value = newTop;
			var alignedTop = keepInRange(value);
			componentRef.current.scrollTop = alignedTop;
			return alignedTop;
		});
	}
	var rangeRef = (0, import_react.useRef)({
		start: 0,
		end: mergedData.length
	});
	var diffItemRef = (0, import_react.useRef)();
	var _useDiffItem = useDiffItem(mergedData, getKey$3);
	diffItemRef.current = _slicedToArray(_useDiffItem, 1)[0];
	var _React$useMemo = import_react.useMemo(function() {
		if (!useVirtual) return {
			scrollHeight: void 0,
			start: 0,
			end: mergedData.length - 1,
			offset: void 0
		};
		if (!inVirtual) {
			var _fillerInnerRef$curre;
			return {
				scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
				start: 0,
				end: mergedData.length - 1,
				offset: void 0
			};
		}
		var itemTop = 0;
		var startIndex;
		var startOffset;
		var endIndex;
		var dataLen = mergedData.length;
		for (var i = 0; i < dataLen; i += 1) {
			var _item = mergedData[i];
			var key = getKey$3(_item);
			var cacheHeight = heights.get(key);
			var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
			if (currentItemBottom >= offsetTop && startIndex === void 0) {
				startIndex = i;
				startOffset = itemTop;
			}
			if (currentItemBottom > offsetTop + height && endIndex === void 0) endIndex = i;
			itemTop = currentItemBottom;
		}
		if (startIndex === void 0) {
			startIndex = 0;
			startOffset = 0;
			endIndex = Math.ceil(height / itemHeight);
		}
		if (endIndex === void 0) endIndex = mergedData.length - 1;
		endIndex = Math.min(endIndex + 1, mergedData.length - 1);
		return {
			scrollHeight: itemTop,
			start: startIndex,
			end: endIndex,
			offset: startOffset
		};
	}, [
		inVirtual,
		useVirtual,
		offsetTop,
		mergedData,
		heightUpdatedMark,
		height
	]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
	rangeRef.current.start = start;
	rangeRef.current.end = end;
	import_react.useLayoutEffect(function() {
		var changedRecord = heights.getRecord();
		if (changedRecord.size === 1) {
			var recordKey = Array.from(changedRecord.keys())[0];
			var prevCacheHeight = changedRecord.get(recordKey);
			var startItem = mergedData[start];
			if (startItem && prevCacheHeight === void 0) {
				if (getKey$3(startItem) === recordKey) {
					var diffHeight = heights.get(recordKey) - itemHeight;
					syncScrollTop(function(ori) {
						return ori + diffHeight;
					});
				}
			}
		}
		heights.resetRecord();
	}, [scrollHeight]);
	var _React$useState = import_react.useState({
		width: 0,
		height
	}), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
	var onHolderResize = function onHolderResize$1(sizeInfo) {
		setSize({
			width: sizeInfo.offsetWidth,
			height: sizeInfo.offsetHeight
		});
	};
	var verticalScrollBarRef = (0, import_react.useRef)();
	var horizontalScrollBarRef = (0, import_react.useRef)();
	var horizontalScrollBarSpinSize = import_react.useMemo(function() {
		return getSpinSize(size.width, scrollWidth);
	}, [size.width, scrollWidth]);
	var verticalScrollBarSpinSize = import_react.useMemo(function() {
		return getSpinSize(size.height, scrollHeight);
	}, [size.height, scrollHeight]);
	var maxScrollHeight = scrollHeight - height;
	var maxScrollHeightRef = (0, import_react.useRef)(maxScrollHeight);
	maxScrollHeightRef.current = maxScrollHeight;
	function keepInRange(newScrollTop) {
		var newTop = newScrollTop;
		if (!Number.isNaN(maxScrollHeightRef.current)) newTop = Math.min(newTop, maxScrollHeightRef.current);
		newTop = Math.max(newTop, 0);
		return newTop;
	}
	var isScrollAtTop = offsetTop <= 0;
	var isScrollAtBottom = offsetTop >= maxScrollHeight;
	var isScrollAtLeft = offsetLeft <= 0;
	var isScrollAtRight = offsetLeft >= scrollWidth;
	var originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
	var getVirtualScrollInfo = function getVirtualScrollInfo$1() {
		return {
			x: isRTL ? -offsetLeft : offsetLeft,
			y: offsetTop
		};
	};
	var lastVirtualScrollInfoRef = (0, import_react.useRef)(getVirtualScrollInfo());
	var triggerScroll = useEvent(function(params) {
		if (onVirtualScroll) {
			var nextInfo = _objectSpread2(_objectSpread2({}, getVirtualScrollInfo()), params);
			if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
				onVirtualScroll(nextInfo);
				lastVirtualScrollInfoRef.current = nextInfo;
			}
		}
	});
	function onScrollBar(newScrollOffset, horizontal) {
		var newOffset = newScrollOffset;
		if (horizontal) {
			(0, import_react_dom$5.flushSync)(function() {
				setOffsetLeft(newOffset);
			});
			triggerScroll();
		} else syncScrollTop(newOffset);
	}
	function onFallbackScroll(e$2) {
		var newScrollTop = e$2.currentTarget.scrollTop;
		if (newScrollTop !== offsetTop) syncScrollTop(newScrollTop);
		onScroll === null || onScroll === void 0 || onScroll(e$2);
		triggerScroll();
	}
	var keepInHorizontalRange = function keepInHorizontalRange$1(nextOffsetLeft) {
		var tmpOffsetLeft = nextOffsetLeft;
		var max = !!scrollWidth ? scrollWidth - size.width : 0;
		tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
		tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
		return tmpOffsetLeft;
	};
	var onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
		if (fromHorizontal) {
			(0, import_react_dom$5.flushSync)(function() {
				setOffsetLeft(function(left) {
					var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
					return keepInHorizontalRange(nextOffsetLeft);
				});
			});
			triggerScroll();
		} else syncScrollTop(function(top) {
			return top + offsetXY;
		});
	});
	var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
	useMobileTouchMove(useVirtual, componentRef, function(isHorizontal, delta, smoothOffset, e$2) {
		var event = e$2;
		if (originScroll(isHorizontal, delta, smoothOffset)) return false;
		if (!event || !event._virtualHandled) {
			if (event) event._virtualHandled = true;
			onRawWheel({
				preventDefault: function preventDefault() {},
				deltaX: isHorizontal ? delta : 0,
				deltaY: isHorizontal ? 0 : delta
			});
			return true;
		}
		return false;
	});
	useScrollDrag(inVirtual, componentRef, function(offset$2) {
		syncScrollTop(function(top) {
			return top + offset$2;
		});
	});
	useLayoutEffect_default(function() {
		function onMozMousePixelScroll(e$2) {
			var scrollingUpAtTop = isScrollAtTop && e$2.detail < 0;
			var scrollingDownAtBottom = isScrollAtBottom && e$2.detail > 0;
			if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) e$2.preventDefault();
		}
		var componentEle = componentRef.current;
		componentEle.addEventListener("wheel", onRawWheel, { passive: false });
		componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll, { passive: true });
		componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll, { passive: false });
		return function() {
			componentEle.removeEventListener("wheel", onRawWheel);
			componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
			componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
		};
	}, [
		useVirtual,
		isScrollAtTop,
		isScrollAtBottom
	]);
	useLayoutEffect_default(function() {
		if (scrollWidth) {
			var newOffsetLeft = keepInHorizontalRange(offsetLeft);
			setOffsetLeft(newOffsetLeft);
			triggerScroll({ x: newOffsetLeft });
		}
	}, [size.width, scrollWidth]);
	var delayHideScrollBar = function delayHideScrollBar$1() {
		var _verticalScrollBarRef, _horizontalScrollBarR;
		(_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 || _verticalScrollBarRef.delayHidden();
		(_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 || _horizontalScrollBarR.delayHidden();
	};
	var _scrollTo = useScrollTo$1(componentRef, mergedData, heights, itemHeight, getKey$3, function() {
		return collectHeight(true);
	}, syncScrollTop, delayHideScrollBar);
	import_react.useImperativeHandle(ref, function() {
		return {
			nativeElement: containerRef.current,
			getScrollInfo: getVirtualScrollInfo,
			scrollTo: function scrollTo$1(config) {
				function isPosScroll(arg) {
					return arg && _typeof(arg) === "object" && ("left" in arg || "top" in arg);
				}
				if (isPosScroll(config)) {
					if (config.left !== void 0) setOffsetLeft(keepInHorizontalRange(config.left));
					_scrollTo(config.top);
				} else _scrollTo(config);
			}
		};
	});
	/** We need told outside that some list not rendered */
	useLayoutEffect_default(function() {
		if (onVisibleChange) {
			var renderList = mergedData.slice(start, end + 1);
			onVisibleChange(renderList, mergedData);
		}
	}, [
		start,
		end,
		mergedData
	]);
	var getSize$2 = useGetSize(mergedData, getKey$3, heights, itemHeight);
	var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
		start,
		end,
		virtual: inVirtual,
		offsetX: offsetLeft,
		offsetY: fillerOffset,
		rtl: isRTL,
		getSize: getSize$2
	});
	var listChildren = useChildren$1(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
	var componentStyle = null;
	if (height) {
		componentStyle = _objectSpread2(_defineProperty({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
		if (useVirtual) {
			componentStyle.overflowY = "hidden";
			if (scrollWidth) componentStyle.overflowX = "hidden";
			if (scrollMoving) componentStyle.pointerEvents = "none";
		}
	}
	var containerProps = {};
	if (isRTL) containerProps.dir = "rtl";
	return /* @__PURE__ */ import_react.createElement("div", _extends({
		ref: containerRef,
		style: _objectSpread2(_objectSpread2({}, style$1), {}, { position: "relative" }),
		className: mergedClassName
	}, containerProps, restProps), /* @__PURE__ */ import_react.createElement(es_default, { onResize: onHolderResize }, /* @__PURE__ */ import_react.createElement(Component$2, {
		className: "".concat(prefixCls, "-holder"),
		style: componentStyle,
		ref: componentRef,
		onScroll: onFallbackScroll,
		onMouseEnter: delayHideScrollBar
	}, /* @__PURE__ */ import_react.createElement(Filler_default, {
		prefixCls,
		height: scrollHeight,
		offsetX: offsetLeft,
		offsetY: fillerOffset,
		scrollWidth,
		onInnerResize: collectHeight,
		ref: fillerInnerRef,
		innerProps,
		rtl: isRTL,
		extra: extraContent
	}, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ import_react.createElement(ScrollBar_default, {
		ref: verticalScrollBarRef,
		prefixCls,
		scrollOffset: offsetTop,
		scrollRange: scrollHeight,
		rtl: isRTL,
		onScroll: onScrollBar,
		onStartMove: onScrollbarStartMove,
		onStopMove: onScrollbarStopMove,
		spinSize: verticalScrollBarSpinSize,
		containerSize: size.height,
		style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
		thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb,
		showScrollBar
	}), inVirtual && scrollWidth > size.width && /* @__PURE__ */ import_react.createElement(ScrollBar_default, {
		ref: horizontalScrollBarRef,
		prefixCls,
		scrollOffset: offsetLeft,
		scrollRange: scrollWidth,
		rtl: isRTL,
		onScroll: onScrollBar,
		onStartMove: onScrollbarStartMove,
		onStopMove: onScrollbarStopMove,
		spinSize: horizontalScrollBarSpinSize,
		containerSize: size.width,
		horizontal: true,
		style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
		thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb,
		showScrollBar
	}));
}
var List$1 = /* @__PURE__ */ import_react.forwardRef(RawList);
List$1.displayName = "List";
var List_default$2 = List$1;

//#endregion
//#region node_modules/rc-virtual-list/es/index.js
var es_default$8 = List_default$2;

//#endregion
//#region node_modules/rc-select/es/utils/platformUtil.js
/* istanbul ignore file */
function isPlatformMac() {
	return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}

//#endregion
//#region node_modules/rc-select/es/OptionList.js
var import_classnames$219 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$57 = [
	"disabled",
	"title",
	"children",
	"style",
	"className"
];
function isTitleType(content) {
	return typeof content === "string" || typeof content === "number";
}
var RefOptionList$2 = /* @__PURE__ */ import_react.forwardRef(function OptionList(_, ref) {
	var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id = _useBaseProps.id, open$2 = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
	var _React$useContext = import_react.useContext(SelectContext_default), maxCount = _React$useContext.maxCount, flattenOptions$1 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, direction = _React$useContext.direction, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight, optionRender = _React$useContext.optionRender;
	var itemPrefixCls = "".concat(prefixCls, "-item");
	var memoFlattenOptions = useMemo$1(function() {
		return flattenOptions$1;
	}, [open$2, flattenOptions$1], function(prev$1, next$1) {
		return next$1[0] && prev$1[1] !== next$1[1];
	});
	var listRef = import_react.useRef(null);
	var overMaxCount = import_react.useMemo(function() {
		return multiple && isValidCount(maxCount) && (rawValues === null || rawValues === void 0 ? void 0 : rawValues.size) >= maxCount;
	}, [
		multiple,
		maxCount,
		rawValues === null || rawValues === void 0 ? void 0 : rawValues.size
	]);
	var onListMouseDown = function onListMouseDown$1(event) {
		event.preventDefault();
	};
	var scrollIntoView = function scrollIntoView$1(args) {
		var _listRef$current;
		(_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(typeof args === "number" ? { index: args } : args);
	};
	var isSelected = import_react.useCallback(function(value) {
		if (mode === "combobox") return false;
		return rawValues.has(value);
	}, [
		mode,
		_toConsumableArray(rawValues).toString(),
		rawValues.size
	]);
	var getEnabledActiveIndex = function getEnabledActiveIndex$1(index$2) {
		var offset$2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
		var len = memoFlattenOptions.length;
		for (var i = 0; i < len; i += 1) {
			var current = (index$2 + i * offset$2 + len) % len;
			var _ref = memoFlattenOptions[current] || {}, group = _ref.group, data = _ref.data;
			if (!group && !(data !== null && data !== void 0 && data.disabled) && (isSelected(data.value) || !overMaxCount)) return current;
		}
		return -1;
	};
	var _React$useState = import_react.useState(function() {
		return getEnabledActiveIndex(0);
	}), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
	var setActive = function setActive$1(index$2) {
		var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
		setActiveIndex(index$2);
		var info = { source: fromKeyboard ? "keyboard" : "mouse" };
		var flattenItem = memoFlattenOptions[index$2];
		if (!flattenItem) {
			onActiveValue(null, -1, info);
			return;
		}
		onActiveValue(flattenItem.value, index$2, info);
	};
	(0, import_react.useEffect)(function() {
		setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
	}, [memoFlattenOptions.length, searchValue]);
	var isAriaSelected = import_react.useCallback(function(value) {
		if (mode === "combobox") return String(value).toLowerCase() === searchValue.toLowerCase();
		return rawValues.has(value);
	}, [
		mode,
		searchValue,
		_toConsumableArray(rawValues).toString(),
		rawValues.size
	]);
	(0, import_react.useEffect)(function() {
		/**
		* React will skip `onChange` when component update.
		* `setActive` function will call root accessibility state update which makes re-render.
		* So we need to delay to let Input component trigger onChange first.
		*/
		var timeoutId = setTimeout(function() {
			if (!multiple && open$2 && rawValues.size === 1) {
				var value = Array.from(rawValues)[0];
				var index$2 = memoFlattenOptions.findIndex(function(_ref2) {
					var data = _ref2.data;
					return searchValue ? String(data.value).startsWith(searchValue) : data.value === value;
				});
				if (index$2 !== -1) {
					setActive(index$2);
					scrollIntoView(index$2);
				}
			}
		});
		if (open$2) {
			var _listRef$current2;
			(_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.scrollTo(void 0);
		}
		return function() {
			return clearTimeout(timeoutId);
		};
	}, [open$2, searchValue]);
	var onSelectValue = function onSelectValue$1(value) {
		if (value !== void 0) onSelect(value, { selected: !rawValues.has(value) });
		if (!multiple) toggleOpen(false);
	};
	import_react.useImperativeHandle(ref, function() {
		return {
			onKeyDown: function onKeyDown$1(event) {
				var which = event.which, ctrlKey = event.ctrlKey;
				switch (which) {
					case KeyCode_default.N:
					case KeyCode_default.P:
					case KeyCode_default.UP:
					case KeyCode_default.DOWN:
						var offset$2 = 0;
						if (which === KeyCode_default.UP) offset$2 = -1;
						else if (which === KeyCode_default.DOWN) offset$2 = 1;
						else if (isPlatformMac() && ctrlKey) {
							if (which === KeyCode_default.N) offset$2 = 1;
							else if (which === KeyCode_default.P) offset$2 = -1;
						}
						if (offset$2 !== 0) {
							var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset$2, offset$2);
							scrollIntoView(nextActiveIndex);
							setActive(nextActiveIndex, true);
						}
						break;
					case KeyCode_default.TAB:
					case KeyCode_default.ENTER:
						var _item$data;
						var item = memoFlattenOptions[activeIndex];
						if (item && !(item !== null && item !== void 0 && (_item$data = item.data) !== null && _item$data !== void 0 && _item$data.disabled) && !overMaxCount) onSelectValue(item.value);
						else onSelectValue(void 0);
						if (open$2) event.preventDefault();
						break;
					case KeyCode_default.ESC:
						toggleOpen(false);
						if (open$2) event.stopPropagation();
				}
			},
			onKeyUp: function onKeyUp() {},
			scrollTo: function scrollTo$1(index$2) {
				scrollIntoView(index$2);
			}
		};
	});
	if (memoFlattenOptions.length === 0) return /* @__PURE__ */ import_react.createElement("div", {
		role: "listbox",
		id: "".concat(id, "_list"),
		className: "".concat(itemPrefixCls, "-empty"),
		onMouseDown: onListMouseDown
	}, notFoundContent);
	var omitFieldNameList = Object.keys(fieldNames).map(function(key) {
		return fieldNames[key];
	});
	var getLabel = function getLabel$1(item) {
		return item.label;
	};
	function getItemAriaProps(item, index$2) {
		return {
			role: item.group ? "presentation" : "option",
			id: "".concat(id, "_list_").concat(index$2)
		};
	}
	var renderItem$1 = function renderItem$2(index$2) {
		var item = memoFlattenOptions[index$2];
		if (!item) return null;
		var itemData = item.data || {};
		var value = itemData.value;
		var group = item.group;
		var attrs = pickAttrs(itemData, true);
		var mergedLabel = getLabel(item);
		return item ? /* @__PURE__ */ import_react.createElement("div", _extends({ "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null }, attrs, { key: index$2 }, getItemAriaProps(item, index$2), { "aria-selected": isAriaSelected(value) }), value) : null;
	};
	var a11yProps = {
		role: "listbox",
		id: "".concat(id, "_list")
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, virtual && /* @__PURE__ */ import_react.createElement("div", _extends({}, a11yProps, { style: {
		height: 0,
		width: 0,
		overflow: "hidden"
	} }), renderItem$1(activeIndex - 1), renderItem$1(activeIndex), renderItem$1(activeIndex + 1)), /* @__PURE__ */ import_react.createElement(es_default$8, {
		itemKey: "key",
		ref: listRef,
		data: memoFlattenOptions,
		height: listHeight,
		itemHeight: listItemHeight,
		fullHeight: false,
		onMouseDown: onListMouseDown,
		onScroll: onPopupScroll,
		virtual,
		direction,
		innerProps: virtual ? null : a11yProps
	}, function(item, itemIndex) {
		var group = item.group, groupOption = item.groupOption, data = item.data, label = item.label, value = item.value;
		var key = data.key;
		if (group) {
			var _data$title;
			var groupTitle = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : void 0;
			return /* @__PURE__ */ import_react.createElement("div", {
				className: (0, import_classnames$219.default)(itemPrefixCls, "".concat(itemPrefixCls, "-group"), data.className),
				title: groupTitle
			}, label !== void 0 ? label : key);
		}
		var disabled = data.disabled, title = data.title;
		data.children;
		var style$1 = data.style, className = data.className, otherProps = _objectWithoutProperties(data, _excluded$57);
		var passedProps = omit(otherProps, omitFieldNameList);
		var selected = isSelected(value);
		var mergedDisabled = disabled || !selected && overMaxCount;
		var optionPrefixCls = "".concat(itemPrefixCls, "-option");
		var optionClassName = (0, import_classnames$219.default)(itemPrefixCls, optionPrefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(optionPrefixCls, "-grouped"), groupOption), "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !mergedDisabled), "".concat(optionPrefixCls, "-disabled"), mergedDisabled), "".concat(optionPrefixCls, "-selected"), selected));
		var mergedLabel = getLabel(item);
		var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
		var content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
		var optionTitle = isTitleType(content) ? content.toString() : void 0;
		if (title !== void 0) optionTitle = title;
		return /* @__PURE__ */ import_react.createElement("div", _extends({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
			"aria-selected": isAriaSelected(value),
			className: optionClassName,
			title: optionTitle,
			onMouseMove: function onMouseMove() {
				if (activeIndex === itemIndex || mergedDisabled) return;
				setActive(itemIndex);
			},
			onClick: function onClick() {
				if (!mergedDisabled) onSelectValue(value);
			},
			style: style$1
		}), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(optionPrefixCls, "-content") }, typeof optionRender === "function" ? optionRender(item, { index: itemIndex }) : content), /* @__PURE__ */ import_react.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ import_react.createElement(TransBtn_default, {
			className: "".concat(itemPrefixCls, "-option-state"),
			customizeIcon: menuItemSelectedIcon,
			customizeIconProps: {
				value,
				disabled: mergedDisabled,
				isSelected: selected
			}
		}, selected ? "" : null));
	}));
});
RefOptionList$2.displayName = "OptionList";
var OptionList_default$2 = RefOptionList$2;

//#endregion
//#region node_modules/rc-select/es/hooks/useCache.js
/**
* Cache `value` related LabeledValue & options.
*/
var useCache_default$1 = (function(labeledValues, valueOptions) {
	var cacheRef = import_react.useRef({
		values: /* @__PURE__ */ new Map(),
		options: /* @__PURE__ */ new Map()
	});
	var filledLabeledValues = import_react.useMemo(function() {
		var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
		var patchedValues = labeledValues.map(function(item) {
			if (item.label === void 0) {
				var _prevValueCache$get;
				return _objectSpread2(_objectSpread2({}, item), {}, { label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label });
			}
			return item;
		});
		var valueCache = /* @__PURE__ */ new Map();
		var optionCache = /* @__PURE__ */ new Map();
		patchedValues.forEach(function(item) {
			valueCache.set(item.value, item);
			optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
		});
		cacheRef.current.values = valueCache;
		cacheRef.current.options = optionCache;
		return patchedValues;
	}, [labeledValues, valueOptions]);
	var getOption = import_react.useCallback(function(val) {
		return valueOptions.get(val) || cacheRef.current.options.get(val);
	}, [valueOptions]);
	return [filledLabeledValues, getOption];
});

//#endregion
//#region node_modules/rc-select/es/hooks/useFilterOptions.js
function includes(test, search) {
	return toArray$6(test).join("").toUpperCase().includes(search);
}
var useFilterOptions_default = (function(options, fieldNames, searchValue, filterOption$1, optionFilterProp) {
	return import_react.useMemo(function() {
		if (!searchValue || filterOption$1 === false) return options;
		var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
		var filteredOptions = [];
		var customizeFilter = typeof filterOption$1 === "function";
		var upperSearch = searchValue.toUpperCase();
		var filterFunc = customizeFilter ? filterOption$1 : function(_, option) {
			if (optionFilterProp) return includes(option[optionFilterProp], upperSearch);
			if (option[fieldOptions]) return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
			return includes(option[fieldValue], upperSearch);
		};
		var wrapOption = customizeFilter ? function(opt) {
			return injectPropsWithOption(opt);
		} : function(opt) {
			return opt;
		};
		options.forEach(function(item) {
			if (item[fieldOptions]) {
				if (filterFunc(searchValue, wrapOption(item))) filteredOptions.push(item);
				else {
					var subOptions = item[fieldOptions].filter(function(subItem) {
						return filterFunc(searchValue, wrapOption(subItem));
					});
					if (subOptions.length) filteredOptions.push(_objectSpread2(_objectSpread2({}, item), {}, _defineProperty({}, fieldOptions, subOptions)));
				}
				return;
			}
			if (filterFunc(searchValue, wrapOption(item))) filteredOptions.push(item);
		});
		return filteredOptions;
	}, [
		options,
		filterOption$1,
		optionFilterProp,
		searchValue,
		fieldNames
	]);
});

//#endregion
//#region node_modules/rc-select/es/hooks/useId.js
var uuid$2 = 0;
/** Is client side and not jsdom */
var isBrowserClient$1 = canUseDom();
/** Get unique id for accessibility usage */
function getUUID$1() {
	var retId;
	/* istanbul ignore if */
	if (isBrowserClient$1) {
		retId = uuid$2;
		uuid$2 += 1;
	} else retId = "TEST_OR_SSR";
	return retId;
}
function useId(id) {
	var _React$useState = import_react.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
	import_react.useEffect(function() {
		setInnerId("rc_select_".concat(getUUID$1()));
	}, []);
	return id || innerId;
}

//#endregion
//#region node_modules/rc-select/es/utils/legacyUtil.js
var _excluded$56 = ["children", "value"], _excluded2$11 = ["children"];
function convertNodeToOption(node$1) {
	var _ref = node$1, key = _ref.key, _ref$props = _ref.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties(_ref$props, _excluded$56);
	return _objectSpread2({
		key,
		value: value !== void 0 ? value : key,
		children
	}, restProps);
}
function convertChildrenToData$1(nodes) {
	var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	return toArray(nodes).map(function(node$1, index$2) {
		if (!/* @__PURE__ */ import_react.isValidElement(node$1) || !node$1.type) return null;
		var _ref2 = node$1, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children = _ref2$props.children, restProps = _objectWithoutProperties(_ref2$props, _excluded2$11);
		if (optionOnly || !isSelectOptGroup) return convertNodeToOption(node$1);
		return _objectSpread2(_objectSpread2({
			key: "__RC_SELECT_GRP__".concat(key === null ? index$2 : key, "__"),
			label: key
		}, restProps), {}, { options: convertChildrenToData$1(children) });
	}).filter(function(data) {
		return data;
	});
}

//#endregion
//#region node_modules/rc-select/es/hooks/useOptions.js
/**
* Parse `children` to `options` if `options` is not provided.
* Then flatten the `options`.
*/
var useOptions$1 = function useOptions$2(options, children, fieldNames, optionFilterProp, optionLabelProp) {
	return import_react.useMemo(function() {
		var mergedOptions = options;
		if (!options) mergedOptions = convertChildrenToData$1(children);
		var valueOptions = /* @__PURE__ */ new Map();
		var labelOptions = /* @__PURE__ */ new Map();
		var setLabelOptions = function setLabelOptions$1(labelOptionsMap, option, key) {
			if (key && typeof key === "string") labelOptionsMap.set(option[key], option);
		};
		(function dig(optionList) {
			var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			for (var i = 0; i < optionList.length; i += 1) {
				var option = optionList[i];
				if (!option[fieldNames.options] || isChildren) {
					valueOptions.set(option[fieldNames.value], option);
					setLabelOptions(labelOptions, option, fieldNames.label);
					setLabelOptions(labelOptions, option, optionFilterProp);
					setLabelOptions(labelOptions, option, optionLabelProp);
				} else dig(option[fieldNames.options], true);
			}
		})(mergedOptions);
		return {
			options: mergedOptions,
			valueOptions,
			labelOptions
		};
	}, [
		options,
		children,
		fieldNames,
		optionFilterProp,
		optionLabelProp
	]);
};
var useOptions_default = useOptions$1;

//#endregion
//#region node_modules/rc-select/es/hooks/useRefFunc.js
/**
* Same as `React.useCallback` but always return a memoized function
* but redirect to real function.
*/
function useRefFunc$1(callback) {
	var funcRef = import_react.useRef();
	funcRef.current = callback;
	return import_react.useCallback(function() {
		return funcRef.current.apply(funcRef, arguments);
	}, []);
}

//#endregion
//#region node_modules/rc-select/es/utils/warningPropsUtil.js
function warningProps$2(props) {
	var mode = props.mode, options = props.options, children = props.children, backfill = props.backfill, allowClear = props.allowClear, placeholder = props.placeholder, getInputElement = props.getInputElement, showSearch = props.showSearch, onSearch = props.onSearch, defaultOpen = props.defaultOpen, autoFocus = props.autoFocus, labelInValue = props.labelInValue, value = props.value, inputValue = props.inputValue, optionLabelProp = props.optionLabelProp;
	var multiple = isMultiple(mode);
	var mergedShowSearch = showSearch !== void 0 ? showSearch : multiple || mode === "combobox";
	var mergedOptions = options || convertChildrenToData$1(children);
	warning_default(mode !== "tags" || mergedOptions.every(function(opt) {
		return !opt.disabled;
	}), "Please avoid setting option to disabled in tags mode since user can always type text as tag.");
	if (mode === "tags" || mode === "combobox") {
		var hasNumberValue = mergedOptions.some(function(item) {
			if (item.options) return item.options.some(function(opt) {
				return typeof ("value" in opt ? opt.value : opt.key) === "number";
			});
			return typeof ("value" in item ? item.value : item.key) === "number";
		});
		warning_default(!hasNumberValue, "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
	}
	warning_default(mode !== "combobox" || !optionLabelProp, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly.");
	warning_default(mode === "combobox" || !backfill, "`backfill` only works with `combobox` mode.");
	warning_default(mode === "combobox" || !getInputElement, "`getInputElement` only work with `combobox` mode.");
	noteOnce(mode !== "combobox" || !getInputElement || !allowClear || !placeholder, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`.");
	if (onSearch && !mergedShowSearch && mode !== "combobox" && mode !== "tags") warning_default(false, "`onSearch` should work with `showSearch` instead of use alone.");
	noteOnce(!defaultOpen || autoFocus, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed.");
	if (value !== void 0 && value !== null) {
		var values = toArray$6(value);
		warning_default(!labelInValue || values.every(function(val) {
			return _typeof(val) === "object" && ("key" in val || "value" in val);
		}), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`");
		warning_default(!multiple || Array.isArray(value), "`value` should be array when `mode` is `multiple` or `tags`");
	}
	if (children) {
		var invalidateChildType = null;
		toArray(children).some(function(node$1) {
			if (!/* @__PURE__ */ import_react.isValidElement(node$1) || !node$1.type) return false;
			var _ref = node$1, type$2 = _ref.type;
			if (type$2.isSelectOption) return false;
			if (type$2.isSelectOptGroup) {
				if (toArray(node$1.props.children).every(function(subNode) {
					if (!/* @__PURE__ */ import_react.isValidElement(subNode) || !node$1.type || subNode.type.isSelectOption) return true;
					invalidateChildType = subNode.type;
					return false;
				})) return false;
				return true;
			}
			invalidateChildType = type$2;
			return true;
		});
		if (invalidateChildType) warning_default(false, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(invalidateChildType.displayName || invalidateChildType.name || invalidateChildType, "`."));
		warning_default(inputValue === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
	}
}
function warningNullOptions$1(options, fieldNames) {
	if (options) (function recursiveOptions(optionsList) {
		var inGroup = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
		for (var i = 0; i < optionsList.length; i++) {
			var option = optionsList[i];
			if (option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.value] === null) {
				warning_default(false, "`value` in Select options should not be `null`.");
				return true;
			}
			if (!inGroup && Array.isArray(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.options]) && recursiveOptions(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.options], true)) break;
		}
	})(options);
}
var warningPropsUtil_default$2 = warningProps$2;

//#endregion
//#region node_modules/rc-select/es/Select.js
var _excluded$55 = [
	"id",
	"mode",
	"prefixCls",
	"backfill",
	"fieldNames",
	"inputValue",
	"searchValue",
	"onSearch",
	"autoClearSearchValue",
	"onSelect",
	"onDeselect",
	"dropdownMatchSelectWidth",
	"filterOption",
	"filterSort",
	"optionFilterProp",
	"optionLabelProp",
	"options",
	"optionRender",
	"children",
	"defaultActiveFirstOption",
	"menuItemSelectedIcon",
	"virtual",
	"direction",
	"listHeight",
	"listItemHeight",
	"labelRender",
	"value",
	"defaultValue",
	"labelInValue",
	"onChange",
	"maxCount"
];
var OMIT_DOM_PROPS = ["inputValue"];
function isRawValue$1(value) {
	return !value || _typeof(value) !== "object";
}
var Select$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var id = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption$1 = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, optionRender = props.optionRender, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, direction = props.direction, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, labelRender = props.labelRender, value = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange = props.onChange, maxCount = props.maxCount, restProps = _objectWithoutProperties(props, _excluded$55);
	var mergedId = useId(id);
	var multiple = isMultiple(mode);
	var childrenAsData = !!(!options && children);
	var mergedFilterOption = import_react.useMemo(function() {
		if (filterOption$1 === void 0 && mode === "combobox") return false;
		return filterOption$1;
	}, [filterOption$1, mode]);
	var mergedFieldNames = import_react.useMemo(function() {
		return fillFieldNames$3(fieldNames, childrenAsData);
	}, [JSON.stringify(fieldNames), childrenAsData]);
	var _useMergedState = useMergedState("", {
		value: searchValue !== void 0 ? searchValue : inputValue,
		postState: function postState(search) {
			return search || "";
		}
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
	var parsedOptions = useOptions_default(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
	var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
	var convert2LabelValues = import_react.useCallback(function(draftValues) {
		return toArray$6(draftValues).map(function(val) {
			var rawValue;
			var rawLabel;
			var rawKey;
			var rawDisabled;
			var rawTitle;
			if (isRawValue$1(val)) rawValue = val;
			else {
				var _val$value;
				rawKey = val.key;
				rawLabel = val.label;
				rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
			}
			var option = valueOptions.get(rawValue);
			if (option) {
				var _option$key;
				if (rawLabel === void 0) rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
				if (rawKey === void 0) rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
				rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
				rawTitle = option === null || option === void 0 ? void 0 : option.title;
				if (!optionLabelProp) {
					var optionLabel = option === null || option === void 0 ? void 0 : option[mergedFieldNames.label];
					if (optionLabel !== void 0 && !/* @__PURE__ */ import_react.isValidElement(optionLabel) && !/* @__PURE__ */ import_react.isValidElement(rawLabel) && optionLabel !== rawLabel) warning_default(false, "`label` of `value` is not same as `label` in Select options.");
				}
			}
			return {
				label: rawLabel,
				value: rawValue,
				key: rawKey,
				disabled: rawDisabled,
				title: rawTitle
			};
		});
	}, [
		mergedFieldNames,
		optionLabelProp,
		valueOptions
	]);
	var _useMergedState3 = useMergedState(defaultValue, { value }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
	var rawLabeledValues = import_react.useMemo(function() {
		var _values$;
		var values = convert2LabelValues(multiple && internalValue === null ? [] : internalValue);
		if (mode === "combobox" && isComboNoValue((_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.value)) return [];
		return values;
	}, [
		internalValue,
		convert2LabelValues,
		mode,
		multiple
	]);
	var _useCache = useCache_default$1(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
	var displayValues = import_react.useMemo(function() {
		if (!mode && mergedValues.length === 1) {
			var firstValue = mergedValues[0];
			if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) return [];
		}
		return mergedValues.map(function(item) {
			var _ref;
			return _objectSpread2(_objectSpread2({}, item), {}, { label: (_ref = typeof labelRender === "function" ? labelRender(item) : item.label) !== null && _ref !== void 0 ? _ref : item.value });
		});
	}, [
		mode,
		mergedValues,
		labelRender
	]);
	/** Convert `displayValues` to raw value type set */
	var rawValues = import_react.useMemo(function() {
		return new Set(mergedValues.map(function(val) {
			return val.value;
		}));
	}, [mergedValues]);
	import_react.useEffect(function() {
		if (mode === "combobox") {
			var _mergedValues$;
			var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
			setSearchValue(hasValue(strValue) ? String(strValue) : "");
		}
	}, [mergedValues]);
	var createTagOption = useRefFunc$1(function(val, label) {
		var mergedLabel = label !== null && label !== void 0 ? label : val;
		return _defineProperty(_defineProperty({}, mergedFieldNames.value, val), mergedFieldNames.label, mergedLabel);
	});
	var filledTagOptions = import_react.useMemo(function() {
		if (mode !== "tags") return mergedOptions;
		var cloneOptions = _toConsumableArray(mergedOptions);
		var existOptions = function existOptions$1(val) {
			return valueOptions.has(val);
		};
		_toConsumableArray(mergedValues).sort(function(a, b) {
			return a.value < b.value ? -1 : 1;
		}).forEach(function(item) {
			var val = item.value;
			if (!existOptions(val)) cloneOptions.push(createTagOption(val, item.label));
		});
		return cloneOptions;
	}, [
		createTagOption,
		mergedOptions,
		valueOptions,
		mergedValues,
		mode
	]);
	var filteredOptions = useFilterOptions_default(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
	var filledSearchOptions = import_react.useMemo(function() {
		if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
			return item[optionFilterProp || "value"] === mergedSearchValue;
		})) return filteredOptions;
		if (filteredOptions.some(function(item) {
			return item[mergedFieldNames.value] === mergedSearchValue;
		})) return filteredOptions;
		return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
	}, [
		createTagOption,
		optionFilterProp,
		mode,
		filteredOptions,
		mergedSearchValue,
		mergedFieldNames
	]);
	var sorter = function sorter$1(inputOptions) {
		return _toConsumableArray(inputOptions).sort(function(a, b) {
			return filterSort(a, b, { searchValue: mergedSearchValue });
		}).map(function(item) {
			if (Array.isArray(item.options)) return _objectSpread2(_objectSpread2({}, item), {}, { options: item.options.length > 0 ? sorter$1(item.options) : item.options });
			return item;
		});
	};
	var orderedFilteredOptions = import_react.useMemo(function() {
		if (!filterSort) return filledSearchOptions;
		return sorter(filledSearchOptions);
	}, [
		filledSearchOptions,
		filterSort,
		mergedSearchValue
	]);
	var displayOptions = import_react.useMemo(function() {
		return flattenOptions(orderedFilteredOptions, {
			fieldNames: mergedFieldNames,
			childrenAsData
		});
	}, [
		orderedFilteredOptions,
		mergedFieldNames,
		childrenAsData
	]);
	var triggerChange = function triggerChange$1(values) {
		var labeledValues = convert2LabelValues(values);
		setInternalValue(labeledValues);
		if (onChange && (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index$2) {
			var _mergedValues$index;
			return ((_mergedValues$index = mergedValues[index$2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
		}))) {
			var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v) {
				return v.value;
			});
			var returnOptions = labeledValues.map(function(v) {
				return injectPropsWithOption(getMixedOption(v.value));
			});
			onChange(multiple ? returnValues : returnValues[0], multiple ? returnOptions : returnOptions[0]);
		}
	};
	var _React$useState = import_react.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
	var _React$useState3 = import_react.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
	var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
	var onActiveValue = import_react.useCallback(function(active, index$2) {
		var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref3$source = _ref3.source, source = _ref3$source === void 0 ? "keyboard" : _ref3$source;
		setAccessibilityIndex(index$2);
		if (backfill && mode === "combobox" && active !== null && source === "keyboard") setActiveValue(String(active));
	}, [backfill, mode]);
	var triggerSelect = function triggerSelect$1(val, selected, type$2) {
		var getSelectEnt = function getSelectEnt$1() {
			var _option$key2;
			var option = getMixedOption(val);
			return [labelInValue ? {
				label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
				value: val,
				key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
			} : val, injectPropsWithOption(option)];
		};
		if (selected && onSelect) {
			var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], _option = _getSelectEnt2[1];
			onSelect(wrappedValue, _option);
		} else if (!selected && onDeselect && type$2 !== "clear") {
			var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option2 = _getSelectEnt4[1];
			onDeselect(_wrappedValue, _option2);
		}
	};
	var onInternalSelect = useRefFunc$1(function(val, info) {
		var cloneValues;
		var mergedSelect = multiple ? info.selected : true;
		if (mergedSelect) cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
		else cloneValues = mergedValues.filter(function(v) {
			return v.value !== val;
		});
		triggerChange(cloneValues);
		triggerSelect(val, mergedSelect);
		if (mode === "combobox") setActiveValue("");
		else if (!isMultiple || autoClearSearchValue) {
			setSearchValue("");
			setActiveValue("");
		}
	});
	var onDisplayValuesChange = function onDisplayValuesChange$1(nextValues, info) {
		triggerChange(nextValues);
		var type$2 = info.type, values = info.values;
		if (type$2 === "remove" || type$2 === "clear") values.forEach(function(item) {
			triggerSelect(item.value, false, type$2);
		});
	};
	var onInternalSearch = function onInternalSearch$1(searchText, info) {
		setSearchValue(searchText);
		setActiveValue(null);
		if (info.source === "submit") {
			var formatted = (searchText || "").trim();
			if (formatted) {
				var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
				triggerChange(newRawValues);
				triggerSelect(formatted, true);
				setSearchValue("");
			}
			return;
		}
		if (info.source !== "blur") {
			if (mode === "combobox") triggerChange(searchText);
			onSearch === null || onSearch === void 0 || onSearch(searchText);
		}
	};
	var onInternalSearchSplit = function onInternalSearchSplit$1(words) {
		var patchValues = words;
		if (mode !== "tags") patchValues = words.map(function(word) {
			var opt = labelOptions.get(word);
			return opt === null || opt === void 0 ? void 0 : opt.value;
		}).filter(function(val) {
			return val !== void 0;
		});
		var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
		triggerChange(newRawValues);
		newRawValues.forEach(function(newRawValue) {
			triggerSelect(newRawValue, true);
		});
	};
	var selectContext = import_react.useMemo(function() {
		var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
		return _objectSpread2(_objectSpread2({}, parsedOptions), {}, {
			flattenOptions: displayOptions,
			onActiveValue,
			defaultActiveFirstOption: mergedDefaultActiveFirstOption,
			onSelect: onInternalSelect,
			menuItemSelectedIcon,
			rawValues,
			fieldNames: mergedFieldNames,
			virtual: realVirtual,
			direction,
			listHeight,
			listItemHeight,
			childrenAsData,
			maxCount,
			optionRender
		});
	}, [
		maxCount,
		parsedOptions,
		displayOptions,
		onActiveValue,
		mergedDefaultActiveFirstOption,
		onInternalSelect,
		menuItemSelectedIcon,
		rawValues,
		mergedFieldNames,
		virtual,
		dropdownMatchSelectWidth,
		direction,
		listHeight,
		listItemHeight,
		childrenAsData,
		optionRender
	]);
	warningPropsUtil_default$2(props);
	warningNullOptions$1(mergedOptions, mergedFieldNames);
	return /* @__PURE__ */ import_react.createElement(SelectContext_default.Provider, { value: selectContext }, /* @__PURE__ */ import_react.createElement(BaseSelect_default, _extends({}, restProps, {
		id: mergedId,
		prefixCls,
		ref,
		omitDomProps: OMIT_DOM_PROPS,
		mode,
		displayValues,
		onDisplayValuesChange,
		direction,
		searchValue: mergedSearchValue,
		onSearch: onInternalSearch,
		autoClearSearchValue,
		onSearchSplit: onInternalSearchSplit,
		dropdownMatchSelectWidth,
		OptionList: OptionList_default$2,
		emptyOptions: !displayOptions.length,
		activeValue,
		activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
	})));
});
Select$1.displayName = "Select";
var TypedSelect = Select$1;
TypedSelect.Option = Option_default$1;
TypedSelect.OptGroup = OptGroup_default;
var Select_default = TypedSelect;

//#endregion
//#region node_modules/rc-select/es/index.js
var es_default$33 = Select_default;

//#endregion
//#region node_modules/antd/es/_util/statusUtils.js
var import_classnames$218 = /* @__PURE__ */ __toESM(require_classnames());
function getStatusClassNames(prefixCls, status, hasFeedback) {
	return (0, import_classnames$218.default)({
		[`${prefixCls}-status-success`]: status === "success",
		[`${prefixCls}-status-warning`]: status === "warning",
		[`${prefixCls}-status-error`]: status === "error",
		[`${prefixCls}-status-validating`]: status === "validating",
		[`${prefixCls}-has-feedback`]: hasFeedback
	});
}
const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;

//#endregion
//#region node_modules/antd/es/empty/empty.js
var Empty$1 = () => {
	const [, token$1] = useToken();
	const [locale$5] = useLocale_default("Empty");
	const themeStyle = new FastColor(token$1.colorBgBase).toHsl().l < .5 ? { opacity: .65 } : {};
	return /* @__PURE__ */ import_react.createElement("svg", {
		style: themeStyle,
		width: "184",
		height: "152",
		viewBox: "0 0 184 152",
		xmlns: "http://www.w3.org/2000/svg"
	}, /* @__PURE__ */ import_react.createElement("title", null, (locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.description) || "Empty"), /* @__PURE__ */ import_react.createElement("g", {
		fill: "none",
		fillRule: "evenodd"
	}, /* @__PURE__ */ import_react.createElement("g", { transform: "translate(24 31.67)" }, /* @__PURE__ */ import_react.createElement("ellipse", {
		fillOpacity: ".8",
		fill: "#F5F5F7",
		cx: "67.797",
		cy: "106.89",
		rx: "67.797",
		ry: "12.668"
	}), /* @__PURE__ */ import_react.createElement("path", {
		d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
		fill: "#AEB8C2"
	}), /* @__PURE__ */ import_react.createElement("path", {
		d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
		fill: "url(#linearGradient-1)",
		transform: "translate(13.56)"
	}), /* @__PURE__ */ import_react.createElement("path", {
		d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
		fill: "#F5F5F7"
	}), /* @__PURE__ */ import_react.createElement("path", {
		d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
		fill: "#DCE0E6"
	})), /* @__PURE__ */ import_react.createElement("path", {
		d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
		fill: "#DCE0E6"
	}), /* @__PURE__ */ import_react.createElement("g", {
		transform: "translate(149.65 15.383)",
		fill: "#FFF"
	}, /* @__PURE__ */ import_react.createElement("ellipse", {
		cx: "20.654",
		cy: "3.167",
		rx: "2.849",
		ry: "2.815"
	}), /* @__PURE__ */ import_react.createElement("path", { d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z" }))));
};
Empty$1.displayName = "EmptyImage";
var empty_default$2 = Empty$1;

//#endregion
//#region node_modules/antd/es/empty/simple.js
var Simple = () => {
	const [, token$1] = useToken();
	const [locale$5] = useLocale_default("Empty");
	const { colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer } = token$1;
	const { borderColor, shadowColor, contentColor } = (0, import_react.useMemo)(() => ({
		borderColor: new FastColor(colorFill).onBackground(colorBgContainer).toHexString(),
		shadowColor: new FastColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
		contentColor: new FastColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
	}), [
		colorFill,
		colorFillTertiary,
		colorFillQuaternary,
		colorBgContainer
	]);
	return /* @__PURE__ */ import_react.createElement("svg", {
		width: "64",
		height: "41",
		viewBox: "0 0 64 41",
		xmlns: "http://www.w3.org/2000/svg"
	}, /* @__PURE__ */ import_react.createElement("title", null, (locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.description) || "Empty"), /* @__PURE__ */ import_react.createElement("g", {
		transform: "translate(0 1)",
		fill: "none",
		fillRule: "evenodd"
	}, /* @__PURE__ */ import_react.createElement("ellipse", {
		fill: shadowColor,
		cx: "32",
		cy: "33",
		rx: "32",
		ry: "7"
	}), /* @__PURE__ */ import_react.createElement("g", {
		fillRule: "nonzero",
		stroke: borderColor
	}, /* @__PURE__ */ import_react.createElement("path", { d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z" }), /* @__PURE__ */ import_react.createElement("path", {
		d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
		fill: contentColor
	}))));
};
Simple.displayName = "SimpleImage";
var simple_default = Simple;

//#endregion
//#region node_modules/antd/es/empty/style/index.js
var genSharedEmptyStyle = (token$1) => {
	const { componentCls, margin, marginXS, marginXL, fontSize, lineHeight } = token$1;
	return { [componentCls]: {
		marginInline: marginXS,
		fontSize,
		lineHeight,
		textAlign: "center",
		[`${componentCls}-image`]: {
			height: token$1.emptyImgHeight,
			marginBottom: marginXS,
			opacity: token$1.opacityImage,
			img: { height: "100%" },
			svg: {
				maxWidth: "100%",
				height: "100%",
				margin: "auto"
			}
		},
		[`${componentCls}-description`]: { color: token$1.colorTextDescription },
		[`${componentCls}-footer`]: { marginTop: margin },
		"&-normal": {
			marginBlock: marginXL,
			color: token$1.colorTextDescription,
			[`${componentCls}-description`]: { color: token$1.colorTextDescription },
			[`${componentCls}-image`]: { height: token$1.emptyImgHeightMD }
		},
		"&-small": {
			marginBlock: marginXS,
			color: token$1.colorTextDescription,
			[`${componentCls}-image`]: { height: token$1.emptyImgHeightSM }
		}
	} };
};
var style_default$53 = genStyleHooks("Empty", (token$1) => {
	const { componentCls, controlHeightLG, calc } = token$1;
	const emptyToken = merge(token$1, {
		emptyImgCls: `${componentCls}-img`,
		emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
		emptyImgHeightMD: controlHeightLG,
		emptyImgHeightSM: calc(controlHeightLG).mul(.875).equal()
	});
	return genSharedEmptyStyle(emptyToken);
});

//#endregion
//#region node_modules/antd/es/empty/index.js
var import_classnames$217 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$99 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var defaultEmptyImg = /* @__PURE__ */ import_react.createElement(empty_default$2, null);
var simpleEmptyImg = /* @__PURE__ */ import_react.createElement(simple_default, null);
var Empty = (props) => {
	var _a;
	const { className, rootClassName, prefixCls: customizePrefixCls, image, description, children, imageStyle, style: style$1, classNames: emptyClassNames, styles } = props, restProps = __rest$99(props, [
		"className",
		"rootClassName",
		"prefixCls",
		"image",
		"description",
		"children",
		"imageStyle",
		"style",
		"classNames",
		"styles"
	]);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, image: contextImage } = useComponentConfig("empty");
	const prefixCls = getPrefixCls("empty", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$53(prefixCls);
	const [locale$5] = useLocale_default("Empty");
	const des = typeof description !== "undefined" ? description : locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.description;
	const alt = typeof des === "string" ? des : "empty";
	const mergedImage = (_a = image !== null && image !== void 0 ? image : contextImage) !== null && _a !== void 0 ? _a : defaultEmptyImg;
	let imageNode = null;
	if (typeof mergedImage === "string") imageNode = /* @__PURE__ */ import_react.createElement("img", {
		draggable: false,
		alt,
		src: mergedImage
	});
	else imageNode = mergedImage;
	{
		const warning$4 = devUseWarning("Empty");
		[["imageStyle", "styles: { image: {} }"]].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({
		className: (0, import_classnames$217.default)(hashId, cssVarCls, prefixCls, contextClassName, {
			[`${prefixCls}-normal`]: mergedImage === simpleEmptyImg,
			[`${prefixCls}-rtl`]: direction === "rtl"
		}, className, rootClassName, contextClassNames.root, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.root),
		style: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), contextStyle), styles === null || styles === void 0 ? void 0 : styles.root), style$1)
	}, restProps), /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$217.default)(`${prefixCls}-image`, contextClassNames.image, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.image),
		style: Object.assign(Object.assign(Object.assign({}, imageStyle), contextStyles.image), styles === null || styles === void 0 ? void 0 : styles.image)
	}, imageNode), des && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$217.default)(`${prefixCls}-description`, contextClassNames.description, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.description),
		style: Object.assign(Object.assign({}, contextStyles.description), styles === null || styles === void 0 ? void 0 : styles.description)
	}, des), children && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$217.default)(`${prefixCls}-footer`, contextClassNames.footer, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.footer),
		style: Object.assign(Object.assign({}, contextStyles.footer), styles === null || styles === void 0 ? void 0 : styles.footer)
	}, children)));
};
Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
Empty.displayName = "Empty";
var empty_default = Empty;

//#endregion
//#region node_modules/antd/es/config-provider/defaultRenderEmpty.js
var DefaultRenderEmpty = (props) => {
	const { componentName } = props;
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefix = getPrefixCls("empty");
	switch (componentName) {
		case "Table":
		case "List": return /* @__PURE__ */ import_react.createElement(empty_default, { image: empty_default.PRESENTED_IMAGE_SIMPLE });
		case "Select":
		case "TreeSelect":
		case "Cascader":
		case "Transfer":
		case "Mentions": return /* @__PURE__ */ import_react.createElement(empty_default, {
			image: empty_default.PRESENTED_IMAGE_SIMPLE,
			className: `${prefix}-small`
		});
		case "Table.filter": return null;
		default: return /* @__PURE__ */ import_react.createElement(empty_default, null);
	}
};
var defaultRenderEmpty_default = DefaultRenderEmpty;

//#endregion
//#region node_modules/antd/es/form/hooks/useVariants.js
/**
* Compatible for legacy `bordered` prop.
*/
var useVariant = (component, variant, legacyBordered = void 0) => {
	var _a, _b;
	const { variant: configVariant, [component]: componentConfig } = import_react.useContext(ConfigContext);
	const ctxVariant = import_react.useContext(VariantContext);
	const configComponentVariant = componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.variant;
	let mergedVariant;
	if (typeof variant !== "undefined") mergedVariant = variant;
	else if (legacyBordered === false) mergedVariant = "borderless";
	else mergedVariant = (_b = (_a = ctxVariant !== null && ctxVariant !== void 0 ? ctxVariant : configComponentVariant) !== null && _a !== void 0 ? _a : configVariant) !== null && _b !== void 0 ? _b : "outlined";
	const enableVariantCls = Variants.includes(mergedVariant);
	return [mergedVariant, enableVariantCls];
};
var useVariants_default = useVariant;

//#endregion
//#region node_modules/antd/es/select/mergedBuiltinPlacements.js
var getBuiltInPlacements = (popupOverflow) => {
	const sharedConfig = {
		overflow: {
			adjustX: true,
			adjustY: true,
			shiftY: true
		},
		htmlRegion: popupOverflow === "scroll" ? "scroll" : "visible",
		dynamicInset: true
	};
	return {
		bottomLeft: Object.assign(Object.assign({}, sharedConfig), {
			points: ["tl", "bl"],
			offset: [0, 4]
		}),
		bottomRight: Object.assign(Object.assign({}, sharedConfig), {
			points: ["tr", "br"],
			offset: [0, 4]
		}),
		topLeft: Object.assign(Object.assign({}, sharedConfig), {
			points: ["bl", "tl"],
			offset: [0, -4]
		}),
		topRight: Object.assign(Object.assign({}, sharedConfig), {
			points: ["br", "tr"],
			offset: [0, -4]
		})
	};
};
function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
	return buildInPlacements || getBuiltInPlacements(popupOverflow);
}
var mergedBuiltinPlacements_default = mergedBuiltinPlacements;

//#endregion
//#region node_modules/antd/es/select/style/dropdown.js
var genItemStyle = (token$1) => {
	const { optionHeight, optionFontSize, optionLineHeight, optionPadding } = token$1;
	return {
		position: "relative",
		display: "block",
		minHeight: optionHeight,
		padding: optionPadding,
		color: token$1.colorText,
		fontWeight: "normal",
		fontSize: optionFontSize,
		lineHeight: optionLineHeight,
		boxSizing: "border-box"
	};
};
var genSingleStyle$1 = (token$1) => {
	const { antCls, componentCls } = token$1;
	const selectItemCls = `${componentCls}-item`;
	const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
	const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
	const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
	const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
	const selectedItemCls = `${selectItemCls}-option-selected`;
	return [
		{ [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "absolute",
			top: -9999,
			zIndex: token$1.zIndexPopup,
			boxSizing: "border-box",
			padding: token$1.paddingXXS,
			overflow: "hidden",
			fontSize: token$1.fontSize,
			fontVariant: "initial",
			backgroundColor: token$1.colorBgElevated,
			borderRadius: token$1.borderRadiusLG,
			outline: "none",
			boxShadow: token$1.boxShadowSecondary,
			[`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: { animationName: slideUpIn },
			[`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: { animationName: slideDownIn },
			[`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: { animationName: slideUpOut },
			[`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: { animationName: slideDownOut },
			"&-hidden": { display: "none" },
			[selectItemCls]: Object.assign(Object.assign({}, genItemStyle(token$1)), {
				cursor: "pointer",
				transition: `background ${token$1.motionDurationSlow} ease`,
				borderRadius: token$1.borderRadiusSM,
				"&-group": {
					color: token$1.colorTextDescription,
					fontSize: token$1.fontSizeSM,
					cursor: "default"
				},
				"&-option": {
					display: "flex",
					"&-content": Object.assign({ flex: "auto" }, textEllipsis),
					"&-state": {
						flex: "none",
						display: "flex",
						alignItems: "center"
					},
					[`&-active:not(${selectItemCls}-option-disabled)`]: { backgroundColor: token$1.optionActiveBg },
					[`&-selected:not(${selectItemCls}-option-disabled)`]: {
						color: token$1.optionSelectedColor,
						fontWeight: token$1.optionSelectedFontWeight,
						backgroundColor: token$1.optionSelectedBg,
						[`${selectItemCls}-option-state`]: { color: token$1.colorPrimary }
					},
					"&-disabled": {
						[`&${selectItemCls}-option-selected`]: { backgroundColor: token$1.colorBgContainerDisabled },
						color: token$1.colorTextDisabled,
						cursor: "not-allowed"
					},
					"&-grouped": { paddingInlineStart: token$1.calc(token$1.controlPaddingHorizontal).mul(2).equal() }
				},
				"&-empty": Object.assign(Object.assign({}, genItemStyle(token$1)), { color: token$1.colorTextDisabled })
			}),
			[`${selectedItemCls}:has(+ ${selectedItemCls})`]: {
				borderEndStartRadius: 0,
				borderEndEndRadius: 0,
				[`& + ${selectedItemCls}`]: {
					borderStartStartRadius: 0,
					borderStartEndRadius: 0
				}
			},
			"&-rtl": { direction: "rtl" }
		}) },
		initSlideMotion(token$1, "slide-up"),
		initSlideMotion(token$1, "slide-down"),
		initMoveMotion(token$1, "move-up"),
		initMoveMotion(token$1, "move-down")
	];
};
var dropdown_default$2 = genSingleStyle$1;

//#endregion
//#region node_modules/antd/es/select/style/multiple.js
/**
* Get multiple selector needed style. The calculation:
*
* ContainerPadding = BasePadding - ItemMargin
*
* Border:                                     
* ContainerPadding:                                                      
*                                            
* Item Margin:                                                          
*                                                           
* Item(multipleItemHeight):   BasePadding    Item       Overflow  Container(ControlHeight)
*                                                           
* Item Margin:                                                          
*                                            
* ContainerPadding:                                                      
* Border:                                     
*/
const getMultipleSelectorUnit = (token$1) => {
	const { multipleSelectItemHeight, paddingXXS, lineWidth, INTERNAL_FIXED_ITEM_MARGIN } = token$1;
	const basePadding = token$1.max(token$1.calc(paddingXXS).sub(lineWidth).equal(), 0);
	const containerPadding = token$1.max(token$1.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(), 0);
	return {
		basePadding,
		containerPadding,
		itemHeight: unit(multipleSelectItemHeight),
		itemLineHeight: unit(token$1.calc(multipleSelectItemHeight).sub(token$1.calc(token$1.lineWidth).mul(2)).equal())
	};
};
var getSelectItemStyle = (token$1) => {
	const { multipleSelectItemHeight, selectHeight, lineWidth } = token$1;
	return token$1.calc(selectHeight).sub(multipleSelectItemHeight).div(2).sub(lineWidth).equal();
};
/**
* Get the `rc-overflow` needed style.
* It's a share style which means not affected by `size`.
*/
const genOverflowStyle = (token$1) => {
	const { componentCls, iconCls, borderRadiusSM, motionDurationSlow, paddingXS, multipleItemColorDisabled, multipleItemBorderColorDisabled, colorIcon, colorIconHover, INTERNAL_FIXED_ITEM_MARGIN } = token$1;
	return { [`${componentCls}-selection-overflow`]: {
		position: "relative",
		display: "flex",
		flex: "auto",
		flexWrap: "wrap",
		maxWidth: "100%",
		"&-item": {
			flex: "none",
			alignSelf: "center",
			maxWidth: "calc(100% - 4px)",
			display: "inline-flex"
		},
		[`${componentCls}-selection-item`]: {
			display: "flex",
			alignSelf: "center",
			flex: "none",
			boxSizing: "border-box",
			maxWidth: "100%",
			marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
			borderRadius: borderRadiusSM,
			cursor: "default",
			transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
			marginInlineEnd: token$1.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
			paddingInlineStart: paddingXS,
			paddingInlineEnd: token$1.calc(paddingXS).div(2).equal(),
			[`${componentCls}-disabled&`]: {
				color: multipleItemColorDisabled,
				borderColor: multipleItemBorderColorDisabled,
				cursor: "not-allowed"
			},
			"&-content": {
				display: "inline-block",
				marginInlineEnd: token$1.calc(paddingXS).div(2).equal(),
				overflow: "hidden",
				whiteSpace: "pre",
				textOverflow: "ellipsis"
			},
			"&-remove": Object.assign(Object.assign({}, resetIcon()), {
				display: "inline-flex",
				alignItems: "center",
				color: colorIcon,
				fontWeight: "bold",
				fontSize: 10,
				lineHeight: "inherit",
				cursor: "pointer",
				[`> ${iconCls}`]: { verticalAlign: "-0.2em" },
				"&:hover": { color: colorIconHover }
			})
		}
	} };
};
var genSelectionStyle$1 = (token$1, suffix) => {
	const { componentCls, INTERNAL_FIXED_ITEM_MARGIN } = token$1;
	const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
	const selectItemHeight = token$1.multipleSelectItemHeight;
	const selectItemDist = getSelectItemStyle(token$1);
	const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
	const multipleSelectorUnit = getMultipleSelectorUnit(token$1);
	return { [`${componentCls}-multiple${suffixCls}`]: Object.assign(Object.assign({}, genOverflowStyle(token$1)), {
		[`${componentCls}-selector`]: {
			display: "flex",
			alignItems: "center",
			width: "100%",
			height: "100%",
			paddingInline: multipleSelectorUnit.basePadding,
			paddingBlock: multipleSelectorUnit.containerPadding,
			borderRadius: token$1.borderRadius,
			[`${componentCls}-disabled&`]: {
				background: token$1.multipleSelectorBgDisabled,
				cursor: "not-allowed"
			},
			"&:after": {
				display: "inline-block",
				width: 0,
				margin: `${unit(INTERNAL_FIXED_ITEM_MARGIN)} 0`,
				lineHeight: unit(selectItemHeight),
				visibility: "hidden",
				content: "\"\\a0\""
			}
		},
		[`${componentCls}-selection-item`]: {
			height: multipleSelectorUnit.itemHeight,
			lineHeight: unit(multipleSelectorUnit.itemLineHeight)
		},
		[`${componentCls}-selection-wrap`]: {
			alignSelf: "flex-start",
			"&:after": {
				lineHeight: unit(selectItemHeight),
				marginBlock: INTERNAL_FIXED_ITEM_MARGIN
			}
		},
		[`${componentCls}-prefix`]: { marginInlineStart: token$1.calc(token$1.inputPaddingHorizontalBase).sub(multipleSelectorUnit.basePadding).equal() },
		[`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item,
        ${componentCls}-prefix + ${componentCls}-selection-wrap
      `]: {
			[`${componentCls}-selection-search`]: { marginInlineStart: 0 },
			[`${componentCls}-selection-placeholder`]: { insetInlineStart: 0 }
		},
		[`${selectOverflowPrefixCls}-item-suffix`]: {
			minHeight: multipleSelectorUnit.itemHeight,
			marginBlock: INTERNAL_FIXED_ITEM_MARGIN
		},
		[`${componentCls}-selection-search`]: {
			display: "inline-flex",
			position: "relative",
			maxWidth: "100%",
			marginInlineStart: token$1.calc(token$1.inputPaddingHorizontalBase).sub(selectItemDist).equal(),
			[`
          &-input,
          &-mirror
        `]: {
				height: selectItemHeight,
				fontFamily: token$1.fontFamily,
				lineHeight: unit(selectItemHeight),
				transition: `all ${token$1.motionDurationSlow}`
			},
			"&-input": {
				width: "100%",
				minWidth: 4.1
			},
			"&-mirror": {
				position: "absolute",
				top: 0,
				insetInlineStart: 0,
				insetInlineEnd: "auto",
				zIndex: 999,
				whiteSpace: "pre",
				visibility: "hidden"
			}
		},
		[`${componentCls}-selection-placeholder`]: {
			position: "absolute",
			top: "50%",
			insetInlineStart: token$1.calc(token$1.inputPaddingHorizontalBase).sub(multipleSelectorUnit.basePadding).equal(),
			insetInlineEnd: token$1.inputPaddingHorizontalBase,
			transform: "translateY(-50%)",
			transition: `all ${token$1.motionDurationSlow}`
		}
	}) };
};
function genSizeStyle$4(token$1, suffix) {
	const { componentCls } = token$1;
	const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
	const rawStyle = { [`${componentCls}-multiple${suffixCls}`]: {
		fontSize: token$1.fontSize,
		[`${componentCls}-selector`]: { [`${componentCls}-show-search&`]: { cursor: "text" } },
		[`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: { paddingInlineEnd: token$1.calc(token$1.fontSizeIcon).add(token$1.controlPaddingHorizontal).equal() }
	} };
	return [genSelectionStyle$1(token$1, suffix), rawStyle];
}
var genMultipleStyle = (token$1) => {
	const { componentCls } = token$1;
	const smallToken = merge(token$1, {
		selectHeight: token$1.controlHeightSM,
		multipleSelectItemHeight: token$1.multipleItemHeightSM,
		borderRadius: token$1.borderRadiusSM,
		borderRadiusSM: token$1.borderRadiusXS
	});
	const largeToken = merge(token$1, {
		fontSize: token$1.fontSizeLG,
		selectHeight: token$1.controlHeightLG,
		multipleSelectItemHeight: token$1.multipleItemHeightLG,
		borderRadius: token$1.borderRadiusLG,
		borderRadiusSM: token$1.borderRadius
	});
	return [
		genSizeStyle$4(token$1),
		genSizeStyle$4(smallToken, "sm"),
		{ [`${componentCls}-multiple${componentCls}-sm`]: {
			[`${componentCls}-selection-placeholder`]: { insetInline: token$1.calc(token$1.controlPaddingHorizontalSM).sub(token$1.lineWidth).equal() },
			[`${componentCls}-selection-search`]: { marginInlineStart: 2 }
		} },
		genSizeStyle$4(largeToken, "lg")
	];
};
var multiple_default$1 = genMultipleStyle;

//#endregion
//#region node_modules/antd/es/select/style/single.js
function genSizeStyle$3(token$1, suffix) {
	const { componentCls, inputPaddingHorizontalBase, borderRadius } = token$1;
	const selectHeightWithoutBorder = token$1.calc(token$1.controlHeight).sub(token$1.calc(token$1.lineWidth).mul(2)).equal();
	const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
	return { [`${componentCls}-single${suffixCls}`]: {
		fontSize: token$1.fontSize,
		height: token$1.controlHeight,
		[`${componentCls}-selector`]: Object.assign(Object.assign({}, resetComponent(token$1, true)), {
			display: "flex",
			borderRadius,
			flex: "1 1 auto",
			[`${componentCls}-selection-wrap:after`]: { lineHeight: unit(selectHeightWithoutBorder) },
			[`${componentCls}-selection-search`]: {
				position: "absolute",
				inset: 0,
				width: "100%",
				"&-input": {
					width: "100%",
					WebkitAppearance: "textfield"
				}
			},
			[`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
				display: "block",
				padding: 0,
				lineHeight: unit(selectHeightWithoutBorder),
				transition: `all ${token$1.motionDurationSlow}, visibility 0s`,
				alignSelf: "center"
			},
			[`${componentCls}-selection-placeholder`]: {
				transition: "none",
				pointerEvents: "none"
			},
			[[
				"&:after",
				`${componentCls}-selection-item:empty:after`,
				`${componentCls}-selection-placeholder:empty:after`
			].join(",")]: {
				display: "inline-block",
				width: 0,
				visibility: "hidden",
				content: "\"\\a0\""
			}
		}),
		[`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-search,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: { paddingInlineEnd: token$1.showArrowPaddingInlineEnd },
		[`&${componentCls}-open ${componentCls}-selection-item`]: { color: token$1.colorTextPlaceholder },
		[`&:not(${componentCls}-customize-input)`]: { [`${componentCls}-selector`]: {
			width: "100%",
			height: "100%",
			alignItems: "center",
			padding: `0 ${unit(inputPaddingHorizontalBase)}`,
			[`${componentCls}-selection-search-input`]: {
				height: selectHeightWithoutBorder,
				fontSize: token$1.fontSize
			},
			"&:after": { lineHeight: unit(selectHeightWithoutBorder) }
		} },
		[`&${componentCls}-customize-input`]: { [`${componentCls}-selector`]: {
			"&:after": { display: "none" },
			[`${componentCls}-selection-search`]: {
				position: "static",
				width: "100%"
			},
			[`${componentCls}-selection-placeholder`]: {
				position: "absolute",
				insetInlineStart: 0,
				insetInlineEnd: 0,
				padding: `0 ${unit(inputPaddingHorizontalBase)}`,
				"&:after": { display: "none" }
			}
		} }
	} };
}
function genSingleStyle(token$1) {
	const { componentCls } = token$1;
	const inputPaddingHorizontalSM = token$1.calc(token$1.controlPaddingHorizontalSM).sub(token$1.lineWidth).equal();
	return [
		genSizeStyle$3(token$1),
		genSizeStyle$3(merge(token$1, {
			controlHeight: token$1.controlHeightSM,
			borderRadius: token$1.borderRadiusSM
		}), "sm"),
		{ [`${componentCls}-single${componentCls}-sm`]: { [`&:not(${componentCls}-customize-input)`]: {
			[`${componentCls}-selector`]: { padding: `0 ${unit(inputPaddingHorizontalSM)}` },
			[`&${componentCls}-show-arrow ${componentCls}-selection-search`]: { insetInlineEnd: token$1.calc(inputPaddingHorizontalSM).add(token$1.calc(token$1.fontSize).mul(1.5)).equal() },
			[`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: { paddingInlineEnd: token$1.calc(token$1.fontSize).mul(1.5).equal() }
		} } },
		genSizeStyle$3(merge(token$1, {
			controlHeight: token$1.singleItemHeightLG,
			fontSize: token$1.fontSizeLG,
			borderRadius: token$1.borderRadiusLG
		}), "lg")
	];
}

//#endregion
//#region node_modules/antd/es/select/style/token.js
const prepareComponentToken$47 = (token$1) => {
	const { fontSize, lineHeight, lineWidth, controlHeight, controlHeightSM, controlHeightLG, paddingXXS, controlPaddingHorizontal, zIndexPopupBase, colorText, fontWeightStrong, controlItemBgActive, controlItemBgHover, colorBgContainer, colorFillSecondary, colorBgContainerDisabled, colorTextDisabled, colorPrimaryHover, colorPrimary, controlOutline } = token$1;
	const dblPaddingXXS = paddingXXS * 2;
	const dblLineWidth = lineWidth * 2;
	const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
	const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
	const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
	return {
		INTERNAL_FIXED_ITEM_MARGIN: Math.floor(paddingXXS / 2),
		zIndexPopup: zIndexPopupBase + 50,
		optionSelectedColor: colorText,
		optionSelectedFontWeight: fontWeightStrong,
		optionSelectedBg: controlItemBgActive,
		optionActiveBg: controlItemBgHover,
		optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
		optionFontSize: fontSize,
		optionLineHeight: lineHeight,
		optionHeight: controlHeight,
		selectorBg: colorBgContainer,
		clearBg: colorBgContainer,
		singleItemHeightLG: controlHeightLG,
		multipleItemBg: colorFillSecondary,
		multipleItemBorderColor: "transparent",
		multipleItemHeight,
		multipleItemHeightSM,
		multipleItemHeightLG,
		multipleSelectorBgDisabled: colorBgContainerDisabled,
		multipleItemColorDisabled: colorTextDisabled,
		multipleItemBorderColorDisabled: "transparent",
		showArrowPaddingInlineEnd: Math.ceil(token$1.fontSize * 1.25),
		hoverBorderColor: colorPrimaryHover,
		activeBorderColor: colorPrimary,
		activeOutlineColor: controlOutline,
		selectAffixPadding: paddingXXS
	};
};

//#endregion
//#region node_modules/antd/es/select/style/variants.js
var genBaseOutlinedStyle$1 = (token$1, options) => {
	const { componentCls, antCls, controlOutlineWidth } = token$1;
	return {
		[`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${options.borderColor}`,
			background: token$1.selectorBg
		},
		[`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
			[`&:hover ${componentCls}-selector`]: { borderColor: options.hoverBorderHover },
			[`${componentCls}-focused& ${componentCls}-selector`]: {
				borderColor: options.activeBorderColor,
				boxShadow: `0 0 0 ${unit(controlOutlineWidth)} ${options.activeOutlineColor}`,
				outline: 0
			},
			[`${componentCls}-prefix`]: { color: options.color }
		}
	};
};
var genOutlinedStatusStyle$1 = (token$1, options) => ({ [`&${token$1.componentCls}-status-${options.status}`]: Object.assign({}, genBaseOutlinedStyle$1(token$1, options)) });
var genOutlinedStyle$1 = (token$1) => ({ "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle$1(token$1, {
	borderColor: token$1.colorBorder,
	hoverBorderHover: token$1.hoverBorderColor,
	activeBorderColor: token$1.activeBorderColor,
	activeOutlineColor: token$1.activeOutlineColor,
	color: token$1.colorText
})), genOutlinedStatusStyle$1(token$1, {
	status: "error",
	borderColor: token$1.colorError,
	hoverBorderHover: token$1.colorErrorHover,
	activeBorderColor: token$1.colorError,
	activeOutlineColor: token$1.colorErrorOutline,
	color: token$1.colorError
})), genOutlinedStatusStyle$1(token$1, {
	status: "warning",
	borderColor: token$1.colorWarning,
	hoverBorderHover: token$1.colorWarningHover,
	activeBorderColor: token$1.colorWarning,
	activeOutlineColor: token$1.colorWarningOutline,
	color: token$1.colorWarning
})), {
	[`&${token$1.componentCls}-disabled`]: { [`&:not(${token$1.componentCls}-customize-input) ${token$1.componentCls}-selector`]: {
		background: token$1.colorBgContainerDisabled,
		color: token$1.colorTextDisabled
	} },
	[`&${token$1.componentCls}-multiple ${token$1.componentCls}-selection-item`]: {
		background: token$1.multipleItemBg,
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
	}
}) });
var genBaseFilledStyle$1 = (token$1, options) => {
	const { componentCls, antCls } = token$1;
	return {
		[`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
			background: options.bg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
			color: options.color
		},
		[`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
			[`&:hover ${componentCls}-selector`]: { background: options.hoverBg },
			[`${componentCls}-focused& ${componentCls}-selector`]: {
				background: token$1.selectorBg,
				borderColor: options.activeBorderColor,
				outline: 0
			}
		}
	};
};
var genFilledStatusStyle$1 = (token$1, options) => ({ [`&${token$1.componentCls}-status-${options.status}`]: Object.assign({}, genBaseFilledStyle$1(token$1, options)) });
var genFilledStyle$1 = (token$1) => ({ "&-filled": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle$1(token$1, {
	bg: token$1.colorFillTertiary,
	hoverBg: token$1.colorFillSecondary,
	activeBorderColor: token$1.activeBorderColor,
	color: token$1.colorText
})), genFilledStatusStyle$1(token$1, {
	status: "error",
	bg: token$1.colorErrorBg,
	hoverBg: token$1.colorErrorBgHover,
	activeBorderColor: token$1.colorError,
	color: token$1.colorError
})), genFilledStatusStyle$1(token$1, {
	status: "warning",
	bg: token$1.colorWarningBg,
	hoverBg: token$1.colorWarningBgHover,
	activeBorderColor: token$1.colorWarning,
	color: token$1.colorWarning
})), {
	[`&${token$1.componentCls}-disabled`]: { [`&:not(${token$1.componentCls}-customize-input) ${token$1.componentCls}-selector`]: {
		borderColor: token$1.colorBorder,
		background: token$1.colorBgContainerDisabled,
		color: token$1.colorTextDisabled
	} },
	[`&${token$1.componentCls}-multiple ${token$1.componentCls}-selection-item`]: {
		background: token$1.colorBgContainer,
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`
	}
}) });
var genBorderlessStyle$1 = (token$1) => ({ "&-borderless": {
	[`${token$1.componentCls}-selector`]: {
		background: "transparent",
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`
	},
	[`&${token$1.componentCls}-disabled`]: { [`&:not(${token$1.componentCls}-customize-input) ${token$1.componentCls}-selector`]: { color: token$1.colorTextDisabled } },
	[`&${token$1.componentCls}-multiple ${token$1.componentCls}-selection-item`]: {
		background: token$1.multipleItemBg,
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
	},
	[`&${token$1.componentCls}-status-error`]: { [`${token$1.componentCls}-prefix, ${token$1.componentCls}-selection-item`]: { color: token$1.colorError } },
	[`&${token$1.componentCls}-status-warning`]: { [`${token$1.componentCls}-prefix, ${token$1.componentCls}-selection-item`]: { color: token$1.colorWarning } }
} });
var genBaseUnderlinedStyle$1 = (token$1, options) => {
	const { componentCls, antCls } = token$1;
	return {
		[`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
			borderWidth: `0 0 ${unit(token$1.lineWidth)} 0`,
			borderStyle: `none none ${token$1.lineType} none`,
			borderColor: options.borderColor,
			background: token$1.selectorBg,
			borderRadius: 0
		},
		[`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
			[`&:hover ${componentCls}-selector`]: { borderColor: options.hoverBorderHover },
			[`${componentCls}-focused& ${componentCls}-selector`]: {
				borderColor: options.activeBorderColor,
				outline: 0
			},
			[`${componentCls}-prefix`]: { color: options.color }
		}
	};
};
var genUnderlinedStatusStyle$1 = (token$1, options) => ({ [`&${token$1.componentCls}-status-${options.status}`]: Object.assign({}, genBaseUnderlinedStyle$1(token$1, options)) });
var genUnderlinedStyle$1 = (token$1) => ({ "&-underlined": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseUnderlinedStyle$1(token$1, {
	borderColor: token$1.colorBorder,
	hoverBorderHover: token$1.hoverBorderColor,
	activeBorderColor: token$1.activeBorderColor,
	activeOutlineColor: token$1.activeOutlineColor,
	color: token$1.colorText
})), genUnderlinedStatusStyle$1(token$1, {
	status: "error",
	borderColor: token$1.colorError,
	hoverBorderHover: token$1.colorErrorHover,
	activeBorderColor: token$1.colorError,
	activeOutlineColor: token$1.colorErrorOutline,
	color: token$1.colorError
})), genUnderlinedStatusStyle$1(token$1, {
	status: "warning",
	borderColor: token$1.colorWarning,
	hoverBorderHover: token$1.colorWarningHover,
	activeBorderColor: token$1.colorWarning,
	activeOutlineColor: token$1.colorWarningOutline,
	color: token$1.colorWarning
})), {
	[`&${token$1.componentCls}-disabled`]: { [`&:not(${token$1.componentCls}-customize-input) ${token$1.componentCls}-selector`]: { color: token$1.colorTextDisabled } },
	[`&${token$1.componentCls}-multiple ${token$1.componentCls}-selection-item`]: {
		background: token$1.multipleItemBg,
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
	}
}) });
var genVariantsStyle$1 = (token$1) => ({ [token$1.componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedStyle$1(token$1)), genFilledStyle$1(token$1)), genBorderlessStyle$1(token$1)), genUnderlinedStyle$1(token$1)) });
var variants_default$1 = genVariantsStyle$1;

//#endregion
//#region node_modules/antd/es/select/style/index.js
var genSelectorStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		position: "relative",
		transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseInOut}`,
		input: { cursor: "pointer" },
		[`${componentCls}-show-search&`]: {
			cursor: "text",
			input: {
				cursor: "auto",
				color: "inherit",
				height: "100%"
			}
		},
		[`${componentCls}-disabled&`]: {
			cursor: "not-allowed",
			input: { cursor: "not-allowed" }
		}
	};
};
var getSearchInputWithoutBorderStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-selection-search-input`]: {
		margin: 0,
		padding: 0,
		background: "transparent",
		border: "none",
		outline: "none",
		appearance: "none",
		fontFamily: "inherit",
		"&::-webkit-search-cancel-button": {
			display: "none",
			appearance: "none"
		}
	} };
};
var genBaseStyle$14 = (token$1) => {
	const { antCls, componentCls, inputPaddingHorizontalBase, iconCls } = token$1;
	const hoverShowClearStyle = { [`${componentCls}-clear`]: {
		opacity: 1,
		background: token$1.colorBgBase,
		borderRadius: "50%"
	} };
	return {
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "relative",
			display: "inline-flex",
			cursor: "pointer",
			[`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: Object.assign(Object.assign({}, genSelectorStyle(token$1)), getSearchInputWithoutBorderStyle(token$1)),
			[`${componentCls}-selection-item`]: Object.assign(Object.assign({
				flex: 1,
				fontWeight: "normal",
				position: "relative",
				userSelect: "none"
			}, textEllipsis), { [`> ${antCls}-typography`]: { display: "inline" } }),
			[`${componentCls}-selection-placeholder`]: Object.assign(Object.assign({}, textEllipsis), {
				flex: 1,
				color: token$1.colorTextPlaceholder,
				pointerEvents: "none"
			}),
			[`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
				position: "absolute",
				top: "50%",
				insetInlineStart: "auto",
				insetInlineEnd: inputPaddingHorizontalBase,
				height: token$1.fontSizeIcon,
				marginTop: token$1.calc(token$1.fontSizeIcon).mul(-1).div(2).equal(),
				color: token$1.colorTextQuaternary,
				fontSize: token$1.fontSizeIcon,
				lineHeight: 1,
				textAlign: "center",
				pointerEvents: "none",
				display: "flex",
				alignItems: "center",
				transition: `opacity ${token$1.motionDurationSlow} ease`,
				[iconCls]: {
					verticalAlign: "top",
					transition: `transform ${token$1.motionDurationSlow}`,
					"> svg": { verticalAlign: "top" },
					[`&:not(${componentCls}-suffix)`]: { pointerEvents: "auto" }
				},
				[`${componentCls}-disabled &`]: { cursor: "not-allowed" },
				"> *:not(:last-child)": { marginInlineEnd: 8 }
			}),
			[`${componentCls}-selection-wrap`]: {
				display: "flex",
				width: "100%",
				position: "relative",
				minWidth: 0,
				"&:after": {
					content: "\"\\a0\"",
					width: 0,
					overflow: "hidden"
				}
			},
			[`${componentCls}-prefix`]: {
				flex: "none",
				marginInlineEnd: token$1.selectAffixPadding
			},
			[`${componentCls}-clear`]: {
				position: "absolute",
				top: "50%",
				insetInlineStart: "auto",
				insetInlineEnd: inputPaddingHorizontalBase,
				zIndex: 1,
				display: "inline-block",
				width: token$1.fontSizeIcon,
				height: token$1.fontSizeIcon,
				marginTop: token$1.calc(token$1.fontSizeIcon).mul(-1).div(2).equal(),
				color: token$1.colorTextQuaternary,
				fontSize: token$1.fontSizeIcon,
				fontStyle: "normal",
				lineHeight: 1,
				textAlign: "center",
				textTransform: "none",
				cursor: "pointer",
				opacity: 0,
				transition: `color ${token$1.motionDurationMid} ease, opacity ${token$1.motionDurationSlow} ease`,
				textRendering: "auto",
				transform: "translateZ(0)",
				"&:before": { display: "block" },
				"&:hover": { color: token$1.colorIcon }
			},
			"@media(hover:none)": hoverShowClearStyle,
			"&:hover": hoverShowClearStyle
		}),
		[`${componentCls}-status`]: { "&-error, &-warning, &-success, &-validating": { [`&${componentCls}-has-feedback`]: { [`${componentCls}-clear`]: { insetInlineEnd: token$1.calc(inputPaddingHorizontalBase).add(token$1.fontSize).add(token$1.paddingXS).equal() } } } }
	};
};
var genSelectStyle = (token$1) => {
	const { componentCls } = token$1;
	return [
		{ [componentCls]: { [`&${componentCls}-in-form-item`]: { width: "100%" } } },
		genBaseStyle$14(token$1),
		genSingleStyle(token$1),
		multiple_default$1(token$1),
		dropdown_default$2(token$1),
		{ [`${componentCls}-rtl`]: { direction: "rtl" } },
		genCompactItemStyle(token$1, {
			borderElCls: `${componentCls}-selector`,
			focusElCls: `${componentCls}-focused`
		})
	];
};
var style_default$3 = genStyleHooks("Select", (token$1, { rootPrefixCls }) => {
	const selectToken = merge(token$1, {
		rootPrefixCls,
		inputPaddingHorizontalBase: token$1.calc(token$1.paddingSM).sub(1).equal(),
		multipleSelectItemHeight: token$1.multipleItemHeight,
		selectHeight: token$1.controlHeight
	});
	return [genSelectStyle(selectToken), variants_default$1(selectToken)];
}, prepareComponentToken$47, { unitless: {
	optionLineHeight: true,
	optionSelectedFontWeight: true
} });

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CheckOutlined.js
var CheckOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" }
		}]
	},
	"name": "check",
	"theme": "outlined"
};
var CheckOutlined_default$1 = CheckOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CheckOutlined.js
/**![check](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkxMiAxOTBoLTY5LjljLTkuOCAwLTE5LjEgNC41LTI1LjEgMTIuMkw0MDQuNyA3MjQuNSAyMDcgNDc0YTMyIDMyIDAgMDAtMjUuMS0xMi4ySDExMmMtNi43IDAtMTAuNCA3LjctNi4zIDEyLjlsMjczLjkgMzQ3YzEyLjggMTYuMiAzNy40IDE2LjIgNTAuMyAwbDQ4OC40LTYxOC45YzQuMS01LjEuNC0xMi44LTYuMy0xMi44eiIgLz48L3N2Zz4=) */
var RefIcon$43 = /* @__PURE__ */ import_react.forwardRef(function CheckOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CheckOutlined_default$1
	}));
});
RefIcon$43.displayName = "CheckOutlined";
var CheckOutlined_default = RefIcon$43;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/DownOutlined.js
var DownOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" }
		}]
	},
	"name": "down",
	"theme": "outlined"
};
var DownOutlined_default$1 = DownOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/DownOutlined.js
/**![down](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg4NCAyNTZoLTc1Yy01LjEgMC05LjkgMi41LTEyLjkgNi42TDUxMiA2NTQuMiAyMjcuOSAyNjIuNmMtMy00LjEtNy44LTYuNi0xMi45LTYuNmgtNzVjLTYuNSAwLTEwLjMgNy40LTYuNSAxMi43bDM1Mi42IDQ4Ni4xYzEyLjggMTcuNiAzOSAxNy42IDUxLjcgMGwzNTIuNi00ODYuMWMzLjktNS4zLjEtMTIuNy02LjQtMTIuN3oiIC8+PC9zdmc+) */
var RefIcon$42 = /* @__PURE__ */ import_react.forwardRef(function DownOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: DownOutlined_default$1
	}));
});
RefIcon$42.displayName = "DownOutlined";
var DownOutlined_default = RefIcon$42;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/SearchOutlined.js
var SearchOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" }
		}]
	},
	"name": "search",
	"theme": "outlined"
};
var SearchOutlined_default$1 = SearchOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/SearchOutlined.js
/**![search](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkwOS42IDg1NC41TDY0OS45IDU5NC44QzY5MC4yIDU0Mi43IDcxMiA0NzkgNzEyIDQxMmMwLTgwLjItMzEuMy0xNTUuNC04Ny45LTIxMi4xLTU2LjYtNTYuNy0xMzItODcuOS0yMTIuMS04Ny45cy0xNTUuNSAzMS4zLTIxMi4xIDg3LjlDMTQzLjIgMjU2LjUgMTEyIDMzMS44IDExMiA0MTJjMCA4MC4xIDMxLjMgMTU1LjUgODcuOSAyMTIuMUMyNTYuNSA2ODAuOCAzMzEuOCA3MTIgNDEyIDcxMmM2NyAwIDEzMC42LTIxLjggMTgyLjctNjJsMjU5LjcgMjU5LjZhOC4yIDguMiAwIDAwMTEuNiAwbDQzLjYtNDMuNWE4LjIgOC4yIDAgMDAwLTExLjZ6TTU3MC40IDU3MC40QzUyOCA2MTIuNyA0NzEuOCA2MzYgNDEyIDYzNnMtMTE2LTIzLjMtMTU4LjQtNjUuNkMyMTEuMyA1MjggMTg4IDQ3MS44IDE4OCA0MTJzMjMuMy0xMTYuMSA2NS42LTE1OC40QzI5NiAyMTEuMyAzNTIuMiAxODggNDEyIDE4OHMxMTYuMSAyMy4yIDE1OC40IDY1LjZTNjM2IDM1Mi4yIDYzNiA0MTJzLTIzLjMgMTE2LjEtNjUuNiAxNTguNHoiIC8+PC9zdmc+) */
var RefIcon$41 = /* @__PURE__ */ import_react.forwardRef(function SearchOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: SearchOutlined_default$1
	}));
});
RefIcon$41.displayName = "SearchOutlined";
var SearchOutlined_default = RefIcon$41;

//#endregion
//#region node_modules/antd/es/select/useIcons.js
function useIcons({ suffixIcon, clearIcon, menuItemSelectedIcon, removeIcon, loading, multiple, hasFeedback, prefixCls, showSuffixIcon, feedbackIcon, showArrow, componentName }) {
	devUseWarning(componentName).deprecated(!clearIcon, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
	const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null);
	const getSuffixIconNode = (arrowIcon) => {
		if (suffixIcon === null && !hasFeedback && !showArrow) return null;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
	};
	let mergedSuffixIcon = null;
	if (suffixIcon !== void 0) mergedSuffixIcon = getSuffixIconNode(suffixIcon);
	else if (loading) mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { spin: true }));
	else {
		const iconCls = `${prefixCls}-suffix`;
		mergedSuffixIcon = ({ open: open$2, showSearch }) => {
			if (open$2 && showSearch) return getSuffixIconNode(/* @__PURE__ */ import_react.createElement(SearchOutlined_default, { className: iconCls }));
			return getSuffixIconNode(/* @__PURE__ */ import_react.createElement(DownOutlined_default, { className: iconCls }));
		};
	}
	let mergedItemIcon = null;
	if (menuItemSelectedIcon !== void 0) mergedItemIcon = menuItemSelectedIcon;
	else if (multiple) mergedItemIcon = /* @__PURE__ */ import_react.createElement(CheckOutlined_default, null);
	else mergedItemIcon = null;
	let mergedRemoveIcon = null;
	if (removeIcon !== void 0) mergedRemoveIcon = removeIcon;
	else mergedRemoveIcon = /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null);
	return {
		clearIcon: mergedClearIcon,
		suffixIcon: mergedSuffixIcon,
		itemIcon: mergedItemIcon,
		removeIcon: mergedRemoveIcon
	};
}

//#endregion
//#region node_modules/antd/es/select/usePopupRender.js
function usePopupRender(renderFn) {
	return import_react.useMemo(() => {
		if (!renderFn) return;
		return (...args) => /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, renderFn.apply(void 0, args));
	}, [renderFn]);
}
var usePopupRender_default = usePopupRender;

//#endregion
//#region node_modules/antd/es/select/useShowArrow.js
/**
* Since Select, TreeSelect, Cascader is same Select like component.
* We just use same hook to handle this logic.
*
* If `suffixIcon` is not equal to `null`, always show it.
*/
function useShowArrow(suffixIcon, showArrow) {
	return showArrow !== void 0 ? showArrow : suffixIcon !== null;
}

//#endregion
//#region node_modules/antd/es/select/index.js
var import_classnames$216 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$98 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var InternalSelect = (props, ref) => {
	var _a, _b, _c, _d, _e;
	const { prefixCls: customizePrefixCls, bordered, className, rootClassName, getPopupContainer, popupClassName, dropdownClassName, listHeight = 256, placement, listItemHeight: customListItemHeight, size: customizeSize, disabled: customDisabled, notFoundContent, status: customStatus, builtinPlacements, dropdownMatchSelectWidth, popupMatchSelectWidth, direction: propDirection, style: style$1, allowClear, variant: customizeVariant, dropdownStyle, transitionName, tagRender, maxCount, prefix, dropdownRender, popupRender, onDropdownVisibleChange, onOpenChange, styles, classNames: classNames$252 } = props, rest = __rest$98(props, [
		"prefixCls",
		"bordered",
		"className",
		"rootClassName",
		"getPopupContainer",
		"popupClassName",
		"dropdownClassName",
		"listHeight",
		"placement",
		"listItemHeight",
		"size",
		"disabled",
		"notFoundContent",
		"status",
		"builtinPlacements",
		"dropdownMatchSelectWidth",
		"popupMatchSelectWidth",
		"direction",
		"style",
		"allowClear",
		"variant",
		"dropdownStyle",
		"transitionName",
		"tagRender",
		"maxCount",
		"prefix",
		"dropdownRender",
		"popupRender",
		"onDropdownVisibleChange",
		"onOpenChange",
		"styles",
		"classNames"
	]);
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, renderEmpty, direction: contextDirection, virtual, popupMatchSelectWidth: contextPopupMatchSelectWidth, popupOverflow } = import_react.useContext(ConfigContext);
	const { showSearch, style: contextStyle, styles: contextStyles, className: contextClassName, classNames: contextClassNames } = useComponentConfig("select");
	const [, token$1] = useToken();
	const listItemHeight = customListItemHeight !== null && customListItemHeight !== void 0 ? customListItemHeight : token$1 === null || token$1 === void 0 ? void 0 : token$1.controlHeight;
	const prefixCls = getPrefixCls("select", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const direction = propDirection !== null && propDirection !== void 0 ? propDirection : contextDirection;
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const [variant, enableVariantCls] = useVariants_default("select", customizeVariant, bordered);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$3(prefixCls, rootCls);
	const mode = import_react.useMemo(() => {
		const { mode: m } = props;
		if (m === "combobox") return;
		if (m === SECRET_COMBOBOX_MODE_DO_NOT_USE) return "combobox";
		return m;
	}, [props.mode]);
	const isMultiple$1 = mode === "multiple" || mode === "tags";
	const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
	const mergedPopupMatchSelectWidth = (_a = popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth) !== null && _a !== void 0 ? _a : contextPopupMatchSelectWidth;
	const mergedPopupStyle = ((_b = styles === null || styles === void 0 ? void 0 : styles.popup) === null || _b === void 0 ? void 0 : _b.root) || ((_c = contextStyles.popup) === null || _c === void 0 ? void 0 : _c.root) || dropdownStyle;
	const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
	const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
	const { status: contextStatus, hasFeedback, isFormItemInput, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	let mergedNotFound;
	if (notFoundContent !== void 0) mergedNotFound = notFoundContent;
	else if (mode === "combobox") mergedNotFound = null;
	else mergedNotFound = (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Select" });
	const { suffixIcon, itemIcon, removeIcon, clearIcon } = useIcons(Object.assign(Object.assign({}, rest), {
		multiple: isMultiple$1,
		hasFeedback,
		feedbackIcon,
		showSuffixIcon,
		prefixCls,
		componentName: "Select"
	}));
	const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
	const selectProps = omit(rest, ["suffixIcon", "itemIcon"]);
	const mergedPopupClassName = (0, import_classnames$216.default)(((_d = classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.popup) === null || _d === void 0 ? void 0 : _d.root) || ((_e = contextClassNames === null || contextClassNames === void 0 ? void 0 : contextClassNames.popup) === null || _e === void 0 ? void 0 : _e.root) || popupClassName || dropdownClassName, { [`${prefixCls}-dropdown-${direction}`]: direction === "rtl" }, rootClassName, contextClassNames.root, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.root, cssVarCls, rootCls, hashId);
	const mergedSize = useSize_default((ctx) => {
		var _a$1;
		return (_a$1 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a$1 !== void 0 ? _a$1 : ctx;
	});
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const mergedClassName = (0, import_classnames$216.default)({
		[`${prefixCls}-lg`]: mergedSize === "large",
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${variant}`]: enableVariantCls,
		[`${prefixCls}-in-form-item`]: isFormItemInput
	}, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, contextClassNames.root, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.root, rootClassName, cssVarCls, rootCls, hashId);
	const memoPlacement = import_react.useMemo(() => {
		if (placement !== void 0) return placement;
		return direction === "rtl" ? "bottomRight" : "bottomLeft";
	}, [placement, direction]);
	{
		const warning$4 = devUseWarning("Select");
		Object.entries({
			dropdownMatchSelectWidth: "popupMatchSelectWidth",
			dropdownStyle: "styles.popup.root",
			dropdownClassName: "classNames.popup.root",
			popupClassName: "classNames.popup.root",
			dropdownRender: "popupRender",
			onDropdownVisibleChange: "onOpenChange",
			bordered: "variant"
		}).forEach(([oldProp, newProp]) => {
			warning$4.deprecated(!(oldProp in props), oldProp, newProp);
		});
		warning$4(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.");
		warning$4(!(typeof maxCount !== "undefined" && !isMultiple$1), "usage", "`maxCount` only works with mode `multiple` or `tags`");
	}
	const [zIndex] = useZIndex("SelectLike", mergedPopupStyle === null || mergedPopupStyle === void 0 ? void 0 : mergedPopupStyle.zIndex);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$33, Object.assign({
		ref,
		virtual,
		showSearch
	}, selectProps, {
		style: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), styles === null || styles === void 0 ? void 0 : styles.root), contextStyle), style$1),
		dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
		transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
		builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
		listHeight,
		listItemHeight,
		mode,
		prefixCls,
		placement: memoPlacement,
		direction,
		prefix,
		suffixIcon,
		menuItemSelectedIcon: itemIcon,
		removeIcon,
		allowClear: mergedAllowClear,
		notFoundContent: mergedNotFound,
		className: mergedClassName,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		dropdownClassName: mergedPopupClassName,
		disabled: mergedDisabled,
		dropdownStyle: Object.assign(Object.assign({}, mergedPopupStyle), { zIndex }),
		maxCount: isMultiple$1 ? maxCount : void 0,
		tagRender: isMultiple$1 ? tagRender : void 0,
		dropdownRender: mergedPopupRender,
		onDropdownVisibleChange: mergedOnOpenChange
	})));
};
InternalSelect.displayName = "Select";
var Select = /* @__PURE__ */ import_react.forwardRef(InternalSelect);
/* istanbul ignore next */
var PurePanel$12 = PurePanel_default(Select, "dropdownAlign");
Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select.Option = Option_default$1;
Select.OptGroup = OptGroup_default;
Select._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$12;
Select.displayName = "Select";
var select_default = Select;

//#endregion
//#region node_modules/antd/es/auto-complete/AutoComplete.js
var import_classnames$215 = /* @__PURE__ */ __toESM(require_classnames());
var { Option: Option$3 } = select_default;
function isSelectOptionOrSelectOptGroup(child) {
	return (child === null || child === void 0 ? void 0 : child.type) && (child.type.isSelectOption || child.type.isSelectOptGroup);
}
var AutoComplete$1 = (props, ref) => {
	var _a, _b;
	const { prefixCls: customizePrefixCls, className, popupClassName, dropdownClassName, children, dataSource, dropdownStyle, dropdownRender, popupRender, onDropdownVisibleChange, onOpenChange, styles, classNames: classNames$252 } = props;
	const childNodes = toArray(children);
	const mergedPopupStyle = ((_a = styles === null || styles === void 0 ? void 0 : styles.popup) === null || _a === void 0 ? void 0 : _a.root) || dropdownStyle;
	const mergedPopupClassName = ((_b = classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.popup) === null || _b === void 0 ? void 0 : _b.root) || popupClassName || dropdownClassName;
	const mergedPopupRender = popupRender || dropdownRender;
	const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
	let customizeInput;
	if (childNodes.length === 1 && /* @__PURE__ */ import_react.isValidElement(childNodes[0]) && !isSelectOptionOrSelectOptGroup(childNodes[0])) [customizeInput] = childNodes;
	const getInputElement = customizeInput ? () => customizeInput : void 0;
	let optionChildren;
	if (childNodes.length && isSelectOptionOrSelectOptGroup(childNodes[0])) optionChildren = children;
	else optionChildren = dataSource ? dataSource.map((item) => {
		if (/* @__PURE__ */ import_react.isValidElement(item)) return item;
		switch (typeof item) {
			case "string": return /* @__PURE__ */ import_react.createElement(Option$3, {
				key: item,
				value: item
			}, item);
			case "object": {
				const { value: optionValue } = item;
				return /* @__PURE__ */ import_react.createElement(Option$3, {
					key: optionValue,
					value: optionValue
				}, item.text);
			}
			default: return;
		}
	}) : [];
	{
		const warning$4 = devUseWarning("AutoComplete");
		warning$4(!customizeInput || !("size" in props), "usage", "You need to control style self instead of setting `size` when using customize input.");
		Object.entries({
			dropdownMatchSelectWidth: "popupMatchSelectWidth",
			dropdownStyle: "styles.popup.root",
			dropdownClassName: "classNames.popup.root",
			popupClassName: "classNames.popup.root",
			dropdownRender: "popupRender",
			onDropdownVisibleChange: "onOpenChange",
			dataSource: "options"
		}).forEach(([oldProp, newProp]) => {
			warning$4.deprecated(!(oldProp in props), oldProp, newProp);
		});
	}
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("select", customizePrefixCls);
	const [zIndex] = useZIndex("SelectLike", mergedPopupStyle === null || mergedPopupStyle === void 0 ? void 0 : mergedPopupStyle.zIndex);
	return /* @__PURE__ */ import_react.createElement(select_default, Object.assign({
		ref,
		suffixIcon: null
	}, omit(props, [
		"dataSource",
		"dropdownClassName",
		"popupClassName"
	]), {
		prefixCls,
		classNames: {
			popup: { root: mergedPopupClassName },
			root: classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.root
		},
		styles: {
			popup: { root: Object.assign(Object.assign({}, mergedPopupStyle), { zIndex }) },
			root: styles === null || styles === void 0 ? void 0 : styles.root
		},
		className: (0, import_classnames$215.default)(`${prefixCls}-auto-complete`, className),
		mode: select_default.SECRET_COMBOBOX_MODE_DO_NOT_USE,
		popupRender: mergedPopupRender,
		onOpenChange: mergedOnOpenChange,
		getInputElement
	}), optionChildren);
};
var RefAutoComplete = /* @__PURE__ */ import_react.forwardRef(AutoComplete$1);
RefAutoComplete.displayName = "AutoComplete";
var AutoComplete_default = RefAutoComplete;

//#endregion
//#region node_modules/antd/es/auto-complete/index.js
var { Option: Option$2 } = select_default;
/* istanbul ignore next */
var PurePanel$11 = PurePanel_default(AutoComplete_default, "dropdownAlign", (props) => omit(props, ["visible"]));
var AutoComplete = AutoComplete_default;
AutoComplete.Option = Option$2;
AutoComplete._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$11;
var auto_complete_default = AutoComplete;

//#endregion
//#region node_modules/antd/es/_util/mediaQueryUtil.js
const addMediaQueryListener = (mql, handler) => {
	if (typeof (mql === null || mql === void 0 ? void 0 : mql.addEventListener) !== "undefined") mql.addEventListener("change", handler);
	else if (typeof (mql === null || mql === void 0 ? void 0 : mql.addListener) !== "undefined") mql.addListener(handler);
};
const removeMediaQueryListener = (mql, handler) => {
	if (typeof (mql === null || mql === void 0 ? void 0 : mql.removeEventListener) !== "undefined") mql.removeEventListener("change", handler);
	else if (typeof (mql === null || mql === void 0 ? void 0 : mql.removeListener) !== "undefined") mql.removeListener(handler);
};

//#endregion
//#region node_modules/antd/es/_util/responsiveObserver.js
const responsiveArray = [
	"xxl",
	"xl",
	"lg",
	"md",
	"sm",
	"xs"
];
var getResponsiveMap = (token$1) => ({
	xs: `(max-width: ${token$1.screenXSMax}px)`,
	sm: `(min-width: ${token$1.screenSM}px)`,
	md: `(min-width: ${token$1.screenMD}px)`,
	lg: `(min-width: ${token$1.screenLG}px)`,
	xl: `(min-width: ${token$1.screenXL}px)`,
	xxl: `(min-width: ${token$1.screenXXL}px)`
});
/**
* Ensures that the breakpoints token are valid, in good order
* For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin
*/
var validateBreakpoints = (token$1) => {
	const indexableToken = token$1;
	const revBreakpoints = [].concat(responsiveArray).reverse();
	revBreakpoints.forEach((breakpoint, i) => {
		const breakpointUpper = breakpoint.toUpperCase();
		const screenMin = `screen${breakpointUpper}Min`;
		const screen = `screen${breakpointUpper}`;
		if (!(indexableToken[screenMin] <= indexableToken[screen])) throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
		if (i < revBreakpoints.length - 1) {
			const screenMax = `screen${breakpointUpper}Max`;
			if (!(indexableToken[screen] <= indexableToken[screenMax])) throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
			const nextScreenMin = `screen${revBreakpoints[i + 1].toUpperCase()}Min`;
			if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
		}
	});
	return token$1;
};
const matchScreen = (screens, screenSizes) => {
	if (!screenSizes) return;
	for (const breakpoint of responsiveArray) if (screens[breakpoint] && (screenSizes === null || screenSizes === void 0 ? void 0 : screenSizes[breakpoint]) !== void 0) return screenSizes[breakpoint];
};
var useResponsiveObserver = () => {
	const [, token$1] = useToken();
	const responsiveMap = getResponsiveMap(validateBreakpoints(token$1));
	return import_react.useMemo(() => {
		const subscribers = /* @__PURE__ */ new Map();
		let subUid = -1;
		let screens = {};
		return {
			responsiveMap,
			matchHandlers: {},
			dispatch(pointMap) {
				screens = pointMap;
				subscribers.forEach((func) => func(screens));
				return subscribers.size >= 1;
			},
			subscribe(func) {
				if (!subscribers.size) this.register();
				subUid += 1;
				subscribers.set(subUid, func);
				func(screens);
				return subUid;
			},
			unsubscribe(paramToken) {
				subscribers.delete(paramToken);
				if (!subscribers.size) this.unregister();
			},
			register() {
				Object.entries(responsiveMap).forEach(([screen, mediaQuery]) => {
					const listener = ({ matches }) => {
						this.dispatch(Object.assign(Object.assign({}, screens), { [screen]: matches }));
					};
					const mql = window.matchMedia(mediaQuery);
					addMediaQueryListener(mql, listener);
					this.matchHandlers[mediaQuery] = {
						mql,
						listener
					};
					listener(mql);
				});
			},
			unregister() {
				Object.values(responsiveMap).forEach((mediaQuery) => {
					const handler = this.matchHandlers[mediaQuery];
					removeMediaQueryListener(handler === null || handler === void 0 ? void 0 : handler.mql, handler === null || handler === void 0 ? void 0 : handler.listener);
				});
				subscribers.clear();
			}
		};
	}, [token$1]);
};
var responsiveObserver_default = useResponsiveObserver;

//#endregion
//#region node_modules/antd/es/_util/hooks/useForceUpdate.js
function useForceUpdate() {
	const [, forceUpdate] = import_react.useReducer((x) => x + 1, 0);
	return forceUpdate;
}

//#endregion
//#region node_modules/antd/es/grid/hooks/useBreakpoint.js
function useBreakpoint$1(refreshOnChange = true, defaultScreens = {}) {
	const screensRef = (0, import_react.useRef)(defaultScreens);
	const forceUpdate = useForceUpdate();
	const responsiveObserver = responsiveObserver_default();
	useLayoutEffect_default(() => {
		const token$1 = responsiveObserver.subscribe((supportScreens) => {
			screensRef.current = supportScreens;
			if (refreshOnChange) forceUpdate();
		});
		return () => responsiveObserver.unsubscribe(token$1);
	}, []);
	return screensRef.current;
}
var useBreakpoint_default = useBreakpoint$1;

//#endregion
//#region node_modules/antd/es/avatar/AvatarContext.js
var AvatarContext = /* @__PURE__ */ import_react.createContext({});
var AvatarContext_default = AvatarContext;

//#endregion
//#region node_modules/antd/es/avatar/style/index.js
var genBaseStyle$13 = (token$1) => {
	const { antCls, componentCls, iconCls, avatarBg, avatarColor, containerSize, containerSizeLG, containerSizeSM, textFontSize, textFontSizeLG, textFontSizeSM, iconFontSize, iconFontSizeLG, iconFontSizeSM, borderRadius, borderRadiusLG, borderRadiusSM, lineWidth, lineType } = token$1;
	const avatarSizeStyle = (size, fontSize, iconFontSize$1, radius$1) => ({
		width: size,
		height: size,
		borderRadius: "50%",
		fontSize,
		[`&${componentCls}-square`]: { borderRadius: radius$1 },
		[`&${componentCls}-icon`]: {
			fontSize: iconFontSize$1,
			[`> ${iconCls}`]: { margin: 0 }
		}
	});
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "relative",
		display: "inline-flex",
		justifyContent: "center",
		alignItems: "center",
		overflow: "hidden",
		color: avatarColor,
		whiteSpace: "nowrap",
		textAlign: "center",
		verticalAlign: "middle",
		background: avatarBg,
		border: `${unit(lineWidth)} ${lineType} transparent`,
		"&-image": { background: "transparent" },
		[`${antCls}-image-img`]: { display: "block" }
	}), avatarSizeStyle(containerSize, textFontSize, iconFontSize, borderRadius)), {
		"&-lg": Object.assign({}, avatarSizeStyle(containerSizeLG, textFontSizeLG, iconFontSizeLG, borderRadiusLG)),
		"&-sm": Object.assign({}, avatarSizeStyle(containerSizeSM, textFontSizeSM, iconFontSizeSM, borderRadiusSM)),
		"> img": {
			display: "block",
			width: "100%",
			height: "100%",
			objectFit: "cover"
		}
	}) };
};
var genGroupStyle$1 = (token$1) => {
	const { componentCls, groupBorderColor, groupOverlapping, groupSpace } = token$1;
	return {
		[`${componentCls}-group`]: {
			display: "inline-flex",
			[componentCls]: { borderColor: groupBorderColor },
			"> *:not(:first-child)": { marginInlineStart: groupOverlapping }
		},
		[`${componentCls}-group-popover`]: { [`${componentCls} + ${componentCls}`]: { marginInlineStart: groupSpace } }
	};
};
const prepareComponentToken$46 = (token$1) => {
	const { controlHeight, controlHeightLG, controlHeightSM, fontSize, fontSizeLG, fontSizeXL, fontSizeHeading3, marginXS, marginXXS, colorBorderBg } = token$1;
	return {
		containerSize: controlHeight,
		containerSizeLG: controlHeightLG,
		containerSizeSM: controlHeightSM,
		textFontSize: fontSize,
		textFontSizeLG: fontSize,
		textFontSizeSM: fontSize,
		iconFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
		iconFontSizeLG: fontSizeHeading3,
		iconFontSizeSM: fontSize,
		groupSpace: marginXXS,
		groupOverlapping: -marginXS,
		groupBorderColor: colorBorderBg
	};
};
var style_default$50 = genStyleHooks("Avatar", (token$1) => {
	const { colorTextLightSolid, colorTextPlaceholder } = token$1;
	const avatarToken = merge(token$1, {
		avatarBg: colorTextPlaceholder,
		avatarColor: colorTextLightSolid
	});
	return [genBaseStyle$13(avatarToken), genGroupStyle$1(avatarToken)];
}, prepareComponentToken$46);

//#endregion
//#region node_modules/antd/es/avatar/Avatar.js
var import_classnames$214 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$97 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Avatar$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, shape, size: customSize, src, srcSet, icon, className, rootClassName, style: style$1, alt, draggable, children, crossOrigin, gap = 4, onError } = props, others = __rest$97(props, [
		"prefixCls",
		"shape",
		"size",
		"src",
		"srcSet",
		"icon",
		"className",
		"rootClassName",
		"style",
		"alt",
		"draggable",
		"children",
		"crossOrigin",
		"gap",
		"onError"
	]);
	const [scale, setScale] = import_react.useState(1);
	const [mounted, setMounted] = import_react.useState(false);
	const [isImgExist, setIsImgExist] = import_react.useState(true);
	const avatarNodeRef = import_react.useRef(null);
	const avatarChildrenRef = import_react.useRef(null);
	const avatarNodeMergedRef = composeRef(ref, avatarNodeRef);
	const { getPrefixCls, avatar } = import_react.useContext(ConfigContext);
	const avatarCtx = import_react.useContext(AvatarContext_default);
	const setScaleParam = () => {
		if (!avatarChildrenRef.current || !avatarNodeRef.current) return;
		const childrenWidth = avatarChildrenRef.current.offsetWidth;
		const nodeWidth = avatarNodeRef.current.offsetWidth;
		if (childrenWidth !== 0 && nodeWidth !== 0) {
			if (gap * 2 < nodeWidth) setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
		}
	};
	import_react.useEffect(() => {
		setMounted(true);
	}, []);
	import_react.useEffect(() => {
		setIsImgExist(true);
		setScale(1);
	}, [src]);
	import_react.useEffect(setScaleParam, [gap]);
	const handleImgLoadError = () => {
		if ((onError === null || onError === void 0 ? void 0 : onError()) !== false) setIsImgExist(false);
	};
	const size = useSize_default((ctxSize) => {
		var _a, _b;
		return (_b = (_a = customSize !== null && customSize !== void 0 ? customSize : avatarCtx === null || avatarCtx === void 0 ? void 0 : avatarCtx.size) !== null && _a !== void 0 ? _a : ctxSize) !== null && _b !== void 0 ? _b : "default";
	});
	const needResponsive = Object.keys(typeof size === "object" ? size || {} : {}).some((key) => [
		"xs",
		"sm",
		"md",
		"lg",
		"xl",
		"xxl"
	].includes(key));
	const screens = useBreakpoint_default(needResponsive);
	const responsiveSizeStyle = import_react.useMemo(() => {
		if (typeof size !== "object") return {};
		const currentBreakpoint = responsiveArray.find((screen) => screens[screen]);
		const currentSize = size[currentBreakpoint];
		return currentSize ? {
			width: currentSize,
			height: currentSize,
			fontSize: currentSize && (icon || children) ? currentSize / 2 : 18
		} : {};
	}, [screens, size]);
	devUseWarning("Avatar")(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`);
	const prefixCls = getPrefixCls("avatar", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$50(prefixCls, rootCls);
	const sizeCls = (0, import_classnames$214.default)({
		[`${prefixCls}-lg`]: size === "large",
		[`${prefixCls}-sm`]: size === "small"
	});
	const hasImageElement = /* @__PURE__ */ import_react.isValidElement(src);
	const mergedShape = shape || (avatarCtx === null || avatarCtx === void 0 ? void 0 : avatarCtx.shape) || "circle";
	const classString = (0, import_classnames$214.default)(prefixCls, sizeCls, avatar === null || avatar === void 0 ? void 0 : avatar.className, `${prefixCls}-${mergedShape}`, {
		[`${prefixCls}-image`]: hasImageElement || src && isImgExist,
		[`${prefixCls}-icon`]: !!icon
	}, cssVarCls, rootCls, className, rootClassName, hashId);
	const sizeStyle = typeof size === "number" ? {
		width: size,
		height: size,
		fontSize: icon ? size / 2 : 18
	} : {};
	let childrenToRender;
	if (typeof src === "string" && isImgExist) childrenToRender = /* @__PURE__ */ import_react.createElement("img", {
		src,
		draggable,
		srcSet,
		onError: handleImgLoadError,
		alt,
		crossOrigin
	});
	else if (hasImageElement) childrenToRender = src;
	else if (icon) childrenToRender = icon;
	else if (mounted || scale !== 1) {
		const transformString = `scale(${scale})`;
		const childrenStyle = {
			msTransform: transformString,
			WebkitTransform: transformString,
			transform: transformString
		};
		childrenToRender = /* @__PURE__ */ import_react.createElement(es_default, { onResize: setScaleParam }, /* @__PURE__ */ import_react.createElement("span", {
			className: `${prefixCls}-string`,
			ref: avatarChildrenRef,
			style: Object.assign({}, childrenStyle)
		}, children));
	} else childrenToRender = /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-string`,
		style: { opacity: 0 },
		ref: avatarChildrenRef
	}, children);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("span", Object.assign({}, others, {
		style: Object.assign(Object.assign(Object.assign(Object.assign({}, sizeStyle), responsiveSizeStyle), avatar === null || avatar === void 0 ? void 0 : avatar.style), style$1),
		className: classString,
		ref: avatarNodeMergedRef
	}), childrenToRender));
});
Avatar$1.displayName = "Avatar";
var Avatar_default = Avatar$1;

//#endregion
//#region node_modules/antd/es/_util/getRenderPropValue.js
const getRenderPropValue = (propValue) => {
	if (!propValue) return null;
	return typeof propValue === "function" ? propValue() : propValue;
};

//#endregion
//#region node_modules/rc-tooltip/es/Popup.js
var import_classnames$213 = /* @__PURE__ */ __toESM(require_classnames());
function Popup$1(props) {
	var children = props.children, prefixCls = props.prefixCls, id = props.id, innerStyle = props.overlayInnerStyle, bodyClassName = props.bodyClassName, className = props.className, style$1 = props.style;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$213.default)("".concat(prefixCls, "-content"), className),
		style: style$1
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$213.default)("".concat(prefixCls, "-inner"), bodyClassName),
		id,
		role: "tooltip",
		style: innerStyle
	}, typeof children === "function" ? children() : children));
}

//#endregion
//#region node_modules/rc-tooltip/es/placements.js
var autoAdjustOverflowTopBottom = {
	shiftX: 64,
	adjustY: 1
};
var autoAdjustOverflowLeftRight = {
	adjustX: 1,
	shiftY: true
};
var targetOffset$2 = [0, 0];
var placements$3 = {
	left: {
		points: ["cr", "cl"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [-4, 0],
		targetOffset: targetOffset$2
	},
	right: {
		points: ["cl", "cr"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [4, 0],
		targetOffset: targetOffset$2
	},
	top: {
		points: ["bc", "tc"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, -4],
		targetOffset: targetOffset$2
	},
	bottom: {
		points: ["tc", "bc"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, 4],
		targetOffset: targetOffset$2
	},
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, -4],
		targetOffset: targetOffset$2
	},
	leftTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [-4, 0],
		targetOffset: targetOffset$2
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, -4],
		targetOffset: targetOffset$2
	},
	rightTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [4, 0],
		targetOffset: targetOffset$2
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, 4],
		targetOffset: targetOffset$2
	},
	rightBottom: {
		points: ["bl", "br"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [4, 0],
		targetOffset: targetOffset$2
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflowTopBottom,
		offset: [0, 4],
		targetOffset: targetOffset$2
	},
	leftBottom: {
		points: ["br", "bl"],
		overflow: autoAdjustOverflowLeftRight,
		offset: [-4, 0],
		targetOffset: targetOffset$2
	}
};

//#endregion
//#region node_modules/rc-tooltip/es/Tooltip.js
var import_classnames$212 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$54 = [
	"overlayClassName",
	"trigger",
	"mouseEnterDelay",
	"mouseLeaveDelay",
	"overlayStyle",
	"prefixCls",
	"children",
	"onVisibleChange",
	"afterVisibleChange",
	"transitionName",
	"animation",
	"motion",
	"placement",
	"align",
	"destroyTooltipOnHide",
	"defaultVisible",
	"getTooltipContainer",
	"overlayInnerStyle",
	"arrowContent",
	"overlay",
	"id",
	"showArrow",
	"classNames",
	"styles"
];
var Tooltip$1 = function Tooltip$2(props, ref) {
	var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? .1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion$1 = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
	props.arrowContent;
	var overlay = props.overlay, id = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, tooltipClassNames = props.classNames, tooltipStyles = props.styles, restProps = _objectWithoutProperties(props, _excluded$54);
	var mergedId = useId_default(id);
	var triggerRef = (0, import_react.useRef)(null);
	(0, import_react.useImperativeHandle)(ref, function() {
		return triggerRef.current;
	});
	var extraProps = _objectSpread2({}, restProps);
	if ("visible" in props) extraProps.popupVisible = props.visible;
	return /* @__PURE__ */ import_react.createElement(es_default$7, _extends({
		popupClassName: (0, import_classnames$212.default)(overlayClassName, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.root),
		prefixCls,
		popup: function getPopupElement() {
			return /* @__PURE__ */ import_react.createElement(Popup$1, {
				key: "content",
				prefixCls,
				id: mergedId,
				bodyClassName: tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.body,
				overlayInnerStyle: _objectSpread2(_objectSpread2({}, overlayInnerStyle), tooltipStyles === null || tooltipStyles === void 0 ? void 0 : tooltipStyles.body)
			}, overlay);
		},
		action: trigger,
		builtinPlacements: placements$3,
		popupPlacement: placement,
		ref: triggerRef,
		popupAlign: align,
		getPopupContainer: getTooltipContainer,
		onPopupVisibleChange: onVisibleChange,
		afterPopupVisibleChange: afterVisibleChange,
		popupTransitionName: transitionName,
		popupAnimation: animation,
		popupMotion: motion$1,
		defaultPopupVisible: defaultVisible,
		autoDestroy: destroyTooltipOnHide,
		mouseLeaveDelay,
		popupStyle: _objectSpread2(_objectSpread2({}, overlayStyle), tooltipStyles === null || tooltipStyles === void 0 ? void 0 : tooltipStyles.root),
		mouseEnterDelay,
		arrow: showArrow
	}, extraProps), function getChildren() {
		var child = import_react.Children.only(children);
		var originalProps = (child === null || child === void 0 ? void 0 : child.props) || {};
		var childProps = _objectSpread2(_objectSpread2({}, originalProps), {}, { "aria-describedby": overlay ? mergedId : null });
		return /* @__PURE__ */ import_react.cloneElement(children, childProps);
	}());
};
var Tooltip_default = /* @__PURE__ */ (0, import_react.forwardRef)(Tooltip$1);

//#endregion
//#region node_modules/rc-tooltip/es/index.js
var es_default$32 = Tooltip_default;

//#endregion
//#region node_modules/antd/es/style/roundedArrow.js
function getArrowToken(token$1) {
	const { sizePopupArrow, borderRadiusXS, borderRadiusOuter } = token$1;
	const unitWidth = sizePopupArrow / 2;
	const ax = 0;
	const ay = unitWidth;
	const bx = borderRadiusOuter * 1 / Math.sqrt(2);
	const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
	const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
	const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
	const dx = 2 * unitWidth - cx;
	const dy = cy;
	const ex = 2 * unitWidth - bx;
	const ey = by;
	const fx = 2 * unitWidth - ax;
	const fy = ay;
	const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
	const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
	const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
	const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
	return {
		arrowShadowWidth: shadowWidth,
		arrowPath,
		arrowPolygon
	};
}
const genRoundedArrow = (token$1, bgColor, boxShadow) => {
	const { sizePopupArrow, arrowPolygon, arrowPath, arrowShadowWidth, borderRadiusXS, calc } = token$1;
	return {
		pointerEvents: "none",
		width: sizePopupArrow,
		height: sizePopupArrow,
		overflow: "hidden",
		"&::before": {
			position: "absolute",
			bottom: 0,
			insetInlineStart: 0,
			width: sizePopupArrow,
			height: calc(sizePopupArrow).div(2).equal(),
			background: bgColor,
			clipPath: {
				_multi_value_: true,
				value: [arrowPolygon, arrowPath]
			},
			content: "\"\""
		},
		"&::after": {
			content: "\"\"",
			position: "absolute",
			width: arrowShadowWidth,
			height: arrowShadowWidth,
			bottom: 0,
			insetInline: 0,
			margin: "auto",
			borderRadius: {
				_skip_check_: true,
				value: `0 0 ${unit(borderRadiusXS)} 0`
			},
			transform: "translateY(50%) rotate(-135deg)",
			boxShadow,
			zIndex: 0,
			background: "transparent"
		}
	};
};

//#endregion
//#region node_modules/antd/es/style/placementArrow.js
const MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffsetToken(options) {
	const { contentRadius, limitVerticalRadius } = options;
	const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
	return {
		arrowOffsetHorizontal: arrowOffset,
		arrowOffsetVertical: limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset
	};
}
function isInject(valid, code) {
	if (!valid) return {};
	return code;
}
function getArrowStyle(token$1, colorBg, options) {
	const { componentCls, boxShadowPopoverArrow, arrowOffsetVertical, arrowOffsetHorizontal } = token$1;
	const { arrowDistance = 0, arrowPlacement = {
		left: true,
		right: true,
		top: true,
		bottom: true
	} } = options || {};
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({ [`${componentCls}-arrow`]: [Object.assign(Object.assign({
		position: "absolute",
		zIndex: 1,
		display: "block"
	}, genRoundedArrow(token$1, colorBg, boxShadowPopoverArrow)), { "&:before": { background: colorBg } })] }, isInject(!!arrowPlacement.top, {
		[[
			`&-placement-top > ${componentCls}-arrow`,
			`&-placement-topLeft > ${componentCls}-arrow`,
			`&-placement-topRight > ${componentCls}-arrow`
		].join(",")]: {
			bottom: arrowDistance,
			transform: "translateY(100%) rotate(180deg)"
		},
		[`&-placement-top > ${componentCls}-arrow`]: {
			left: {
				_skip_check_: true,
				value: "50%"
			},
			transform: "translateX(-50%) translateY(100%) rotate(180deg)"
		},
		"&-placement-topLeft": {
			"--arrow-offset-horizontal": arrowOffsetHorizontal,
			[`> ${componentCls}-arrow`]: { left: {
				_skip_check_: true,
				value: arrowOffsetHorizontal
			} }
		},
		"&-placement-topRight": {
			"--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
			[`> ${componentCls}-arrow`]: { right: {
				_skip_check_: true,
				value: arrowOffsetHorizontal
			} }
		}
	})), isInject(!!arrowPlacement.bottom, {
		[[
			`&-placement-bottom > ${componentCls}-arrow`,
			`&-placement-bottomLeft > ${componentCls}-arrow`,
			`&-placement-bottomRight > ${componentCls}-arrow`
		].join(",")]: {
			top: arrowDistance,
			transform: `translateY(-100%)`
		},
		[`&-placement-bottom > ${componentCls}-arrow`]: {
			left: {
				_skip_check_: true,
				value: "50%"
			},
			transform: `translateX(-50%) translateY(-100%)`
		},
		"&-placement-bottomLeft": {
			"--arrow-offset-horizontal": arrowOffsetHorizontal,
			[`> ${componentCls}-arrow`]: { left: {
				_skip_check_: true,
				value: arrowOffsetHorizontal
			} }
		},
		"&-placement-bottomRight": {
			"--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
			[`> ${componentCls}-arrow`]: { right: {
				_skip_check_: true,
				value: arrowOffsetHorizontal
			} }
		}
	})), isInject(!!arrowPlacement.left, {
		[[
			`&-placement-left > ${componentCls}-arrow`,
			`&-placement-leftTop > ${componentCls}-arrow`,
			`&-placement-leftBottom > ${componentCls}-arrow`
		].join(",")]: {
			right: {
				_skip_check_: true,
				value: arrowDistance
			},
			transform: "translateX(100%) rotate(90deg)"
		},
		[`&-placement-left > ${componentCls}-arrow`]: {
			top: {
				_skip_check_: true,
				value: "50%"
			},
			transform: "translateY(-50%) translateX(100%) rotate(90deg)"
		},
		[`&-placement-leftTop > ${componentCls}-arrow`]: { top: arrowOffsetVertical },
		[`&-placement-leftBottom > ${componentCls}-arrow`]: { bottom: arrowOffsetVertical }
	})), isInject(!!arrowPlacement.right, {
		[[
			`&-placement-right > ${componentCls}-arrow`,
			`&-placement-rightTop > ${componentCls}-arrow`,
			`&-placement-rightBottom > ${componentCls}-arrow`
		].join(",")]: {
			left: {
				_skip_check_: true,
				value: arrowDistance
			},
			transform: "translateX(-100%) rotate(-90deg)"
		},
		[`&-placement-right > ${componentCls}-arrow`]: {
			top: {
				_skip_check_: true,
				value: "50%"
			},
			transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
		},
		[`&-placement-rightTop > ${componentCls}-arrow`]: { top: arrowOffsetVertical },
		[`&-placement-rightBottom > ${componentCls}-arrow`]: { bottom: arrowOffsetVertical }
	})) };
}

//#endregion
//#region node_modules/antd/es/_util/placements.js
function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow$2) {
	if (autoAdjustOverflow$2 === false) return {
		adjustX: false,
		adjustY: false
	};
	const overflow = autoAdjustOverflow$2 && typeof autoAdjustOverflow$2 === "object" ? autoAdjustOverflow$2 : {};
	const baseOverflow = {};
	switch (placement) {
		case "top":
		case "bottom":
			baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
			baseOverflow.shiftY = true;
			baseOverflow.adjustY = true;
			break;
		case "left":
		case "right":
			baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
			baseOverflow.shiftX = true;
			baseOverflow.adjustX = true;
			break;
	}
	const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
	if (!mergedOverflow.shiftX) mergedOverflow.adjustX = true;
	if (!mergedOverflow.shiftY) mergedOverflow.adjustY = true;
	return mergedOverflow;
}
var PlacementAlignMap = {
	left: { points: ["cr", "cl"] },
	right: { points: ["cl", "cr"] },
	top: { points: ["bc", "tc"] },
	bottom: { points: ["tc", "bc"] },
	topLeft: { points: ["bl", "tl"] },
	leftTop: { points: ["tr", "tl"] },
	topRight: { points: ["br", "tr"] },
	rightTop: { points: ["tl", "tr"] },
	bottomRight: { points: ["tr", "br"] },
	rightBottom: { points: ["bl", "br"] },
	bottomLeft: { points: ["tl", "bl"] },
	leftBottom: { points: ["br", "bl"] }
};
var ArrowCenterPlacementAlignMap = {
	topLeft: { points: ["bl", "tc"] },
	leftTop: { points: ["tr", "cl"] },
	topRight: { points: ["br", "tc"] },
	rightTop: { points: ["tl", "cr"] },
	bottomRight: { points: ["tr", "bc"] },
	rightBottom: { points: ["bl", "cr"] },
	bottomLeft: { points: ["tl", "bc"] },
	leftBottom: { points: ["br", "cl"] }
};
var DisableAutoArrowList = new Set([
	"topLeft",
	"topRight",
	"bottomLeft",
	"bottomRight",
	"leftTop",
	"leftBottom",
	"rightTop",
	"rightBottom"
]);
function getPlacements(config) {
	const { arrowWidth, autoAdjustOverflow: autoAdjustOverflow$2, arrowPointAtCenter, offset: offset$2, borderRadius, visibleFirst } = config;
	const halfArrowWidth = arrowWidth / 2;
	const placementMap = {};
	const arrowOffset = getArrowOffsetToken({
		contentRadius: borderRadius,
		limitVerticalRadius: true
	});
	Object.keys(PlacementAlignMap).forEach((key) => {
		const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
		const placementInfo = Object.assign(Object.assign({}, template), {
			offset: [0, 0],
			dynamicInset: true
		});
		placementMap[key] = placementInfo;
		if (DisableAutoArrowList.has(key)) placementInfo.autoArrow = false;
		switch (key) {
			case "top":
			case "topLeft":
			case "topRight":
				placementInfo.offset[1] = -halfArrowWidth - offset$2;
				break;
			case "bottom":
			case "bottomLeft":
			case "bottomRight":
				placementInfo.offset[1] = halfArrowWidth + offset$2;
				break;
			case "left":
			case "leftTop":
			case "leftBottom":
				placementInfo.offset[0] = -halfArrowWidth - offset$2;
				break;
			case "right":
			case "rightTop":
			case "rightBottom":
				placementInfo.offset[0] = halfArrowWidth + offset$2;
				break;
		}
		if (arrowPointAtCenter) switch (key) {
			case "topLeft":
			case "bottomLeft":
				placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
				break;
			case "topRight":
			case "bottomRight":
				placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
				break;
			case "leftTop":
			case "rightTop":
				placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal * 2 + halfArrowWidth;
				break;
			case "leftBottom":
			case "rightBottom":
				placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal * 2 - halfArrowWidth;
				break;
		}
		placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow$2);
		if (visibleFirst) placementInfo.htmlRegion = "visibleFirst";
	});
	return placementMap;
}

//#endregion
//#region node_modules/antd/es/tooltip/style/index.js
var genTooltipStyle = (token$1) => {
	const { calc, componentCls, tooltipMaxWidth, tooltipColor, tooltipBg, tooltipBorderRadius, zIndexPopup, controlHeight, boxShadowSecondary, paddingSM, paddingXS, arrowOffsetHorizontal, sizePopupArrow } = token$1;
	const edgeAlignMinWidth = calc(tooltipBorderRadius).add(sizePopupArrow).add(arrowOffsetHorizontal).equal();
	const centerAlignMinWidth = calc(tooltipBorderRadius).mul(2).add(sizePopupArrow).equal();
	return [
		{ [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "absolute",
			zIndex: zIndexPopup,
			display: "block",
			width: "max-content",
			maxWidth: tooltipMaxWidth,
			visibility: "visible",
			"--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
			transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" "),
			"&-hidden": { display: "none" },
			"--antd-arrow-background-color": tooltipBg,
			[`${componentCls}-inner`]: {
				minWidth: centerAlignMinWidth,
				minHeight: controlHeight,
				padding: `${unit(token$1.calc(paddingSM).div(2).equal())} ${unit(paddingXS)}`,
				color: `var(--ant-tooltip-color, ${tooltipColor})`,
				textAlign: "start",
				textDecoration: "none",
				wordWrap: "break-word",
				backgroundColor: tooltipBg,
				borderRadius: tooltipBorderRadius,
				boxShadow: boxShadowSecondary,
				boxSizing: "border-box"
			},
			[[
				`&-placement-topLeft`,
				`&-placement-topRight`,
				`&-placement-bottomLeft`,
				`&-placement-bottomRight`
			].join(",")]: { minWidth: edgeAlignMinWidth },
			[[
				`&-placement-left`,
				`&-placement-leftTop`,
				`&-placement-leftBottom`,
				`&-placement-right`,
				`&-placement-rightTop`,
				`&-placement-rightBottom`
			].join(",")]: { [`${componentCls}-inner`]: { borderRadius: token$1.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS) } },
			[`${componentCls}-content`]: { position: "relative" }
		}), genPresetColor(token$1, (colorKey, { darkColor }) => ({ [`&${componentCls}-${colorKey}`]: {
			[`${componentCls}-inner`]: { backgroundColor: darkColor },
			[`${componentCls}-arrow`]: { "--antd-arrow-background-color": darkColor }
		} }))), { "&-rtl": { direction: "rtl" } }) },
		getArrowStyle(token$1, "var(--antd-arrow-background-color)"),
		{ [`${componentCls}-pure`]: {
			position: "relative",
			maxWidth: "none",
			margin: token$1.sizePopupArrow
		} }
	];
};
const prepareComponentToken$45 = (token$1) => Object.assign(Object.assign({ zIndexPopup: token$1.zIndexPopupBase + 70 }, getArrowOffsetToken({
	contentRadius: token$1.borderRadius,
	limitVerticalRadius: true
})), getArrowToken(merge(token$1, { borderRadiusOuter: Math.min(token$1.borderRadiusOuter, 4) })));
var style_default$52 = (prefixCls, injectStyle = true) => {
	return genStyleHooks("Tooltip", (token$1) => {
		const { borderRadius, colorTextLightSolid, colorBgSpotlight } = token$1;
		const TooltipToken = merge(token$1, {
			tooltipMaxWidth: 250,
			tooltipColor: colorTextLightSolid,
			tooltipBorderRadius: borderRadius,
			tooltipBg: colorBgSpotlight
		});
		return [genTooltipStyle(TooltipToken), initZoomMotion(token$1, "zoom-big-fast")];
	}, prepareComponentToken$45, {
		resetStyle: false,
		injectStyle
	})(prefixCls);
};

//#endregion
//#region node_modules/antd/es/_util/colors.js
var inverseColors = PresetColors.map((color) => `${color}-inverse`);
const PresetStatusColorTypes = [
	"success",
	"processing",
	"error",
	"default",
	"warning"
];
/**
* determine if the color keyword belongs to the `Ant Design` {@link PresetColors}.
* @param color color to be judged
* @param includeInverse whether to include reversed colors
*/
function isPresetColor(color, includeInverse = true) {
	if (includeInverse) return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
	return PresetColors.includes(color);
}
function isPresetStatusColor(color) {
	return PresetStatusColorTypes.includes(color);
}

//#endregion
//#region node_modules/antd/es/tooltip/util.js
var import_classnames$211 = /* @__PURE__ */ __toESM(require_classnames());
function parseColor(prefixCls, color) {
	const isInternalColor = isPresetColor(color);
	const className = (0, import_classnames$211.default)({ [`${prefixCls}-${color}`]: color && isInternalColor });
	const overlayStyle = {};
	const arrowStyle = {};
	const rgb = generateColor(color).toRgb();
	const textColor = (.299 * rgb.r + .587 * rgb.g + .114 * rgb.b) / 255 < .5 ? "#FFF" : "#000";
	if (color && !isInternalColor) {
		overlayStyle.background = color;
		overlayStyle["--ant-tooltip-color"] = textColor;
		arrowStyle["--antd-arrow-background-color"] = color;
	}
	return {
		className,
		overlayStyle,
		arrowStyle
	};
}

//#endregion
//#region node_modules/antd/es/tooltip/PurePanel.js
var import_classnames$210 = /* @__PURE__ */ __toESM(require_classnames());
/** @private Internal Component. Do not use in your production. */
var PurePanel$10 = (props) => {
	const { prefixCls: customizePrefixCls, className, placement = "top", title, color, overlayInnerStyle } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$52(prefixCls);
	const colorInfo = parseColor(prefixCls, color);
	const arrowContentStyle = colorInfo.arrowStyle;
	const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
	const cls$12 = (0, import_classnames$210.default)(hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
		className: cls$12,
		style: arrowContentStyle
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-arrow` }), /* @__PURE__ */ import_react.createElement(Popup$1, Object.assign({}, props, {
		className: hashId,
		prefixCls,
		overlayInnerStyle: formattedOverlayInnerStyle
	}), title)));
};
var PurePanel_default$8 = PurePanel$10;

//#endregion
//#region node_modules/antd/es/tooltip/index.js
var import_classnames$209 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$96 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Tooltip = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a, _b;
	const { prefixCls: customizePrefixCls, openClassName, getTooltipContainer, color, overlayInnerStyle, children, afterOpenChange, afterVisibleChange, destroyTooltipOnHide, destroyOnHidden, arrow = true, title, overlay, builtinPlacements, arrowPointAtCenter = false, autoAdjustOverflow: autoAdjustOverflow$2 = true, motion: motion$1, getPopupContainer, placement = "top", mouseEnterDelay = .1, mouseLeaveDelay = .1, overlayStyle, rootClassName, overlayClassName, styles, classNames: tooltipClassNames } = props, restProps = __rest$96(props, [
		"prefixCls",
		"openClassName",
		"getTooltipContainer",
		"color",
		"overlayInnerStyle",
		"children",
		"afterOpenChange",
		"afterVisibleChange",
		"destroyTooltipOnHide",
		"destroyOnHidden",
		"arrow",
		"title",
		"overlay",
		"builtinPlacements",
		"arrowPointAtCenter",
		"autoAdjustOverflow",
		"motion",
		"getPopupContainer",
		"placement",
		"mouseEnterDelay",
		"mouseLeaveDelay",
		"overlayStyle",
		"rootClassName",
		"overlayClassName",
		"styles",
		"classNames"
	]);
	const mergedShowArrow = !!arrow;
	const [, token$1] = useToken();
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("tooltip");
	const warning$4 = devUseWarning("Tooltip");
	const tooltipRef = import_react.useRef(null);
	const forceAlign = () => {
		var _a$1;
		(_a$1 = tooltipRef.current) === null || _a$1 === void 0 || _a$1.forceAlign();
	};
	import_react.useImperativeHandle(ref, () => {
		var _a$1, _b$1;
		return {
			forceAlign,
			forcePopupAlign: () => {
				warning$4.deprecated(false, "forcePopupAlign", "forceAlign");
				forceAlign();
			},
			nativeElement: (_a$1 = tooltipRef.current) === null || _a$1 === void 0 ? void 0 : _a$1.nativeElement,
			popupElement: (_b$1 = tooltipRef.current) === null || _b$1 === void 0 ? void 0 : _b$1.popupElement
		};
	});
	[
		["visible", "open"],
		["defaultVisible", "defaultOpen"],
		["onVisibleChange", "onOpenChange"],
		["afterVisibleChange", "afterOpenChange"],
		["destroyTooltipOnHide", "destroyOnHidden"],
		["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"],
		["overlayStyle", "styles={{ root: {} }}"],
		["overlayInnerStyle", "styles={{ body: {} }}"],
		["overlayClassName", "classNames={{ root: \"\" }}"]
	].forEach(([deprecatedName, newName]) => {
		warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
	});
	warning$4(!destroyTooltipOnHide || typeof destroyTooltipOnHide === "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly.");
	warning$4(!arrow || typeof arrow === "boolean" || !("arrowPointAtCenter" in arrow), "deprecated", "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead.");
	const [open$2, setOpen] = useMergedState(false, {
		value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
		defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
	});
	const noTitle = !title && !overlay && title !== 0;
	const onOpenChange = (vis) => {
		var _a$1, _b$1;
		setOpen(noTitle ? false : vis);
		if (!noTitle) {
			(_a$1 = props.onOpenChange) === null || _a$1 === void 0 || _a$1.call(props, vis);
			(_b$1 = props.onVisibleChange) === null || _b$1 === void 0 || _b$1.call(props, vis);
		}
	};
	const tooltipPlacements = import_react.useMemo(() => {
		var _a$1, _b$1;
		let mergedArrowPointAtCenter = arrowPointAtCenter;
		if (typeof arrow === "object") mergedArrowPointAtCenter = (_b$1 = (_a$1 = arrow.pointAtCenter) !== null && _a$1 !== void 0 ? _a$1 : arrow.arrowPointAtCenter) !== null && _b$1 !== void 0 ? _b$1 : arrowPointAtCenter;
		return builtinPlacements || getPlacements({
			arrowPointAtCenter: mergedArrowPointAtCenter,
			autoAdjustOverflow: autoAdjustOverflow$2,
			arrowWidth: mergedShowArrow ? token$1.sizePopupArrow : 0,
			borderRadius: token$1.borderRadius,
			offset: token$1.marginXXS,
			visibleFirst: true
		});
	}, [
		arrowPointAtCenter,
		arrow,
		builtinPlacements,
		token$1
	]);
	const memoOverlay = import_react.useMemo(() => {
		if (title === 0) return title;
		return overlay || title || "";
	}, [overlay, title]);
	const memoOverlayWrapper = /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
	const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const injectFromPopover = props["data-popover-inject"];
	let tempOpen = open$2;
	if (!("open" in props) && !("visible" in props) && noTitle) tempOpen = false;
	const child = /* @__PURE__ */ import_react.isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ import_react.createElement("span", null, children);
	const childProps = child.props;
	const childCls = !childProps.className || typeof childProps.className === "string" ? (0, import_classnames$209.default)(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
	const [wrapCSSVar, hashId, cssVarCls] = style_default$52(prefixCls, !injectFromPopover);
	const colorInfo = parseColor(prefixCls, color);
	const arrowContentStyle = colorInfo.arrowStyle;
	const rootClassNames = (0, import_classnames$209.default)(overlayClassName, { [`${prefixCls}-rtl`]: direction === "rtl" }, colorInfo.className, rootClassName, hashId, cssVarCls, contextClassName, contextClassNames.root, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.root);
	const bodyClassNames = (0, import_classnames$209.default)(contextClassNames.body, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.body);
	const [zIndex, contextZIndex] = useZIndex("Tooltip", restProps.zIndex);
	const content = /* @__PURE__ */ import_react.createElement(es_default$32, Object.assign({}, restProps, {
		zIndex,
		showArrow: mergedShowArrow,
		placement,
		mouseEnterDelay,
		mouseLeaveDelay,
		prefixCls,
		classNames: {
			root: rootClassNames,
			body: bodyClassNames
		},
		styles: {
			root: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, arrowContentStyle), contextStyles.root), contextStyle), overlayStyle), styles === null || styles === void 0 ? void 0 : styles.root),
			body: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.body), overlayInnerStyle), styles === null || styles === void 0 ? void 0 : styles.body), colorInfo.overlayStyle)
		},
		getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
		ref: tooltipRef,
		builtinPlacements: tooltipPlacements,
		overlay: memoOverlayWrapper,
		visible: tempOpen,
		onVisibleChange: onOpenChange,
		afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
		arrowContent: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-arrow-content` }),
		motion: {
			motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
			motionDeadline: 1e3
		},
		destroyTooltipOnHide: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : !!destroyTooltipOnHide
	}), tempOpen ? cloneElement(child, { className: childCls }) : child);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, content));
});
Tooltip.displayName = "Tooltip";
Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$8;
var tooltip_default = Tooltip;

//#endregion
//#region node_modules/antd/es/popover/style/index.js
var genBaseStyle$12 = (token$1) => {
	const { componentCls, popoverColor, titleMinWidth, fontWeightStrong, innerPadding, boxShadowSecondary, colorTextHeading, borderRadiusLG, zIndexPopup, titleMarginBottom, colorBgElevated, popoverBg, titleBorderBottom, innerContentPadding, titlePadding } = token$1;
	return [
		{ [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "absolute",
			top: 0,
			left: {
				_skip_check_: true,
				value: 0
			},
			zIndex: zIndexPopup,
			fontWeight: "normal",
			whiteSpace: "normal",
			textAlign: "start",
			cursor: "auto",
			userSelect: "text",
			"--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
			transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" "),
			"--antd-arrow-background-color": colorBgElevated,
			width: "max-content",
			maxWidth: "100vw",
			"&-rtl": { direction: "rtl" },
			"&-hidden": { display: "none" },
			[`${componentCls}-content`]: { position: "relative" },
			[`${componentCls}-inner`]: {
				backgroundColor: popoverBg,
				backgroundClip: "padding-box",
				borderRadius: borderRadiusLG,
				boxShadow: boxShadowSecondary,
				padding: innerPadding
			},
			[`${componentCls}-title`]: {
				minWidth: titleMinWidth,
				marginBottom: titleMarginBottom,
				color: colorTextHeading,
				fontWeight: fontWeightStrong,
				borderBottom: titleBorderBottom,
				padding: titlePadding
			},
			[`${componentCls}-inner-content`]: {
				color: popoverColor,
				padding: innerContentPadding
			}
		}) },
		getArrowStyle(token$1, "var(--antd-arrow-background-color)"),
		{ [`${componentCls}-pure`]: {
			position: "relative",
			maxWidth: "none",
			margin: token$1.sizePopupArrow,
			display: "inline-block",
			[`${componentCls}-content`]: { display: "inline-block" }
		} }
	];
};
var genColorStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: PresetColors.map((colorKey) => {
		const lightColor = token$1[`${colorKey}6`];
		return { [`&${componentCls}-${colorKey}`]: {
			"--antd-arrow-background-color": lightColor,
			[`${componentCls}-inner`]: { backgroundColor: lightColor },
			[`${componentCls}-arrow`]: { background: "transparent" }
		} };
	}) };
};
const prepareComponentToken$44 = (token$1) => {
	const { lineWidth, controlHeight, fontHeight, padding, wireframe, zIndexPopupBase, borderRadiusLG, marginXS, lineType, colorSplit, paddingSM } = token$1;
	const titlePaddingBlockDist = controlHeight - fontHeight;
	const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
	const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
	const popoverPaddingHorizontal = padding;
	return Object.assign(Object.assign(Object.assign({
		titleMinWidth: 177,
		zIndexPopup: zIndexPopupBase + 30
	}, getArrowToken(token$1)), getArrowOffsetToken({
		contentRadius: borderRadiusLG,
		limitVerticalRadius: true
	})), {
		innerPadding: wireframe ? 0 : 12,
		titleMarginBottom: wireframe ? 0 : marginXS,
		titlePadding: wireframe ? `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px` : 0,
		titleBorderBottom: wireframe ? `${lineWidth}px ${lineType} ${colorSplit}` : "none",
		innerContentPadding: wireframe ? `${paddingSM}px ${popoverPaddingHorizontal}px` : 0
	});
};
var style_default$51 = genStyleHooks("Popover", (token$1) => {
	const { colorBgElevated, colorText } = token$1;
	const popoverToken = merge(token$1, {
		popoverBg: colorBgElevated,
		popoverColor: colorText
	});
	return [
		genBaseStyle$12(popoverToken),
		genColorStyle(popoverToken),
		initZoomMotion(popoverToken, "zoom-big")
	];
}, prepareComponentToken$44, {
	resetStyle: false,
	deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});

//#endregion
//#region node_modules/antd/es/popover/PurePanel.js
var import_classnames$208 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$95 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const Overlay$2 = ({ title, content, prefixCls }) => {
	if (!title && !content) return null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, title && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-title` }, title), content && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-inner-content` }, content));
};
const RawPurePanel = (props) => {
	const { hashId, prefixCls, className, style: style$1, placement = "top", title, content, children } = props;
	const titleNode = getRenderPropValue(title);
	const contentNode = getRenderPropValue(content);
	const cls$12 = (0, import_classnames$208.default)(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: cls$12,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-arrow` }), /* @__PURE__ */ import_react.createElement(Popup$1, Object.assign({}, props, {
		className: hashId,
		prefixCls
	}), children || /* @__PURE__ */ import_react.createElement(Overlay$2, {
		prefixCls,
		title: titleNode,
		content: contentNode
	})));
};
var PurePanel$9 = (props) => {
	const { prefixCls: customizePrefixCls, className } = props, restProps = __rest$95(props, ["prefixCls", "className"]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("popover", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$51(prefixCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(RawPurePanel, Object.assign({}, restProps, {
		prefixCls,
		hashId,
		className: (0, import_classnames$208.default)(className, cssVarCls)
	})));
};
var PurePanel_default$3 = PurePanel$9;

//#endregion
//#region node_modules/antd/es/popover/index.js
var import_classnames$207 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$94 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Popover = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a, _b;
	const { prefixCls: customizePrefixCls, title, content, overlayClassName, placement = "top", trigger = "hover", children, mouseEnterDelay = .1, mouseLeaveDelay = .1, onOpenChange, overlayStyle = {}, styles, classNames: popoverClassNames } = props, otherProps = __rest$94(props, [
		"prefixCls",
		"title",
		"content",
		"overlayClassName",
		"placement",
		"trigger",
		"children",
		"mouseEnterDelay",
		"mouseLeaveDelay",
		"onOpenChange",
		"overlayStyle",
		"styles",
		"classNames"
	]);
	const { getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("popover");
	const prefixCls = getPrefixCls("popover", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$51(prefixCls);
	const rootPrefixCls = getPrefixCls();
	const rootClassNames = (0, import_classnames$207.default)(overlayClassName, hashId, cssVarCls, contextClassName, contextClassNames.root, popoverClassNames === null || popoverClassNames === void 0 ? void 0 : popoverClassNames.root);
	const bodyClassNames = (0, import_classnames$207.default)(contextClassNames.body, popoverClassNames === null || popoverClassNames === void 0 ? void 0 : popoverClassNames.body);
	const [open$2, setOpen] = useMergedState(false, {
		value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
		defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
	});
	const settingOpen = (value, e$2) => {
		setOpen(value, true);
		onOpenChange === null || onOpenChange === void 0 || onOpenChange(value, e$2);
	};
	const onKeyDown$1 = (e$2) => {
		if (e$2.keyCode === KeyCode_default.ESC) settingOpen(false, e$2);
	};
	const onInternalOpenChange = (value) => {
		settingOpen(value);
	};
	const titleNode = getRenderPropValue(title);
	const contentNode = getRenderPropValue(content);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(tooltip_default, Object.assign({
		placement,
		trigger,
		mouseEnterDelay,
		mouseLeaveDelay
	}, otherProps, {
		prefixCls,
		classNames: {
			root: rootClassNames,
			body: bodyClassNames
		},
		styles: {
			root: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), contextStyle), overlayStyle), styles === null || styles === void 0 ? void 0 : styles.root),
			body: Object.assign(Object.assign({}, contextStyles.body), styles === null || styles === void 0 ? void 0 : styles.body)
		},
		ref,
		open: open$2,
		onOpenChange: onInternalOpenChange,
		overlay: titleNode || contentNode ? /* @__PURE__ */ import_react.createElement(Overlay$2, {
			prefixCls,
			title: titleNode,
			content: contentNode
		}) : null,
		transitionName: getTransitionName(rootPrefixCls, "zoom-big", otherProps.transitionName),
		"data-popover-inject": true
	}), cloneElement(children, { onKeyDown: (e$2) => {
		var _a$1, _b$1;
		if (/* @__PURE__ */ (0, import_react.isValidElement)(children)) (_b$1 = children === null || children === void 0 ? void 0 : (_a$1 = children.props).onKeyDown) === null || _b$1 === void 0 || _b$1.call(_a$1, e$2);
		onKeyDown$1(e$2);
	} })));
});
Popover._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$3;
Popover.displayName = "Popover";
var popover_default = Popover;

//#endregion
//#region node_modules/antd/es/avatar/AvatarGroup.js
var import_classnames$206 = /* @__PURE__ */ __toESM(require_classnames());
var AvatarContextProvider = (props) => {
	const { size, shape } = import_react.useContext(AvatarContext_default);
	const avatarContextValue = import_react.useMemo(() => ({
		size: props.size || size,
		shape: props.shape || shape
	}), [
		props.size,
		props.shape,
		size,
		shape
	]);
	return /* @__PURE__ */ import_react.createElement(AvatarContext_default.Provider, { value: avatarContextValue }, props.children);
};
var AvatarGroup = (props) => {
	var _a, _b, _c, _d;
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, maxCount, maxStyle, size, shape, maxPopoverPlacement, maxPopoverTrigger, children, max } = props;
	{
		const warning$4 = devUseWarning("Avatar.Group");
		[
			["maxCount", "max={{ count: number }}"],
			["maxStyle", "max={{ style: CSSProperties }}"],
			["maxPopoverPlacement", "max={{ popover: PopoverProps }}"],
			["maxPopoverTrigger", "max={{ popover: PopoverProps }}"]
		].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const prefixCls = getPrefixCls("avatar", customizePrefixCls);
	const groupPrefixCls = `${prefixCls}-group`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$50(prefixCls, rootCls);
	const cls$12 = (0, import_classnames$206.default)(groupPrefixCls, { [`${groupPrefixCls}-rtl`]: direction === "rtl" }, cssVarCls, rootCls, className, rootClassName, hashId);
	const childrenWithProps = toArray(children).map((child, index$2) => cloneElement(child, { key: `avatar-key-${index$2}` }));
	const mergeCount = (max === null || max === void 0 ? void 0 : max.count) || maxCount;
	const numOfChildren = childrenWithProps.length;
	if (mergeCount && mergeCount < numOfChildren) {
		const childrenShow = childrenWithProps.slice(0, mergeCount);
		const childrenHidden = childrenWithProps.slice(mergeCount, numOfChildren);
		const mergeStyle = (max === null || max === void 0 ? void 0 : max.style) || maxStyle;
		const mergePopoverTrigger = ((_a = max === null || max === void 0 ? void 0 : max.popover) === null || _a === void 0 ? void 0 : _a.trigger) || maxPopoverTrigger || "hover";
		const mergePopoverPlacement = ((_b = max === null || max === void 0 ? void 0 : max.popover) === null || _b === void 0 ? void 0 : _b.placement) || maxPopoverPlacement || "top";
		const mergeProps$2 = Object.assign(Object.assign({ content: childrenHidden }, max === null || max === void 0 ? void 0 : max.popover), {
			classNames: { root: (0, import_classnames$206.default)(`${groupPrefixCls}-popover`, (_d = (_c = max === null || max === void 0 ? void 0 : max.popover) === null || _c === void 0 ? void 0 : _c.classNames) === null || _d === void 0 ? void 0 : _d.root) },
			placement: mergePopoverPlacement,
			trigger: mergePopoverTrigger
		});
		childrenShow.push(/* @__PURE__ */ import_react.createElement(popover_default, Object.assign({
			key: "avatar-popover-key",
			destroyOnHidden: true
		}, mergeProps$2), /* @__PURE__ */ import_react.createElement(Avatar_default, { style: mergeStyle }, `+${numOfChildren - mergeCount}`)));
		return wrapCSSVar(/* @__PURE__ */ import_react.createElement(AvatarContextProvider, {
			shape,
			size
		}, /* @__PURE__ */ import_react.createElement("div", {
			className: cls$12,
			style: style$1
		}, childrenShow)));
	}
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(AvatarContextProvider, {
		shape,
		size
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: cls$12,
		style: style$1
	}, childrenWithProps)));
};
var AvatarGroup_default = AvatarGroup;

//#endregion
//#region node_modules/antd/es/avatar/index.js
var Avatar = Avatar_default;
Avatar.Group = AvatarGroup_default;
var avatar_default = Avatar;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/VerticalAlignTopOutlined.js
var VerticalAlignTopOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" }
		}]
	},
	"name": "vertical-align-top",
	"theme": "outlined"
};
var VerticalAlignTopOutlined_default$1 = VerticalAlignTopOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/VerticalAlignTopOutlined.js
/**![vertical-align-top](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg1OS45IDE2OEgxNjQuMWMtNC41IDAtOC4xIDMuNi04LjEgOHY2MGMwIDQuNCAzLjYgOCA4LjEgOGg2OTUuOGM0LjUgMCA4LjEtMy42IDguMS04di02MGMwLTQuNC0zLjYtOC04LjEtOHpNNTE4LjMgMzU1YTggOCAwIDAwLTEyLjYgMGwtMTEyIDE0MS43YTcuOTggNy45OCAwIDAwNi4zIDEyLjloNzMuOVY4NDhjMCA0LjQgMy42IDggOCA4aDYwYzQuNCAwIDgtMy42IDgtOFY1MDkuN0g2MjRjNi43IDAgMTAuNC03LjcgNi4zLTEyLjlMNTE4LjMgMzU1eiIgLz48L3N2Zz4=) */
var RefIcon$40 = /* @__PURE__ */ import_react.forwardRef(function VerticalAlignTopOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: VerticalAlignTopOutlined_default$1
	}));
});
RefIcon$40.displayName = "VerticalAlignTopOutlined";
var VerticalAlignTopOutlined_default = RefIcon$40;

//#endregion
//#region node_modules/antd/es/back-top/style/index.js
var genSharedBackTopStyle = (token$1) => {
	const { componentCls, backTopFontSize, backTopSize, zIndexPopup } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "fixed",
		insetInlineEnd: token$1.backTopInlineEnd,
		insetBlockEnd: token$1.backTopBlockEnd,
		zIndex: zIndexPopup,
		width: 40,
		height: 40,
		cursor: "pointer",
		"&:empty": { display: "none" },
		[`${componentCls}-content`]: {
			width: backTopSize,
			height: backTopSize,
			overflow: "hidden",
			color: token$1.backTopColor,
			textAlign: "center",
			backgroundColor: token$1.backTopBackground,
			borderRadius: backTopSize,
			transition: `all ${token$1.motionDurationMid}`,
			"&:hover": {
				backgroundColor: token$1.backTopHoverBackground,
				transition: `all ${token$1.motionDurationMid}`
			}
		},
		[`${componentCls}-icon`]: {
			fontSize: backTopFontSize,
			lineHeight: unit(backTopSize)
		}
	}) };
};
var genMediaBackTopStyle = (token$1) => {
	const { componentCls, screenMD, screenXS, backTopInlineEndMD, backTopInlineEndXS } = token$1;
	return {
		[`@media (max-width: ${unit(screenMD)})`]: { [componentCls]: { insetInlineEnd: backTopInlineEndMD } },
		[`@media (max-width: ${unit(screenXS)})`]: { [componentCls]: { insetInlineEnd: backTopInlineEndXS } }
	};
};
const prepareComponentToken$43 = (token$1) => ({ zIndexPopup: token$1.zIndexBase + 10 });
var style_default$49 = genStyleHooks("BackTop", (token$1) => {
	const { fontSizeHeading3, colorTextDescription, colorTextLightSolid, colorText, controlHeightLG, calc } = token$1;
	const backTopToken = merge(token$1, {
		backTopBackground: colorTextDescription,
		backTopColor: colorTextLightSolid,
		backTopHoverBackground: colorText,
		backTopFontSize: fontSizeHeading3,
		backTopSize: controlHeightLG,
		backTopBlockEnd: calc(controlHeightLG).mul(1.25).equal(),
		backTopInlineEnd: calc(controlHeightLG).mul(2.5).equal(),
		backTopInlineEndMD: calc(controlHeightLG).mul(1.5).equal(),
		backTopInlineEndXS: calc(controlHeightLG).mul(.5).equal()
	});
	return [genSharedBackTopStyle(backTopToken), genMediaBackTopStyle(backTopToken)];
}, prepareComponentToken$43);

//#endregion
//#region node_modules/antd/es/back-top/index.js
var import_classnames$205 = /* @__PURE__ */ __toESM(require_classnames());
var BackTop$1 = (props) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, visibilityHeight = 400, target, onClick, duration = 450 } = props;
	const [visible, setVisible] = import_react.useState(visibilityHeight === 0);
	const ref = import_react.useRef(null);
	const getDefaultTarget$1 = () => {
		var _a;
		return ((_a = ref.current) === null || _a === void 0 ? void 0 : _a.ownerDocument) || window;
	};
	const handleScroll = throttleByAnimationFrame_default((e$2) => {
		const scrollTop = getScroll_default(e$2.target);
		setVisible(scrollTop >= visibilityHeight);
	});
	devUseWarning("BackTop").deprecated(false, "BackTop", "FloatButton.BackTop");
	import_react.useEffect(() => {
		const container = (target || getDefaultTarget$1)();
		handleScroll({ target: container });
		container === null || container === void 0 || container.addEventListener("scroll", handleScroll);
		return () => {
			handleScroll.cancel();
			container === null || container === void 0 || container.removeEventListener("scroll", handleScroll);
		};
	}, [target]);
	const scrollToTop = (e$2) => {
		scrollTo(0, {
			getContainer: target || getDefaultTarget$1,
			duration
		});
		onClick === null || onClick === void 0 || onClick(e$2);
	};
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("back-top", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const [wrapCSSVar, hashId, cssVarCls] = style_default$49(prefixCls);
	const classString = (0, import_classnames$205.default)(hashId, cssVarCls, prefixCls, { [`${prefixCls}-rtl`]: direction === "rtl" }, className, rootClassName);
	const divProps = omit(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"children",
		"visibilityHeight",
		"target"
	]);
	const defaultElement = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-content` }, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-icon` }, /* @__PURE__ */ import_react.createElement(VerticalAlignTopOutlined_default, null)));
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({}, divProps, {
		className: classString,
		onClick: scrollToTop,
		ref
	}), /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible,
		motionName: `${rootPrefixCls}-fade`
	}, ({ className: motionClassName }) => cloneElement(props.children || defaultElement, ({ className: cloneCls }) => ({ className: (0, import_classnames$205.default)(motionClassName, cloneCls) })))));
};
BackTop$1.displayName = "BackTop";
var back_top_default = BackTop$1;

//#endregion
//#region node_modules/antd/es/badge/style/index.js
var antStatusProcessing = new Keyframes_default("antStatusProcessing", {
	"0%": {
		transform: "scale(0.8)",
		opacity: .5
	},
	"100%": {
		transform: "scale(2.4)",
		opacity: 0
	}
});
var antZoomBadgeIn = new Keyframes_default("antZoomBadgeIn", {
	"0%": {
		transform: "scale(0) translate(50%, -50%)",
		opacity: 0
	},
	"100%": { transform: "scale(1) translate(50%, -50%)" }
});
var antZoomBadgeOut = new Keyframes_default("antZoomBadgeOut", {
	"0%": { transform: "scale(1) translate(50%, -50%)" },
	"100%": {
		transform: "scale(0) translate(50%, -50%)",
		opacity: 0
	}
});
var antNoWrapperZoomBadgeIn = new Keyframes_default("antNoWrapperZoomBadgeIn", {
	"0%": {
		transform: "scale(0)",
		opacity: 0
	},
	"100%": { transform: "scale(1)" }
});
var antNoWrapperZoomBadgeOut = new Keyframes_default("antNoWrapperZoomBadgeOut", {
	"0%": { transform: "scale(1)" },
	"100%": {
		transform: "scale(0)",
		opacity: 0
	}
});
var antBadgeLoadingCircle = new Keyframes_default("antBadgeLoadingCircle", {
	"0%": { transformOrigin: "50%" },
	"100%": {
		transform: "translate(50%, -50%) rotate(360deg)",
		transformOrigin: "50%"
	}
});
var genSharedBadgeStyle = (token$1) => {
	const { componentCls, iconCls, antCls, badgeShadowSize, textFontSize, textFontSizeSM, statusSize, dotSize, textFontWeight, indicatorHeight, indicatorHeightSM, marginXS, calc } = token$1;
	const numberPrefixCls = `${antCls}-scroll-number`;
	const colorPreset = genPresetColor(token$1, (colorKey, { darkColor }) => ({ [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
		background: darkColor,
		[`&:not(${componentCls}-count)`]: { color: darkColor },
		"a:hover &": { background: darkColor }
	} }));
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "relative",
		display: "inline-block",
		width: "fit-content",
		lineHeight: 1,
		[`${componentCls}-count`]: {
			display: "inline-flex",
			justifyContent: "center",
			zIndex: token$1.indicatorZIndex,
			minWidth: indicatorHeight,
			height: indicatorHeight,
			color: token$1.badgeTextColor,
			fontWeight: textFontWeight,
			fontSize: textFontSize,
			lineHeight: unit(indicatorHeight),
			whiteSpace: "nowrap",
			textAlign: "center",
			background: token$1.badgeColor,
			borderRadius: calc(indicatorHeight).div(2).equal(),
			boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token$1.badgeShadowColor}`,
			transition: `background ${token$1.motionDurationMid}`,
			a: { color: token$1.badgeTextColor },
			"a:hover": { color: token$1.badgeTextColor },
			"a:hover &": { background: token$1.badgeColorHover }
		},
		[`${componentCls}-count-sm`]: {
			minWidth: indicatorHeightSM,
			height: indicatorHeightSM,
			fontSize: textFontSizeSM,
			lineHeight: unit(indicatorHeightSM),
			borderRadius: calc(indicatorHeightSM).div(2).equal()
		},
		[`${componentCls}-multiple-words`]: {
			padding: `0 ${unit(token$1.paddingXS)}`,
			bdi: { unicodeBidi: "plaintext" }
		},
		[`${componentCls}-dot`]: {
			zIndex: token$1.indicatorZIndex,
			width: dotSize,
			minWidth: dotSize,
			height: dotSize,
			background: token$1.badgeColor,
			borderRadius: "100%",
			boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token$1.badgeShadowColor}`
		},
		[`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
			position: "absolute",
			top: 0,
			insetInlineEnd: 0,
			transform: "translate(50%, -50%)",
			transformOrigin: "100% 0%",
			[`&${iconCls}-spin`]: {
				animationName: antBadgeLoadingCircle,
				animationDuration: "1s",
				animationIterationCount: "infinite",
				animationTimingFunction: "linear"
			}
		},
		[`&${componentCls}-status`]: {
			lineHeight: "inherit",
			verticalAlign: "baseline",
			[`${componentCls}-status-dot`]: {
				position: "relative",
				top: -1,
				display: "inline-block",
				width: statusSize,
				height: statusSize,
				verticalAlign: "middle",
				borderRadius: "50%"
			},
			[`${componentCls}-status-success`]: { backgroundColor: token$1.colorSuccess },
			[`${componentCls}-status-processing`]: {
				overflow: "visible",
				color: token$1.colorInfo,
				backgroundColor: token$1.colorInfo,
				borderColor: "currentcolor",
				"&::after": {
					position: "absolute",
					top: 0,
					insetInlineStart: 0,
					width: "100%",
					height: "100%",
					borderWidth: badgeShadowSize,
					borderStyle: "solid",
					borderColor: "inherit",
					borderRadius: "50%",
					animationName: antStatusProcessing,
					animationDuration: token$1.badgeProcessingDuration,
					animationIterationCount: "infinite",
					animationTimingFunction: "ease-in-out",
					content: "\"\""
				}
			},
			[`${componentCls}-status-default`]: { backgroundColor: token$1.colorTextPlaceholder },
			[`${componentCls}-status-error`]: { backgroundColor: token$1.colorError },
			[`${componentCls}-status-warning`]: { backgroundColor: token$1.colorWarning },
			[`${componentCls}-status-text`]: {
				marginInlineStart: marginXS,
				color: token$1.colorText,
				fontSize: token$1.fontSize
			}
		}
	}), colorPreset), {
		[`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
			animationName: antZoomBadgeIn,
			animationDuration: token$1.motionDurationSlow,
			animationTimingFunction: token$1.motionEaseOutBack,
			animationFillMode: "both"
		},
		[`${componentCls}-zoom-leave`]: {
			animationName: antZoomBadgeOut,
			animationDuration: token$1.motionDurationSlow,
			animationTimingFunction: token$1.motionEaseOutBack,
			animationFillMode: "both"
		},
		[`&${componentCls}-not-a-wrapper`]: {
			[`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
				animationName: antNoWrapperZoomBadgeIn,
				animationDuration: token$1.motionDurationSlow,
				animationTimingFunction: token$1.motionEaseOutBack
			},
			[`${componentCls}-zoom-leave`]: {
				animationName: antNoWrapperZoomBadgeOut,
				animationDuration: token$1.motionDurationSlow,
				animationTimingFunction: token$1.motionEaseOutBack
			},
			[`&:not(${componentCls}-status)`]: { verticalAlign: "middle" },
			[`${numberPrefixCls}-custom-component, ${componentCls}-count`]: { transform: "none" },
			[`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
				position: "relative",
				top: "auto",
				display: "block",
				transformOrigin: "50% 50%"
			}
		},
		[numberPrefixCls]: {
			overflow: "hidden",
			transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseOutBack}`,
			[`${numberPrefixCls}-only`]: {
				position: "relative",
				display: "inline-block",
				height: indicatorHeight,
				transition: `all ${token$1.motionDurationSlow} ${token$1.motionEaseOutBack}`,
				WebkitTransformStyle: "preserve-3d",
				WebkitBackfaceVisibility: "hidden",
				[`> p${numberPrefixCls}-only-unit`]: {
					height: indicatorHeight,
					margin: 0,
					WebkitTransformStyle: "preserve-3d",
					WebkitBackfaceVisibility: "hidden"
				}
			},
			[`${numberPrefixCls}-symbol`]: { verticalAlign: "top" }
		},
		"&-rtl": {
			direction: "rtl",
			[`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: { transform: "translate(-50%, -50%)" }
		}
	}) };
};
const prepareToken$3 = (token$1) => {
	const { fontHeight, lineWidth, marginXS, colorBorderBg } = token$1;
	const badgeFontHeight = fontHeight;
	const badgeShadowSize = lineWidth;
	const badgeTextColor = token$1.colorTextLightSolid;
	const badgeColor = token$1.colorError;
	const badgeColorHover = token$1.colorErrorHover;
	return merge(token$1, {
		badgeFontHeight,
		badgeShadowSize,
		badgeTextColor,
		badgeColor,
		badgeColorHover,
		badgeShadowColor: colorBorderBg,
		badgeProcessingDuration: "1.2s",
		badgeRibbonOffset: marginXS,
		badgeRibbonCornerTransform: "scaleY(0.75)",
		badgeRibbonCornerFilter: `brightness(75%)`
	});
};
const prepareComponentToken$42 = (token$1) => {
	const { fontSize, lineHeight, fontSizeSM, lineWidth } = token$1;
	return {
		indicatorZIndex: "auto",
		indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
		indicatorHeightSM: fontSize,
		dotSize: fontSizeSM / 2,
		textFontSize: fontSizeSM,
		textFontSizeSM: fontSizeSM,
		textFontWeight: "normal",
		statusSize: fontSizeSM / 2
	};
};
var style_default$48 = genStyleHooks("Badge", (token$1) => {
	const badgeToken = prepareToken$3(token$1);
	return genSharedBadgeStyle(badgeToken);
}, prepareComponentToken$42);

//#endregion
//#region node_modules/antd/es/badge/style/ribbon.js
var genRibbonStyle = (token$1) => {
	const { antCls, badgeFontHeight, marginXS, badgeRibbonOffset, calc } = token$1;
	const ribbonPrefixCls = `${antCls}-ribbon`;
	const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
	const statusRibbonPreset = genPresetColor(token$1, (colorKey, { darkColor }) => ({ [`&${ribbonPrefixCls}-color-${colorKey}`]: {
		background: darkColor,
		color: darkColor
	} }));
	return {
		[ribbonWrapperPrefixCls]: { position: "relative" },
		[ribbonPrefixCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "absolute",
			top: marginXS,
			padding: `0 ${unit(token$1.paddingXS)}`,
			color: token$1.colorPrimary,
			lineHeight: unit(badgeFontHeight),
			whiteSpace: "nowrap",
			backgroundColor: token$1.colorPrimary,
			borderRadius: token$1.borderRadiusSM,
			[`${ribbonPrefixCls}-text`]: { color: token$1.badgeTextColor },
			[`${ribbonPrefixCls}-corner`]: {
				position: "absolute",
				top: "100%",
				width: badgeRibbonOffset,
				height: badgeRibbonOffset,
				color: "currentcolor",
				border: `${unit(calc(badgeRibbonOffset).div(2).equal())} solid`,
				transform: token$1.badgeRibbonCornerTransform,
				transformOrigin: "top",
				filter: token$1.badgeRibbonCornerFilter
			}
		}), statusRibbonPreset), {
			[`&${ribbonPrefixCls}-placement-end`]: {
				insetInlineEnd: calc(badgeRibbonOffset).mul(-1).equal(),
				borderEndEndRadius: 0,
				[`${ribbonPrefixCls}-corner`]: {
					insetInlineEnd: 0,
					borderInlineEndColor: "transparent",
					borderBlockEndColor: "transparent"
				}
			},
			[`&${ribbonPrefixCls}-placement-start`]: {
				insetInlineStart: calc(badgeRibbonOffset).mul(-1).equal(),
				borderEndStartRadius: 0,
				[`${ribbonPrefixCls}-corner`]: {
					insetInlineStart: 0,
					borderBlockEndColor: "transparent",
					borderInlineStartColor: "transparent"
				}
			},
			"&-rtl": { direction: "rtl" }
		})
	};
};
var ribbon_default = genStyleHooks(["Badge", "Ribbon"], (token$1) => {
	const badgeToken = prepareToken$3(token$1);
	return genRibbonStyle(badgeToken);
}, prepareComponentToken$42);

//#endregion
//#region node_modules/antd/es/badge/Ribbon.js
var import_classnames$204 = /* @__PURE__ */ __toESM(require_classnames());
var Ribbon = (props) => {
	const { className, prefixCls: customizePrefixCls, style: style$1, color, children, text, placement = "end", rootClassName } = props;
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
	const wrapperCls = `${prefixCls}-wrapper`;
	const [wrapCSSVar, hashId, cssVarCls] = ribbon_default(prefixCls, wrapperCls);
	const colorInPreset = isPresetColor(color, false);
	const ribbonCls = (0, import_classnames$204.default)(prefixCls, `${prefixCls}-placement-${placement}`, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-color-${color}`]: colorInPreset
	}, className);
	const colorStyle = {};
	const cornerColorStyle = {};
	if (color && !colorInPreset) {
		colorStyle.background = color;
		cornerColorStyle.color = color;
	}
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$204.default)(wrapperCls, rootClassName, hashId, cssVarCls) }, children, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$204.default)(ribbonCls, hashId),
		style: Object.assign(Object.assign({}, colorStyle), style$1)
	}, /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-text` }, text), /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-corner`,
		style: cornerColorStyle
	}))));
};
Ribbon.displayName = "Ribbon";
var Ribbon_default = Ribbon;

//#endregion
//#region node_modules/antd/es/badge/SingleNumber.js
var import_classnames$203 = /* @__PURE__ */ __toESM(require_classnames());
var UnitNumber = (props) => {
	const { prefixCls, value, current, offset: offset$2 = 0 } = props;
	let style$1;
	if (offset$2) style$1 = {
		position: "absolute",
		top: `${offset$2}00%`,
		left: 0
	};
	return /* @__PURE__ */ import_react.createElement("span", {
		style: style$1,
		className: (0, import_classnames$203.default)(`${prefixCls}-only-unit`, { current })
	}, value);
};
function getOffset$5(start, end, unit$2) {
	let index$2 = start;
	let offset$2 = 0;
	while ((index$2 + 10) % 10 !== end) {
		index$2 += unit$2;
		offset$2 += unit$2;
	}
	return offset$2;
}
var SingleNumber = (props) => {
	const { prefixCls, count: originCount, value: originValue } = props;
	const value = Number(originValue);
	const count = Math.abs(originCount);
	const [prevValue, setPrevValue] = import_react.useState(value);
	const [prevCount, setPrevCount] = import_react.useState(count);
	const onTransitionEnd = () => {
		setPrevValue(value);
		setPrevCount(count);
	};
	import_react.useEffect(() => {
		const timer = setTimeout(onTransitionEnd, 1e3);
		return () => clearTimeout(timer);
	}, [value]);
	let unitNodes;
	let offsetStyle;
	if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
		unitNodes = [/* @__PURE__ */ import_react.createElement(UnitNumber, Object.assign({}, props, {
			key: value,
			current: true
		}))];
		offsetStyle = { transition: "none" };
	} else {
		unitNodes = [];
		const end = value + 10;
		const unitNumberList = [];
		for (let index$2 = value; index$2 <= end; index$2 += 1) unitNumberList.push(index$2);
		const unit$2 = prevCount < count ? 1 : -1;
		const prevIndex = unitNumberList.findIndex((n$1) => n$1 % 10 === prevValue);
		unitNodes = (unit$2 < 0 ? unitNumberList.slice(0, prevIndex + 1) : unitNumberList.slice(prevIndex)).map((n$1, index$2) => {
			const singleUnit = n$1 % 10;
			return /* @__PURE__ */ import_react.createElement(UnitNumber, Object.assign({}, props, {
				key: n$1,
				value: singleUnit,
				offset: unit$2 < 0 ? index$2 - prevIndex : index$2,
				current: index$2 === prevIndex
			}));
		});
		offsetStyle = { transform: `translateY(${-getOffset$5(prevValue, value, unit$2)}00%)` };
	}
	return /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-only`,
		style: offsetStyle,
		onTransitionEnd
	}, unitNodes);
};
var SingleNumber_default = SingleNumber;

//#endregion
//#region node_modules/antd/es/badge/ScrollNumber.js
var import_classnames$202 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$93 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var ScrollNumber = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, count, className, motionClassName, style: style$1, title, show, component: Component$2 = "sup", children } = props, restProps = __rest$93(props, [
		"prefixCls",
		"count",
		"className",
		"motionClassName",
		"style",
		"title",
		"show",
		"component",
		"children"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
	const newProps = Object.assign(Object.assign({}, restProps), {
		"data-show": show,
		style: style$1,
		className: (0, import_classnames$202.default)(prefixCls, className, motionClassName),
		title
	});
	let numberNodes = count;
	if (count && Number(count) % 1 === 0) {
		const numberList = String(count).split("");
		numberNodes = /* @__PURE__ */ import_react.createElement("bdi", null, numberList.map((num, i) => /* @__PURE__ */ import_react.createElement(SingleNumber_default, {
			prefixCls,
			count: Number(count),
			value: num,
			key: numberList.length - i
		})));
	}
	if (style$1 === null || style$1 === void 0 ? void 0 : style$1.borderColor) newProps.style = Object.assign(Object.assign({}, style$1), { boxShadow: `0 0 0 1px ${style$1.borderColor} inset` });
	if (children) return cloneElement(children, (oriProps) => ({ className: (0, import_classnames$202.default)(`${prefixCls}-custom-component`, oriProps === null || oriProps === void 0 ? void 0 : oriProps.className, motionClassName) }));
	return /* @__PURE__ */ import_react.createElement(Component$2, Object.assign({}, newProps, { ref }), numberNodes);
});
var ScrollNumber_default = ScrollNumber;

//#endregion
//#region node_modules/antd/es/badge/index.js
var import_classnames$201 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$92 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Badge = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a, _b, _c, _d, _e;
	const { prefixCls: customizePrefixCls, scrollNumberPrefixCls: customizeScrollNumberPrefixCls, children, status, text, color, count = null, overflowCount = 99, dot = false, size = "default", title, offset: offset$2, style: style$1, className, rootClassName, classNames: classNames$252, styles, showZero = false } = props, restProps = __rest$92(props, [
		"prefixCls",
		"scrollNumberPrefixCls",
		"children",
		"status",
		"text",
		"color",
		"count",
		"overflowCount",
		"dot",
		"size",
		"title",
		"offset",
		"style",
		"className",
		"rootClassName",
		"classNames",
		"styles",
		"showZero"
	]);
	const { getPrefixCls, direction, badge } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("badge", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$48(prefixCls);
	const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
	const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0 || text === "0" || text === 0;
	const ignoreCount = count === null || isZero && !showZero;
	const hasStatus = (status !== null && status !== void 0 || color !== null && color !== void 0) && ignoreCount;
	const hasStatusValue = status !== null && status !== void 0 || !isZero;
	const showAsDot = dot && !isZero;
	const mergedCount = showAsDot ? "" : numberedDisplayCount;
	const isHidden = (0, import_react.useMemo)(() => {
		return ((mergedCount === null || mergedCount === void 0 || mergedCount === "") && (text === void 0 || text === null || text === "") || isZero && !showZero) && !showAsDot;
	}, [
		mergedCount,
		isZero,
		showZero,
		showAsDot,
		text
	]);
	const countRef = (0, import_react.useRef)(count);
	if (!isHidden) countRef.current = count;
	const livingCount = countRef.current;
	const displayCountRef = (0, import_react.useRef)(mergedCount);
	if (!isHidden) displayCountRef.current = mergedCount;
	const displayCount = displayCountRef.current;
	const isDotRef = (0, import_react.useRef)(showAsDot);
	if (!isHidden) isDotRef.current = showAsDot;
	const mergedStyle = (0, import_react.useMemo)(() => {
		if (!offset$2) return Object.assign(Object.assign({}, badge === null || badge === void 0 ? void 0 : badge.style), style$1);
		const offsetStyle = { marginTop: offset$2[1] };
		if (direction === "rtl") offsetStyle.left = parseInt(offset$2[0], 10);
		else offsetStyle.right = -parseInt(offset$2[0], 10);
		return Object.assign(Object.assign(Object.assign({}, offsetStyle), badge === null || badge === void 0 ? void 0 : badge.style), style$1);
	}, [
		direction,
		offset$2,
		style$1,
		badge === null || badge === void 0 ? void 0 : badge.style
	]);
	const titleNode = title !== null && title !== void 0 ? title : typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0;
	const showStatusTextNode = !isHidden && (text === 0 ? showZero : !!text && text !== true);
	const statusTextNode = !showStatusTextNode ? null : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-status-text` }, text);
	const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement(livingCount, (oriProps) => ({ style: Object.assign(Object.assign({}, mergedStyle), oriProps.style) }));
	const isInternalColor = isPresetColor(color, false);
	const statusCls = (0, import_classnames$201.default)(classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.indicator, (_a = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _a === void 0 ? void 0 : _a.indicator, {
		[`${prefixCls}-status-dot`]: hasStatus,
		[`${prefixCls}-status-${status}`]: !!status,
		[`${prefixCls}-color-${color}`]: isInternalColor
	});
	const statusStyle = {};
	if (color && !isInternalColor) {
		statusStyle.color = color;
		statusStyle.background = color;
	}
	const badgeClassName = (0, import_classnames$201.default)(prefixCls, {
		[`${prefixCls}-status`]: hasStatus,
		[`${prefixCls}-not-a-wrapper`]: !children,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, rootClassName, badge === null || badge === void 0 ? void 0 : badge.className, (_b = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _b === void 0 ? void 0 : _b.root, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.root, hashId, cssVarCls);
	if (!children && hasStatus && (text || hasStatusValue || !ignoreCount)) {
		const statusTextColor = mergedStyle.color;
		return wrapCSSVar(/* @__PURE__ */ import_react.createElement("span", Object.assign({}, restProps, {
			className: badgeClassName,
			style: Object.assign(Object.assign(Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.root), (_c = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _c === void 0 ? void 0 : _c.root), mergedStyle)
		}), /* @__PURE__ */ import_react.createElement("span", {
			className: statusCls,
			style: Object.assign(Object.assign(Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.indicator), (_d = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _d === void 0 ? void 0 : _d.indicator), statusStyle)
		}), showStatusTextNode && /* @__PURE__ */ import_react.createElement("span", {
			style: { color: statusTextColor },
			className: `${prefixCls}-status-text`
		}, text)));
	}
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("span", Object.assign({ ref }, restProps, {
		className: badgeClassName,
		style: Object.assign(Object.assign({}, (_e = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _e === void 0 ? void 0 : _e.root), styles === null || styles === void 0 ? void 0 : styles.root)
	}), children, /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible: !isHidden,
		motionName: `${prefixCls}-zoom`,
		motionAppear: false,
		motionDeadline: 1e3
	}, ({ className: motionClassName }) => {
		var _a$1, _b$1;
		const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls);
		const isDot = isDotRef.current;
		const scrollNumberCls = (0, import_classnames$201.default)(classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.indicator, (_a$1 = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _a$1 === void 0 ? void 0 : _a$1.indicator, {
			[`${prefixCls}-dot`]: isDot,
			[`${prefixCls}-count`]: !isDot,
			[`${prefixCls}-count-sm`]: size === "small",
			[`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
			[`${prefixCls}-status-${status}`]: !!status,
			[`${prefixCls}-color-${color}`]: isInternalColor
		});
		let scrollNumberStyle = Object.assign(Object.assign(Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.indicator), (_b$1 = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _b$1 === void 0 ? void 0 : _b$1.indicator), mergedStyle);
		if (color && !isInternalColor) {
			scrollNumberStyle = scrollNumberStyle || {};
			scrollNumberStyle.background = color;
		}
		return /* @__PURE__ */ import_react.createElement(ScrollNumber_default, {
			prefixCls: scrollNumberPrefixCls,
			show: !isHidden,
			motionClassName,
			className: scrollNumberCls,
			count: displayCount,
			title: titleNode,
			style: scrollNumberStyle,
			key: "scrollNumber"
		}, displayNode);
	}), statusTextNode));
});
Badge.Ribbon = Ribbon_default;
Badge.displayName = "Badge";
var badge_default = Badge;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/LeftOutlined.js
var LeftOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" }
		}]
	},
	"name": "left",
	"theme": "outlined"
};
var LeftOutlined_default$1 = LeftOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/LeftOutlined.js
/**![left](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcyNCAyMTguM1YxNDFjMC02LjctNy43LTEwLjQtMTIuOS02LjNMMjYwLjMgNDg2LjhhMzEuODYgMzEuODYgMCAwMDAgNTAuM2w0NTAuOCAzNTIuMWM1LjMgNC4xIDEyLjkuNCAxMi45LTYuM3YtNzcuM2MwLTQuOS0yLjMtOS42LTYuMS0xMi42bC0zNjAtMjgxIDM2MC0yODEuMWMzLjgtMyA2LjEtNy43IDYuMS0xMi42eiIgLz48L3N2Zz4=) */
var RefIcon$39 = /* @__PURE__ */ import_react.forwardRef(function LeftOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: LeftOutlined_default$1
	}));
});
RefIcon$39.displayName = "LeftOutlined";
var LeftOutlined_default = RefIcon$39;

//#endregion
//#region node_modules/rc-dropdown/es/hooks/useAccessibility.js
var ESC$1 = KeyCode_default.ESC, TAB = KeyCode_default.TAB;
function useAccessibility$1(_ref) {
	var visible = _ref.visible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus, overlayRef = _ref.overlayRef;
	var focusMenuRef = import_react.useRef(false);
	var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus$1() {
		if (visible) {
			var _triggerRef$current, _triggerRef$current$f;
			(_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 || (_triggerRef$current$f = _triggerRef$current.focus) === null || _triggerRef$current$f === void 0 || _triggerRef$current$f.call(_triggerRef$current);
			onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(false);
		}
	};
	var focusMenu = function focusMenu$1() {
		var _overlayRef$current;
		if ((_overlayRef$current = overlayRef.current) !== null && _overlayRef$current !== void 0 && _overlayRef$current.focus) {
			overlayRef.current.focus();
			focusMenuRef.current = true;
			return true;
		}
		return false;
	};
	var handleKeyDown = function handleKeyDown$1(event) {
		switch (event.keyCode) {
			case ESC$1:
				handleCloseMenuAndReturnFocus();
				break;
			case TAB:
				var focusResult = false;
				if (!focusMenuRef.current) focusResult = focusMenu();
				if (focusResult) event.preventDefault();
				else handleCloseMenuAndReturnFocus();
				break;
		}
	};
	import_react.useEffect(function() {
		if (visible) {
			window.addEventListener("keydown", handleKeyDown);
			if (autoFocus) raf_default(focusMenu, 3);
			return function() {
				window.removeEventListener("keydown", handleKeyDown);
				focusMenuRef.current = false;
			};
		}
		return function() {
			focusMenuRef.current = false;
		};
	}, [visible]);
}

//#endregion
//#region node_modules/rc-dropdown/es/Overlay.js
var Overlay$1 = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var overlay = props.overlay, arrow = props.arrow, prefixCls = props.prefixCls;
	var overlayNode = (0, import_react.useMemo)(function() {
		var overlayElement;
		if (typeof overlay === "function") overlayElement = overlay();
		else overlayElement = overlay;
		return overlayElement;
	}, [overlay]);
	var composedRef = composeRef(ref, getNodeRef(overlayNode));
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, arrow && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-arrow") }), /* @__PURE__ */ import_react.cloneElement(overlayNode, { ref: supportRef(overlayNode) ? composedRef : void 0 }));
});
var Overlay_default = Overlay$1;

//#endregion
//#region node_modules/rc-dropdown/es/placements.js
var autoAdjustOverflow$1 = {
	adjustX: 1,
	adjustY: 1
};
var targetOffset$1 = [0, 0];
var placements$2 = {
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	top: {
		points: ["bc", "tc"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflow$1,
		offset: [0, -4],
		targetOffset: targetOffset$1
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	},
	bottom: {
		points: ["tc", "bc"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflow$1,
		offset: [0, 4],
		targetOffset: targetOffset$1
	}
};
var placements_default = placements$2;

//#endregion
//#region node_modules/rc-dropdown/es/Dropdown.js
var import_classnames$200 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$53 = [
	"arrow",
	"prefixCls",
	"transitionName",
	"animation",
	"align",
	"placement",
	"placements",
	"getPopupContainer",
	"showAction",
	"hideAction",
	"overlayClassName",
	"overlayStyle",
	"visible",
	"trigger",
	"autoFocus",
	"overlay",
	"children",
	"onVisibleChange"
];
function Dropdown$2(props, ref) {
	var _children$props;
	var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements$4 = _props$placements === void 0 ? placements_default : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, overlay = props.overlay, children = props.children, onVisibleChange = props.onVisibleChange, otherProps = _objectWithoutProperties(props, _excluded$53);
	var _React$useState = import_react.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
	var mergedVisible = "visible" in props ? visible : triggerVisible;
	var triggerRef = import_react.useRef(null);
	var overlayRef = import_react.useRef(null);
	var childRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, function() {
		return triggerRef.current;
	});
	var handleVisibleChange = function handleVisibleChange$1(newVisible) {
		setTriggerVisible(newVisible);
		onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(newVisible);
	};
	useAccessibility$1({
		visible: mergedVisible,
		triggerRef: childRef,
		onVisibleChange: handleVisibleChange,
		autoFocus,
		overlayRef
	});
	var onClick = function onClick$1(e$2) {
		var onOverlayClick = props.onOverlayClick;
		setTriggerVisible(false);
		if (onOverlayClick) onOverlayClick(e$2);
	};
	var getMenuElement = function getMenuElement$1() {
		return /* @__PURE__ */ import_react.createElement(Overlay_default, {
			ref: overlayRef,
			overlay,
			prefixCls,
			arrow
		});
	};
	var getMenuElementOrLambda = function getMenuElementOrLambda$1() {
		if (typeof overlay === "function") return getMenuElement;
		return getMenuElement();
	};
	var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger$1() {
		var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint = props.alignPoint;
		if ("minOverlayWidthMatchTrigger" in props) return minOverlayWidthMatchTrigger;
		return !alignPoint;
	};
	var childrenNode = /* @__PURE__ */ import_react.cloneElement(children, {
		className: (0, import_classnames$200.default)((_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.className, mergedVisible && function getOpenClassName() {
			var openClassName = props.openClassName;
			if (openClassName !== void 0) return openClassName;
			return "".concat(prefixCls, "-open");
		}()),
		ref: supportRef(children) ? composeRef(childRef, getNodeRef(children)) : void 0
	});
	var triggerHideAction = hideAction;
	if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) triggerHideAction = ["click"];
	return /* @__PURE__ */ import_react.createElement(es_default$7, _extends({ builtinPlacements: placements$4 }, otherProps, {
		prefixCls,
		ref: triggerRef,
		popupClassName: (0, import_classnames$200.default)(overlayClassName, _defineProperty({}, "".concat(prefixCls, "-show-arrow"), arrow)),
		popupStyle: overlayStyle,
		action: trigger,
		showAction,
		hideAction: triggerHideAction,
		popupPlacement: placement,
		popupAlign: align,
		popupTransitionName: transitionName,
		popupAnimation: animation,
		popupVisible: mergedVisible,
		stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
		popup: getMenuElementOrLambda(),
		onPopupVisibleChange: handleVisibleChange,
		onPopupClick: onClick,
		getPopupContainer
	}), childrenNode);
}
var Dropdown_default = /* @__PURE__ */ import_react.forwardRef(Dropdown$2);

//#endregion
//#region node_modules/rc-dropdown/es/index.js
var es_default$30 = Dropdown_default;

//#endregion
//#region node_modules/antd/es/_util/isPrimitive.js
var isPrimitive = (value) => typeof value !== "object" && typeof value !== "function" || value === null;
var isPrimitive_default = isPrimitive;

//#endregion
//#region node_modules/rc-menu/es/context/IdContext.js
var IdContext = /* @__PURE__ */ import_react.createContext(null);
function getMenuId(uuid$7, eventKey) {
	if (uuid$7 === void 0) return null;
	return "".concat(uuid$7, "-").concat(eventKey);
}
/**
* Get `data-menu-id`
*/
function useMenuId(eventKey) {
	var id = import_react.useContext(IdContext);
	return getMenuId(id, eventKey);
}

//#endregion
//#region node_modules/rc-menu/es/context/MenuContext.js
var _excluded$52 = ["children", "locked"];
var MenuContext$1 = /* @__PURE__ */ import_react.createContext(null);
function mergeProps(origin, target) {
	var clone = _objectSpread2({}, origin);
	Object.keys(target).forEach(function(key) {
		var value = target[key];
		if (value !== void 0) clone[key] = value;
	});
	return clone;
}
function InheritableContextProvider(_ref) {
	var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties(_ref, _excluded$52);
	var context = import_react.useContext(MenuContext$1);
	var inheritableContext = useMemo$1(function() {
		return mergeProps(context, restProps);
	}, [context, restProps], function(prev$1, next$1) {
		return !locked && (prev$1[0] !== next$1[0] || !isEqual_default(prev$1[1], next$1[1], true));
	});
	return /* @__PURE__ */ import_react.createElement(MenuContext$1.Provider, { value: inheritableContext }, children);
}

//#endregion
//#region node_modules/rc-menu/es/context/PathContext.js
var EmptyList = [];
var PathRegisterContext = /* @__PURE__ */ import_react.createContext(null);
function useMeasure() {
	return import_react.useContext(PathRegisterContext);
}
var PathTrackerContext = /* @__PURE__ */ import_react.createContext(EmptyList);
function useFullPath(eventKey) {
	var parentKeyPath = import_react.useContext(PathTrackerContext);
	return import_react.useMemo(function() {
		return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
	}, [parentKeyPath, eventKey]);
}
var PathUserContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/rc-menu/es/context/PrivateContext.js
var PrivateContext = /* @__PURE__ */ import_react.createContext({});
var PrivateContext_default = PrivateContext;

//#endregion
//#region node_modules/rc-util/es/Dom/focus.js
function focusable(node$1) {
	var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	if (isVisible_default(node$1)) {
		var nodeName = node$1.nodeName.toLowerCase();
		var isFocusableElement = [
			"input",
			"select",
			"textarea",
			"button"
		].includes(nodeName) || node$1.isContentEditable || nodeName === "a" && !!node$1.getAttribute("href");
		var tabIndexAttr = node$1.getAttribute("tabindex");
		var tabIndexNum = Number(tabIndexAttr);
		var tabIndex = null;
		if (tabIndexAttr && !Number.isNaN(tabIndexNum)) tabIndex = tabIndexNum;
		else if (isFocusableElement && tabIndex === null) tabIndex = 0;
		if (isFocusableElement && node$1.disabled) tabIndex = null;
		return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
	}
	return false;
}
function getFocusNodeList(node$1) {
	var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	var res = _toConsumableArray(node$1.querySelectorAll("*")).filter(function(child) {
		return focusable(child, includePositive);
	});
	if (focusable(node$1, includePositive)) res.unshift(node$1);
	return res;
}

//#endregion
//#region node_modules/rc-menu/es/hooks/useAccessibility.js
var LEFT = KeyCode_default.LEFT, RIGHT = KeyCode_default.RIGHT, UP = KeyCode_default.UP, DOWN = KeyCode_default.DOWN, ENTER = KeyCode_default.ENTER, ESC = KeyCode_default.ESC, HOME = KeyCode_default.HOME, END = KeyCode_default.END;
var ArrowKeys = [
	UP,
	DOWN,
	LEFT,
	RIGHT
];
function getOffset$4(mode, isRootLevel, isRtl, which) {
	var _offsets;
	var prev$1 = "prev";
	var next$1 = "next";
	var children = "children";
	var parent = "parent";
	if (mode === "inline" && which === ENTER) return { inlineTrigger: true };
	var inline$1 = _defineProperty(_defineProperty({}, UP, prev$1), DOWN, next$1);
	var horizontal = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LEFT, isRtl ? next$1 : prev$1), RIGHT, isRtl ? prev$1 : next$1), DOWN, children), ENTER, children);
	var vertical = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, UP, prev$1), DOWN, next$1), ENTER, children), ESC, parent), LEFT, isRtl ? children : parent), RIGHT, isRtl ? parent : children);
	switch ((_offsets = {
		inline: inline$1,
		horizontal,
		vertical,
		inlineSub: inline$1,
		horizontalSub: vertical,
		verticalSub: vertical
	}["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which]) {
		case prev$1: return {
			offset: -1,
			sibling: true
		};
		case next$1: return {
			offset: 1,
			sibling: true
		};
		case parent: return {
			offset: -1,
			sibling: false
		};
		case children: return {
			offset: 1,
			sibling: false
		};
		default: return null;
	}
}
function findContainerUL(element) {
	var current = element;
	while (current) {
		if (current.getAttribute("data-menu-list")) return current;
		current = current.parentElement;
	}
	/* istanbul ignore next */
	return null;
}
/**
* Find focused element within element set provided
*/
function getFocusElement(activeElement, elements) {
	var current = activeElement || document.activeElement;
	while (current) {
		if (elements.has(current)) return current;
		current = current.parentElement;
	}
	return null;
}
/**
* Get focusable elements from the element set under provided container
*/
function getFocusableElements(container, elements) {
	return getFocusNodeList(container, true).filter(function(ele) {
		return elements.has(ele);
	});
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
	var offset$2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
	if (!parentQueryContainer) return null;
	var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
	var count = sameLevelFocusableMenuElementList.length;
	var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
		return focusMenuElement === ele;
	});
	if (offset$2 < 0) if (focusIndex === -1) focusIndex = count - 1;
	else focusIndex -= 1;
	else if (offset$2 > 0) focusIndex += 1;
	focusIndex = (focusIndex + count) % count;
	return sameLevelFocusableMenuElementList[focusIndex];
}
var refreshElements = function refreshElements$1(keys$1, id) {
	var elements = /* @__PURE__ */ new Set();
	var key2element = /* @__PURE__ */ new Map();
	var element2key = /* @__PURE__ */ new Map();
	keys$1.forEach(function(key) {
		var element = document.querySelector("[data-menu-id='".concat(getMenuId(id, key), "']"));
		if (element) {
			elements.add(element);
			element2key.set(element, key);
			key2element.set(key, element);
		}
	});
	return {
		elements,
		key2element,
		element2key
	};
};
function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
	var rafRef = import_react.useRef();
	var activeRef = import_react.useRef();
	activeRef.current = activeKey;
	var cleanRaf = function cleanRaf$1() {
		raf_default.cancel(rafRef.current);
	};
	import_react.useEffect(function() {
		return function() {
			cleanRaf();
		};
	}, []);
	return function(e$2) {
		var which = e$2.which;
		if ([].concat(ArrowKeys, [
			ENTER,
			ESC,
			HOME,
			END
		]).includes(which)) {
			var keys$1 = getKeys();
			var refreshedElements = refreshElements(keys$1, id);
			var _refreshedElements = refreshedElements, elements = _refreshedElements.elements, key2element = _refreshedElements.key2element, element2key = _refreshedElements.element2key;
			var activeElement = key2element.get(activeKey);
			var focusMenuElement = getFocusElement(activeElement, elements);
			var focusMenuKey = element2key.get(focusMenuElement);
			var offsetObj = getOffset$4(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
			if (!offsetObj && which !== HOME && which !== END) return;
			if (ArrowKeys.includes(which) || [HOME, END].includes(which)) e$2.preventDefault();
			var tryFocus = function tryFocus$1(menuElement) {
				if (menuElement) {
					var focusTargetElement = menuElement;
					var link = menuElement.querySelector("a");
					if (link !== null && link !== void 0 && link.getAttribute("href")) focusTargetElement = link;
					var targetKey = element2key.get(menuElement);
					triggerActiveKey(targetKey);
					/**
					* Do not `useEffect` here since `tryFocus` may trigger async
					* which makes React sync update the `activeKey`
					* that force render before `useRef` set the next activeKey
					*/
					cleanRaf();
					rafRef.current = raf_default(function() {
						if (activeRef.current === targetKey) focusTargetElement.focus();
					});
				}
			};
			if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
				var parentQueryContainer;
				if (!focusMenuElement || mode === "inline") parentQueryContainer = containerRef.current;
				else parentQueryContainer = findContainerUL(focusMenuElement);
				var targetElement;
				var focusableElements = getFocusableElements(parentQueryContainer, elements);
				if (which === HOME) targetElement = focusableElements[0];
				else if (which === END) targetElement = focusableElements[focusableElements.length - 1];
				else targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
				tryFocus(targetElement);
			} else if (offsetObj.inlineTrigger) triggerAccessibilityOpen(focusMenuKey);
			else if (offsetObj.offset > 0) {
				triggerAccessibilityOpen(focusMenuKey, true);
				cleanRaf();
				rafRef.current = raf_default(function() {
					refreshedElements = refreshElements(keys$1, id);
					var controlId = focusMenuElement.getAttribute("aria-controls");
					var subQueryContainer = document.getElementById(controlId);
					var targetElement$1 = getNextFocusElement(subQueryContainer, refreshedElements.elements);
					tryFocus(targetElement$1);
				}, 5);
			} else if (offsetObj.offset < 0) {
				var keyPath = getKeyPath(focusMenuKey, true);
				var parentKey = keyPath[keyPath.length - 2];
				var parentMenuElement = key2element.get(parentKey);
				triggerAccessibilityOpen(parentKey, false);
				tryFocus(parentMenuElement);
			}
		}
		originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e$2);
	};
}

//#endregion
//#region node_modules/rc-menu/es/utils/timeUtil.js
function nextSlice(callback) {
	/* istanbul ignore next */
	Promise.resolve().then(callback);
}

//#endregion
//#region node_modules/rc-menu/es/hooks/useKeyRecords.js
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr = function getPathStr$1(keyPath) {
	return keyPath.join(PATH_SPLIT);
};
var getPathKeys = function getPathKeys$1(keyPathStr) {
	return keyPathStr.split(PATH_SPLIT);
};
var OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
	var _React$useState = import_react.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), internalForceUpdate = _React$useState2[1];
	var key2pathRef = (0, import_react.useRef)(/* @__PURE__ */ new Map());
	var path2keyRef = (0, import_react.useRef)(/* @__PURE__ */ new Map());
	var _React$useState3 = import_react.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
	var updateRef = (0, import_react.useRef)(0);
	var destroyRef = (0, import_react.useRef)(false);
	var forceUpdate = function forceUpdate$1() {
		if (!destroyRef.current) internalForceUpdate({});
	};
	var registerPath = (0, import_react.useCallback)(function(key, keyPath) {
		warning_default(!key2pathRef.current.has(key), "Duplicated key '".concat(key, "' used in Menu by path [").concat(keyPath.join(" > "), "]"));
		var connectedPath = getPathStr(keyPath);
		path2keyRef.current.set(connectedPath, key);
		key2pathRef.current.set(key, connectedPath);
		updateRef.current += 1;
		var id = updateRef.current;
		nextSlice(function() {
			if (id === updateRef.current) forceUpdate();
		});
	}, []);
	var unregisterPath = (0, import_react.useCallback)(function(key, keyPath) {
		var connectedPath = getPathStr(keyPath);
		path2keyRef.current.delete(connectedPath);
		key2pathRef.current.delete(key);
	}, []);
	var refreshOverflowKeys = (0, import_react.useCallback)(function(keys$1) {
		setOverflowKeys(keys$1);
	}, []);
	var getKeyPath = (0, import_react.useCallback)(function(eventKey, includeOverflow) {
		var fullPath = key2pathRef.current.get(eventKey) || "";
		var keys$1 = getPathKeys(fullPath);
		if (includeOverflow && overflowKeys.includes(keys$1[0])) keys$1.unshift(OVERFLOW_KEY);
		return keys$1;
	}, [overflowKeys]);
	var isSubPathKey = (0, import_react.useCallback)(function(pathKeys, eventKey) {
		return pathKeys.filter(function(item) {
			return item !== void 0;
		}).some(function(pathKey$1) {
			return getKeyPath(pathKey$1, true).includes(eventKey);
		});
	}, [getKeyPath]);
	var getKeys = function getKeys$1() {
		var keys$1 = _toConsumableArray(key2pathRef.current.keys());
		if (overflowKeys.length) keys$1.push(OVERFLOW_KEY);
		return keys$1;
	};
	/**
	* Find current key related child path keys
	*/
	var getSubPathKeys = (0, import_react.useCallback)(function(key) {
		var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
		var pathKeys = /* @__PURE__ */ new Set();
		_toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey$1) {
			if (pathKey$1.startsWith(connectedPath)) pathKeys.add(path2keyRef.current.get(pathKey$1));
		});
		return pathKeys;
	}, []);
	import_react.useEffect(function() {
		return function() {
			destroyRef.current = true;
		};
	}, []);
	return {
		registerPath,
		unregisterPath,
		refreshOverflowKeys,
		isSubPathKey,
		getKeyPath,
		getKeys,
		getSubPathKeys
	};
}

//#endregion
//#region node_modules/rc-menu/es/hooks/useMemoCallback.js
/**
* Cache callback function that always return same ref instead.
* This is used for context optimization.
*/
function useMemoCallback(func) {
	var funRef = import_react.useRef(func);
	funRef.current = func;
	var callback = import_react.useCallback(function() {
		var _funRef$current;
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
	}, []);
	return func ? callback : void 0;
}

//#endregion
//#region node_modules/rc-menu/es/hooks/useUUID.js
var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id) {
	var _useMergedState = useMergedState(id, { value: id }), _useMergedState2 = _slicedToArray(_useMergedState, 2), uuid$7 = _useMergedState2[0], setUUID = _useMergedState2[1];
	import_react.useEffect(function() {
		internalId += 1;
		var newId = "".concat(uniquePrefix, "-").concat(internalId);
		setUUID("rc-menu-uuid-".concat(newId));
	}, []);
	return uuid$7;
}

//#endregion
//#region node_modules/rc-menu/es/hooks/useActive.js
function useActive$1(eventKey, disabled, onMouseEnter, onMouseLeave) {
	var _React$useContext = import_react.useContext(MenuContext$1), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
	var ret = { active: activeKey === eventKey };
	if (!disabled) {
		ret.onMouseEnter = function(domEvent) {
			onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
				key: eventKey,
				domEvent
			});
			onActive(eventKey);
		};
		ret.onMouseLeave = function(domEvent) {
			onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
				key: eventKey,
				domEvent
			});
			onInactive(eventKey);
		};
	}
	return ret;
}

//#endregion
//#region node_modules/rc-menu/es/hooks/useDirectionStyle.js
function useDirectionStyle(level) {
	var _React$useContext = import_react.useContext(MenuContext$1), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
	if (mode !== "inline") return null;
	var len = level;
	return rtl ? { paddingRight: len * inlineIndent } : { paddingLeft: len * inlineIndent };
}

//#endregion
//#region node_modules/rc-menu/es/Icon.js
function Icon$2(_ref) {
	var icon = _ref.icon, props = _ref.props, children = _ref.children;
	var iconNode;
	if (icon === null || icon === false) return null;
	if (typeof icon === "function") iconNode = /* @__PURE__ */ import_react.createElement(icon, _objectSpread2({}, props));
	else if (typeof icon !== "boolean") iconNode = icon;
	return iconNode || children || null;
}

//#endregion
//#region node_modules/rc-menu/es/utils/warnUtil.js
var _excluded$51 = ["item"];
/**
* `onClick` event return `info.item` which point to react node directly.
* We should warning this since it will not work on FC.
*/
function warnItemProp(_ref) {
	var item = _ref.item, restInfo = _objectWithoutProperties(_ref, _excluded$51);
	Object.defineProperty(restInfo, "item", { get: function get$1() {
		warning_default(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
		return item;
	} });
	return restInfo;
}

//#endregion
//#region node_modules/rc-menu/es/MenuItem.js
var import_classnames$199 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$50 = [
	"title",
	"attribute",
	"elementRef"
], _excluded2$10 = [
	"style",
	"className",
	"eventKey",
	"warnKey",
	"disabled",
	"itemIcon",
	"children",
	"role",
	"onMouseEnter",
	"onMouseLeave",
	"onClick",
	"onKeyDown",
	"onFocus"
], _excluded3 = ["active"];
var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
	_inherits(LegacyMenuItem$1, _React$Component);
	var _super = _createSuper(LegacyMenuItem$1);
	function LegacyMenuItem$1() {
		_classCallCheck(this, LegacyMenuItem$1);
		return _super.apply(this, arguments);
	}
	_createClass(LegacyMenuItem$1, [{
		key: "render",
		value: function render$1() {
			var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties(_this$props, _excluded$50);
			var passedProps = omit(restProps, [
				"eventKey",
				"popupClassName",
				"popupOffset",
				"onTitleClick"
			]);
			warning_default(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
			return /* @__PURE__ */ import_react.createElement(es_default$31.Item, _extends({}, attribute, { title: typeof title === "string" ? title : void 0 }, passedProps, { ref: elementRef }));
		}
	}]);
	return LegacyMenuItem$1;
}(import_react.Component);
/**
* Real Menu Item component
*/
var InternalMenuItem = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var style$1 = props.style, className = props.className, eventKey = props.eventKey, warnKey = props.warnKey, disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown$1 = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties(props, _excluded2$10);
	var domDataId = useMenuId(eventKey);
	var _React$useContext = import_react.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
	var _React$useContext2 = import_react.useContext(PrivateContext_default), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
	var itemCls = "".concat(prefixCls, "-item");
	var legacyMenuItemRef = import_react.useRef();
	var elementRef = import_react.useRef();
	var mergedDisabled = contextDisabled || disabled;
	var mergedEleRef = useComposeRef(ref, elementRef);
	var connectedKeys = useFullPath(eventKey);
	if (warnKey) warning_default(false, "MenuItem should not leave undefined `key`.");
	var getEventInfo = function getEventInfo$1(e$2) {
		return {
			key: eventKey,
			keyPath: _toConsumableArray(connectedKeys).reverse(),
			item: legacyMenuItemRef.current,
			domEvent: e$2
		};
	};
	var mergedItemIcon = itemIcon || contextItemIcon;
	var _useActive = useActive$1(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded3);
	var selected = selectedKeys.includes(eventKey);
	var directionStyle = useDirectionStyle(connectedKeys.length);
	var onInternalClick = function onInternalClick$1(e$2) {
		if (mergedDisabled) return;
		var info = getEventInfo(e$2);
		onClick === null || onClick === void 0 || onClick(warnItemProp(info));
		onItemClick(info);
	};
	var onInternalKeyDown = function onInternalKeyDown$1(e$2) {
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(e$2);
		if (e$2.which === KeyCode_default.ENTER) {
			var info = getEventInfo(e$2);
			onClick === null || onClick === void 0 || onClick(warnItemProp(info));
			onItemClick(info);
		}
	};
	/**
	* Used for accessibility. Helper will focus element without key board.
	* We should manually trigger an active
	*/
	var onInternalFocus = function onInternalFocus$1(e$2) {
		onActive(eventKey);
		onFocus === null || onFocus === void 0 || onFocus(e$2);
	};
	var optionRoleProps = {};
	if (props.role === "option") optionRoleProps["aria-selected"] = selected;
	var renderNode = /* @__PURE__ */ import_react.createElement(LegacyMenuItem, _extends({
		ref: legacyMenuItemRef,
		elementRef: mergedEleRef,
		role: role === null ? "none" : role || "menuitem",
		tabIndex: disabled ? null : -1,
		"data-menu-id": overflowDisabled && domDataId ? null : domDataId
	}, omit(restProps, ["extra"]), activeProps, optionRoleProps, {
		component: "li",
		"aria-disabled": disabled,
		style: _objectSpread2(_objectSpread2({}, directionStyle), style$1),
		className: (0, import_classnames$199.default)(itemCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(itemCls, "-active"), active), "".concat(itemCls, "-selected"), selected), "".concat(itemCls, "-disabled"), mergedDisabled), className),
		onClick: onInternalClick,
		onKeyDown: onInternalKeyDown,
		onFocus: onInternalFocus
	}), children, /* @__PURE__ */ import_react.createElement(Icon$2, {
		props: _objectSpread2(_objectSpread2({}, props), {}, { isSelected: selected }),
		icon: mergedItemIcon
	}));
	if (_internalRenderMenuItem) renderNode = _internalRenderMenuItem(renderNode, props, { selected });
	return renderNode;
});
function MenuItem$1(props, ref) {
	var eventKey = props.eventKey;
	var measure = useMeasure();
	var connectedKeyPath = useFullPath(eventKey);
	import_react.useEffect(function() {
		if (measure) {
			measure.registerPath(eventKey, connectedKeyPath);
			return function() {
				measure.unregisterPath(eventKey, connectedKeyPath);
			};
		}
	}, [connectedKeyPath]);
	if (measure) return null;
	return /* @__PURE__ */ import_react.createElement(InternalMenuItem, _extends({}, props, { ref }));
}
var MenuItem_default = /* @__PURE__ */ import_react.forwardRef(MenuItem$1);

//#endregion
//#region node_modules/rc-menu/es/SubMenu/SubMenuList.js
var import_classnames$198 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$49 = ["className", "children"];
var SubMenuList = /* @__PURE__ */ import_react.forwardRef(function InternalSubMenuList(_ref, ref) {
	var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties(_ref, _excluded$49);
	var _React$useContext = import_react.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
	return /* @__PURE__ */ import_react.createElement("ul", _extends({
		className: (0, import_classnames$198.default)(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
		role: "menu"
	}, restProps, {
		"data-menu-list": true,
		ref
	}), children);
});
SubMenuList.displayName = "SubMenuList";
var SubMenuList_default = SubMenuList;

//#endregion
//#region node_modules/rc-menu/es/utils/commonUtil.js
function parseChildren(children, keyPath) {
	return toArray(children).map(function(child, index$2) {
		if (/* @__PURE__ */ import_react.isValidElement(child)) {
			var _eventKey, _child$props;
			var key = child.key;
			var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
			var emptyKey = eventKey === null || eventKey === void 0;
			if (emptyKey) eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index$2]).join("-"));
			var cloneProps = {
				key: eventKey,
				eventKey
			};
			if (emptyKey) cloneProps.warnKey = true;
			return /* @__PURE__ */ import_react.cloneElement(child, cloneProps);
		}
		return child;
	});
}

//#endregion
//#region node_modules/rc-menu/es/placements.js
var autoAdjustOverflow = {
	adjustX: 1,
	adjustY: 1
};
var placements$1 = {
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflow
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflow
	},
	leftTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflow
	},
	leftBottom: {
		points: ["br", "bl"],
		overflow: autoAdjustOverflow
	},
	rightTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflow
	},
	rightBottom: {
		points: ["bl", "br"],
		overflow: autoAdjustOverflow
	}
};
var placementsRtl = {
	topLeft: {
		points: ["bl", "tl"],
		overflow: autoAdjustOverflow
	},
	topRight: {
		points: ["br", "tr"],
		overflow: autoAdjustOverflow
	},
	bottomLeft: {
		points: ["tl", "bl"],
		overflow: autoAdjustOverflow
	},
	bottomRight: {
		points: ["tr", "br"],
		overflow: autoAdjustOverflow
	},
	rightTop: {
		points: ["tr", "tl"],
		overflow: autoAdjustOverflow
	},
	rightBottom: {
		points: ["br", "bl"],
		overflow: autoAdjustOverflow
	},
	leftTop: {
		points: ["tl", "tr"],
		overflow: autoAdjustOverflow
	},
	leftBottom: {
		points: ["bl", "br"],
		overflow: autoAdjustOverflow
	}
};

//#endregion
//#region node_modules/rc-menu/es/utils/motionUtil.js
function getMotion(mode, motion$1, defaultMotions) {
	if (motion$1) return motion$1;
	if (defaultMotions) return defaultMotions[mode] || defaultMotions.other;
}

//#endregion
//#region node_modules/rc-menu/es/SubMenu/PopupTrigger.js
var import_classnames$197 = /* @__PURE__ */ __toESM(require_classnames());
var popupPlacementMap = {
	horizontal: "bottomLeft",
	vertical: "rightTop",
	"vertical-left": "rightTop",
	"vertical-right": "leftTop"
};
function PopupTrigger(_ref) {
	var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
	var _React$useContext = import_react.useContext(MenuContext$1), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion$1 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
	var placement = rtl ? _objectSpread2(_objectSpread2({}, placementsRtl), builtinPlacements) : _objectSpread2(_objectSpread2({}, placements$1), builtinPlacements);
	var popupPlacement = popupPlacementMap[mode];
	var targetMotion = getMotion(mode, motion$1, defaultMotions);
	var targetMotionRef = import_react.useRef(targetMotion);
	if (mode !== "inline")
 /**
	* PopupTrigger is only used for vertical and horizontal types.
	* When collapsed is unfolded, the inline animation will destroy the vertical animation.
	*/
	targetMotionRef.current = targetMotion;
	var mergedMotion = _objectSpread2(_objectSpread2({}, targetMotionRef.current), {}, {
		leavedClassName: "".concat(prefixCls, "-hidden"),
		removeOnLeave: false,
		motionAppear: true
	});
	var visibleRef = import_react.useRef();
	import_react.useEffect(function() {
		visibleRef.current = raf_default(function() {
			setInnerVisible(visible);
		});
		return function() {
			raf_default.cancel(visibleRef.current);
		};
	}, [visible]);
	return /* @__PURE__ */ import_react.createElement(es_default$7, {
		prefixCls,
		popupClassName: (0, import_classnames$197.default)("".concat(prefixCls, "-popup"), _defineProperty({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
		stretch: mode === "horizontal" ? "minWidth" : null,
		getPopupContainer,
		builtinPlacements: placement,
		popupPlacement,
		popupVisible: innerVisible,
		popup,
		popupStyle,
		popupAlign: popupOffset && { offset: popupOffset },
		action: disabled ? [] : [triggerSubMenuAction],
		mouseEnterDelay: subMenuOpenDelay,
		mouseLeaveDelay: subMenuCloseDelay,
		onPopupVisibleChange: onVisibleChange,
		forceRender: forceSubMenuRender,
		popupMotion: mergedMotion,
		fresh: true
	}, children);
}

//#endregion
//#region node_modules/rc-menu/es/SubMenu/InlineSubMenuList.js
function InlineSubMenuList(_ref) {
	var id = _ref.id, open$2 = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
	var fixedMode = "inline";
	var _React$useContext = import_react.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion$1 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
	var sameModeRef = import_react.useRef(false);
	sameModeRef.current = mode === fixedMode;
	var _React$useState = import_react.useState(!sameModeRef.current), _React$useState2 = _slicedToArray(_React$useState, 2), destroy$2 = _React$useState2[0], setDestroy = _React$useState2[1];
	var mergedOpen = sameModeRef.current ? open$2 : false;
	import_react.useEffect(function() {
		if (sameModeRef.current) setDestroy(false);
	}, [mode]);
	var mergedMotion = _objectSpread2({}, getMotion(fixedMode, motion$1, defaultMotions));
	if (keyPath.length > 1) mergedMotion.motionAppear = false;
	var originOnVisibleChanged = mergedMotion.onVisibleChanged;
	mergedMotion.onVisibleChanged = function(newVisible) {
		if (!sameModeRef.current && !newVisible) setDestroy(true);
		return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
	};
	if (destroy$2) return null;
	return /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
		mode: fixedMode,
		locked: !sameModeRef.current
	}, /* @__PURE__ */ import_react.createElement(es_default$2, _extends({ visible: mergedOpen }, mergedMotion, {
		forceRender: forceSubMenuRender,
		removeOnLeave: false,
		leavedClassName: "".concat(prefixCls, "-hidden")
	}), function(_ref2) {
		var motionClassName = _ref2.className, motionStyle = _ref2.style;
		return /* @__PURE__ */ import_react.createElement(SubMenuList_default, {
			id,
			className: motionClassName,
			style: motionStyle
		}, children);
	}));
}

//#endregion
//#region node_modules/rc-menu/es/SubMenu/index.js
var import_classnames$196 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$48 = [
	"style",
	"className",
	"title",
	"eventKey",
	"warnKey",
	"disabled",
	"internalPopupClose",
	"children",
	"itemIcon",
	"expandIcon",
	"popupClassName",
	"popupOffset",
	"popupStyle",
	"onClick",
	"onMouseEnter",
	"onMouseLeave",
	"onTitleClick",
	"onTitleMouseEnter",
	"onTitleMouseLeave"
], _excluded2$9 = ["active"];
var InternalSubMenu = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var style$1 = props.style, className = props.className, title = props.title, eventKey = props.eventKey, warnKey = props.warnKey, disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, popupStyle = props.popupStyle, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties(props, _excluded$48);
	var domDataId = useMenuId(eventKey);
	var _React$useContext = import_react.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
	var _React$useContext2 = import_react.useContext(PrivateContext_default), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
	var _React$useContext3 = import_react.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
	var connectedPath = useFullPath();
	var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
	var mergedDisabled = contextDisabled || disabled;
	var elementRef = import_react.useRef();
	var popupRef = import_react.useRef();
	if (warnKey) warning_default(false, "SubMenu should not leave undefined `key`.");
	var mergedItemIcon = itemIcon !== null && itemIcon !== void 0 ? itemIcon : contextItemIcon;
	var mergedExpandIcon = expandIcon !== null && expandIcon !== void 0 ? expandIcon : contextExpandIcon;
	var originOpen = openKeys.includes(eventKey);
	var open$2 = !overflowDisabled && originOpen;
	var childrenSelected = isSubPathKey(selectedKeys, eventKey);
	var _useActive = useActive$1(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded2$9);
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
	var triggerChildrenActive = function triggerChildrenActive$1(newActive) {
		if (!mergedDisabled) setChildrenActive(newActive);
	};
	var onInternalMouseEnter = function onInternalMouseEnter$1(domEvent) {
		triggerChildrenActive(true);
		onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
			key: eventKey,
			domEvent
		});
	};
	var onInternalMouseLeave = function onInternalMouseLeave$1(domEvent) {
		triggerChildrenActive(false);
		onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
			key: eventKey,
			domEvent
		});
	};
	var mergedActive = import_react.useMemo(function() {
		if (active) return active;
		if (mode !== "inline") return childrenActive || isSubPathKey([activeKey], eventKey);
		return false;
	}, [
		mode,
		active,
		activeKey,
		childrenActive,
		eventKey,
		isSubPathKey
	]);
	var directionStyle = useDirectionStyle(connectedPath.length);
	var onInternalTitleClick = function onInternalTitleClick$1(e$2) {
		if (mergedDisabled) return;
		onTitleClick === null || onTitleClick === void 0 || onTitleClick({
			key: eventKey,
			domEvent: e$2
		});
		if (mode === "inline") onOpenChange(eventKey, !originOpen);
	};
	var onMergedItemClick = useMemoCallback(function(info) {
		onClick === null || onClick === void 0 || onClick(warnItemProp(info));
		onItemClick(info);
	});
	var onPopupVisibleChange = function onPopupVisibleChange$1(newVisible) {
		if (mode !== "inline") onOpenChange(eventKey, newVisible);
	};
	/**
	* Used for accessibility. Helper will focus element without key board.
	* We should manually trigger an active
	*/
	var onInternalFocus = function onInternalFocus$1() {
		onActive(eventKey);
	};
	var popupId = domDataId && "".concat(domDataId, "-popup");
	var expandIconNode = import_react.useMemo(function() {
		return /* @__PURE__ */ import_react.createElement(Icon$2, {
			icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
			props: _objectSpread2(_objectSpread2({}, props), {}, {
				isOpen: open$2,
				isSubMenu: true
			})
		}, /* @__PURE__ */ import_react.createElement("i", { className: "".concat(subMenuPrefixCls, "-arrow") }));
	}, [
		mode,
		mergedExpandIcon,
		props,
		open$2,
		subMenuPrefixCls
	]);
	var titleNode = /* @__PURE__ */ import_react.createElement("div", _extends({
		role: "menuitem",
		style: directionStyle,
		className: "".concat(subMenuPrefixCls, "-title"),
		tabIndex: mergedDisabled ? null : -1,
		ref: elementRef,
		title: typeof title === "string" ? title : null,
		"data-menu-id": overflowDisabled && domDataId ? null : domDataId,
		"aria-expanded": open$2,
		"aria-haspopup": true,
		"aria-controls": popupId,
		"aria-disabled": mergedDisabled,
		onClick: onInternalTitleClick,
		onFocus: onInternalFocus
	}, activeProps), title, expandIconNode);
	var triggerModeRef = import_react.useRef(mode);
	if (mode !== "inline" && connectedPath.length > 1) triggerModeRef.current = "vertical";
	else triggerModeRef.current = mode;
	if (!overflowDisabled) {
		var triggerMode = triggerModeRef.current;
		titleNode = /* @__PURE__ */ import_react.createElement(PopupTrigger, {
			mode: triggerMode,
			prefixCls: subMenuPrefixCls,
			visible: !internalPopupClose && open$2 && mode !== "inline",
			popupClassName,
			popupOffset,
			popupStyle,
			popup: /* @__PURE__ */ import_react.createElement(InheritableContextProvider, { mode: triggerMode === "horizontal" ? "vertical" : triggerMode }, /* @__PURE__ */ import_react.createElement(SubMenuList_default, {
				id: popupId,
				ref: popupRef
			}, children)),
			disabled: mergedDisabled,
			onVisibleChange: onPopupVisibleChange
		}, titleNode);
	}
	var listNode = /* @__PURE__ */ import_react.createElement(es_default$31.Item, _extends({
		ref,
		role: "none"
	}, restProps, {
		component: "li",
		style: style$1,
		className: (0, import_classnames$196.default)(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(subMenuPrefixCls, "-open"), open$2), "".concat(subMenuPrefixCls, "-active"), mergedActive), "".concat(subMenuPrefixCls, "-selected"), childrenSelected), "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled)),
		onMouseEnter: onInternalMouseEnter,
		onMouseLeave: onInternalMouseLeave
	}), titleNode, !overflowDisabled && /* @__PURE__ */ import_react.createElement(InlineSubMenuList, {
		id: popupId,
		open: open$2,
		keyPath: connectedPath
	}, children));
	if (_internalRenderSubMenuItem) listNode = _internalRenderSubMenuItem(listNode, props, {
		selected: childrenSelected,
		active: mergedActive,
		open: open$2,
		disabled: mergedDisabled
	});
	return /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
		onItemClick: onMergedItemClick,
		mode: mode === "horizontal" ? "vertical" : mode,
		itemIcon: mergedItemIcon,
		expandIcon: mergedExpandIcon
	}, listNode);
});
var SubMenu$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var eventKey = props.eventKey, children = props.children;
	var connectedKeyPath = useFullPath(eventKey);
	var childList = parseChildren(children, connectedKeyPath);
	var measure = useMeasure();
	import_react.useEffect(function() {
		if (measure) {
			measure.registerPath(eventKey, connectedKeyPath);
			return function() {
				measure.unregisterPath(eventKey, connectedKeyPath);
			};
		}
	}, [connectedKeyPath]);
	var renderNode;
	if (measure) renderNode = childList;
	else renderNode = /* @__PURE__ */ import_react.createElement(InternalSubMenu, _extends({ ref }, props), childList);
	return /* @__PURE__ */ import_react.createElement(PathTrackerContext.Provider, { value: connectedKeyPath }, renderNode);
});
SubMenu$1.displayName = "SubMenu";
var SubMenu_default$1 = SubMenu$1;

//#endregion
//#region node_modules/rc-menu/es/Divider.js
var import_classnames$195 = /* @__PURE__ */ __toESM(require_classnames());
function Divider$1(_ref) {
	var className = _ref.className, style$1 = _ref.style;
	var _React$useContext = import_react.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls;
	if (useMeasure()) return null;
	return /* @__PURE__ */ import_react.createElement("li", {
		role: "separator",
		className: (0, import_classnames$195.default)("".concat(prefixCls, "-item-divider"), className),
		style: style$1
	});
}

//#endregion
//#region node_modules/rc-menu/es/MenuItemGroup.js
var import_classnames$194 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$47 = [
	"className",
	"title",
	"eventKey",
	"children"
];
var InternalMenuItemGroup = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var className = props.className, title = props.title;
	props.eventKey;
	var children = props.children, restProps = _objectWithoutProperties(props, _excluded$47);
	var _React$useContext = import_react.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls;
	var groupPrefixCls = "".concat(prefixCls, "-item-group");
	return /* @__PURE__ */ import_react.createElement("li", _extends({
		ref,
		role: "presentation"
	}, restProps, {
		onClick: function onClick(e$2) {
			return e$2.stopPropagation();
		},
		className: (0, import_classnames$194.default)(groupPrefixCls, className)
	}), /* @__PURE__ */ import_react.createElement("div", {
		role: "presentation",
		className: "".concat(groupPrefixCls, "-title"),
		title: typeof title === "string" ? title : void 0
	}, title), /* @__PURE__ */ import_react.createElement("ul", {
		role: "group",
		className: "".concat(groupPrefixCls, "-list")
	}, children));
});
var MenuItemGroup = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var eventKey = props.eventKey, children = props.children;
	var connectedKeyPath = useFullPath(eventKey);
	var childList = parseChildren(children, connectedKeyPath);
	if (useMeasure()) return childList;
	return /* @__PURE__ */ import_react.createElement(InternalMenuItemGroup, _extends({ ref }, omit(props, ["warnKey"])), childList);
});
MenuItemGroup.displayName = "MenuItemGroup";
var MenuItemGroup_default = MenuItemGroup;

//#endregion
//#region node_modules/rc-menu/es/utils/nodeUtil.js
var _excluded$46 = [
	"label",
	"children",
	"key",
	"type",
	"extra"
];
function convertItemsToNodes(list, components$1, prefixCls) {
	var MergedMenuItem = components$1.item, MergedMenuItemGroup = components$1.group, MergedSubMenu = components$1.submenu, MergedDivider = components$1.divider;
	return (list || []).map(function(opt, index$2) {
		if (opt && _typeof(opt) === "object") {
			var _ref = opt, label = _ref.label, children = _ref.children, key = _ref.key, type$2 = _ref.type, extra = _ref.extra, restProps = _objectWithoutProperties(_ref, _excluded$46);
			var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index$2);
			if (children || type$2 === "group") {
				if (type$2 === "group") return /* @__PURE__ */ import_react.createElement(MergedMenuItemGroup, _extends({ key: mergedKey }, restProps, { title: label }), convertItemsToNodes(children, components$1, prefixCls));
				return /* @__PURE__ */ import_react.createElement(MergedSubMenu, _extends({ key: mergedKey }, restProps, { title: label }), convertItemsToNodes(children, components$1, prefixCls));
			}
			if (type$2 === "divider") return /* @__PURE__ */ import_react.createElement(MergedDivider, _extends({ key: mergedKey }, restProps));
			return /* @__PURE__ */ import_react.createElement(MergedMenuItem, _extends({ key: mergedKey }, restProps, { extra }), label, (!!extra || extra === 0) && /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-item-extra") }, extra));
		}
		return null;
	}).filter(function(opt) {
		return opt;
	});
}
function parseItems(children, items, keyPath, components$1, prefixCls) {
	var childNodes = children;
	var mergedComponents = _objectSpread2({
		divider: Divider$1,
		item: MenuItem_default,
		group: MenuItemGroup_default,
		submenu: SubMenu_default$1
	}, components$1);
	if (items) childNodes = convertItemsToNodes(items, mergedComponents, prefixCls);
	return parseChildren(childNodes, keyPath);
}

//#endregion
//#region node_modules/rc-menu/es/Menu.js
var import_classnames$193 = /* @__PURE__ */ __toESM(require_classnames());
var import_react_dom$4 = /* @__PURE__ */ __toESM(require_react_dom());
var _excluded$45 = [
	"prefixCls",
	"rootClassName",
	"style",
	"className",
	"tabIndex",
	"items",
	"children",
	"direction",
	"id",
	"mode",
	"inlineCollapsed",
	"disabled",
	"disabledOverflow",
	"subMenuOpenDelay",
	"subMenuCloseDelay",
	"forceSubMenuRender",
	"defaultOpenKeys",
	"openKeys",
	"activeKey",
	"defaultActiveFirst",
	"selectable",
	"multiple",
	"defaultSelectedKeys",
	"selectedKeys",
	"onSelect",
	"onDeselect",
	"inlineIndent",
	"motion",
	"defaultMotions",
	"triggerSubMenuAction",
	"builtinPlacements",
	"itemIcon",
	"expandIcon",
	"overflowedIndicator",
	"overflowedIndicatorPopupClassName",
	"getPopupContainer",
	"onClick",
	"onOpenChange",
	"onKeyDown",
	"openAnimation",
	"openTransitionName",
	"_internalRenderMenuItem",
	"_internalRenderSubMenuItem",
	"_internalComponents"
];
/**
* Menu modify after refactor:
* ## Add
* - disabled
*
* ## Remove
* - openTransitionName
* - openAnimation
* - onDestroy
* - siderCollapsed: Seems antd do not use this prop (Need test in antd)
* - collapsedWidth: Seems this logic should be handle by antd Layout.Sider
*/
var EMPTY_LIST$4 = [];
var Menu$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _childList$;
	var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref.rootClassName, style$1 = _ref.style, className = _ref.className, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref.items, children = _ref.children, direction = _ref.direction, id = _ref.id, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref.inlineCollapsed, disabled = _ref.disabled, disabledOverflow = _ref.disabledOverflow, _ref$subMenuOpenDelay = _ref.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? .1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? .1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref.forceSubMenuRender, defaultOpenKeys = _ref.defaultOpenKeys, openKeys = _ref.openKeys, activeKey = _ref.activeKey, defaultActiveFirst = _ref.defaultActiveFirst, _ref$selectable = _ref.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref.defaultSelectedKeys, selectedKeys = _ref.selectedKeys, onSelect = _ref.onSelect, onDeselect = _ref.onDeselect, _ref$inlineIndent = _ref.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion$1 = _ref.motion, defaultMotions = _ref.defaultMotions, _ref$triggerSubMenuAc = _ref.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref.builtinPlacements, itemIcon = _ref.itemIcon, expandIcon = _ref.expandIcon, _ref$overflowedIndica = _ref.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName, getPopupContainer = _ref.getPopupContainer, onClick = _ref.onClick, onOpenChange = _ref.onOpenChange, onKeyDown$1 = _ref.onKeyDown, openAnimation = _ref.openAnimation, openTransitionName = _ref.openTransitionName, _internalRenderMenuItem = _ref._internalRenderMenuItem, _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem, _internalComponents = _ref._internalComponents, restProps = _objectWithoutProperties(_ref, _excluded$45);
	var _React$useMemo = import_react.useMemo(function() {
		return [parseItems(children, items, EMPTY_LIST$4, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST$4, {}, prefixCls)];
	}, [
		children,
		items,
		_internalComponents
	]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), childList = _React$useMemo2[0], measureChildList = _React$useMemo2[1];
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
	var containerRef = import_react.useRef();
	var uuid$7 = useUUID(id);
	var isRtl = direction === "rtl";
	warning_default(!openAnimation && !openTransitionName, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
	var _useMergedState = useMergedState(defaultOpenKeys, {
		value: openKeys,
		postState: function postState(keys$1) {
			return keys$1 || EMPTY_LIST$4;
		}
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
	var triggerOpenKeys = function triggerOpenKeys$1(keys$1) {
		var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
		function doUpdate() {
			setMergedOpenKeys(keys$1);
			onOpenChange === null || onOpenChange === void 0 || onOpenChange(keys$1);
		}
		if (forceFlush) (0, import_react_dom$4.flushSync)(doUpdate);
		else doUpdate();
	};
	var _React$useState3 = import_react.useState(mergedOpenKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
	var mountRef = import_react.useRef(false);
	var _React$useMemo3 = import_react.useMemo(function() {
		if ((mode === "inline" || mode === "vertical") && inlineCollapsed) return ["vertical", inlineCollapsed];
		return [mode, false];
	}, [mode, inlineCollapsed]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 2), mergedMode = _React$useMemo4[0], mergedInlineCollapsed = _React$useMemo4[1];
	var isInlineMode = mergedMode === "inline";
	var _React$useState5 = import_react.useState(mergedMode), _React$useState6 = _slicedToArray(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
	var _React$useState7 = import_react.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
	import_react.useEffect(function() {
		setInternalMode(mergedMode);
		setInternalInlineCollapsed(mergedInlineCollapsed);
		if (!mountRef.current) return;
		if (isInlineMode) setMergedOpenKeys(inlineCacheOpenKeys);
		else triggerOpenKeys(EMPTY_LIST$4);
	}, [mergedMode, mergedInlineCollapsed]);
	var _React$useState9 = import_react.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
	var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
	import_react.useEffect(function() {
		if (isInlineMode) setInlineCacheOpenKeys(mergedOpenKeys);
	}, [mergedOpenKeys]);
	import_react.useEffect(function() {
		mountRef.current = true;
		return function() {
			mountRef.current = false;
		};
	}, []);
	var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
	var registerPathContext = import_react.useMemo(function() {
		return {
			registerPath,
			unregisterPath
		};
	}, [registerPath, unregisterPath]);
	var pathUserContext = import_react.useMemo(function() {
		return { isSubPathKey };
	}, [isSubPathKey]);
	import_react.useEffect(function() {
		refreshOverflowKeys(allVisible ? EMPTY_LIST$4 : childList.slice(lastVisibleIndex + 1).map(function(child) {
			return child.key;
		}));
	}, [lastVisibleIndex, allVisible]);
	var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), { value: activeKey }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
	var onActive = useMemoCallback(function(key) {
		setMergedActiveKey(key);
	});
	var onInactive = useMemoCallback(function() {
		setMergedActiveKey(void 0);
	});
	(0, import_react.useImperativeHandle)(ref, function() {
		return {
			list: containerRef.current,
			focus: function focus(options) {
				var _childList$find;
				var keys$1 = getKeys();
				var _refreshElements = refreshElements(keys$1, uuid$7), elements = _refreshElements.elements, key2element = _refreshElements.key2element, element2key = _refreshElements.element2key;
				var focusableElements = getFocusableElements(containerRef.current, elements);
				var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : focusableElements[0] ? element2key.get(focusableElements[0]) : (_childList$find = childList.find(function(node$1) {
					return !node$1.props.disabled;
				})) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
				var elementToFocus = key2element.get(shouldFocusKey);
				if (shouldFocusKey && elementToFocus) {
					var _elementToFocus$focus;
					elementToFocus === null || elementToFocus === void 0 || (_elementToFocus$focus = elementToFocus.focus) === null || _elementToFocus$focus === void 0 || _elementToFocus$focus.call(elementToFocus, options);
				}
			}
		};
	});
	var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
		value: selectedKeys,
		postState: function postState(keys$1) {
			if (Array.isArray(keys$1)) return keys$1;
			if (keys$1 === null || keys$1 === void 0) return EMPTY_LIST$4;
			return [keys$1];
		}
	}), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
	var triggerSelection = function triggerSelection$1(info) {
		if (selectable) {
			var targetKey = info.key;
			var exist = mergedSelectKeys.includes(targetKey);
			var newSelectKeys;
			if (multiple) if (exist) newSelectKeys = mergedSelectKeys.filter(function(key) {
				return key !== targetKey;
			});
			else newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
			else newSelectKeys = [targetKey];
			setMergedSelectKeys(newSelectKeys);
			var selectInfo = _objectSpread2(_objectSpread2({}, info), {}, { selectedKeys: newSelectKeys });
			if (exist) onDeselect === null || onDeselect === void 0 || onDeselect(selectInfo);
			else onSelect === null || onSelect === void 0 || onSelect(selectInfo);
		}
		if (!multiple && mergedOpenKeys.length && internalMode !== "inline") triggerOpenKeys(EMPTY_LIST$4);
	};
	/**
	* Click for item. SubMenu do not have selection status
	*/
	var onInternalClick = useMemoCallback(function(info) {
		onClick === null || onClick === void 0 || onClick(warnItemProp(info));
		triggerSelection(info);
	});
	var onInternalOpenChange = useMemoCallback(function(key, open$2) {
		var newOpenKeys = mergedOpenKeys.filter(function(k) {
			return k !== key;
		});
		if (open$2) newOpenKeys.push(key);
		else if (internalMode !== "inline") {
			var subPathKeys = getSubPathKeys(key);
			newOpenKeys = newOpenKeys.filter(function(k) {
				return !subPathKeys.has(k);
			});
		}
		if (!isEqual_default(mergedOpenKeys, newOpenKeys, true)) triggerOpenKeys(newOpenKeys, true);
	});
	var onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid$7, containerRef, getKeys, getKeyPath, setMergedActiveKey, function triggerAccessibilityOpen(key, open$2) {
		var nextOpen = open$2 !== null && open$2 !== void 0 ? open$2 : !mergedOpenKeys.includes(key);
		onInternalOpenChange(key, nextOpen);
	}, onKeyDown$1);
	import_react.useEffect(function() {
		setMounted(true);
	}, []);
	var privateContext = import_react.useMemo(function() {
		return {
			_internalRenderMenuItem,
			_internalRenderSubMenuItem
		};
	}, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
	var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : childList.map(function(child, index$2) {
		return /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
			key: child.key,
			overflowDisabled: index$2 > lastVisibleIndex
		}, child);
	});
	var container = /* @__PURE__ */ import_react.createElement(es_default$31, _extends({
		id,
		ref: containerRef,
		prefixCls: "".concat(prefixCls, "-overflow"),
		component: "ul",
		itemComponent: MenuItem_default,
		className: (0, import_classnames$193.default)(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), "".concat(prefixCls, "-rtl"), isRtl), rootClassName),
		dir: direction,
		style: style$1,
		role: "menu",
		tabIndex,
		data: wrappedChildList,
		renderRawItem: function renderRawItem(node$1) {
			return node$1;
		},
		renderRawRest: function renderRawRest(omitItems) {
			var len = omitItems.length;
			var originOmitItems = len ? childList.slice(-len) : null;
			return /* @__PURE__ */ import_react.createElement(SubMenu_default$1, {
				eventKey: OVERFLOW_KEY,
				title: overflowedIndicator,
				disabled: allVisible,
				internalPopupClose: len === 0,
				popupClassName: overflowedIndicatorPopupClassName
			}, originOmitItems);
		},
		maxCount: internalMode !== "horizontal" || disabledOverflow ? es_default$31.INVALIDATE : es_default$31.RESPONSIVE,
		ssr: "full",
		"data-menu-list": true,
		onVisibleChange: function onVisibleChange(newLastIndex) {
			setLastVisibleIndex(newLastIndex);
		},
		onKeyDown: onInternalKeyDown
	}, restProps));
	return /* @__PURE__ */ import_react.createElement(PrivateContext_default.Provider, { value: privateContext }, /* @__PURE__ */ import_react.createElement(IdContext.Provider, { value: uuid$7 }, /* @__PURE__ */ import_react.createElement(InheritableContextProvider, {
		prefixCls,
		rootClassName,
		mode: internalMode,
		openKeys: mergedOpenKeys,
		rtl: isRtl,
		disabled,
		motion: mounted ? motion$1 : null,
		defaultMotions: mounted ? defaultMotions : null,
		activeKey: mergedActiveKey,
		onActive,
		onInactive,
		selectedKeys: mergedSelectKeys,
		inlineIndent,
		subMenuOpenDelay,
		subMenuCloseDelay,
		forceSubMenuRender,
		builtinPlacements,
		triggerSubMenuAction,
		getPopupContainer,
		itemIcon,
		expandIcon,
		onItemClick: onInternalClick,
		onOpenChange: onInternalOpenChange
	}, /* @__PURE__ */ import_react.createElement(PathUserContext.Provider, { value: pathUserContext }, container), /* @__PURE__ */ import_react.createElement("div", {
		style: { display: "none" },
		"aria-hidden": true
	}, /* @__PURE__ */ import_react.createElement(PathRegisterContext.Provider, { value: registerPathContext }, measureChildList)))));
});
var Menu_default = Menu$1;

//#endregion
//#region node_modules/rc-menu/es/index.js
var ExportMenu = Menu_default;
ExportMenu.Item = MenuItem_default;
ExportMenu.SubMenu = SubMenu_default$1;
ExportMenu.ItemGroup = MenuItemGroup_default;
ExportMenu.Divider = Divider$1;
var es_default$14 = ExportMenu;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/BarsOutlined.js
var BarsOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" }
		}]
	},
	"name": "bars",
	"theme": "outlined"
};
var BarsOutlined_default$1 = BarsOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/BarsOutlined.js
/**![bars](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkxMiAxOTJIMzI4Yy00LjQgMC04IDMuNi04IDh2NTZjMCA0LjQgMy42IDggOCA4aDU4NGM0LjQgMCA4LTMuNiA4LTh2LTU2YzAtNC40LTMuNi04LTgtOHptMCAyODRIMzI4Yy00LjQgMC04IDMuNi04IDh2NTZjMCA0LjQgMy42IDggOCA4aDU4NGM0LjQgMCA4LTMuNiA4LTh2LTU2YzAtNC40LTMuNi04LTgtOHptMCAyODRIMzI4Yy00LjQgMC04IDMuNi04IDh2NTZjMCA0LjQgMy42IDggOCA4aDU4NGM0LjQgMCA4LTMuNiA4LTh2LTU2YzAtNC40LTMuNi04LTgtOHpNMTA0IDIyOGE1NiA1NiAwIDEwMTEyIDAgNTYgNTYgMCAxMC0xMTIgMHptMCAyODRhNTYgNTYgMCAxMDExMiAwIDU2IDU2IDAgMTAtMTEyIDB6bTAgMjg0YTU2IDU2IDAgMTAxMTIgMCA1NiA1NiAwIDEwLTExMiAweiIgLz48L3N2Zz4=) */
var RefIcon$38 = /* @__PURE__ */ import_react.forwardRef(function BarsOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: BarsOutlined_default$1
	}));
});
RefIcon$38.displayName = "BarsOutlined";
var BarsOutlined_default = RefIcon$38;

//#endregion
//#region node_modules/antd/es/layout/context.js
const LayoutContext = /* @__PURE__ */ import_react.createContext({ siderHook: {
	addSider: () => null,
	removeSider: () => null
} });

//#endregion
//#region node_modules/antd/es/layout/style/index.js
var genLayoutStyle = (token$1) => {
	const { antCls, componentCls, colorText, footerBg, headerHeight, headerPadding, headerColor, footerPadding, fontSize, bodyBg, headerBg } = token$1;
	return {
		[componentCls]: {
			display: "flex",
			flex: "auto",
			flexDirection: "column",
			minHeight: 0,
			background: bodyBg,
			"&, *": { boxSizing: "border-box" },
			[`&${componentCls}-has-sider`]: {
				flexDirection: "row",
				[`> ${componentCls}, > ${componentCls}-content`]: { width: 0 }
			},
			[`${componentCls}-header, &${componentCls}-footer`]: { flex: "0 0 auto" },
			"&-rtl": { direction: "rtl" }
		},
		[`${componentCls}-header`]: {
			height: headerHeight,
			padding: headerPadding,
			color: headerColor,
			lineHeight: unit(headerHeight),
			background: headerBg,
			[`${antCls}-menu`]: { lineHeight: "inherit" }
		},
		[`${componentCls}-footer`]: {
			padding: footerPadding,
			color: colorText,
			fontSize,
			background: footerBg
		},
		[`${componentCls}-content`]: {
			flex: "auto",
			color: colorText,
			minHeight: 0
		}
	};
};
const prepareComponentToken$41 = (token$1) => {
	const { colorBgLayout, controlHeight, controlHeightLG, colorText, controlHeightSM, marginXXS, colorTextLightSolid, colorBgContainer } = token$1;
	const paddingInline = controlHeightLG * 1.25;
	return {
		colorBgHeader: "#001529",
		colorBgBody: colorBgLayout,
		colorBgTrigger: "#002140",
		bodyBg: colorBgLayout,
		headerBg: "#001529",
		headerHeight: controlHeight * 2,
		headerPadding: `0 ${paddingInline}px`,
		headerColor: colorText,
		footerPadding: `${controlHeightSM}px ${paddingInline}px`,
		footerBg: colorBgLayout,
		siderBg: "#001529",
		triggerHeight: controlHeightLG + marginXXS * 2,
		triggerBg: "#002140",
		triggerColor: colorTextLightSolid,
		zeroTriggerWidth: controlHeightLG,
		zeroTriggerHeight: controlHeightLG,
		lightSiderBg: colorBgContainer,
		lightTriggerBg: colorBgContainer,
		lightTriggerColor: colorText
	};
};
const DEPRECATED_TOKENS = [
	["colorBgBody", "bodyBg"],
	["colorBgHeader", "headerBg"],
	["colorBgTrigger", "triggerBg"]
];
var style_default$23 = genStyleHooks("Layout", genLayoutStyle, prepareComponentToken$41, { deprecatedTokens: DEPRECATED_TOKENS });

//#endregion
//#region node_modules/antd/es/layout/style/sider.js
var genSiderStyle = (token$1) => {
	const { componentCls, siderBg, motionDurationMid, motionDurationSlow, antCls, triggerHeight, triggerColor, triggerBg, headerHeight, zeroTriggerWidth, zeroTriggerHeight, borderRadiusLG, lightSiderBg, lightTriggerColor, lightTriggerBg, bodyBg } = token$1;
	return { [componentCls]: {
		position: "relative",
		minWidth: 0,
		background: siderBg,
		transition: `all ${motionDurationMid}, background 0s`,
		"&-has-trigger": { paddingBottom: triggerHeight },
		"&-right": { order: 1 },
		[`${componentCls}-children`]: {
			height: "100%",
			marginTop: -.1,
			paddingTop: .1,
			[`${antCls}-menu${antCls}-menu-inline-collapsed`]: { width: "auto" }
		},
		[`&-zero-width ${componentCls}-children`]: { overflow: "hidden" },
		[`${componentCls}-trigger`]: {
			position: "fixed",
			bottom: 0,
			zIndex: 1,
			height: triggerHeight,
			color: triggerColor,
			lineHeight: unit(triggerHeight),
			textAlign: "center",
			background: triggerBg,
			cursor: "pointer",
			transition: `all ${motionDurationMid}`
		},
		[`${componentCls}-zero-width-trigger`]: {
			position: "absolute",
			top: headerHeight,
			insetInlineEnd: token$1.calc(zeroTriggerWidth).mul(-1).equal(),
			zIndex: 1,
			width: zeroTriggerWidth,
			height: zeroTriggerHeight,
			color: triggerColor,
			fontSize: token$1.fontSizeXL,
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			background: siderBg,
			borderRadius: `0 ${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0`,
			cursor: "pointer",
			transition: `background ${motionDurationSlow} ease`,
			"&::after": {
				position: "absolute",
				inset: 0,
				background: "transparent",
				transition: `all ${motionDurationSlow}`,
				content: "\"\""
			},
			"&:hover::after": { background: `rgba(255, 255, 255, 0.2)` },
			"&-right": {
				insetInlineStart: token$1.calc(zeroTriggerWidth).mul(-1).equal(),
				borderRadius: `${unit(borderRadiusLG)} 0 0 ${unit(borderRadiusLG)}`
			}
		},
		"&-light": {
			background: lightSiderBg,
			[`${componentCls}-trigger`]: {
				color: lightTriggerColor,
				background: lightTriggerBg
			},
			[`${componentCls}-zero-width-trigger`]: {
				color: lightTriggerColor,
				background: lightTriggerBg,
				border: `1px solid ${bodyBg}`,
				borderInlineStart: 0
			}
		}
	} };
};
var sider_default = genStyleHooks(["Layout", "Sider"], genSiderStyle, prepareComponentToken$41, { deprecatedTokens: DEPRECATED_TOKENS });

//#endregion
//#region node_modules/antd/es/layout/Sider.js
var import_classnames$192 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$91 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var dimensionMaxMap = {
	xs: "479.98px",
	sm: "575.98px",
	md: "767.98px",
	lg: "991.98px",
	xl: "1199.98px",
	xxl: "1599.98px"
};
var isNumeric = (value) => !Number.isNaN(Number.parseFloat(value)) && isFinite(value);
const SiderContext = /* @__PURE__ */ import_react.createContext({});
var generateId = (() => {
	let i = 0;
	return (prefix = "") => {
		i += 1;
		return `${prefix}${i}`;
	};
})();
var Sider = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, trigger, children, defaultCollapsed = false, theme = "dark", style: style$1 = {}, collapsible = false, reverseArrow = false, width = 200, collapsedWidth = 80, zeroWidthTriggerStyle, breakpoint, onCollapse, onBreakpoint } = props, otherProps = __rest$91(props, [
		"prefixCls",
		"className",
		"trigger",
		"children",
		"defaultCollapsed",
		"theme",
		"style",
		"collapsible",
		"reverseArrow",
		"width",
		"collapsedWidth",
		"zeroWidthTriggerStyle",
		"breakpoint",
		"onCollapse",
		"onBreakpoint"
	]);
	const { siderHook } = (0, import_react.useContext)(LayoutContext);
	const [collapsed, setCollapsed] = (0, import_react.useState)("collapsed" in props ? props.collapsed : defaultCollapsed);
	const [below, setBelow] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		if ("collapsed" in props) setCollapsed(props.collapsed);
	}, [props.collapsed]);
	const handleSetCollapsed = (value, type$2) => {
		if (!("collapsed" in props)) setCollapsed(value);
		onCollapse === null || onCollapse === void 0 || onCollapse(value, type$2);
	};
	const { getPrefixCls, direction } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("layout-sider", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = sider_default(prefixCls);
	const responsiveHandlerRef = (0, import_react.useRef)(null);
	responsiveHandlerRef.current = (mql) => {
		setBelow(mql.matches);
		onBreakpoint === null || onBreakpoint === void 0 || onBreakpoint(mql.matches);
		if (collapsed !== mql.matches) handleSetCollapsed(mql.matches, "responsive");
	};
	(0, import_react.useEffect)(() => {
		function responsiveHandler(mql$1) {
			var _a;
			return (_a = responsiveHandlerRef.current) === null || _a === void 0 ? void 0 : _a.call(responsiveHandlerRef, mql$1);
		}
		let mql;
		if (typeof (window === null || window === void 0 ? void 0 : window.matchMedia) !== "undefined" && breakpoint && breakpoint in dimensionMaxMap) {
			mql = window.matchMedia(`screen and (max-width: ${dimensionMaxMap[breakpoint]})`);
			addMediaQueryListener(mql, responsiveHandler);
			responsiveHandler(mql);
		}
		return () => {
			removeMediaQueryListener(mql, responsiveHandler);
		};
	}, [breakpoint]);
	(0, import_react.useEffect)(() => {
		const uniqueId = generateId("ant-sider-");
		siderHook.addSider(uniqueId);
		return () => siderHook.removeSider(uniqueId);
	}, []);
	const toggle = () => {
		handleSetCollapsed(!collapsed, "clickTrigger");
	};
	const divProps = omit(otherProps, ["collapsed"]);
	const rawWidth = collapsed ? collapsedWidth : width;
	const siderWidth = isNumeric(rawWidth) ? `${rawWidth}px` : String(rawWidth);
	const zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? /* @__PURE__ */ import_react.createElement("span", {
		onClick: toggle,
		className: (0, import_classnames$192.default)(`${prefixCls}-zero-width-trigger`, `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
		style: zeroWidthTriggerStyle
	}, trigger || /* @__PURE__ */ import_react.createElement(BarsOutlined_default, null)) : null;
	const reverseIcon = direction === "rtl" === !reverseArrow;
	const defaultTrigger = {
		expanded: reverseIcon ? /* @__PURE__ */ import_react.createElement(RightOutlined_default, null) : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null),
		collapsed: reverseIcon ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null)
	}[collapsed ? "collapsed" : "expanded"];
	const triggerDom = trigger !== null ? zeroWidthTrigger || /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-trigger`,
		onClick: toggle,
		style: { width: siderWidth }
	}, trigger || defaultTrigger) : null;
	const divStyle = Object.assign(Object.assign({}, style$1), {
		flex: `0 0 ${siderWidth}`,
		maxWidth: siderWidth,
		minWidth: siderWidth,
		width: siderWidth
	});
	const siderCls = (0, import_classnames$192.default)(prefixCls, `${prefixCls}-${theme}`, {
		[`${prefixCls}-collapsed`]: !!collapsed,
		[`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
		[`${prefixCls}-below`]: !!below,
		[`${prefixCls}-zero-width`]: parseFloat(siderWidth) === 0
	}, className, hashId, cssVarCls);
	const contextValue = import_react.useMemo(() => ({ siderCollapsed: collapsed }), [collapsed]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(SiderContext.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement("aside", Object.assign({ className: siderCls }, divProps, {
		style: divStyle,
		ref
	}), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-children` }, children), collapsible || below && zeroWidthTrigger ? triggerDom : null)));
});
Sider.displayName = "Sider";
var Sider_default = Sider;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/EllipsisOutlined.js
var EllipsisOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" }
		}]
	},
	"name": "ellipsis",
	"theme": "outlined"
};
var EllipsisOutlined_default$1 = EllipsisOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/EllipsisOutlined.js
/**![ellipsis](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE3NiA1MTFhNTYgNTYgMCAxMDExMiAwIDU2IDU2IDAgMTAtMTEyIDB6bTI4MCAwYTU2IDU2IDAgMTAxMTIgMCA1NiA1NiAwIDEwLTExMiAwem0yODAgMGE1NiA1NiAwIDEwMTEyIDAgNTYgNTYgMCAxMC0xMTIgMHoiIC8+PC9zdmc+) */
var RefIcon$37 = /* @__PURE__ */ import_react.forwardRef(function EllipsisOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: EllipsisOutlined_default$1
	}));
});
RefIcon$37.displayName = "EllipsisOutlined";
var EllipsisOutlined_default = RefIcon$37;

//#endregion
//#region node_modules/antd/es/menu/MenuContext.js
var MenuContext = /* @__PURE__ */ (0, import_react.createContext)({
	prefixCls: "",
	firstLevel: true,
	inlineCollapsed: false
});
var MenuContext_default = MenuContext;

//#endregion
//#region node_modules/antd/es/menu/MenuDivider.js
var import_classnames$191 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$90 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var MenuDivider = (props) => {
	const { prefixCls: customizePrefixCls, className, dashed } = props, restProps = __rest$90(props, [
		"prefixCls",
		"className",
		"dashed"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("menu", customizePrefixCls);
	const classString = (0, import_classnames$191.default)({ [`${prefixCls}-item-divider-dashed`]: !!dashed }, className);
	return /* @__PURE__ */ import_react.createElement(Divider$1, Object.assign({ className: classString }, restProps));
};
var MenuDivider_default = MenuDivider;

//#endregion
//#region node_modules/antd/es/menu/MenuItem.js
var import_classnames$190 = /* @__PURE__ */ __toESM(require_classnames());
var MenuItem = (props) => {
	var _a;
	const { className, children, icon, title, danger, extra } = props;
	const { prefixCls, firstLevel, direction, disableMenuItemTitleTooltip, inlineCollapsed: isInlineCollapsed } = import_react.useContext(MenuContext_default);
	const renderItemChildren = (inlineCollapsed) => {
		const label = children === null || children === void 0 ? void 0 : children[0];
		const wrapNode = /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$190.default)(`${prefixCls}-title-content`, { [`${prefixCls}-title-content-with-extra`]: !!extra || extra === 0 }) }, children);
		if (!icon || /* @__PURE__ */ import_react.isValidElement(children) && children.type === "span") {
			if (children && inlineCollapsed && firstLevel && typeof label === "string") return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-inline-collapsed-noicon` }, label.charAt(0));
		}
		return wrapNode;
	};
	const { siderCollapsed } = import_react.useContext(SiderContext);
	let tooltipTitle = title;
	if (typeof title === "undefined") tooltipTitle = firstLevel ? children : "";
	else if (title === false) tooltipTitle = "";
	const tooltipProps = { title: tooltipTitle };
	if (!siderCollapsed && !isInlineCollapsed) {
		tooltipProps.title = null;
		tooltipProps.open = false;
	}
	const childrenLength = toArray(children).length;
	let returnNode = /* @__PURE__ */ import_react.createElement(MenuItem_default, Object.assign({}, omit(props, [
		"title",
		"icon",
		"danger"
	]), {
		className: (0, import_classnames$190.default)({
			[`${prefixCls}-item-danger`]: danger,
			[`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
		}, className),
		title: typeof title === "string" ? title : void 0
	}), cloneElement(icon, { className: (0, import_classnames$190.default)(/* @__PURE__ */ import_react.isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : void 0, `${prefixCls}-item-icon`) }), renderItemChildren(isInlineCollapsed));
	if (!disableMenuItemTitleTooltip) returnNode = /* @__PURE__ */ import_react.createElement(tooltip_default, Object.assign({}, tooltipProps, {
		placement: direction === "rtl" ? "left" : "right",
		classNames: { root: `${prefixCls}-inline-collapsed-tooltip` }
	}), returnNode);
	return returnNode;
};
var MenuItem_default$1 = MenuItem;

//#endregion
//#region node_modules/antd/es/menu/OverrideContext.js
var __rest$89 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var OverrideContext = /* @__PURE__ */ import_react.createContext(null);
/** @internal Only used for Dropdown component. Do not use this in your production. */
const OverrideProvider = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { children } = props, restProps = __rest$89(props, ["children"]);
	const override = import_react.useContext(OverrideContext);
	const context = import_react.useMemo(() => Object.assign(Object.assign({}, override), restProps), [
		override,
		restProps.prefixCls,
		restProps.mode,
		restProps.selectable,
		restProps.rootClassName
	]);
	const canRef = supportNodeRef(children);
	const mergedRef = useComposeRef(ref, canRef ? getNodeRef(children) : null);
	return /* @__PURE__ */ import_react.createElement(OverrideContext.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, canRef ? /* @__PURE__ */ import_react.cloneElement(children, { ref: mergedRef }) : children));
});
/** @internal Only used for Dropdown component. Do not use this in your production. */
var OverrideContext_default = OverrideContext;

//#endregion
//#region node_modules/antd/es/menu/style/horizontal.js
var getHorizontalStyle = (token$1) => {
	const { componentCls, motionDurationSlow, horizontalLineHeight, colorSplit, lineWidth, lineType, itemPaddingInline } = token$1;
	return { [`${componentCls}-horizontal`]: {
		lineHeight: horizontalLineHeight,
		border: 0,
		borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
		boxShadow: "none",
		"&::after": {
			display: "block",
			clear: "both",
			height: 0,
			content: "\"\\20\""
		},
		[`${componentCls}-item, ${componentCls}-submenu`]: {
			position: "relative",
			display: "inline-block",
			verticalAlign: "bottom",
			paddingInline: itemPaddingInline
		},
		[`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: { backgroundColor: "transparent" },
		[`${componentCls}-item, ${componentCls}-submenu-title`]: { transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",") },
		[`${componentCls}-submenu-arrow`]: { display: "none" }
	} };
};
var horizontal_default$1 = getHorizontalStyle;

//#endregion
//#region node_modules/antd/es/menu/style/rtl.js
var getRTLStyle = ({ componentCls, menuArrowOffset, calc }) => ({
	[`${componentCls}-rtl`]: { direction: "rtl" },
	[`${componentCls}-submenu-rtl`]: { transformOrigin: "100% 0" },
	[`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: { [`${componentCls}-submenu-arrow`]: {
		"&::before": { transform: `rotate(-45deg) translateY(${unit(calc(menuArrowOffset).mul(-1).equal())})` },
		"&::after": { transform: `rotate(45deg) translateY(${unit(menuArrowOffset)})` }
	} }
});
var rtl_default$3 = getRTLStyle;

//#endregion
//#region node_modules/antd/es/menu/style/theme.js
var accessibilityFocus = (token$1) => genFocusOutline(token$1);
var getThemeStyle = (token$1, themeSuffix) => {
	const { componentCls, itemColor, itemSelectedColor, subMenuItemSelectedColor, groupTitleColor, itemBg, subMenuItemBg, itemSelectedBg, activeBarHeight, activeBarWidth, activeBarBorderWidth, motionDurationSlow, motionEaseInOut, motionEaseOut, itemPaddingInline, motionDurationMid, itemHoverColor, lineType, colorSplit, itemDisabledColor, dangerItemColor, dangerItemHoverColor, dangerItemSelectedColor, dangerItemActiveBg, dangerItemSelectedBg, popupBg, itemHoverBg, itemActiveBg, menuSubMenuBg, horizontalItemSelectedColor, horizontalItemSelectedBg, horizontalItemBorderRadius, horizontalItemHoverBg } = token$1;
	return { [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
		color: itemColor,
		background: itemBg,
		[`&${componentCls}-root:focus-visible`]: Object.assign({}, accessibilityFocus(token$1)),
		[`${componentCls}-item`]: { "&-group-title, &-extra": { color: groupTitleColor } },
		[`${componentCls}-submenu-selected > ${componentCls}-submenu-title`]: { color: subMenuItemSelectedColor },
		[`${componentCls}-item, ${componentCls}-submenu-title`]: {
			color: itemColor,
			[`&:not(${componentCls}-item-disabled):focus-visible`]: Object.assign({}, accessibilityFocus(token$1))
		},
		[`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: { color: `${itemDisabledColor} !important` },
		[`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: { [`&:hover, > ${componentCls}-submenu-title:hover`]: { color: itemHoverColor } },
		[`&:not(${componentCls}-horizontal)`]: {
			[`${componentCls}-item:not(${componentCls}-item-selected)`]: {
				"&:hover": { backgroundColor: itemHoverBg },
				"&:active": { backgroundColor: itemActiveBg }
			},
			[`${componentCls}-submenu-title`]: {
				"&:hover": { backgroundColor: itemHoverBg },
				"&:active": { backgroundColor: itemActiveBg }
			}
		},
		[`${componentCls}-item-danger`]: {
			color: dangerItemColor,
			[`&${componentCls}-item:hover`]: { [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: { color: dangerItemHoverColor } },
			[`&${componentCls}-item:active`]: { background: dangerItemActiveBg }
		},
		[`${componentCls}-item a`]: { "&, &:hover": { color: "inherit" } },
		[`${componentCls}-item-selected`]: {
			color: itemSelectedColor,
			[`&${componentCls}-item-danger`]: { color: dangerItemSelectedColor },
			"a, a:hover": { color: "inherit" }
		},
		[`& ${componentCls}-item-selected`]: {
			backgroundColor: itemSelectedBg,
			[`&${componentCls}-item-danger`]: { backgroundColor: dangerItemSelectedBg }
		},
		[`&${componentCls}-submenu > ${componentCls}`]: { backgroundColor: menuSubMenuBg },
		[`&${componentCls}-popup > ${componentCls}`]: { backgroundColor: popupBg },
		[`&${componentCls}-submenu-popup > ${componentCls}`]: { backgroundColor: popupBg },
		[`&${componentCls}-horizontal`]: Object.assign(Object.assign({}, themeSuffix === "dark" ? { borderBottom: 0 } : {}), { [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
			top: activeBarBorderWidth,
			marginTop: token$1.calc(activeBarBorderWidth).mul(-1).equal(),
			marginBottom: 0,
			borderRadius: horizontalItemBorderRadius,
			"&::after": {
				position: "absolute",
				insetInline: itemPaddingInline,
				bottom: 0,
				borderBottom: `${unit(activeBarHeight)} solid transparent`,
				transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
				content: "\"\""
			},
			"&:hover, &-active, &-open": {
				background: horizontalItemHoverBg,
				"&::after": {
					borderBottomWidth: activeBarHeight,
					borderBottomColor: horizontalItemSelectedColor
				}
			},
			"&-selected": {
				color: horizontalItemSelectedColor,
				backgroundColor: horizontalItemSelectedBg,
				"&:hover": { backgroundColor: horizontalItemSelectedBg },
				"&::after": {
					borderBottomWidth: activeBarHeight,
					borderBottomColor: horizontalItemSelectedColor
				}
			}
		} }),
		[`&${componentCls}-root`]: { [`&${componentCls}-inline, &${componentCls}-vertical`]: { borderInlineEnd: `${unit(activeBarBorderWidth)} ${lineType} ${colorSplit}` } },
		[`&${componentCls}-inline`]: {
			[`${componentCls}-sub${componentCls}-inline`]: { background: subMenuItemBg },
			[`${componentCls}-item`]: {
				position: "relative",
				"&::after": {
					position: "absolute",
					insetBlock: 0,
					insetInlineEnd: 0,
					borderInlineEnd: `${unit(activeBarWidth)} solid ${itemSelectedColor}`,
					transform: "scaleY(0.0001)",
					opacity: 0,
					transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
					content: "\"\""
				},
				[`&${componentCls}-item-danger`]: { "&::after": { borderInlineEndColor: dangerItemSelectedColor } }
			},
			[`${componentCls}-selected, ${componentCls}-item-selected`]: { "&::after": {
				transform: "scaleY(1)",
				opacity: 1,
				transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
			} }
		}
	} };
};
var theme_default$2 = getThemeStyle;

//#endregion
//#region node_modules/antd/es/menu/style/vertical.js
var getVerticalInlineStyle = (token$1) => {
	const { componentCls, itemHeight, itemMarginInline, padding, menuArrowSize, marginXS, itemMarginBlock, itemWidth, itemPaddingInline } = token$1;
	const paddingWithArrow = token$1.calc(menuArrowSize).add(padding).add(marginXS).equal();
	return {
		[`${componentCls}-item`]: {
			position: "relative",
			overflow: "hidden"
		},
		[`${componentCls}-item, ${componentCls}-submenu-title`]: {
			height: itemHeight,
			lineHeight: unit(itemHeight),
			paddingInline: itemPaddingInline,
			overflow: "hidden",
			textOverflow: "ellipsis",
			marginInline: itemMarginInline,
			marginBlock: itemMarginBlock,
			width: itemWidth
		},
		[`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
			height: itemHeight,
			lineHeight: unit(itemHeight)
		},
		[`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: { paddingInlineEnd: paddingWithArrow }
	};
};
var getVerticalStyle = (token$1) => {
	const { componentCls, iconCls, itemHeight, colorTextLightSolid, dropdownWidth, controlHeightLG, motionEaseOut, paddingXL, itemMarginInline, fontSizeLG, motionDurationFast, motionDurationSlow, paddingXS, boxShadowSecondary, collapsedWidth, collapsedIconSize } = token$1;
	const inlineItemStyle = {
		height: itemHeight,
		lineHeight: unit(itemHeight),
		listStylePosition: "inside",
		listStyleType: "disc"
	};
	return [
		{
			[componentCls]: { "&-inline, &-vertical": Object.assign({ [`&${componentCls}-root`]: { boxShadow: "none" } }, getVerticalInlineStyle(token$1)) },
			[`${componentCls}-submenu-popup`]: { [`${componentCls}-vertical`]: Object.assign(Object.assign({}, getVerticalInlineStyle(token$1)), { boxShadow: boxShadowSecondary }) }
		},
		{ [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
			minWidth: dropdownWidth,
			maxHeight: `calc(100vh - ${unit(token$1.calc(controlHeightLG).mul(2.5).equal())})`,
			padding: "0",
			overflow: "hidden",
			borderInlineEnd: 0,
			"&:not([class*='-active'])": {
				overflowX: "hidden",
				overflowY: "auto"
			}
		} },
		{ [`${componentCls}-inline`]: {
			width: "100%",
			[`&${componentCls}-root`]: { [`${componentCls}-item, ${componentCls}-submenu-title`]: {
				display: "flex",
				alignItems: "center",
				transition: [
					`border-color ${motionDurationSlow}`,
					`background ${motionDurationSlow}`,
					`padding ${motionDurationFast} ${motionEaseOut}`
				].join(","),
				[`> ${componentCls}-title-content`]: {
					flex: "auto",
					minWidth: 0,
					overflow: "hidden",
					textOverflow: "ellipsis"
				},
				"> *": { flex: "none" }
			} },
			[`${componentCls}-sub${componentCls}-inline`]: {
				padding: 0,
				border: 0,
				borderRadius: 0,
				boxShadow: "none",
				[`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
				[`& ${componentCls}-item-group-title`]: { paddingInlineStart: paddingXL }
			},
			[`${componentCls}-item`]: inlineItemStyle
		} },
		{ [`${componentCls}-inline-collapsed`]: {
			width: collapsedWidth,
			[`&${componentCls}-root`]: { [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: { [`> ${componentCls}-inline-collapsed-noicon`]: {
				fontSize: fontSizeLG,
				textAlign: "center"
			} } },
			[`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
				insetInlineStart: 0,
				paddingInline: `calc(50% - ${unit(token$1.calc(collapsedIconSize).div(2).equal())} - ${unit(itemMarginInline)})`,
				textOverflow: "clip",
				[`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: { opacity: 0 },
				[`${componentCls}-item-icon, ${iconCls}`]: {
					margin: 0,
					fontSize: collapsedIconSize,
					lineHeight: unit(itemHeight),
					"+ span": {
						display: "inline-block",
						opacity: 0
					}
				}
			},
			[`${componentCls}-item-icon, ${iconCls}`]: { display: "inline-block" },
			"&-tooltip": {
				pointerEvents: "none",
				[`${componentCls}-item-icon, ${iconCls}`]: { display: "none" },
				"a, a:hover": { color: colorTextLightSolid }
			},
			[`${componentCls}-item-group-title`]: Object.assign(Object.assign({}, textEllipsis), { paddingInline: paddingXS })
		} }
	];
};
var vertical_default$1 = getVerticalStyle;

//#endregion
//#region node_modules/antd/es/menu/style/index.js
var genMenuItemStyle = (token$1) => {
	const { componentCls, motionDurationSlow, motionDurationMid, motionEaseInOut, motionEaseOut, iconCls, iconSize, iconMarginInlineEnd } = token$1;
	return {
		[`${componentCls}-item, ${componentCls}-submenu-title`]: {
			position: "relative",
			display: "block",
			margin: 0,
			whiteSpace: "nowrap",
			cursor: "pointer",
			transition: [
				`border-color ${motionDurationSlow}`,
				`background ${motionDurationSlow}`,
				`padding calc(${motionDurationSlow} + 0.1s) ${motionEaseInOut}`
			].join(","),
			[`${componentCls}-item-icon, ${iconCls}`]: {
				minWidth: iconSize,
				fontSize: iconSize,
				transition: [
					`font-size ${motionDurationMid} ${motionEaseOut}`,
					`margin ${motionDurationSlow} ${motionEaseInOut}`,
					`color ${motionDurationSlow}`
				].join(","),
				"+ span": {
					marginInlineStart: iconMarginInlineEnd,
					opacity: 1,
					transition: [
						`opacity ${motionDurationSlow} ${motionEaseInOut}`,
						`margin ${motionDurationSlow}`,
						`color ${motionDurationSlow}`
					].join(",")
				}
			},
			[`${componentCls}-item-icon`]: Object.assign({}, resetIcon()),
			[`&${componentCls}-item-only-child`]: { [`> ${iconCls}, > ${componentCls}-item-icon`]: { marginInlineEnd: 0 } }
		},
		[`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
			background: "none !important",
			cursor: "not-allowed",
			"&::after": { borderColor: "transparent !important" },
			a: {
				color: "inherit !important",
				cursor: "not-allowed",
				pointerEvents: "none"
			},
			[`> ${componentCls}-submenu-title`]: {
				color: "inherit !important",
				cursor: "not-allowed"
			}
		}
	};
};
var genSubMenuArrowStyle = (token$1) => {
	const { componentCls, motionDurationSlow, motionEaseInOut, borderRadius, menuArrowSize, menuArrowOffset } = token$1;
	return { [`${componentCls}-submenu`]: {
		"&-expand-icon, &-arrow": {
			position: "absolute",
			top: "50%",
			insetInlineEnd: token$1.margin,
			width: menuArrowSize,
			color: "currentcolor",
			transform: "translateY(-50%)",
			transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
		},
		"&-arrow": {
			"&::before, &::after": {
				position: "absolute",
				width: token$1.calc(menuArrowSize).mul(.6).equal(),
				height: token$1.calc(menuArrowSize).mul(.15).equal(),
				backgroundColor: "currentcolor",
				borderRadius,
				transition: [
					`background ${motionDurationSlow} ${motionEaseInOut}`,
					`transform ${motionDurationSlow} ${motionEaseInOut}`,
					`top ${motionDurationSlow} ${motionEaseInOut}`,
					`color ${motionDurationSlow} ${motionEaseInOut}`
				].join(","),
				content: "\"\""
			},
			"&::before": { transform: `rotate(45deg) translateY(${unit(token$1.calc(menuArrowOffset).mul(-1).equal())})` },
			"&::after": { transform: `rotate(-45deg) translateY(${unit(menuArrowOffset)})` }
		}
	} };
};
var getBaseStyle = (token$1) => {
	const { antCls, componentCls, fontSize, motionDurationSlow, motionDurationMid, motionEaseInOut, paddingXS, padding, colorSplit, lineWidth, zIndexPopup, borderRadiusLG, subMenuItemBorderRadius, menuArrowSize, menuArrowOffset, lineType, groupTitleLineHeight, groupTitleFontSize } = token$1;
	return [
		{
			"": { [componentCls]: Object.assign(Object.assign({}, clearFix()), { "&-hidden": { display: "none" } }) },
			[`${componentCls}-submenu-hidden`]: { display: "none" }
		},
		{ [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), clearFix()), {
			marginBottom: 0,
			paddingInlineStart: 0,
			fontSize,
			lineHeight: 0,
			listStyle: "none",
			outline: "none",
			transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
			"ul, ol": {
				margin: 0,
				padding: 0,
				listStyle: "none"
			},
			"&-overflow": {
				display: "flex",
				[`${componentCls}-item`]: { flex: "none" }
			},
			[`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: { borderRadius: token$1.itemBorderRadius },
			[`${componentCls}-item-group-title`]: {
				padding: `${unit(paddingXS)} ${unit(padding)}`,
				fontSize: groupTitleFontSize,
				lineHeight: groupTitleLineHeight,
				transition: `all ${motionDurationSlow}`
			},
			[`&-horizontal ${componentCls}-submenu`]: { transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",") },
			[`${componentCls}-submenu, ${componentCls}-submenu-inline`]: { transition: [
				`border-color ${motionDurationSlow} ${motionEaseInOut}`,
				`background ${motionDurationSlow} ${motionEaseInOut}`,
				`padding ${motionDurationMid} ${motionEaseInOut}`
			].join(",") },
			[`${componentCls}-submenu ${componentCls}-sub`]: {
				cursor: "initial",
				transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
			},
			[`${componentCls}-title-content`]: {
				transition: `color ${motionDurationSlow}`,
				"&-with-extra": {
					display: "inline-flex",
					alignItems: "center",
					width: "100%"
				},
				[`> ${antCls}-typography-ellipsis-single-line`]: {
					display: "inline",
					verticalAlign: "unset"
				},
				[`${componentCls}-item-extra`]: {
					marginInlineStart: "auto",
					paddingInlineStart: token$1.padding
				}
			},
			[`${componentCls}-item a`]: { "&::before": {
				position: "absolute",
				inset: 0,
				backgroundColor: "transparent",
				content: "\"\""
			} },
			[`${componentCls}-item-divider`]: {
				overflow: "hidden",
				lineHeight: 0,
				borderColor: colorSplit,
				borderStyle: lineType,
				borderWidth: 0,
				borderTopWidth: lineWidth,
				marginBlock: lineWidth,
				padding: 0,
				"&-dashed": { borderStyle: "dashed" }
			}
		}), genMenuItemStyle(token$1)), {
			[`${componentCls}-item-group`]: { [`${componentCls}-item-group-list`]: {
				margin: 0,
				padding: 0,
				[`${componentCls}-item, ${componentCls}-submenu-title`]: { paddingInline: `${unit(token$1.calc(fontSize).mul(2).equal())} ${unit(padding)}` }
			} },
			"&-submenu": {
				"&-popup": {
					position: "absolute",
					zIndex: zIndexPopup,
					borderRadius: borderRadiusLG,
					boxShadow: "none",
					transformOrigin: "0 0",
					[`&${componentCls}-submenu`]: { background: "transparent" },
					"&::before": {
						position: "absolute",
						inset: 0,
						zIndex: -1,
						width: "100%",
						height: "100%",
						opacity: 0,
						content: "\"\""
					},
					[`> ${componentCls}`]: Object.assign(Object.assign(Object.assign({ borderRadius: borderRadiusLG }, genMenuItemStyle(token$1)), genSubMenuArrowStyle(token$1)), {
						[`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: { borderRadius: subMenuItemBorderRadius },
						[`${componentCls}-submenu-title::after`]: { transition: `transform ${motionDurationSlow} ${motionEaseInOut}` }
					})
				},
				[`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: { transformOrigin: "100% 0" },
				[`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: { transformOrigin: "100% 100%" },
				[`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: { transformOrigin: "0 100%" },
				[`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: { transformOrigin: "0 0" },
				[`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: { paddingInlineEnd: token$1.paddingXS },
				[`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: { paddingInlineStart: token$1.paddingXS },
				[`
          &-placement-topRight,
          &-placement-topLeft
          `]: { paddingBottom: token$1.paddingXS },
				[`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: { paddingTop: token$1.paddingXS }
			}
		}), genSubMenuArrowStyle(token$1)), {
			[`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
				"&::before": { transform: `rotate(-45deg) translateX(${unit(menuArrowOffset)})` },
				"&::after": { transform: `rotate(45deg) translateX(${unit(token$1.calc(menuArrowOffset).mul(-1).equal())})` }
			},
			[`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
				transform: `translateY(${unit(token$1.calc(menuArrowSize).mul(.2).mul(-1).equal())})`,
				"&::after": { transform: `rotate(-45deg) translateX(${unit(token$1.calc(menuArrowOffset).mul(-1).equal())})` },
				"&::before": { transform: `rotate(45deg) translateX(${unit(menuArrowOffset)})` }
			}
		}) },
		{ [`${antCls}-layout-header`]: { [componentCls]: { lineHeight: "inherit" } } }
	];
};
const prepareComponentToken$40 = (token$1) => {
	var _a, _b, _c;
	const { colorPrimary, colorError, colorTextDisabled, colorErrorBg, colorText, colorTextDescription, colorBgContainer, colorFillAlter, colorFillContent, lineWidth, lineWidthBold, controlItemBgActive, colorBgTextHover, controlHeightLG, lineHeight, colorBgElevated, marginXXS, padding, fontSize, controlHeightSM, fontSizeLG, colorTextLightSolid, colorErrorHover } = token$1;
	const activeBarWidth = (_a = token$1.activeBarWidth) !== null && _a !== void 0 ? _a : 0;
	const activeBarBorderWidth = (_b = token$1.activeBarBorderWidth) !== null && _b !== void 0 ? _b : lineWidth;
	const itemMarginInline = (_c = token$1.itemMarginInline) !== null && _c !== void 0 ? _c : token$1.marginXXS;
	const colorTextDark = new FastColor(colorTextLightSolid).setA(.65).toRgbString();
	return {
		dropdownWidth: 160,
		zIndexPopup: token$1.zIndexPopupBase + 50,
		radiusItem: token$1.borderRadiusLG,
		itemBorderRadius: token$1.borderRadiusLG,
		radiusSubMenuItem: token$1.borderRadiusSM,
		subMenuItemBorderRadius: token$1.borderRadiusSM,
		colorItemText: colorText,
		itemColor: colorText,
		colorItemTextHover: colorText,
		itemHoverColor: colorText,
		colorItemTextHoverHorizontal: colorPrimary,
		horizontalItemHoverColor: colorPrimary,
		colorGroupTitle: colorTextDescription,
		groupTitleColor: colorTextDescription,
		colorItemTextSelected: colorPrimary,
		itemSelectedColor: colorPrimary,
		subMenuItemSelectedColor: colorPrimary,
		colorItemTextSelectedHorizontal: colorPrimary,
		horizontalItemSelectedColor: colorPrimary,
		colorItemBg: colorBgContainer,
		itemBg: colorBgContainer,
		colorItemBgHover: colorBgTextHover,
		itemHoverBg: colorBgTextHover,
		colorItemBgActive: colorFillContent,
		itemActiveBg: controlItemBgActive,
		colorSubItemBg: colorFillAlter,
		subMenuItemBg: colorFillAlter,
		colorItemBgSelected: controlItemBgActive,
		itemSelectedBg: controlItemBgActive,
		colorItemBgSelectedHorizontal: "transparent",
		horizontalItemSelectedBg: "transparent",
		colorActiveBarWidth: 0,
		activeBarWidth,
		colorActiveBarHeight: lineWidthBold,
		activeBarHeight: lineWidthBold,
		colorActiveBarBorderSize: lineWidth,
		activeBarBorderWidth,
		colorItemTextDisabled: colorTextDisabled,
		itemDisabledColor: colorTextDisabled,
		colorDangerItemText: colorError,
		dangerItemColor: colorError,
		colorDangerItemTextHover: colorError,
		dangerItemHoverColor: colorError,
		colorDangerItemTextSelected: colorError,
		dangerItemSelectedColor: colorError,
		colorDangerItemBgActive: colorErrorBg,
		dangerItemActiveBg: colorErrorBg,
		colorDangerItemBgSelected: colorErrorBg,
		dangerItemSelectedBg: colorErrorBg,
		itemMarginInline,
		horizontalItemBorderRadius: 0,
		horizontalItemHoverBg: "transparent",
		itemHeight: controlHeightLG,
		groupTitleLineHeight: lineHeight,
		collapsedWidth: controlHeightLG * 2,
		popupBg: colorBgElevated,
		itemMarginBlock: marginXXS,
		itemPaddingInline: padding,
		horizontalLineHeight: `${controlHeightLG * 1.15}px`,
		iconSize: fontSize,
		iconMarginInlineEnd: controlHeightSM - fontSize,
		collapsedIconSize: fontSizeLG,
		groupTitleFontSize: fontSize,
		darkItemDisabledColor: new FastColor(colorTextLightSolid).setA(.25).toRgbString(),
		darkItemColor: colorTextDark,
		darkDangerItemColor: colorError,
		darkItemBg: "#001529",
		darkPopupBg: "#001529",
		darkSubMenuItemBg: "#000c17",
		darkItemSelectedColor: colorTextLightSolid,
		darkItemSelectedBg: colorPrimary,
		darkDangerItemSelectedBg: colorError,
		darkItemHoverBg: "transparent",
		darkGroupTitleColor: colorTextDark,
		darkItemHoverColor: colorTextLightSolid,
		darkDangerItemHoverColor: colorErrorHover,
		darkDangerItemSelectedColor: colorTextLightSolid,
		darkDangerItemActiveBg: colorError,
		itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
	};
};
var style_default$47 = (prefixCls, rootCls = prefixCls, injectStyle = true) => {
	return genStyleHooks("Menu", (token$1) => {
		const { colorBgElevated, controlHeightLG, fontSize, darkItemColor, darkDangerItemColor, darkItemBg, darkSubMenuItemBg, darkItemSelectedColor, darkItemSelectedBg, darkDangerItemSelectedBg, darkItemHoverBg, darkGroupTitleColor, darkItemHoverColor, darkItemDisabledColor, darkDangerItemHoverColor, darkDangerItemSelectedColor, darkDangerItemActiveBg, popupBg, darkPopupBg } = token$1;
		const menuArrowSize = token$1.calc(fontSize).div(7).mul(5).equal();
		const menuToken = merge(token$1, {
			menuArrowSize,
			menuHorizontalHeight: token$1.calc(controlHeightLG).mul(1.15).equal(),
			menuArrowOffset: token$1.calc(menuArrowSize).mul(.25).equal(),
			menuSubMenuBg: colorBgElevated,
			calc: token$1.calc,
			popupBg
		});
		const menuDarkToken = merge(menuToken, {
			itemColor: darkItemColor,
			itemHoverColor: darkItemHoverColor,
			groupTitleColor: darkGroupTitleColor,
			itemSelectedColor: darkItemSelectedColor,
			subMenuItemSelectedColor: darkItemSelectedColor,
			itemBg: darkItemBg,
			popupBg: darkPopupBg,
			subMenuItemBg: darkSubMenuItemBg,
			itemActiveBg: "transparent",
			itemSelectedBg: darkItemSelectedBg,
			activeBarHeight: 0,
			activeBarBorderWidth: 0,
			itemHoverBg: darkItemHoverBg,
			itemDisabledColor: darkItemDisabledColor,
			dangerItemColor: darkDangerItemColor,
			dangerItemHoverColor: darkDangerItemHoverColor,
			dangerItemSelectedColor: darkDangerItemSelectedColor,
			dangerItemActiveBg: darkDangerItemActiveBg,
			dangerItemSelectedBg: darkDangerItemSelectedBg,
			menuSubMenuBg: darkSubMenuItemBg,
			horizontalItemSelectedColor: darkItemSelectedColor,
			horizontalItemSelectedBg: darkItemSelectedBg
		});
		return [
			getBaseStyle(menuToken),
			horizontal_default$1(menuToken),
			vertical_default$1(menuToken),
			theme_default$2(menuToken, "light"),
			theme_default$2(menuDarkToken, "dark"),
			rtl_default$3(menuToken),
			collapse_default$1(menuToken),
			initSlideMotion(menuToken, "slide-up"),
			initSlideMotion(menuToken, "slide-down"),
			initZoomMotion(menuToken, "zoom-big")
		];
	}, prepareComponentToken$40, {
		deprecatedTokens: [
			["colorGroupTitle", "groupTitleColor"],
			["radiusItem", "itemBorderRadius"],
			["radiusSubMenuItem", "subMenuItemBorderRadius"],
			["colorItemText", "itemColor"],
			["colorItemTextHover", "itemHoverColor"],
			["colorItemTextHoverHorizontal", "horizontalItemHoverColor"],
			["colorItemTextSelected", "itemSelectedColor"],
			["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"],
			["colorItemTextDisabled", "itemDisabledColor"],
			["colorDangerItemText", "dangerItemColor"],
			["colorDangerItemTextHover", "dangerItemHoverColor"],
			["colorDangerItemTextSelected", "dangerItemSelectedColor"],
			["colorDangerItemBgActive", "dangerItemActiveBg"],
			["colorDangerItemBgSelected", "dangerItemSelectedBg"],
			["colorItemBg", "itemBg"],
			["colorItemBgHover", "itemHoverBg"],
			["colorSubItemBg", "subMenuItemBg"],
			["colorItemBgActive", "itemActiveBg"],
			["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"],
			["colorActiveBarWidth", "activeBarWidth"],
			["colorActiveBarHeight", "activeBarHeight"],
			["colorActiveBarBorderSize", "activeBarBorderWidth"],
			["colorItemBgSelected", "itemSelectedBg"]
		],
		injectStyle,
		unitless: { groupTitleLineHeight: true }
	})(prefixCls, rootCls);
};

//#endregion
//#region node_modules/antd/es/menu/SubMenu.js
var import_classnames$189 = /* @__PURE__ */ __toESM(require_classnames());
var SubMenu = (props) => {
	var _a;
	const { popupClassName, icon, title, theme: customTheme } = props;
	const context = import_react.useContext(MenuContext_default);
	const { prefixCls, inlineCollapsed, theme: contextTheme } = context;
	const parentPath = useFullPath();
	let titleNode;
	if (!icon) titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-inline-collapsed-noicon` }, title.charAt(0)) : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-title-content` }, title);
	else {
		const titleIsSpan = /* @__PURE__ */ import_react.isValidElement(title) && title.type === "span";
		titleNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, cloneElement(icon, { className: (0, import_classnames$189.default)(/* @__PURE__ */ import_react.isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : void 0, `${prefixCls}-item-icon`) }), titleIsSpan ? title : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-title-content` }, title));
	}
	const contextValue = import_react.useMemo(() => Object.assign(Object.assign({}, context), { firstLevel: false }), [context]);
	const [zIndex] = useZIndex("Menu");
	return /* @__PURE__ */ import_react.createElement(MenuContext_default.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement(SubMenu_default$1, Object.assign({}, omit(props, ["icon"]), {
		title: titleNode,
		popupClassName: (0, import_classnames$189.default)(prefixCls, popupClassName, `${prefixCls}-${customTheme || contextTheme}`),
		popupStyle: Object.assign({ zIndex }, props.popupStyle)
	})));
};
var SubMenu_default = SubMenu;

//#endregion
//#region node_modules/antd/es/menu/menu.js
var import_classnames$188 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$88 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function isEmptyIcon(icon) {
	return icon === null || icon === false;
}
var MENU_COMPONENTS = {
	item: MenuItem_default$1,
	submenu: SubMenu_default,
	divider: MenuDivider_default
};
var InternalMenu = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var _a;
	const override = import_react.useContext(OverrideContext_default);
	const overrideObj = override || {};
	const { getPrefixCls, getPopupContainer, direction, menu } = import_react.useContext(ConfigContext);
	const rootPrefixCls = getPrefixCls();
	const { prefixCls: customizePrefixCls, className, style: style$1, theme = "light", expandIcon, _internalDisableMenuItemTitleTooltip, inlineCollapsed, siderCollapsed, rootClassName, mode, selectable, onClick, overflowedIndicatorPopupClassName } = props, restProps = __rest$88(props, [
		"prefixCls",
		"className",
		"style",
		"theme",
		"expandIcon",
		"_internalDisableMenuItemTitleTooltip",
		"inlineCollapsed",
		"siderCollapsed",
		"rootClassName",
		"mode",
		"selectable",
		"onClick",
		"overflowedIndicatorPopupClassName"
	]);
	const passedProps = omit(restProps, ["collapsedWidth"]);
	{
		const warning$4 = devUseWarning("Menu");
		warning$4(!("inlineCollapsed" in props && mode !== "inline"), "usage", "`inlineCollapsed` should only be used when `mode` is inline.");
		warning$4.deprecated("items" in props && !props.children, "children", "items");
	}
	(_a = overrideObj.validator) === null || _a === void 0 || _a.call(overrideObj, { mode });
	const onItemClick = useEvent((...args) => {
		var _a$1;
		onClick === null || onClick === void 0 || onClick.apply(void 0, args);
		(_a$1 = overrideObj.onClick) === null || _a$1 === void 0 || _a$1.call(overrideObj);
	});
	const mergedMode = overrideObj.mode || mode;
	const mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : overrideObj.selectable;
	const mergedInlineCollapsed = inlineCollapsed !== null && inlineCollapsed !== void 0 ? inlineCollapsed : siderCollapsed;
	const defaultMotions = {
		horizontal: { motionName: `${rootPrefixCls}-slide-up` },
		inline: motion_default(rootPrefixCls),
		other: { motionName: `${rootPrefixCls}-zoom-big` }
	};
	const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$47(prefixCls, rootCls, !override);
	const menuClassName = (0, import_classnames$188.default)(`${prefixCls}-${theme}`, menu === null || menu === void 0 ? void 0 : menu.className, className);
	const mergedExpandIcon = import_react.useMemo(() => {
		var _a$1, _b;
		if (typeof expandIcon === "function" || isEmptyIcon(expandIcon)) return expandIcon || null;
		if (typeof overrideObj.expandIcon === "function" || isEmptyIcon(overrideObj.expandIcon)) return overrideObj.expandIcon || null;
		if (typeof (menu === null || menu === void 0 ? void 0 : menu.expandIcon) === "function" || isEmptyIcon(menu === null || menu === void 0 ? void 0 : menu.expandIcon)) return (menu === null || menu === void 0 ? void 0 : menu.expandIcon) || null;
		const mergedIcon = (_a$1 = expandIcon !== null && expandIcon !== void 0 ? expandIcon : overrideObj === null || overrideObj === void 0 ? void 0 : overrideObj.expandIcon) !== null && _a$1 !== void 0 ? _a$1 : menu === null || menu === void 0 ? void 0 : menu.expandIcon;
		return cloneElement(mergedIcon, { className: (0, import_classnames$188.default)(`${prefixCls}-submenu-expand-icon`, /* @__PURE__ */ import_react.isValidElement(mergedIcon) ? (_b = mergedIcon.props) === null || _b === void 0 ? void 0 : _b.className : void 0) });
	}, [
		expandIcon,
		overrideObj === null || overrideObj === void 0 ? void 0 : overrideObj.expandIcon,
		menu === null || menu === void 0 ? void 0 : menu.expandIcon,
		prefixCls
	]);
	const contextValue = import_react.useMemo(() => ({
		prefixCls,
		inlineCollapsed: mergedInlineCollapsed || false,
		direction,
		firstLevel: true,
		theme,
		mode: mergedMode,
		disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
	}), [
		prefixCls,
		mergedInlineCollapsed,
		direction,
		_internalDisableMenuItemTitleTooltip,
		theme
	]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(OverrideContext_default.Provider, { value: null }, /* @__PURE__ */ import_react.createElement(MenuContext_default.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement(es_default$14, Object.assign({
		getPopupContainer,
		overflowedIndicator: /* @__PURE__ */ import_react.createElement(EllipsisOutlined_default, null),
		overflowedIndicatorPopupClassName: (0, import_classnames$188.default)(prefixCls, `${prefixCls}-${theme}`, overflowedIndicatorPopupClassName),
		mode: mergedMode,
		selectable: mergedSelectable,
		onClick: onItemClick
	}, passedProps, {
		inlineCollapsed: mergedInlineCollapsed,
		style: Object.assign(Object.assign({}, menu === null || menu === void 0 ? void 0 : menu.style), style$1),
		className: menuClassName,
		prefixCls,
		direction,
		defaultMotions,
		expandIcon: mergedExpandIcon,
		ref,
		rootClassName: (0, import_classnames$188.default)(rootClassName, hashId, overrideObj.rootClassName, cssVarCls, rootCls),
		_internalComponents: MENU_COMPONENTS
	})))));
});
var menu_default$1 = InternalMenu;

//#endregion
//#region node_modules/antd/es/menu/index.js
var Menu = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const menuRef = (0, import_react.useRef)(null);
	const context = import_react.useContext(SiderContext);
	(0, import_react.useImperativeHandle)(ref, () => ({
		menu: menuRef.current,
		focus: (options) => {
			var _a;
			(_a = menuRef.current) === null || _a === void 0 || _a.focus(options);
		}
	}));
	return /* @__PURE__ */ import_react.createElement(menu_default$1, Object.assign({ ref: menuRef }, props, context));
});
Menu.Item = MenuItem_default$1;
Menu.SubMenu = SubMenu_default;
Menu.Divider = MenuDivider_default;
Menu.ItemGroup = MenuItemGroup_default;
Menu.displayName = "Menu";
var menu_default = Menu;

//#endregion
//#region node_modules/antd/es/dropdown/style/status.js
var genStatusStyle$1 = (token$1) => {
	const { componentCls, menuCls, colorError, colorTextLightSolid } = token$1;
	const itemCls = `${menuCls}-item`;
	return { [`${componentCls}, ${componentCls}-menu-submenu`]: { [`${menuCls} ${itemCls}`]: { [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
		color: colorError,
		"&:hover": {
			color: colorTextLightSolid,
			backgroundColor: colorError
		}
	} } } };
};
var status_default = genStatusStyle$1;

//#endregion
//#region node_modules/antd/es/dropdown/style/index.js
var genBaseStyle$11 = (token$1) => {
	const { componentCls, menuCls, zIndexPopup, dropdownArrowDistance, sizePopupArrow, antCls, iconCls, motionDurationMid, paddingBlock, fontSize, dropdownEdgeChildPadding, colorTextDisabled, fontSizeIcon, controlPaddingHorizontal, colorBgElevated } = token$1;
	return [
		{ [componentCls]: {
			position: "absolute",
			top: -9999,
			left: {
				_skip_check_: true,
				value: -9999
			},
			zIndex: zIndexPopup,
			display: "block",
			"&::before": {
				position: "absolute",
				insetBlock: token$1.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
				zIndex: -9999,
				opacity: 1e-4,
				content: "\"\""
			},
			"&-menu-vertical": {
				maxHeight: "100vh",
				overflowY: "auto"
			},
			[`&-trigger${antCls}-btn`]: { [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: { fontSize: fontSizeIcon } },
			[`${componentCls}-wrap`]: {
				position: "relative",
				[`${antCls}-btn > ${iconCls}-down`]: { fontSize: fontSizeIcon },
				[`${iconCls}-down::before`]: { transition: `transform ${motionDurationMid}` }
			},
			[`${componentCls}-wrap-open`]: { [`${iconCls}-down::before`]: { transform: `rotate(180deg)` } },
			[`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: { display: "none" },
			[`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: { animationName: slideUpIn },
			[`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: { animationName: slideDownIn },
			[`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: { animationName: slideUpOut },
			[`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: { animationName: slideDownOut }
		} },
		getArrowStyle(token$1, colorBgElevated, { arrowPlacement: {
			top: true,
			bottom: true
		} }),
		{
			[`${componentCls} ${menuCls}`]: {
				position: "relative",
				margin: 0
			},
			[`${menuCls}-submenu-popup`]: {
				position: "absolute",
				zIndex: zIndexPopup,
				background: "transparent",
				boxShadow: "none",
				transformOrigin: "0 0",
				"ul, li": {
					listStyle: "none",
					margin: 0
				}
			},
			[`${componentCls}, ${componentCls}-menu-submenu`]: Object.assign(Object.assign({}, resetComponent(token$1)), { [menuCls]: Object.assign(Object.assign({
				padding: dropdownEdgeChildPadding,
				listStyleType: "none",
				backgroundColor: colorBgElevated,
				backgroundClip: "padding-box",
				borderRadius: token$1.borderRadiusLG,
				outline: "none",
				boxShadow: token$1.boxShadowSecondary
			}, genFocusStyle(token$1)), {
				"&:empty": {
					padding: 0,
					boxShadow: "none"
				},
				[`${menuCls}-item-group-title`]: {
					padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
					color: token$1.colorTextDescription,
					transition: `all ${motionDurationMid}`
				},
				[`${menuCls}-item`]: {
					position: "relative",
					display: "flex",
					alignItems: "center"
				},
				[`${menuCls}-item-icon`]: {
					minWidth: fontSize,
					marginInlineEnd: token$1.marginXS,
					fontSize: token$1.fontSizeSM
				},
				[`${menuCls}-title-content`]: {
					flex: "auto",
					"&-with-extra": {
						display: "inline-flex",
						alignItems: "center",
						width: "100%"
					},
					"> a": {
						color: "inherit",
						transition: `all ${motionDurationMid}`,
						"&:hover": { color: "inherit" },
						"&::after": {
							position: "absolute",
							inset: 0,
							content: "\"\""
						}
					},
					[`${menuCls}-item-extra`]: {
						paddingInlineStart: token$1.padding,
						marginInlineStart: "auto",
						fontSize: token$1.fontSizeSM,
						color: token$1.colorTextDescription
					}
				},
				[`${menuCls}-item, ${menuCls}-submenu-title`]: Object.assign(Object.assign({
					display: "flex",
					margin: 0,
					padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
					color: token$1.colorText,
					fontWeight: "normal",
					fontSize,
					lineHeight: token$1.lineHeight,
					cursor: "pointer",
					transition: `all ${motionDurationMid}`,
					borderRadius: token$1.borderRadiusSM,
					"&:hover, &-active": { backgroundColor: token$1.controlItemBgHover }
				}, genFocusStyle(token$1)), {
					"&-selected": {
						color: token$1.colorPrimary,
						backgroundColor: token$1.controlItemBgActive,
						"&:hover, &-active": { backgroundColor: token$1.controlItemBgActiveHover }
					},
					"&-disabled": {
						color: colorTextDisabled,
						cursor: "not-allowed",
						"&:hover": {
							color: colorTextDisabled,
							backgroundColor: colorBgElevated,
							cursor: "not-allowed"
						},
						a: { pointerEvents: "none" }
					},
					"&-divider": {
						height: 1,
						margin: `${unit(token$1.marginXXS)} 0`,
						overflow: "hidden",
						lineHeight: 0,
						backgroundColor: token$1.colorSplit
					},
					[`${componentCls}-menu-submenu-expand-icon`]: {
						position: "absolute",
						insetInlineEnd: token$1.paddingXS,
						[`${componentCls}-menu-submenu-arrow-icon`]: {
							marginInlineEnd: "0 !important",
							color: token$1.colorIcon,
							fontSize: fontSizeIcon,
							fontStyle: "normal"
						}
					}
				}),
				[`${menuCls}-item-group-list`]: {
					margin: `0 ${unit(token$1.marginXS)}`,
					padding: 0,
					listStyle: "none"
				},
				[`${menuCls}-submenu-title`]: { paddingInlineEnd: token$1.calc(controlPaddingHorizontal).add(token$1.fontSizeSM).equal() },
				[`${menuCls}-submenu-vertical`]: { position: "relative" },
				[`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: { [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
					color: colorTextDisabled,
					backgroundColor: colorBgElevated,
					cursor: "not-allowed"
				} },
				[`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: { color: token$1.colorPrimary }
			}) })
		},
		[
			initSlideMotion(token$1, "slide-up"),
			initSlideMotion(token$1, "slide-down"),
			initMoveMotion(token$1, "move-up"),
			initMoveMotion(token$1, "move-down"),
			initZoomMotion(token$1, "zoom-big")
		]
	];
};
const prepareComponentToken$39 = (token$1) => Object.assign(Object.assign({
	zIndexPopup: token$1.zIndexPopupBase + 50,
	paddingBlock: (token$1.controlHeight - token$1.fontSize * token$1.lineHeight) / 2
}, getArrowOffsetToken({
	contentRadius: token$1.borderRadiusLG,
	limitVerticalRadius: true
})), getArrowToken(token$1));
var style_default$46 = genStyleHooks("Dropdown", (token$1) => {
	const { marginXXS, sizePopupArrow, paddingXXS, componentCls } = token$1;
	const dropdownToken = merge(token$1, {
		menuCls: `${componentCls}-menu`,
		dropdownArrowDistance: token$1.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
		dropdownEdgeChildPadding: paddingXXS
	});
	return [genBaseStyle$11(dropdownToken), status_default(dropdownToken)];
}, prepareComponentToken$39, { resetStyle: false });

//#endregion
//#region node_modules/antd/es/dropdown/dropdown.js
var import_classnames$187 = /* @__PURE__ */ __toESM(require_classnames());
var Dropdown$1 = (props) => {
	var _a;
	const { menu, arrow, prefixCls: customizePrefixCls, children, trigger, disabled, dropdownRender, popupRender, getPopupContainer, overlayClassName, rootClassName, overlayStyle, open: open$2, onOpenChange, visible, onVisibleChange, mouseEnterDelay = .15, mouseLeaveDelay = .1, autoAdjustOverflow: autoAdjustOverflow$2 = true, placement = "", overlay, transitionName, destroyOnHidden, destroyPopupOnHide } = props;
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, direction, dropdown } = import_react.useContext(ConfigContext);
	const mergedPopupRender = popupRender || dropdownRender;
	const warning$4 = devUseWarning("Dropdown");
	Object.entries({
		visible: "open",
		onVisibleChange: "onOpenChange",
		overlay: "menu",
		dropdownRender: "popupRender",
		destroyPopupOnHide: "destroyOnHidden"
	}).forEach(([deprecatedName, newName]) => {
		warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
	});
	if (placement.includes("Center")) warning$4.deprecated(!placement.includes("Center"), `placement: ${placement}`, `placement: ${placement.slice(0, placement.indexOf("Center"))}`);
	const memoTransitionName = import_react.useMemo(() => {
		const rootPrefixCls = getPrefixCls();
		if (transitionName !== void 0) return transitionName;
		if (placement.includes("top")) return `${rootPrefixCls}-slide-down`;
		return `${rootPrefixCls}-slide-up`;
	}, [
		getPrefixCls,
		placement,
		transitionName
	]);
	const memoPlacement = import_react.useMemo(() => {
		if (!placement) return direction === "rtl" ? "bottomRight" : "bottomLeft";
		if (placement.includes("Center")) return placement.slice(0, placement.indexOf("Center"));
		return placement;
	}, [placement, direction]);
	const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$46(prefixCls, rootCls);
	const [, token$1] = useToken();
	const child = import_react.Children.only(isPrimitive_default(children) ? /* @__PURE__ */ import_react.createElement("span", null, children) : children);
	const popupTrigger = cloneElement(child, {
		className: (0, import_classnames$187.default)(`${prefixCls}-trigger`, { [`${prefixCls}-rtl`]: direction === "rtl" }, child.props.className),
		disabled: (_a = child.props.disabled) !== null && _a !== void 0 ? _a : disabled
	});
	const triggerActions = disabled ? [] : trigger;
	const alignPoint = !!(triggerActions === null || triggerActions === void 0 ? void 0 : triggerActions.includes("contextMenu"));
	const [mergedOpen, setOpen] = useMergedState(false, { value: open$2 !== null && open$2 !== void 0 ? open$2 : visible });
	const onInnerOpenChange = useEvent((nextOpen) => {
		onOpenChange === null || onOpenChange === void 0 || onOpenChange(nextOpen, { source: "trigger" });
		onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(nextOpen);
		setOpen(nextOpen);
	});
	const overlayClassNameCustomized = (0, import_classnames$187.default)(overlayClassName, rootClassName, hashId, cssVarCls, rootCls, dropdown === null || dropdown === void 0 ? void 0 : dropdown.className, { [`${prefixCls}-rtl`]: direction === "rtl" });
	const builtinPlacements = getPlacements({
		arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
		autoAdjustOverflow: autoAdjustOverflow$2,
		offset: token$1.marginXXS,
		arrowWidth: arrow ? token$1.sizePopupArrow : 0,
		borderRadius: token$1.borderRadius
	});
	const onMenuClick = useEvent(() => {
		if ((menu === null || menu === void 0 ? void 0 : menu.selectable) && (menu === null || menu === void 0 ? void 0 : menu.multiple)) return;
		onOpenChange === null || onOpenChange === void 0 || onOpenChange(false, { source: "menu" });
		setOpen(false);
	});
	const renderOverlay = () => {
		let overlayNode;
		if (menu === null || menu === void 0 ? void 0 : menu.items) overlayNode = /* @__PURE__ */ import_react.createElement(menu_default, Object.assign({}, menu));
		else if (typeof overlay === "function") overlayNode = overlay();
		else overlayNode = overlay;
		if (mergedPopupRender) overlayNode = mergedPopupRender(overlayNode);
		overlayNode = import_react.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ import_react.createElement("span", null, overlayNode) : overlayNode);
		return /* @__PURE__ */ import_react.createElement(OverrideProvider, {
			prefixCls: `${prefixCls}-menu`,
			rootClassName: (0, import_classnames$187.default)(cssVarCls, rootCls),
			expandIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-menu-submenu-arrow` }, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, { className: `${prefixCls}-menu-submenu-arrow-icon` }) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, { className: `${prefixCls}-menu-submenu-arrow-icon` })),
			mode: "vertical",
			selectable: false,
			onClick: onMenuClick,
			validator: ({ mode }) => {
				warning$4(!mode || mode === "vertical", "usage", `mode="${mode}" is not supported for Dropdown's Menu.`);
			}
		}, overlayNode);
	};
	const [zIndex, contextZIndex] = useZIndex("Dropdown", overlayStyle === null || overlayStyle === void 0 ? void 0 : overlayStyle.zIndex);
	let renderNode = /* @__PURE__ */ import_react.createElement(es_default$30, Object.assign({ alignPoint }, omit(props, ["rootClassName"]), {
		mouseEnterDelay,
		mouseLeaveDelay,
		visible: mergedOpen,
		builtinPlacements,
		arrow: !!arrow,
		overlayClassName: overlayClassNameCustomized,
		prefixCls,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		transitionName: memoTransitionName,
		trigger: triggerActions,
		overlay: renderOverlay,
		placement: memoPlacement,
		onVisibleChange: onInnerOpenChange,
		overlayStyle: Object.assign(Object.assign(Object.assign({}, dropdown === null || dropdown === void 0 ? void 0 : dropdown.style), overlayStyle), { zIndex }),
		autoDestroy: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyPopupOnHide
	}), popupTrigger);
	if (zIndex) renderNode = /* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, renderNode);
	return wrapCSSVar(renderNode);
};
var PurePanel$8 = PurePanel_default(Dropdown$1, "align", void 0, "dropdown", (prefixCls) => prefixCls);
/* istanbul ignore next */
var WrapPurePanel = (props) => /* @__PURE__ */ import_react.createElement(PurePanel$8, Object.assign({}, props), /* @__PURE__ */ import_react.createElement("span", null));
Dropdown$1._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
Dropdown$1.displayName = "Dropdown";
var dropdown_default$1 = Dropdown$1;

//#endregion
//#region node_modules/antd/es/breadcrumb/BreadcrumbSeparator.js
var BreadcrumbSeparator = ({ children }) => {
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("breadcrumb");
	return /* @__PURE__ */ import_react.createElement("li", {
		className: `${prefixCls}-separator`,
		"aria-hidden": "true"
	}, children === "" ? children : children || "/");
};
BreadcrumbSeparator.__ANT_BREADCRUMB_SEPARATOR = true;
var BreadcrumbSeparator_default = BreadcrumbSeparator;

//#endregion
//#region node_modules/antd/es/breadcrumb/useItemRender.js
var import_classnames$186 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$87 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function getBreadcrumbName(route, params) {
	if (route.title === void 0 || route.title === null) return null;
	const paramsKeys = Object.keys(params).join("|");
	return typeof route.title === "object" ? route.title : String(route.title).replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key) => params[key] || replacement);
}
function renderItem(prefixCls, item, children, href) {
	if (children === null || children === void 0) return null;
	const { className, onClick } = item, restItem = __rest$87(item, ["className", "onClick"]);
	const passedProps = Object.assign(Object.assign({}, pickAttrs(restItem, {
		data: true,
		aria: true
	})), { onClick });
	if (href !== void 0) return /* @__PURE__ */ import_react.createElement("a", Object.assign({}, passedProps, {
		className: (0, import_classnames$186.default)(`${prefixCls}-link`, className),
		href
	}), children);
	return /* @__PURE__ */ import_react.createElement("span", Object.assign({}, passedProps, { className: (0, import_classnames$186.default)(`${prefixCls}-link`, className) }), children);
}
function useItemRender(prefixCls, itemRender) {
	const mergedItemRender = (item, params, routes, path$1, href) => {
		if (itemRender) return itemRender(item, params, routes, path$1);
		const name = getBreadcrumbName(item, params);
		return renderItem(prefixCls, item, name, href);
	};
	return mergedItemRender;
}

//#endregion
//#region node_modules/antd/es/breadcrumb/BreadcrumbItem.js
var __rest$86 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const InternalBreadcrumbItem = (props) => {
	const { prefixCls, separator = "/", children, menu, overlay, dropdownProps, href } = props;
	devUseWarning("Breadcrumb.Item").deprecated(!("overlay" in props), "overlay", "menu");
	/** If overlay is have Wrap a Dropdown */
	const renderBreadcrumbNode = (breadcrumbItem) => {
		if (menu || overlay) {
			const mergeDropDownProps = Object.assign({}, dropdownProps);
			if (menu) {
				const _a = menu || {}, { items } = _a, menuProps = __rest$86(_a, ["items"]);
				mergeDropDownProps.menu = Object.assign(Object.assign({}, menuProps), { items: items === null || items === void 0 ? void 0 : items.map((_a$1, index$2) => {
					var { key, title, label, path: path$1 } = _a$1, itemProps = __rest$86(_a$1, [
						"key",
						"title",
						"label",
						"path"
					]);
					let mergedLabel = label !== null && label !== void 0 ? label : title;
					if (path$1) mergedLabel = /* @__PURE__ */ import_react.createElement("a", { href: `${href}${path$1}` }, mergedLabel);
					return Object.assign(Object.assign({}, itemProps), {
						key: key !== null && key !== void 0 ? key : index$2,
						label: mergedLabel
					});
				}) });
			} else if (overlay) mergeDropDownProps.overlay = overlay;
			return /* @__PURE__ */ import_react.createElement(dropdown_default$1, Object.assign({ placement: "bottom" }, mergeDropDownProps), /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-overlay-link` }, breadcrumbItem, /* @__PURE__ */ import_react.createElement(DownOutlined_default, null)));
		}
		return breadcrumbItem;
	};
	const link = renderBreadcrumbNode(children);
	if (link !== void 0 && link !== null) return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("li", null, link), separator && /* @__PURE__ */ import_react.createElement(BreadcrumbSeparator_default, null, separator));
	return null;
};
var BreadcrumbItem = (props) => {
	const { prefixCls: customizePrefixCls, children, href } = props, restProps = __rest$86(props, [
		"prefixCls",
		"children",
		"href"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
	return /* @__PURE__ */ import_react.createElement(InternalBreadcrumbItem, Object.assign({}, restProps, { prefixCls }), renderItem(prefixCls, restProps, children, href));
};
BreadcrumbItem.__ANT_BREADCRUMB_ITEM = true;
var BreadcrumbItem_default = BreadcrumbItem;

//#endregion
//#region node_modules/antd/es/breadcrumb/style/index.js
var genBreadcrumbStyle = (token$1) => {
	const { componentCls, iconCls, calc } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		color: token$1.itemColor,
		fontSize: token$1.fontSize,
		[iconCls]: { fontSize: token$1.iconFontSize },
		ol: {
			display: "flex",
			flexWrap: "wrap",
			margin: 0,
			padding: 0,
			listStyle: "none"
		},
		a: Object.assign({
			color: token$1.linkColor,
			transition: `color ${token$1.motionDurationMid}`,
			padding: `0 ${unit(token$1.paddingXXS)}`,
			borderRadius: token$1.borderRadiusSM,
			height: token$1.fontHeight,
			display: "inline-block",
			marginInline: calc(token$1.marginXXS).mul(-1).equal(),
			"&:hover": {
				color: token$1.linkHoverColor,
				backgroundColor: token$1.colorBgTextHover
			}
		}, genFocusStyle(token$1)),
		"li:last-child": { color: token$1.lastItemColor },
		[`${componentCls}-separator`]: {
			marginInline: token$1.separatorMargin,
			color: token$1.separatorColor
		},
		[`${componentCls}-link`]: { [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: { marginInlineStart: token$1.marginXXS } },
		[`${componentCls}-overlay-link`]: {
			borderRadius: token$1.borderRadiusSM,
			height: token$1.fontHeight,
			display: "inline-block",
			padding: `0 ${unit(token$1.paddingXXS)}`,
			marginInline: calc(token$1.marginXXS).mul(-1).equal(),
			[`> ${iconCls}`]: {
				marginInlineStart: token$1.marginXXS,
				fontSize: token$1.fontSizeIcon
			},
			"&:hover": {
				color: token$1.linkHoverColor,
				backgroundColor: token$1.colorBgTextHover,
				a: { color: token$1.linkHoverColor }
			},
			a: { "&:hover": { backgroundColor: "transparent" } }
		},
		[`&${token$1.componentCls}-rtl`]: { direction: "rtl" }
	}) };
};
const prepareComponentToken$38 = (token$1) => ({
	itemColor: token$1.colorTextDescription,
	lastItemColor: token$1.colorText,
	iconFontSize: token$1.fontSize,
	linkColor: token$1.colorTextDescription,
	linkHoverColor: token$1.colorText,
	separatorColor: token$1.colorTextDescription,
	separatorMargin: token$1.marginXS
});
var style_default$45 = genStyleHooks("Breadcrumb", (token$1) => {
	const breadcrumbToken = merge(token$1, {});
	return genBreadcrumbStyle(breadcrumbToken);
}, prepareComponentToken$38);

//#endregion
//#region node_modules/antd/es/breadcrumb/useItems.js
var __rest$85 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function route2item(route) {
	const { breadcrumbName, children } = route, rest = __rest$85(route, ["breadcrumbName", "children"]);
	const clone = Object.assign({ title: breadcrumbName }, rest);
	if (children) clone.menu = { items: children.map((_a) => {
		var { breadcrumbName: itemBreadcrumbName } = _a, itemProps = __rest$85(_a, ["breadcrumbName"]);
		return Object.assign(Object.assign({}, itemProps), { title: itemBreadcrumbName });
	}) };
	return clone;
}
function useItems$3(items, routes) {
	return (0, import_react.useMemo)(() => {
		if (items) return items;
		if (routes) return routes.map(route2item);
		return null;
	}, [items, routes]);
}

//#endregion
//#region node_modules/antd/es/breadcrumb/Breadcrumb.js
var import_classnames$185 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$84 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var getPath = (params, path$1) => {
	if (path$1 === void 0) return path$1;
	let mergedPath = (path$1 || "").replace(/^\//, "");
	Object.keys(params).forEach((key) => {
		mergedPath = mergedPath.replace(`:${key}`, params[key]);
	});
	return mergedPath;
};
var Breadcrumb = (props) => {
	const { prefixCls: customizePrefixCls, separator = "/", style: style$1, className, rootClassName, routes: legacyRoutes, items, children, itemRender, params = {} } = props, restProps = __rest$84(props, [
		"prefixCls",
		"separator",
		"style",
		"className",
		"rootClassName",
		"routes",
		"items",
		"children",
		"itemRender",
		"params"
	]);
	const { getPrefixCls, direction, breadcrumb } = import_react.useContext(ConfigContext);
	let crumbs;
	const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$45(prefixCls);
	const mergedItems = useItems$3(items, legacyRoutes);
	{
		const warning$4 = devUseWarning("Breadcrumb");
		warning$4.deprecated(!legacyRoutes, "routes", "items");
		if (!mergedItems || mergedItems.length === 0) {
			const childList = toArray(children);
			warning$4.deprecated(childList.length === 0, "Breadcrumb.Item and Breadcrumb.Separator", "items");
			childList.forEach((element) => {
				if (element) warning$4(element.type && (element.type.__ANT_BREADCRUMB_ITEM === true || element.type.__ANT_BREADCRUMB_SEPARATOR === true), "usage", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children");
			});
		}
	}
	const mergedItemRender = useItemRender(prefixCls, itemRender);
	if (mergedItems && mergedItems.length > 0) {
		const paths = [];
		const itemRenderRoutes = items || legacyRoutes;
		crumbs = mergedItems.map((item, index$2) => {
			const { path: path$1, key, type: type$2, menu, overlay, onClick, className: itemClassName, separator: itemSeparator, dropdownProps } = item;
			const mergedPath = getPath(params, path$1);
			if (mergedPath !== void 0) paths.push(mergedPath);
			const mergedKey = key !== null && key !== void 0 ? key : index$2;
			if (type$2 === "separator") return /* @__PURE__ */ import_react.createElement(BreadcrumbSeparator_default, { key: mergedKey }, itemSeparator);
			const itemProps = {};
			const isLastItem = index$2 === mergedItems.length - 1;
			if (menu) itemProps.menu = menu;
			else if (overlay) itemProps.overlay = overlay;
			let { href } = item;
			if (paths.length && mergedPath !== void 0) href = `#/${paths.join("/")}`;
			return /* @__PURE__ */ import_react.createElement(InternalBreadcrumbItem, Object.assign({ key: mergedKey }, itemProps, pickAttrs(item, {
				data: true,
				aria: true
			}), {
				className: itemClassName,
				dropdownProps,
				href,
				separator: isLastItem ? "" : separator,
				onClick,
				prefixCls
			}), mergedItemRender(item, params, itemRenderRoutes, paths, href));
		});
	} else if (children) {
		const childrenLength = toArray(children).length;
		crumbs = toArray(children).map((element, index$2) => {
			if (!element) return element;
			const isLastItem = index$2 === childrenLength - 1;
			return cloneElement(element, {
				separator: isLastItem ? "" : separator,
				key: index$2
			});
		});
	}
	const breadcrumbClassName = (0, import_classnames$185.default)(prefixCls, breadcrumb === null || breadcrumb === void 0 ? void 0 : breadcrumb.className, { [`${prefixCls}-rtl`]: direction === "rtl" }, className, rootClassName, hashId, cssVarCls);
	const mergedStyle = Object.assign(Object.assign({}, breadcrumb === null || breadcrumb === void 0 ? void 0 : breadcrumb.style), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("nav", Object.assign({
		className: breadcrumbClassName,
		style: mergedStyle
	}, restProps), /* @__PURE__ */ import_react.createElement("ol", null, crumbs)));
};
Breadcrumb.Item = BreadcrumbItem_default;
Breadcrumb.Separator = BreadcrumbSeparator_default;
Breadcrumb.displayName = "Breadcrumb";
var Breadcrumb_default = Breadcrumb;

//#endregion
//#region node_modules/antd/es/breadcrumb/index.js
var breadcrumb_default = Breadcrumb_default;

//#endregion
//#region node_modules/dayjs/dayjs.min.js
var require_dayjs_min = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/dayjs.min.js": ((exports, module) => {
	(function(t$1, e$2) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = e$2() : "function" == typeof define && define.amd ? define(e$2) : (t$1 = "undefined" != typeof globalThis ? globalThis : t$1 || self).dayjs = e$2();
	})(exports, (function() {
		var t$1 = 1e3, e$2 = 6e4, n$1 = 36e5, r$1 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o$2 = "week", c = "month", f = "quarter", h = "year", d = "date", l$1 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
			name: "en",
			weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
			months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
			ordinal: function(t$2) {
				var e$3 = [
					"th",
					"st",
					"nd",
					"rd"
				], n$2 = t$2 % 100;
				return "[" + t$2 + (e$3[(n$2 - 20) % 10] || e$3[n$2] || e$3[0]) + "]";
			}
		}, m = function(t$2, e$3, n$2) {
			var r$2 = String(t$2);
			return !r$2 || r$2.length >= e$3 ? t$2 : "" + Array(e$3 + 1 - r$2.length).join(n$2) + t$2;
		}, v = {
			s: m,
			z: function(t$2) {
				var e$3 = -t$2.utcOffset(), n$2 = Math.abs(e$3), r$2 = Math.floor(n$2 / 60), i$1 = n$2 % 60;
				return (e$3 <= 0 ? "+" : "-") + m(r$2, 2, "0") + ":" + m(i$1, 2, "0");
			},
			m: function t$2(e$3, n$2) {
				if (e$3.date() < n$2.date()) return -t$2(n$2, e$3);
				var r$2 = 12 * (n$2.year() - e$3.year()) + (n$2.month() - e$3.month()), i$1 = e$3.clone().add(r$2, c), s$1 = n$2 - i$1 < 0, u$1 = e$3.clone().add(r$2 + (s$1 ? -1 : 1), c);
				return +(-(r$2 + (n$2 - i$1) / (s$1 ? i$1 - u$1 : u$1 - i$1)) || 0);
			},
			a: function(t$2) {
				return t$2 < 0 ? Math.ceil(t$2) || 0 : Math.floor(t$2);
			},
			p: function(t$2) {
				return {
					M: c,
					y: h,
					w: o$2,
					d: a,
					D: d,
					h: u,
					m: s,
					s: i,
					ms: r$1,
					Q: f
				}[t$2] || String(t$2 || "").toLowerCase().replace(/s$/, "");
			},
			u: function(t$2) {
				return void 0 === t$2;
			}
		}, g = "en", D = {};
		D[g] = M;
		var p = "$isDayjsObject", S = function(t$2) {
			return t$2 instanceof _ || !(!t$2 || !t$2[p]);
		}, w = function t$2(e$3, n$2, r$2) {
			var i$1;
			if (!e$3) return g;
			if ("string" == typeof e$3) {
				var s$1 = e$3.toLowerCase();
				D[s$1] && (i$1 = s$1), n$2 && (D[s$1] = n$2, i$1 = s$1);
				var u$1 = e$3.split("-");
				if (!i$1 && u$1.length > 1) return t$2(u$1[0]);
			} else {
				var a$1 = e$3.name;
				D[a$1] = e$3, i$1 = a$1;
			}
			return !r$2 && i$1 && (g = i$1), i$1 || !r$2 && g;
		}, O = function(t$2, e$3) {
			if (S(t$2)) return t$2.clone();
			var n$2 = "object" == typeof e$3 ? e$3 : {};
			return n$2.date = t$2, n$2.args = arguments, new _(n$2);
		}, b = v;
		b.l = w, b.i = S, b.w = function(t$2, e$3) {
			return O(t$2, {
				locale: e$3.$L,
				utc: e$3.$u,
				x: e$3.$x,
				$offset: e$3.$offset
			});
		};
		var _ = function() {
			function M$1(t$2) {
				this.$L = w(t$2.locale, null, !0), this.parse(t$2), this.$x = this.$x || t$2.x || {}, this[p] = !0;
			}
			var m$1 = M$1.prototype;
			return m$1.parse = function(t$2) {
				this.$d = function(t$3) {
					var e$3 = t$3.date, n$2 = t$3.utc;
					if (null === e$3) return /* @__PURE__ */ new Date(NaN);
					if (b.u(e$3)) return /* @__PURE__ */ new Date();
					if (e$3 instanceof Date) return new Date(e$3);
					if ("string" == typeof e$3 && !/Z$/i.test(e$3)) {
						var r$2 = e$3.match($);
						if (r$2) {
							var i$1 = r$2[2] - 1 || 0, s$1 = (r$2[7] || "0").substring(0, 3);
							return n$2 ? new Date(Date.UTC(r$2[1], i$1, r$2[3] || 1, r$2[4] || 0, r$2[5] || 0, r$2[6] || 0, s$1)) : new Date(r$2[1], i$1, r$2[3] || 1, r$2[4] || 0, r$2[5] || 0, r$2[6] || 0, s$1);
						}
					}
					return new Date(e$3);
				}(t$2), this.init();
			}, m$1.init = function() {
				var t$2 = this.$d;
				this.$y = t$2.getFullYear(), this.$M = t$2.getMonth(), this.$D = t$2.getDate(), this.$W = t$2.getDay(), this.$H = t$2.getHours(), this.$m = t$2.getMinutes(), this.$s = t$2.getSeconds(), this.$ms = t$2.getMilliseconds();
			}, m$1.$utils = function() {
				return b;
			}, m$1.isValid = function() {
				return !(this.$d.toString() === l$1);
			}, m$1.isSame = function(t$2, e$3) {
				var n$2 = O(t$2);
				return this.startOf(e$3) <= n$2 && n$2 <= this.endOf(e$3);
			}, m$1.isAfter = function(t$2, e$3) {
				return O(t$2) < this.startOf(e$3);
			}, m$1.isBefore = function(t$2, e$3) {
				return this.endOf(e$3) < O(t$2);
			}, m$1.$g = function(t$2, e$3, n$2) {
				return b.u(t$2) ? this[e$3] : this.set(n$2, t$2);
			}, m$1.unix = function() {
				return Math.floor(this.valueOf() / 1e3);
			}, m$1.valueOf = function() {
				return this.$d.getTime();
			}, m$1.startOf = function(t$2, e$3) {
				var n$2 = this, r$2 = !!b.u(e$3) || e$3, f$1 = b.p(t$2), l$2 = function(t$3, e$4) {
					var i$1 = b.w(n$2.$u ? Date.UTC(n$2.$y, e$4, t$3) : new Date(n$2.$y, e$4, t$3), n$2);
					return r$2 ? i$1 : i$1.endOf(a);
				}, $$1 = function(t$3, e$4) {
					return b.w(n$2.toDate()[t$3].apply(n$2.toDate("s"), (r$2 ? [
						0,
						0,
						0,
						0
					] : [
						23,
						59,
						59,
						999
					]).slice(e$4)), n$2);
				}, y$1 = this.$W, M$2 = this.$M, m$2 = this.$D, v$1 = "set" + (this.$u ? "UTC" : "");
				switch (f$1) {
					case h: return r$2 ? l$2(1, 0) : l$2(31, 11);
					case c: return r$2 ? l$2(1, M$2) : l$2(0, M$2 + 1);
					case o$2:
						var g$1 = this.$locale().weekStart || 0, D$1 = (y$1 < g$1 ? y$1 + 7 : y$1) - g$1;
						return l$2(r$2 ? m$2 - D$1 : m$2 + (6 - D$1), M$2);
					case a:
					case d: return $$1(v$1 + "Hours", 0);
					case u: return $$1(v$1 + "Minutes", 1);
					case s: return $$1(v$1 + "Seconds", 2);
					case i: return $$1(v$1 + "Milliseconds", 3);
					default: return this.clone();
				}
			}, m$1.endOf = function(t$2) {
				return this.startOf(t$2, !1);
			}, m$1.$set = function(t$2, e$3) {
				var n$2, o$3 = b.p(t$2), f$1 = "set" + (this.$u ? "UTC" : ""), l$2 = (n$2 = {}, n$2[a] = f$1 + "Date", n$2[d] = f$1 + "Date", n$2[c] = f$1 + "Month", n$2[h] = f$1 + "FullYear", n$2[u] = f$1 + "Hours", n$2[s] = f$1 + "Minutes", n$2[i] = f$1 + "Seconds", n$2[r$1] = f$1 + "Milliseconds", n$2)[o$3], $$1 = o$3 === a ? this.$D + (e$3 - this.$W) : e$3;
				if (o$3 === c || o$3 === h) {
					var y$1 = this.clone().set(d, 1);
					y$1.$d[l$2]($$1), y$1.init(), this.$d = y$1.set(d, Math.min(this.$D, y$1.daysInMonth())).$d;
				} else l$2 && this.$d[l$2]($$1);
				return this.init(), this;
			}, m$1.set = function(t$2, e$3) {
				return this.clone().$set(t$2, e$3);
			}, m$1.get = function(t$2) {
				return this[b.p(t$2)]();
			}, m$1.add = function(r$2, f$1) {
				var d$1, l$2 = this;
				r$2 = Number(r$2);
				var $$1 = b.p(f$1), y$1 = function(t$2) {
					var e$3 = O(l$2);
					return b.w(e$3.date(e$3.date() + Math.round(t$2 * r$2)), l$2);
				};
				if ($$1 === c) return this.set(c, this.$M + r$2);
				if ($$1 === h) return this.set(h, this.$y + r$2);
				if ($$1 === a) return y$1(1);
				if ($$1 === o$2) return y$1(7);
				var M$2 = (d$1 = {}, d$1[s] = e$2, d$1[u] = n$1, d$1[i] = t$1, d$1)[$$1] || 1, m$2 = this.$d.getTime() + r$2 * M$2;
				return b.w(m$2, this);
			}, m$1.subtract = function(t$2, e$3) {
				return this.add(-1 * t$2, e$3);
			}, m$1.format = function(t$2) {
				var e$3 = this, n$2 = this.$locale();
				if (!this.isValid()) return n$2.invalidDate || l$1;
				var r$2 = t$2 || "YYYY-MM-DDTHH:mm:ssZ", i$1 = b.z(this), s$1 = this.$H, u$1 = this.$m, a$1 = this.$M, o$3 = n$2.weekdays, c$1 = n$2.months, f$1 = n$2.meridiem, h$1 = function(t$3, n$3, i$2, s$2) {
					return t$3 && (t$3[n$3] || t$3(e$3, r$2)) || i$2[n$3].slice(0, s$2);
				}, d$1 = function(t$3) {
					return b.s(s$1 % 12 || 12, t$3, "0");
				}, $$1 = f$1 || function(t$3, e$4, n$3) {
					var r$3 = t$3 < 12 ? "AM" : "PM";
					return n$3 ? r$3.toLowerCase() : r$3;
				};
				return r$2.replace(y, (function(t$3, r$3) {
					return r$3 || function(t$4) {
						switch (t$4) {
							case "YY": return String(e$3.$y).slice(-2);
							case "YYYY": return b.s(e$3.$y, 4, "0");
							case "M": return a$1 + 1;
							case "MM": return b.s(a$1 + 1, 2, "0");
							case "MMM": return h$1(n$2.monthsShort, a$1, c$1, 3);
							case "MMMM": return h$1(c$1, a$1);
							case "D": return e$3.$D;
							case "DD": return b.s(e$3.$D, 2, "0");
							case "d": return String(e$3.$W);
							case "dd": return h$1(n$2.weekdaysMin, e$3.$W, o$3, 2);
							case "ddd": return h$1(n$2.weekdaysShort, e$3.$W, o$3, 3);
							case "dddd": return o$3[e$3.$W];
							case "H": return String(s$1);
							case "HH": return b.s(s$1, 2, "0");
							case "h": return d$1(1);
							case "hh": return d$1(2);
							case "a": return $$1(s$1, u$1, !0);
							case "A": return $$1(s$1, u$1, !1);
							case "m": return String(u$1);
							case "mm": return b.s(u$1, 2, "0");
							case "s": return String(e$3.$s);
							case "ss": return b.s(e$3.$s, 2, "0");
							case "SSS": return b.s(e$3.$ms, 3, "0");
							case "Z": return i$1;
						}
						return null;
					}(t$3) || i$1.replace(":", "");
				}));
			}, m$1.utcOffset = function() {
				return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
			}, m$1.diff = function(r$2, d$1, l$2) {
				var $$1, y$1 = this, M$2 = b.p(d$1), m$2 = O(r$2), v$1 = (m$2.utcOffset() - this.utcOffset()) * e$2, g$1 = this - m$2, D$1 = function() {
					return b.m(y$1, m$2);
				};
				switch (M$2) {
					case h:
						$$1 = D$1() / 12;
						break;
					case c:
						$$1 = D$1();
						break;
					case f:
						$$1 = D$1() / 3;
						break;
					case o$2:
						$$1 = (g$1 - v$1) / 6048e5;
						break;
					case a:
						$$1 = (g$1 - v$1) / 864e5;
						break;
					case u:
						$$1 = g$1 / n$1;
						break;
					case s:
						$$1 = g$1 / e$2;
						break;
					case i:
						$$1 = g$1 / t$1;
						break;
					default: $$1 = g$1;
				}
				return l$2 ? $$1 : b.a($$1);
			}, m$1.daysInMonth = function() {
				return this.endOf(c).$D;
			}, m$1.$locale = function() {
				return D[this.$L];
			}, m$1.locale = function(t$2, e$3) {
				if (!t$2) return this.$L;
				var n$2 = this.clone(), r$2 = w(t$2, e$3, !0);
				return r$2 && (n$2.$L = r$2), n$2;
			}, m$1.clone = function() {
				return b.w(this.$d, this);
			}, m$1.toDate = function() {
				return new Date(this.valueOf());
			}, m$1.toJSON = function() {
				return this.isValid() ? this.toISOString() : null;
			}, m$1.toISOString = function() {
				return this.$d.toISOString();
			}, m$1.toString = function() {
				return this.$d.toUTCString();
			}, M$1;
		}(), k = _.prototype;
		return O.prototype = k, [
			["$ms", r$1],
			["$s", i],
			["$m", s],
			["$H", u],
			["$W", a],
			["$M", c],
			["$y", h],
			["$D", d]
		].forEach((function(t$2) {
			k[t$2[1]] = function(e$3) {
				return this.$g(e$3, t$2[0], t$2[1]);
			};
		})), O.extend = function(t$2, e$3) {
			return t$2.$i || (t$2(e$3, _, O), t$2.$i = !0), O;
		}, O.locale = w, O.isDayjs = S, O.unix = function(t$2) {
			return O(1e3 * t$2);
		}, O.en = D[g], O.Ls = D, O.p = {}, O;
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/weekday.js
var require_weekday = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/weekday.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_weekday = t$1();
	})(exports, (function() {
		return function(e$2, t$1) {
			t$1.prototype.weekday = function(e$3) {
				var t$2 = this.$locale().weekStart || 0, i = this.$W, n$1 = (i < t$2 ? i + 7 : i) - t$2;
				return this.$utils().u(e$3) ? n$1 : this.subtract(n$1, "day").add(e$3, "day");
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/localeData.js
var require_localeData = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/localeData.js": ((exports, module) => {
	(function(n$1, e$2) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = e$2() : "function" == typeof define && define.amd ? define(e$2) : (n$1 = "undefined" != typeof globalThis ? globalThis : n$1 || self).dayjs_plugin_localeData = e$2();
	})(exports, (function() {
		return function(n$1, e$2, t$1) {
			var r$1 = e$2.prototype, o$2 = function(n$2) {
				return n$2 && (n$2.indexOf ? n$2 : n$2.s);
			}, u = function(n$2, e$3, t$2, r$2, u$1) {
				var i$1 = n$2.name ? n$2 : n$2.$locale(), a$1 = o$2(i$1[e$3]), s$1 = o$2(i$1[t$2]), f = a$1 || s$1.map((function(n$3) {
					return n$3.slice(0, r$2);
				}));
				if (!u$1) return f;
				var d = i$1.weekStart;
				return f.map((function(n$3, e$4) {
					return f[(e$4 + (d || 0)) % 7];
				}));
			}, i = function() {
				return t$1.Ls[t$1.locale()];
			}, a = function(n$2, e$3) {
				return n$2.formats[e$3] || function(n$3) {
					return n$3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(n$4, e$4, t$2) {
						return e$4 || t$2.slice(1);
					}));
				}(n$2.formats[e$3.toUpperCase()]);
			}, s = function() {
				var n$2 = this;
				return {
					months: function(e$3) {
						return e$3 ? e$3.format("MMMM") : u(n$2, "months");
					},
					monthsShort: function(e$3) {
						return e$3 ? e$3.format("MMM") : u(n$2, "monthsShort", "months", 3);
					},
					firstDayOfWeek: function() {
						return n$2.$locale().weekStart || 0;
					},
					weekdays: function(e$3) {
						return e$3 ? e$3.format("dddd") : u(n$2, "weekdays");
					},
					weekdaysMin: function(e$3) {
						return e$3 ? e$3.format("dd") : u(n$2, "weekdaysMin", "weekdays", 2);
					},
					weekdaysShort: function(e$3) {
						return e$3 ? e$3.format("ddd") : u(n$2, "weekdaysShort", "weekdays", 3);
					},
					longDateFormat: function(e$3) {
						return a(n$2.$locale(), e$3);
					},
					meridiem: this.$locale().meridiem,
					ordinal: this.$locale().ordinal
				};
			};
			r$1.localeData = function() {
				return s.bind(this)();
			}, t$1.localeData = function() {
				var n$2 = i();
				return {
					firstDayOfWeek: function() {
						return n$2.weekStart || 0;
					},
					weekdays: function() {
						return t$1.weekdays();
					},
					weekdaysShort: function() {
						return t$1.weekdaysShort();
					},
					weekdaysMin: function() {
						return t$1.weekdaysMin();
					},
					months: function() {
						return t$1.months();
					},
					monthsShort: function() {
						return t$1.monthsShort();
					},
					longDateFormat: function(e$3) {
						return a(n$2, e$3);
					},
					meridiem: n$2.meridiem,
					ordinal: n$2.ordinal
				};
			}, t$1.months = function() {
				return u(i(), "months");
			}, t$1.monthsShort = function() {
				return u(i(), "monthsShort", "months", 3);
			}, t$1.weekdays = function(n$2) {
				return u(i(), "weekdays", null, null, n$2);
			}, t$1.weekdaysShort = function(n$2) {
				return u(i(), "weekdaysShort", "weekdays", 3, n$2);
			}, t$1.weekdaysMin = function(n$2) {
				return u(i(), "weekdaysMin", "weekdays", 2, n$2);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/weekOfYear.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_weekOfYear = t$1();
	})(exports, (function() {
		var e$2 = "week", t$1 = "year";
		return function(i, n$1, r$1) {
			var f = n$1.prototype;
			f.week = function(i$1) {
				if (void 0 === i$1 && (i$1 = null), null !== i$1) return this.add(7 * (i$1 - this.week()), "day");
				var n$2 = this.$locale().yearStart || 1;
				if (11 === this.month() && this.date() > 25) {
					var f$1 = r$1(this).startOf(t$1).add(1, t$1).date(n$2), s = r$1(this).endOf(e$2);
					if (f$1.isBefore(s)) return 1;
				}
				var a = r$1(this).startOf(t$1).date(n$2).startOf(e$2).subtract(1, "millisecond"), o$2 = this.diff(a, e$2, !0);
				return o$2 < 0 ? r$1(this).startOf("week").week() : Math.ceil(o$2);
			}, f.weeks = function(e$3) {
				return void 0 === e$3 && (e$3 = null), this.week(e$3);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/weekYear.js
var require_weekYear = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/weekYear.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_weekYear = t$1();
	})(exports, (function() {
		return function(e$2, t$1) {
			t$1.prototype.weekYear = function() {
				var e$3 = this.month(), t$2 = this.week(), n$1 = this.year();
				return 1 === t$2 && 11 === e$3 ? n$1 + 1 : 0 === e$3 && t$2 >= 52 ? n$1 - 1 : n$1;
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/advancedFormat.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_advancedFormat = t$1();
	})(exports, (function() {
		return function(e$2, t$1) {
			var r$1 = t$1.prototype, n$1 = r$1.format;
			r$1.format = function(e$3) {
				var t$2 = this, r$2 = this.$locale();
				if (!this.isValid()) return n$1.bind(this)(e$3);
				var s = this.$utils(), a = (e$3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(e$4) {
					switch (e$4) {
						case "Q": return Math.ceil((t$2.$M + 1) / 3);
						case "Do": return r$2.ordinal(t$2.$D);
						case "gggg": return t$2.weekYear();
						case "GGGG": return t$2.isoWeekYear();
						case "wo": return r$2.ordinal(t$2.week(), "W");
						case "w":
						case "ww": return s.s(t$2.week(), "w" === e$4 ? 1 : 2, "0");
						case "W":
						case "WW": return s.s(t$2.isoWeek(), "W" === e$4 ? 1 : 2, "0");
						case "k":
						case "kk": return s.s(String(0 === t$2.$H ? 24 : t$2.$H), "k" === e$4 ? 1 : 2, "0");
						case "X": return Math.floor(t$2.$d.getTime() / 1e3);
						case "x": return t$2.$d.getTime();
						case "z": return "[" + t$2.offsetName() + "]";
						case "zzz": return "[" + t$2.offsetName("long") + "]";
						default: return e$4;
					}
				}));
				return n$1.bind(this)(a);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = /* @__PURE__ */ __commonJS({ "node_modules/dayjs/plugin/customParseFormat.js": ((exports, module) => {
	(function(e$2, t$1) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = t$1() : "function" == typeof define && define.amd ? define(t$1) : (e$2 = "undefined" != typeof globalThis ? globalThis : e$2 || self).dayjs_plugin_customParseFormat = t$1();
	})(exports, (function() {
		var e$2 = {
			LTS: "h:mm:ss A",
			LT: "h:mm A",
			L: "MM/DD/YYYY",
			LL: "MMMM D, YYYY",
			LLL: "MMMM D, YYYY h:mm A",
			LLLL: "dddd, MMMM D, YYYY h:mm A"
		}, t$1 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n$1 = /\d/, r$1 = /\d\d/, i = /\d\d?/, o$2 = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e$3) {
			return (e$3 = +e$3) + (e$3 > 68 ? 1900 : 2e3);
		};
		var f = function(e$3) {
			return function(t$2) {
				this[e$3] = +t$2;
			};
		}, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e$3) {
			(this.zone || (this.zone = {})).offset = function(e$4) {
				if (!e$4) return 0;
				if ("Z" === e$4) return 0;
				var t$2 = e$4.match(/([+-]|\d\d)/g), n$2 = 60 * t$2[1] + (+t$2[2] || 0);
				return 0 === n$2 ? 0 : "+" === t$2[0] ? -n$2 : n$2;
			}(e$3);
		}], u = function(e$3) {
			var t$2 = s[e$3];
			return t$2 && (t$2.indexOf ? t$2 : t$2.s.concat(t$2.f));
		}, d = function(e$3, t$2) {
			var n$2, r$2 = s.meridiem;
			if (r$2) {
				for (var i$1 = 1; i$1 <= 24; i$1 += 1) if (e$3.indexOf(r$2(i$1, 0, t$2)) > -1) {
					n$2 = i$1 > 12;
					break;
				}
			} else n$2 = e$3 === (t$2 ? "pm" : "PM");
			return n$2;
		}, c = {
			A: [o$2, function(e$3) {
				this.afternoon = d(e$3, !1);
			}],
			a: [o$2, function(e$3) {
				this.afternoon = d(e$3, !0);
			}],
			Q: [n$1, function(e$3) {
				this.month = 3 * (e$3 - 1) + 1;
			}],
			S: [n$1, function(e$3) {
				this.milliseconds = 100 * +e$3;
			}],
			SS: [r$1, function(e$3) {
				this.milliseconds = 10 * +e$3;
			}],
			SSS: [/\d{3}/, function(e$3) {
				this.milliseconds = +e$3;
			}],
			s: [i, f("seconds")],
			ss: [i, f("seconds")],
			m: [i, f("minutes")],
			mm: [i, f("minutes")],
			H: [i, f("hours")],
			h: [i, f("hours")],
			HH: [i, f("hours")],
			hh: [i, f("hours")],
			D: [i, f("day")],
			DD: [r$1, f("day")],
			Do: [o$2, function(e$3) {
				var t$2 = s.ordinal;
				if (this.day = e$3.match(/\d+/)[0], t$2) for (var r$2 = 1; r$2 <= 31; r$2 += 1) t$2(r$2).replace(/\[|\]/g, "") === e$3 && (this.day = r$2);
			}],
			w: [i, f("week")],
			ww: [r$1, f("week")],
			M: [i, f("month")],
			MM: [r$1, f("month")],
			MMM: [o$2, function(e$3) {
				var t$2 = u("months"), n$2 = (u("monthsShort") || t$2.map((function(e$4) {
					return e$4.slice(0, 3);
				}))).indexOf(e$3) + 1;
				if (n$2 < 1) throw new Error();
				this.month = n$2 % 12 || n$2;
			}],
			MMMM: [o$2, function(e$3) {
				var t$2 = u("months").indexOf(e$3) + 1;
				if (t$2 < 1) throw new Error();
				this.month = t$2 % 12 || t$2;
			}],
			Y: [/[+-]?\d+/, f("year")],
			YY: [r$1, function(e$3) {
				this.year = a(e$3);
			}],
			YYYY: [/\d{4}/, f("year")],
			Z: h,
			ZZ: h
		};
		function l$1(n$2) {
			var r$2 = n$2, i$1 = s && s.formats;
			for (var o$3 = (n$2 = r$2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t$2, n$3, r$3) {
				var o$4 = r$3 && r$3.toUpperCase();
				return n$3 || i$1[r$3] || e$2[r$3] || i$1[o$4].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e$3, t$3, n$4) {
					return t$3 || n$4.slice(1);
				}));
			}))).match(t$1), a$1 = o$3.length, f$1 = 0; f$1 < a$1; f$1 += 1) {
				var h$1 = o$3[f$1], u$1 = c[h$1], d$1 = u$1 && u$1[0], l$2 = u$1 && u$1[1];
				o$3[f$1] = l$2 ? {
					regex: d$1,
					parser: l$2
				} : h$1.replace(/^\[|\]$/g, "");
			}
			return function(e$3) {
				for (var t$2 = {}, n$3 = 0, r$3 = 0; n$3 < a$1; n$3 += 1) {
					var i$2 = o$3[n$3];
					if ("string" == typeof i$2) r$3 += i$2.length;
					else {
						var s$1 = i$2.regex, f$2 = i$2.parser, h$2 = e$3.slice(r$3), u$2 = s$1.exec(h$2)[0];
						f$2.call(t$2, u$2), e$3 = e$3.replace(u$2, "");
					}
				}
				return function(e$4) {
					var t$3 = e$4.afternoon;
					if (void 0 !== t$3) {
						var n$4 = e$4.hours;
						t$3 ? n$4 < 12 && (e$4.hours += 12) : 12 === n$4 && (e$4.hours = 0), delete e$4.afternoon;
					}
				}(t$2), t$2;
			};
		}
		return function(e$3, t$2, n$2) {
			n$2.p.customParseFormat = !0, e$3 && e$3.parseTwoDigitYear && (a = e$3.parseTwoDigitYear);
			var r$2 = t$2.prototype, i$1 = r$2.parse;
			r$2.parse = function(e$4) {
				var t$3 = e$4.date, r$3 = e$4.utc, o$3 = e$4.args;
				this.$u = r$3;
				var a$1 = o$3[1];
				if ("string" == typeof a$1) {
					var f$1 = !0 === o$3[2], h$1 = !0 === o$3[3], u$1 = f$1 || h$1, d$1 = o$3[2];
					h$1 && (d$1 = o$3[2]), s = this.$locale(), !f$1 && d$1 && (s = n$2.Ls[d$1]), this.$d = function(e$5, t$4, n$3, r$4) {
						try {
							if (["x", "X"].indexOf(t$4) > -1) return /* @__PURE__ */ new Date(("X" === t$4 ? 1e3 : 1) * e$5);
							var i$2 = l$1(t$4)(e$5), o$4 = i$2.year, s$1 = i$2.month, a$2 = i$2.day, f$2 = i$2.hours, h$2 = i$2.minutes, u$2 = i$2.seconds, d$2 = i$2.milliseconds, c$2 = i$2.zone, m$1 = i$2.week, M$1 = /* @__PURE__ */ new Date(), Y = a$2 || (o$4 || s$1 ? 1 : M$1.getDate()), p = o$4 || M$1.getFullYear(), v = 0;
							o$4 && !s$1 || (v = s$1 > 0 ? s$1 - 1 : M$1.getMonth());
							var D, w = f$2 || 0, g = h$2 || 0, y = u$2 || 0, L = d$2 || 0;
							return c$2 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c$2.offset * 1e3)) : n$3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m$1 && (D = r$4(D).week(m$1).toDate()), D);
						} catch (e$6) {
							return /* @__PURE__ */ new Date("");
						}
					}(t$3, a$1, r$3, n$2), this.init(), d$1 && !0 !== d$1 && (this.$L = this.locale(d$1).$L), u$1 && t$3 != this.format(a$1) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
				} else if (a$1 instanceof Array) for (var c$1 = a$1.length, m = 1; m <= c$1; m += 1) {
					o$3[1] = a$1[m - 1];
					var M = n$2.apply(this, o$3);
					if (M.isValid()) {
						this.$d = M.$d, this.$L = M.$L, this.init();
						break;
					}
					m === c$1 && (this.$d = /* @__PURE__ */ new Date(""));
				}
				else i$1.call(this, e$4);
			};
		};
	}));
}) });

//#endregion
//#region node_modules/rc-picker/es/generate/dayjs.js
var import_dayjs_min = /* @__PURE__ */ __toESM(require_dayjs_min());
var import_weekday = /* @__PURE__ */ __toESM(require_weekday());
var import_localeData = /* @__PURE__ */ __toESM(require_localeData());
var import_weekOfYear = /* @__PURE__ */ __toESM(require_weekOfYear());
var import_weekYear = /* @__PURE__ */ __toESM(require_weekYear());
var import_advancedFormat = /* @__PURE__ */ __toESM(require_advancedFormat());
var import_customParseFormat = /* @__PURE__ */ __toESM(require_customParseFormat());
import_dayjs_min.default.extend(import_customParseFormat.default);
import_dayjs_min.default.extend(import_advancedFormat.default);
import_dayjs_min.default.extend(import_weekday.default);
import_dayjs_min.default.extend(import_localeData.default);
import_dayjs_min.default.extend(import_weekOfYear.default);
import_dayjs_min.default.extend(import_weekYear.default);
import_dayjs_min.default.extend(function(o$2, c) {
	var proto = c.prototype;
	var oldFormat = proto.format;
	proto.format = function f(formatStr) {
		var str = (formatStr || "").replace("Wo", "wo");
		return oldFormat.bind(this)(str);
	};
});
var localeMap = {
	bn_BD: "bn-bd",
	by_BY: "be",
	en_GB: "en-gb",
	en_US: "en",
	fr_BE: "fr",
	fr_CA: "fr-ca",
	hy_AM: "hy-am",
	kmr_IQ: "ku",
	nl_BE: "nl-be",
	pt_BR: "pt-br",
	zh_CN: "zh-cn",
	zh_HK: "zh-hk",
	zh_TW: "zh-tw"
};
var parseLocale = function parseLocale$1(locale$5) {
	return localeMap[locale$5] || locale$5.split("_")[0];
};
/* istanbul ignore next */
var parseNoMatchNotice = function parseNoMatchNotice$1() {};
var generateConfig = {
	getNow: function getNow() {
		var now$1 = (0, import_dayjs_min.default)();
		if (typeof now$1.tz === "function") return now$1.tz();
		return now$1;
	},
	getFixedDate: function getFixedDate(string$1) {
		return (0, import_dayjs_min.default)(string$1, ["YYYY-M-DD", "YYYY-MM-DD"]);
	},
	getEndDate: function getEndDate(date$1) {
		return date$1.endOf("month");
	},
	getWeekDay: function getWeekDay(date$1) {
		var clone = date$1.locale("en");
		return clone.weekday() + clone.localeData().firstDayOfWeek();
	},
	getYear: function getYear(date$1) {
		return date$1.year();
	},
	getMonth: function getMonth(date$1) {
		return date$1.month();
	},
	getDate: function getDate(date$1) {
		return date$1.date();
	},
	getHour: function getHour(date$1) {
		return date$1.hour();
	},
	getMinute: function getMinute(date$1) {
		return date$1.minute();
	},
	getSecond: function getSecond(date$1) {
		return date$1.second();
	},
	getMillisecond: function getMillisecond(date$1) {
		return date$1.millisecond();
	},
	addYear: function addYear(date$1, diff) {
		return date$1.add(diff, "year");
	},
	addMonth: function addMonth(date$1, diff) {
		return date$1.add(diff, "month");
	},
	addDate: function addDate(date$1, diff) {
		return date$1.add(diff, "day");
	},
	setYear: function setYear(date$1, year) {
		return date$1.year(year);
	},
	setMonth: function setMonth(date$1, month) {
		return date$1.month(month);
	},
	setDate: function setDate(date$1, num) {
		return date$1.date(num);
	},
	setHour: function setHour(date$1, hour) {
		return date$1.hour(hour);
	},
	setMinute: function setMinute(date$1, minute) {
		return date$1.minute(minute);
	},
	setSecond: function setSecond(date$1, second) {
		return date$1.second(second);
	},
	setMillisecond: function setMillisecond(date$1, milliseconds) {
		return date$1.millisecond(milliseconds);
	},
	isAfter: function isAfter(date1, date2) {
		return date1.isAfter(date2);
	},
	isValidate: function isValidate(date$1) {
		return date$1.isValid();
	},
	locale: {
		getWeekFirstDay: function getWeekFirstDay(locale$5) {
			return (0, import_dayjs_min.default)().locale(parseLocale(locale$5)).localeData().firstDayOfWeek();
		},
		getWeekFirstDate: function getWeekFirstDate(locale$5, date$1) {
			return date$1.locale(parseLocale(locale$5)).weekday(0);
		},
		getWeek: function getWeek(locale$5, date$1) {
			return date$1.locale(parseLocale(locale$5)).week();
		},
		getShortWeekDays: function getShortWeekDays(locale$5) {
			return (0, import_dayjs_min.default)().locale(parseLocale(locale$5)).localeData().weekdaysMin();
		},
		getShortMonths: function getShortMonths(locale$5) {
			return (0, import_dayjs_min.default)().locale(parseLocale(locale$5)).localeData().monthsShort();
		},
		format: function format$2(locale$5, date$1, _format) {
			return date$1.locale(parseLocale(locale$5)).format(_format);
		},
		parse: function parse$1(locale$5, text, formats) {
			var localeStr = parseLocale(locale$5);
			for (var i = 0; i < formats.length; i += 1) {
				var format$2 = formats[i];
				var formatText = text;
				if (format$2.includes("wo") || format$2.includes("Wo")) {
					var year = formatText.split("-")[0];
					var weekStr = formatText.split("-")[1];
					var firstWeek = (0, import_dayjs_min.default)(year, "YYYY").startOf("year").locale(localeStr);
					for (var j = 0; j <= 52; j += 1) {
						var nextWeek = firstWeek.add(j, "week");
						if (nextWeek.format("Wo") === weekStr) return nextWeek;
					}
					parseNoMatchNotice();
					return null;
				}
				var date$1 = (0, import_dayjs_min.default)(formatText, format$2, true).locale(localeStr);
				if (date$1.isValid()) return date$1;
			}
			if (text) parseNoMatchNotice();
			return null;
		}
	}
};
var dayjs_default = generateConfig;

//#endregion
//#region node_modules/rc-picker/es/utils/uiUtil.js
function getRealPlacement(placement, rtl) {
	if (placement !== void 0) return placement;
	return rtl ? "bottomRight" : "bottomLeft";
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/context.js
var PickerContext = /* @__PURE__ */ import_react.createContext(null);
var context_default$6 = PickerContext;

//#endregion
//#region node_modules/rc-picker/es/PickerTrigger/index.js
var import_classnames$184 = /* @__PURE__ */ __toESM(require_classnames());
var BUILT_IN_PLACEMENTS$1 = {
	bottomLeft: {
		points: ["tl", "bl"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	bottomRight: {
		points: ["tr", "br"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	topLeft: {
		points: ["bl", "tl"],
		offset: [0, -4],
		overflow: {
			adjustX: 0,
			adjustY: 1
		}
	},
	topRight: {
		points: ["br", "tr"],
		offset: [0, -4],
		overflow: {
			adjustX: 0,
			adjustY: 1
		}
	}
};
function PickerTrigger(_ref) {
	var popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupAlign = _ref.popupAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range$1 = _ref.range, placement = _ref.placement, _ref$builtinPlacement = _ref.builtinPlacements, builtinPlacements = _ref$builtinPlacement === void 0 ? BUILT_IN_PLACEMENTS$1 : _ref$builtinPlacement, direction = _ref.direction, visible = _ref.visible, onClose = _ref.onClose;
	var _React$useContext = import_react.useContext(context_default$6), prefixCls = _React$useContext.prefixCls;
	var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
	var realPlacement = getRealPlacement(placement, direction === "rtl");
	return /* @__PURE__ */ import_react.createElement(es_default$7, {
		showAction: [],
		hideAction: ["click"],
		popupPlacement: realPlacement,
		builtinPlacements,
		prefixCls: dropdownPrefixCls,
		popupTransitionName: transitionName,
		popup: popupElement,
		popupAlign,
		popupVisible: visible,
		popupClassName: (0, import_classnames$184.default)(popupClassName, _defineProperty(_defineProperty({}, "".concat(dropdownPrefixCls, "-range"), range$1), "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl")),
		popupStyle,
		stretch: "minWidth",
		getPopupContainer,
		onPopupVisibleChange: function onPopupVisibleChange(nextVisible) {
			if (!nextVisible) onClose();
		}
	}, children);
}
var PickerTrigger_default = PickerTrigger;

//#endregion
//#region node_modules/rc-picker/es/utils/miscUtil.js
function leftPad(str, length$1) {
	var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
	var current = String(str);
	while (current.length < length$1) current = "".concat(fill).concat(current);
	return current;
}
/**
* Convert `value` to array. Will provide `[]` if is null or undefined.
*/
function toArray$5(val) {
	if (val === null || val === void 0) return [];
	return Array.isArray(val) ? val : [val];
}
function fillIndex(ori, index$2, value) {
	var clone = _toConsumableArray(ori);
	clone[index$2] = value;
	return clone;
}
/** Pick props from the key list. Will filter empty value */
function pickProps(props, keys$1) {
	var clone = {};
	(keys$1 || Object.keys(props)).forEach(function(key) {
		if (props[key] !== void 0) clone[key] = props[key];
	});
	return clone;
}
function getRowFormat(picker, locale$5, format$2) {
	if (format$2) return format$2;
	switch (picker) {
		case "time": return locale$5.fieldTimeFormat;
		case "datetime": return locale$5.fieldDateTimeFormat;
		case "month": return locale$5.fieldMonthFormat;
		case "year": return locale$5.fieldYearFormat;
		case "quarter": return locale$5.fieldQuarterFormat;
		case "week": return locale$5.fieldWeekFormat;
		default: return locale$5.fieldDateFormat;
	}
}
function getFromDate(calendarValues, activeIndexList, activeIndex) {
	var mergedActiveIndex = activeIndex !== void 0 ? activeIndex : activeIndexList[activeIndexList.length - 1];
	var firstValuedIndex = activeIndexList.find(function(index$2) {
		return calendarValues[index$2];
	});
	return mergedActiveIndex !== firstValuedIndex ? calendarValues[firstValuedIndex] : void 0;
}

//#endregion
//#region node_modules/rc-picker/es/PickerTrigger/util.js
function pickTriggerProps(props) {
	return pickProps(props, [
		"placement",
		"builtinPlacements",
		"popupAlign",
		"getPopupContainer",
		"transitionName",
		"direction"
	]);
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useCellRender.js
function useCellRender$1(cellRender, dateRender, monthCellRender, range$1) {
	warning_default(!dateRender, "'dateRender' is deprecated. Please use 'cellRender' instead.");
	warning_default(!monthCellRender, "'monthCellRender' is deprecated. Please use 'cellRender' instead.");
	var mergedCellRender = import_react.useMemo(function() {
		if (cellRender) return cellRender;
		return function(current, info) {
			var date$1 = current;
			if (dateRender && info.type === "date") return dateRender(date$1, info.today);
			if (monthCellRender && info.type === "month") return monthCellRender(date$1, info.locale);
			return info.originNode;
		};
	}, [
		cellRender,
		monthCellRender,
		dateRender
	]);
	return import_react.useCallback(function(date$1, info) {
		return mergedCellRender(date$1, _objectSpread2(_objectSpread2({}, info), {}, { range: range$1 }));
	}, [mergedCellRender, range$1]);
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useFieldsInvalidate.js
/**
* Used to control each fields invalidate status
*/
function useFieldsInvalidate(calendarValue, isInvalidateDate) {
	var allowEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
	var _React$useState = import_react.useState([false, false]), _React$useState2 = _slicedToArray(_React$useState, 2), fieldsInvalidates = _React$useState2[0], setFieldsInvalidates = _React$useState2[1];
	return [import_react.useMemo(function() {
		return fieldsInvalidates.map(function(invalid, index$2) {
			if (invalid) return true;
			var current = calendarValue[index$2];
			if (!current) return false;
			if (!allowEmpty[index$2] && !current) return true;
			if (current && isInvalidateDate(current, { activeIndex: index$2 })) return true;
			return false;
		});
	}, [
		calendarValue,
		fieldsInvalidates,
		isInvalidateDate,
		allowEmpty
	]), function onSelectorInvalid(invalid, index$2) {
		setFieldsInvalidates(function(ori) {
			return fillIndex(ori, index$2, invalid);
		});
	}];
}

//#endregion
//#region node_modules/rc-picker/es/hooks/useLocale.js
function fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem) {
	var timeFormat = "";
	var cells = [];
	if (showHour) cells.push(showMeridiem ? "hh" : "HH");
	if (showMinute) cells.push("mm");
	if (showSecond) cells.push("ss");
	timeFormat = cells.join(":");
	if (showMillisecond) timeFormat += ".SSS";
	if (showMeridiem) timeFormat += " A";
	return timeFormat;
}
/**
* Used for `useFilledProps` since it already in the React.useMemo
*/
function fillLocale(locale$5, showHour, showMinute, showSecond, showMillisecond, use12Hours) {
	var fieldDateTimeFormat = locale$5.fieldDateTimeFormat, fieldDateFormat = locale$5.fieldDateFormat, fieldTimeFormat = locale$5.fieldTimeFormat, fieldMonthFormat = locale$5.fieldMonthFormat, fieldYearFormat = locale$5.fieldYearFormat, fieldWeekFormat = locale$5.fieldWeekFormat, fieldQuarterFormat = locale$5.fieldQuarterFormat, yearFormat = locale$5.yearFormat, cellYearFormat = locale$5.cellYearFormat, cellQuarterFormat = locale$5.cellQuarterFormat, dayFormat = locale$5.dayFormat, cellDateFormat = locale$5.cellDateFormat;
	var timeFormat = fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, use12Hours);
	return _objectSpread2(_objectSpread2({}, locale$5), {}, {
		fieldDateTimeFormat: fieldDateTimeFormat || "YYYY-MM-DD ".concat(timeFormat),
		fieldDateFormat: fieldDateFormat || "YYYY-MM-DD",
		fieldTimeFormat: fieldTimeFormat || timeFormat,
		fieldMonthFormat: fieldMonthFormat || "YYYY-MM",
		fieldYearFormat: fieldYearFormat || "YYYY",
		fieldWeekFormat: fieldWeekFormat || "gggg-wo",
		fieldQuarterFormat: fieldQuarterFormat || "YYYY-[Q]Q",
		yearFormat: yearFormat || "YYYY",
		cellYearFormat: cellYearFormat || "YYYY",
		cellQuarterFormat: cellQuarterFormat || "[Q]Q",
		cellDateFormat: cellDateFormat || dayFormat || "D"
	});
}
/**
* Fill locale format as start up
*/
function useLocale(locale$5, showProps) {
	var showHour = showProps.showHour, showMinute = showProps.showMinute, showSecond = showProps.showSecond, showMillisecond = showProps.showMillisecond, use12Hours = showProps.use12Hours;
	return import_react.useMemo(function() {
		return fillLocale(locale$5, showHour, showMinute, showSecond, showMillisecond, use12Hours);
	}, [
		locale$5,
		showHour,
		showMinute,
		showSecond,
		showMillisecond,
		use12Hours
	]);
}

//#endregion
//#region node_modules/rc-picker/es/hooks/useTimeConfig.js
function checkShow(format$2, keywords, show) {
	return show !== null && show !== void 0 ? show : keywords.some(function(keyword) {
		return format$2.includes(keyword);
	});
}
var showTimeKeys = [
	"showNow",
	"showHour",
	"showMinute",
	"showSecond",
	"showMillisecond",
	"use12Hours",
	"hourStep",
	"minuteStep",
	"secondStep",
	"millisecondStep",
	"hideDisabledOptions",
	"defaultValue",
	"disabledHours",
	"disabledMinutes",
	"disabledSeconds",
	"disabledMilliseconds",
	"disabledTime",
	"changeOnScroll",
	"defaultOpenValue"
];
/**
* Get SharedTimeProps from props.
*/
function pickTimeProps(props) {
	var timeProps = pickProps(props, showTimeKeys);
	var format$2 = props.format, picker = props.picker;
	var propFormat = null;
	if (format$2) {
		propFormat = format$2;
		if (Array.isArray(propFormat)) propFormat = propFormat[0];
		propFormat = _typeof(propFormat) === "object" ? propFormat.format : propFormat;
	}
	if (picker === "time") timeProps.format = propFormat;
	return [timeProps, propFormat];
}
function isStringFormat(format$2) {
	return format$2 && typeof format$2 === "string";
}
/** Check if all the showXXX is `undefined` */
function existShowConfig(showHour, showMinute, showSecond, showMillisecond) {
	return [
		showHour,
		showMinute,
		showSecond,
		showMillisecond
	].some(function(show) {
		return show !== void 0;
	});
}
/** Fill the showXXX if needed */
function fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond) {
	var parsedShowHour = showHour;
	var parsedShowMinute = showMinute;
	var parsedShowSecond = showSecond;
	if (!hasShowConfig && !parsedShowHour && !parsedShowMinute && !parsedShowSecond && !showMillisecond) {
		parsedShowHour = true;
		parsedShowMinute = true;
		parsedShowSecond = true;
	} else if (hasShowConfig) {
		var _parsedShowHour, _parsedShowMinute, _parsedShowSecond;
		var existFalse = [
			parsedShowHour,
			parsedShowMinute,
			parsedShowSecond
		].some(function(show) {
			return show === false;
		});
		var existTrue = [
			parsedShowHour,
			parsedShowMinute,
			parsedShowSecond
		].some(function(show) {
			return show === true;
		});
		var defaultShow = existFalse ? true : !existTrue;
		parsedShowHour = (_parsedShowHour = parsedShowHour) !== null && _parsedShowHour !== void 0 ? _parsedShowHour : defaultShow;
		parsedShowMinute = (_parsedShowMinute = parsedShowMinute) !== null && _parsedShowMinute !== void 0 ? _parsedShowMinute : defaultShow;
		parsedShowSecond = (_parsedShowSecond = parsedShowSecond) !== null && _parsedShowSecond !== void 0 ? _parsedShowSecond : defaultShow;
	}
	return [
		parsedShowHour,
		parsedShowMinute,
		parsedShowSecond,
		showMillisecond
	];
}
/**
* Get `showHour`, `showMinute`, `showSecond` or other from the props.
* This is pure function, will not get `showXXX` from the `format` prop.
*/
function getTimeProps(componentProps) {
	var showTime = componentProps.showTime;
	var _pickTimeProps = pickTimeProps(componentProps), _pickTimeProps2 = _slicedToArray(_pickTimeProps, 2), pickedProps = _pickTimeProps2[0], propFormat = _pickTimeProps2[1];
	var showTimeConfig = showTime && _typeof(showTime) === "object" ? showTime : {};
	var timeConfig = _objectSpread2(_objectSpread2({ defaultOpenValue: showTimeConfig.defaultOpenValue || showTimeConfig.defaultValue }, pickedProps), showTimeConfig);
	var showMillisecond = timeConfig.showMillisecond;
	var showHour = timeConfig.showHour, showMinute = timeConfig.showMinute, showSecond = timeConfig.showSecond;
	var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
	var _fillShowConfig = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
	var _fillShowConfig2 = _slicedToArray(_fillShowConfig, 3);
	showHour = _fillShowConfig2[0];
	showMinute = _fillShowConfig2[1];
	showSecond = _fillShowConfig2[2];
	return [
		timeConfig,
		_objectSpread2(_objectSpread2({}, timeConfig), {}, {
			showHour,
			showMinute,
			showSecond,
			showMillisecond
		}),
		timeConfig.format,
		propFormat
	];
}
function fillShowTimeConfig(picker, showTimeFormat, propFormat, timeConfig, locale$5) {
	if (picker === "datetime" || picker === "time") {
		var pickedProps = timeConfig;
		var baselineFormat = getRowFormat(picker, locale$5, null);
		var formatList = [showTimeFormat, propFormat];
		for (var i = 0; i < formatList.length; i += 1) {
			var format$2 = toArray$5(formatList[i])[0];
			if (isStringFormat(format$2)) {
				baselineFormat = format$2;
				break;
			}
		}
		var showHour = pickedProps.showHour, showMinute = pickedProps.showMinute, showSecond = pickedProps.showSecond, showMillisecond = pickedProps.showMillisecond;
		var use12Hours = pickedProps.use12Hours;
		var showMeridiem = checkShow(baselineFormat, [
			"a",
			"A",
			"LT",
			"LLL",
			"LTS"
		], use12Hours);
		var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
		if (!hasShowConfig) {
			showHour = checkShow(baselineFormat, [
				"H",
				"h",
				"k",
				"LT",
				"LLL"
			]);
			showMinute = checkShow(baselineFormat, [
				"m",
				"LT",
				"LLL"
			]);
			showSecond = checkShow(baselineFormat, ["s", "LTS"]);
			showMillisecond = checkShow(baselineFormat, ["SSS"]);
		}
		var _fillShowConfig3 = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
		var _fillShowConfig4 = _slicedToArray(_fillShowConfig3, 3);
		showHour = _fillShowConfig4[0];
		showMinute = _fillShowConfig4[1];
		showSecond = _fillShowConfig4[2];
		var timeFormat = showTimeFormat || fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem);
		return _objectSpread2(_objectSpread2({}, pickedProps), {}, {
			format: timeFormat,
			showHour,
			showMinute,
			showSecond,
			showMillisecond,
			use12Hours: showMeridiem
		});
	}
	return null;
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/hooks/useClearIcon.js
/**
* Used for `useFilledProps` since it already in the React.useMemo
*/
function fillClearIcon(prefixCls, allowClear, clearIcon) {
	if (clearIcon) warning_default(false, "`clearIcon` will be removed in future. Please use `allowClear` instead.");
	if (allowClear === false) return null;
	return (allowClear && _typeof(allowClear) === "object" ? allowClear : {}).clearIcon || clearIcon || /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-clear-btn") });
}

//#endregion
//#region node_modules/rc-picker/es/utils/dateUtil.js
var WEEK_DAY_COUNT = 7;
/**
* Wrap the compare logic.
* This will compare the each of value is empty first.
* 1. All is empty, return true.
* 2. One is empty, return false.
* 3. return customize compare logic.
*/
function nullableCompare(value1, value2, oriCompareFn) {
	if (!value1 && !value2 || value1 === value2) return true;
	if (!value1 || !value2) return false;
	return oriCompareFn();
}
function isSameDecade(generateConfig$1, decade1, decade2) {
	return nullableCompare(decade1, decade2, function() {
		var num1 = Math.floor(generateConfig$1.getYear(decade1) / 10);
		var num2 = Math.floor(generateConfig$1.getYear(decade2) / 10);
		return num1 === num2;
	});
}
function isSameYear$1(generateConfig$1, year1, year2) {
	return nullableCompare(year1, year2, function() {
		return generateConfig$1.getYear(year1) === generateConfig$1.getYear(year2);
	});
}
function getQuarter(generateConfig$1, date$1) {
	return Math.floor(generateConfig$1.getMonth(date$1) / 3) + 1;
}
function isSameQuarter(generateConfig$1, quarter1, quarter2) {
	return nullableCompare(quarter1, quarter2, function() {
		return isSameYear$1(generateConfig$1, quarter1, quarter2) && getQuarter(generateConfig$1, quarter1) === getQuarter(generateConfig$1, quarter2);
	});
}
function isSameMonth$1(generateConfig$1, month1, month2) {
	return nullableCompare(month1, month2, function() {
		return isSameYear$1(generateConfig$1, month1, month2) && generateConfig$1.getMonth(month1) === generateConfig$1.getMonth(month2);
	});
}
function isSameDate$1(generateConfig$1, date1, date2) {
	return nullableCompare(date1, date2, function() {
		return isSameYear$1(generateConfig$1, date1, date2) && isSameMonth$1(generateConfig$1, date1, date2) && generateConfig$1.getDate(date1) === generateConfig$1.getDate(date2);
	});
}
function isSameTime(generateConfig$1, time1, time2) {
	return nullableCompare(time1, time2, function() {
		return generateConfig$1.getHour(time1) === generateConfig$1.getHour(time2) && generateConfig$1.getMinute(time1) === generateConfig$1.getMinute(time2) && generateConfig$1.getSecond(time1) === generateConfig$1.getSecond(time2);
	});
}
/**
* Check if the Date is all the same of timestamp
*/
function isSameTimestamp(generateConfig$1, time1, time2) {
	return nullableCompare(time1, time2, function() {
		return isSameDate$1(generateConfig$1, time1, time2) && isSameTime(generateConfig$1, time1, time2) && generateConfig$1.getMillisecond(time1) === generateConfig$1.getMillisecond(time2);
	});
}
function isSameWeek(generateConfig$1, locale$5, date1, date2) {
	return nullableCompare(date1, date2, function() {
		var weekStartDate1 = generateConfig$1.locale.getWeekFirstDate(locale$5, date1);
		var weekStartDate2 = generateConfig$1.locale.getWeekFirstDate(locale$5, date2);
		return isSameYear$1(generateConfig$1, weekStartDate1, weekStartDate2) && generateConfig$1.locale.getWeek(locale$5, date1) === generateConfig$1.locale.getWeek(locale$5, date2);
	});
}
function isSame(generateConfig$1, locale$5, source, target, type$2) {
	switch (type$2) {
		case "date": return isSameDate$1(generateConfig$1, source, target);
		case "week": return isSameWeek(generateConfig$1, locale$5.locale, source, target);
		case "month": return isSameMonth$1(generateConfig$1, source, target);
		case "quarter": return isSameQuarter(generateConfig$1, source, target);
		case "year": return isSameYear$1(generateConfig$1, source, target);
		case "decade": return isSameDecade(generateConfig$1, source, target);
		case "time": return isSameTime(generateConfig$1, source, target);
		default: return isSameTimestamp(generateConfig$1, source, target);
	}
}
/** Between in date but not equal of date */
function isInRange(generateConfig$1, startDate, endDate, current) {
	if (!startDate || !endDate || !current) return false;
	return generateConfig$1.isAfter(current, startDate) && generateConfig$1.isAfter(endDate, current);
}
function isSameOrAfter(generateConfig$1, locale$5, date1, date2, type$2) {
	if (isSame(generateConfig$1, locale$5, date1, date2, type$2)) return true;
	return generateConfig$1.isAfter(date1, date2);
}
function getWeekStartDate(locale$5, generateConfig$1, value) {
	var weekFirstDay = generateConfig$1.locale.getWeekFirstDay(locale$5);
	var monthStartDate = generateConfig$1.setDate(value, 1);
	var startDateWeekDay = generateConfig$1.getWeekDay(monthStartDate);
	var alignStartDate = generateConfig$1.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
	if (generateConfig$1.getMonth(alignStartDate) === generateConfig$1.getMonth(value) && generateConfig$1.getDate(alignStartDate) > 1) alignStartDate = generateConfig$1.addDate(alignStartDate, -7);
	return alignStartDate;
}
function formatValue(value, _ref) {
	var generateConfig$1 = _ref.generateConfig, locale$5 = _ref.locale, format$2 = _ref.format;
	if (!value) return "";
	return typeof format$2 === "function" ? format$2(value) : generateConfig$1.locale.format(locale$5.locale, value, format$2);
}
/**
* Fill the time info into Date if provided.
*/
function fillTime(generateConfig$1, date$1, time) {
	var tmpDate = date$1;
	var getFn = [
		"getHour",
		"getMinute",
		"getSecond",
		"getMillisecond"
	];
	[
		"setHour",
		"setMinute",
		"setSecond",
		"setMillisecond"
	].forEach(function(fn, index$2) {
		if (time) tmpDate = generateConfig$1[fn](tmpDate, generateConfig$1[getFn[index$2]](time));
		else tmpDate = generateConfig$1[fn](tmpDate, 0);
	});
	return tmpDate;
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useDisabledBoundary.js
/**
* Merge `disabledDate` with `minDate` & `maxDate`.
*/
function useDisabledBoundary(generateConfig$1, locale$5, disabledDate, minDate, maxDate) {
	return useEvent(function(date$1, info) {
		if (disabledDate && disabledDate(date$1, info)) return true;
		if (minDate && generateConfig$1.isAfter(minDate, date$1) && !isSame(generateConfig$1, locale$5, minDate, date$1, info.type)) return true;
		if (maxDate && generateConfig$1.isAfter(date$1, maxDate) && !isSame(generateConfig$1, locale$5, maxDate, date$1, info.type)) return true;
		return false;
	});
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useFieldFormat.js
function useFieldFormat(picker, locale$5, format$2) {
	return import_react.useMemo(function() {
		var rawFormat = getRowFormat(picker, locale$5, format$2);
		var formatList = toArray$5(rawFormat);
		var firstFormat = formatList[0];
		var maskFormat = _typeof(firstFormat) === "object" && firstFormat.type === "mask" ? firstFormat.format : null;
		return [formatList.map(function(config) {
			return typeof config === "string" || typeof config === "function" ? config : config.format;
		}), maskFormat];
	}, [
		picker,
		locale$5,
		format$2
	]);
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useInputReadOnly.js
function useInputReadOnly(formatList, inputReadOnly, multiple) {
	if (typeof formatList[0] === "function" || multiple) return true;
	return inputReadOnly;
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useInvalidate.js
/**
* Check if provided date is valid for the `disabledDate` & `showTime.disabledTime`.
*/
function useInvalidate(generateConfig$1, picker, disabledDate, showTime) {
	return useEvent(function(date$1, info) {
		var outsideInfo = _objectSpread2({ type: picker }, info);
		delete outsideInfo.activeIndex;
		if (!generateConfig$1.isValidate(date$1) || disabledDate && disabledDate(date$1, outsideInfo)) return true;
		if ((picker === "date" || picker === "time") && showTime) {
			var _showTime$disabledTim;
			var range$1 = info && info.activeIndex === 1 ? "end" : "start";
			var _ref = ((_showTime$disabledTim = showTime.disabledTime) === null || _showTime$disabledTim === void 0 ? void 0 : _showTime$disabledTim.call(showTime, date$1, range$1, { from: outsideInfo.from })) || {}, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, disabledMilliseconds = _ref.disabledMilliseconds;
			var legacyDisabledHours = showTime.disabledHours, legacyDisabledMinutes = showTime.disabledMinutes, legacyDisabledSeconds = showTime.disabledSeconds;
			var mergedDisabledHours = disabledHours || legacyDisabledHours;
			var mergedDisabledMinutes = disabledMinutes || legacyDisabledMinutes;
			var mergedDisabledSeconds = disabledSeconds || legacyDisabledSeconds;
			var hour = generateConfig$1.getHour(date$1);
			var minute = generateConfig$1.getMinute(date$1);
			var second = generateConfig$1.getSecond(date$1);
			var millisecond = generateConfig$1.getMillisecond(date$1);
			if (mergedDisabledHours && mergedDisabledHours().includes(hour)) return true;
			if (mergedDisabledMinutes && mergedDisabledMinutes(hour).includes(minute)) return true;
			if (mergedDisabledSeconds && mergedDisabledSeconds(hour, minute).includes(second)) return true;
			if (disabledMilliseconds && disabledMilliseconds(hour, minute, second).includes(millisecond)) return true;
		}
		return false;
	});
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useFilledProps.js
function useList(value) {
	var fillMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	return import_react.useMemo(function() {
		var list = value ? toArray$5(value) : value;
		if (fillMode && list) list[1] = list[1] || list[0];
		return list;
	}, [value, fillMode]);
}
/**
* Align the outer props with unique typed and fill undefined props.
* This is shared with both RangePicker and Picker. This will do:
* - Convert `value` & `defaultValue` to array
* - handle the legacy props fill like `clearIcon` + `allowClear` = `clearIcon`
*/
function useFilledProps(props, updater) {
	var generateConfig$1 = props.generateConfig, locale$5 = props.locale, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, _props$styles = props.styles, styles = _props$styles === void 0 ? {} : _props$styles, _props$classNames = props.classNames, classNames$252 = _props$classNames === void 0 ? {} : _props$classNames, _props$order = props.order, order = _props$order === void 0 ? true : _props$order, _props$components = props.components, components$1 = _props$components === void 0 ? {} : _props$components, inputRender = props.inputRender, allowClear = props.allowClear, clearIcon = props.clearIcon, needConfirm = props.needConfirm, multiple = props.multiple, format$2 = props.format, inputReadOnly = props.inputReadOnly, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, showTime = props.showTime, value = props.value, defaultValue = props.defaultValue, pickerValue = props.pickerValue, defaultPickerValue = props.defaultPickerValue;
	var values = useList(value);
	var defaultValues = useList(defaultValue);
	var pickerValues = useList(pickerValue);
	var defaultPickerValues = useList(defaultPickerValue);
	/** Almost same as `picker`, but add `datetime` for `date` with `showTime` */
	var internalPicker = picker === "date" && showTime ? "datetime" : picker;
	/** The picker is `datetime` or `time` */
	var multipleInteractivePicker = internalPicker === "time" || internalPicker === "datetime";
	var complexPicker = multipleInteractivePicker || multiple;
	var mergedNeedConfirm = needConfirm !== null && needConfirm !== void 0 ? needConfirm : multipleInteractivePicker;
	var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
	var mergedLocale = useLocale(locale$5, localeTimeProps);
	var mergedShowTime = import_react.useMemo(function() {
		return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale);
	}, [
		internalPicker,
		showTimeFormat,
		propFormat,
		timeProps,
		mergedLocale
	]);
	if (picker === "time") {
		if ([
			"disabledHours",
			"disabledMinutes",
			"disabledSeconds"
		].some(function(key) {
			return props[key];
		})) warning_default(false, "'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.");
	}
	var filledProps = import_react.useMemo(function() {
		return _objectSpread2(_objectSpread2({}, props), {}, {
			prefixCls,
			locale: mergedLocale,
			picker,
			styles,
			classNames: classNames$252,
			order,
			components: _objectSpread2({ input: inputRender }, components$1),
			clearIcon: fillClearIcon(prefixCls, allowClear, clearIcon),
			showTime: mergedShowTime,
			value: values,
			defaultValue: defaultValues,
			pickerValue: pickerValues,
			defaultPickerValue: defaultPickerValues
		}, updater === null || updater === void 0 ? void 0 : updater());
	}, [props]);
	var _useFieldFormat = useFieldFormat(internalPicker, mergedLocale, format$2), _useFieldFormat2 = _slicedToArray(_useFieldFormat, 2), formatList = _useFieldFormat2[0], maskFormat = _useFieldFormat2[1];
	var mergedInputReadOnly = useInputReadOnly(formatList, inputReadOnly, multiple);
	var disabledBoundaryDate = useDisabledBoundary(generateConfig$1, locale$5, disabledDate, minDate, maxDate);
	var isInvalidateDate = useInvalidate(generateConfig$1, picker, disabledBoundaryDate, mergedShowTime);
	return [
		import_react.useMemo(function() {
			return _objectSpread2(_objectSpread2({}, filledProps), {}, {
				needConfirm: mergedNeedConfirm,
				inputReadOnly: mergedInputReadOnly,
				disabledDate: disabledBoundaryDate
			});
		}, [
			filledProps,
			mergedNeedConfirm,
			mergedInputReadOnly,
			disabledBoundaryDate
		]),
		internalPicker,
		complexPicker,
		formatList,
		maskFormat,
		isInvalidateDate
	];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useDelayState.js
/**
* Will be `true` immediately for next effect.
* But will be `false` for a delay of effect.
*/
function useDelayState(value, defaultValue, onChange) {
	var _useMergedState = useMergedState(defaultValue, { value }), _useMergedState2 = _slicedToArray(_useMergedState, 2), state = _useMergedState2[0], setState = _useMergedState2[1];
	var nextValueRef = import_react.useRef(value);
	var rafRef = import_react.useRef();
	var cancelRaf = function cancelRaf$1() {
		raf_default.cancel(rafRef.current);
	};
	var doUpdate = useEvent(function() {
		setState(nextValueRef.current);
		if (onChange && state !== nextValueRef.current) onChange(nextValueRef.current);
	});
	var updateValue = useEvent(function(next$1, immediately) {
		cancelRaf();
		nextValueRef.current = next$1;
		if (next$1 || immediately) doUpdate();
		else rafRef.current = raf_default(doUpdate);
	});
	import_react.useEffect(function() {
		return cancelRaf;
	}, []);
	return [state, updateValue];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useOpen.js
/**
* Control the open state.
* Will not close if activeElement is on the popup.
*/
function useOpen(open$2, defaultOpen) {
	var disabledList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
	var onOpenChange = arguments.length > 3 ? arguments[3] : void 0;
	var mergedOpen = disabledList.every(function(disabled) {
		return disabled;
	}) ? false : open$2;
	var _useDelayState = useDelayState(mergedOpen, defaultOpen || false, onOpenChange), _useDelayState2 = _slicedToArray(_useDelayState, 2), rafOpen = _useDelayState2[0], setRafOpen = _useDelayState2[1];
	function setOpen(next$1) {
		var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
		if (!config.inherit || rafOpen) setRafOpen(next$1, config.force);
	}
	return [rafOpen, setOpen];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/usePickerRef.js
function usePickerRef(ref) {
	var selectorRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		var _selectorRef$current;
		return {
			nativeElement: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.nativeElement,
			focus: function focus(options) {
				var _selectorRef$current2;
				(_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 || _selectorRef$current2.focus(options);
			},
			blur: function blur() {
				var _selectorRef$current3;
				(_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.blur();
			}
		};
	});
	return selectorRef;
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/usePresets.js
function usePresets(presets, legacyRanges) {
	return import_react.useMemo(function() {
		if (presets) return presets;
		if (legacyRanges) {
			warning_default(false, "`ranges` is deprecated. Please use `presets` instead.");
			return Object.entries(legacyRanges).map(function(_ref) {
				var _ref2 = _slicedToArray(_ref, 2), label = _ref2[0], value = _ref2[1];
				return {
					label,
					value
				};
			});
		}
		return [];
	}, [presets, legacyRanges]);
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useLockEffect.js
/**
* Trigger `callback` immediately when `condition` is `true`.
* But trigger `callback` in next frame when `condition` is `false`.
*/
function useLockEffect(condition, callback) {
	var delayFrames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
	var callbackRef = import_react.useRef(callback);
	callbackRef.current = callback;
	useLayoutUpdateEffect(function() {
		if (condition) callbackRef.current(condition);
		else {
			var id = raf_default(function() {
				callbackRef.current(condition);
			}, delayFrames);
			return function() {
				raf_default.cancel(id);
			};
		}
	}, [condition]);
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useRangeActive.js
/**
* When user first focus one input, any submit will trigger focus another one.
* When second time focus one input, submit will not trigger focus again.
* When click outside to close the panel, trigger event if it can trigger onChange.
*/
function useRangeActive(disabled) {
	var empty$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	var mergedOpen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
	var _React$useState = import_react.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
	var _React$useState3 = import_react.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), focused = _React$useState4[0], setFocused = _React$useState4[1];
	var activeListRef = import_react.useRef([]);
	var submitIndexRef = import_react.useRef(null);
	var lastOperationRef = import_react.useRef(null);
	var updateSubmitIndex = function updateSubmitIndex$1(index$2) {
		submitIndexRef.current = index$2;
	};
	var hasActiveSubmitValue = function hasActiveSubmitValue$1(index$2) {
		return submitIndexRef.current === index$2;
	};
	var triggerFocus$1 = function triggerFocus$2(nextFocus) {
		setFocused(nextFocus);
	};
	var lastOperation = function lastOperation$1(type$2) {
		if (type$2) lastOperationRef.current = type$2;
		return lastOperationRef.current;
	};
	var nextActiveIndex = function nextActiveIndex$1(nextValue) {
		var list = activeListRef.current;
		var filledActiveSet = new Set(list.filter(function(index$2) {
			return nextValue[index$2] || empty$1[index$2];
		}));
		var nextIndex = list[list.length - 1] === 0 ? 1 : 0;
		if (filledActiveSet.size >= 2 || disabled[nextIndex]) return null;
		return nextIndex;
	};
	useLockEffect(focused || mergedOpen, function() {
		if (!focused) {
			activeListRef.current = [];
			updateSubmitIndex(null);
		}
	});
	import_react.useEffect(function() {
		if (focused) activeListRef.current.push(activeIndex);
	}, [focused, activeIndex]);
	return [
		focused,
		triggerFocus$1,
		lastOperation,
		activeIndex,
		setActiveIndex,
		nextActiveIndex,
		activeListRef.current,
		updateSubmitIndex,
		hasActiveSubmitValue
	];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useRangeDisabledDate.js
/**
* RangePicker need additional logic to handle the `disabled` case. e.g.
* [disabled, enabled] should end date not before start date
*/
function useRangeDisabledDate(values, disabled, activeIndexList, generateConfig$1, locale$5, disabledDate) {
	var activeIndex = activeIndexList[activeIndexList.length - 1];
	return function rangeDisabledDate(date$1, info) {
		var _values = _slicedToArray(values, 2), start = _values[0], end = _values[1];
		var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, { from: getFromDate(values, activeIndexList) });
		if (activeIndex === 1 && disabled[0] && start && !isSame(generateConfig$1, locale$5, start, date$1, mergedInfo.type) && generateConfig$1.isAfter(start, date$1)) return true;
		if (activeIndex === 0 && disabled[1] && end && !isSame(generateConfig$1, locale$5, end, date$1, mergedInfo.type) && generateConfig$1.isAfter(date$1, end)) return true;
		return disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date$1, mergedInfo);
	};
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useRangePickerValue.js
function offsetPanelDate(generateConfig$1, picker, date$1, offset$2) {
	switch (picker) {
		case "date":
		case "week": return generateConfig$1.addMonth(date$1, offset$2);
		case "month":
		case "quarter": return generateConfig$1.addYear(date$1, offset$2);
		case "year": return generateConfig$1.addYear(date$1, offset$2 * 10);
		case "decade": return generateConfig$1.addYear(date$1, offset$2 * 100);
		default: return date$1;
	}
}
var EMPTY_LIST$3 = [];
function useRangePickerValue(generateConfig$1, locale$5, calendarValue, modes, open$2, activeIndex, pickerMode, multiplePanel) {
	var defaultPickerValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : EMPTY_LIST$3;
	var pickerValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : EMPTY_LIST$3;
	var timeDefaultValue = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : EMPTY_LIST$3;
	var onPickerValueChange = arguments.length > 11 ? arguments[11] : void 0;
	var minDate = arguments.length > 12 ? arguments[12] : void 0;
	var maxDate = arguments.length > 13 ? arguments[13] : void 0;
	var isTimePicker = pickerMode === "time";
	var mergedActiveIndex = activeIndex || 0;
	var getDefaultPickerValue = function getDefaultPickerValue$1(index$2) {
		var now$1 = generateConfig$1.getNow();
		if (isTimePicker) now$1 = fillTime(generateConfig$1, now$1);
		return defaultPickerValue[index$2] || calendarValue[index$2] || now$1;
	};
	var _pickerValue = _slicedToArray(pickerValue, 2), startPickerValue = _pickerValue[0], endPickerValue = _pickerValue[1];
	var _useMergedState = useMergedState(function() {
		return getDefaultPickerValue(0);
	}, { value: startPickerValue }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedStartPickerValue = _useMergedState2[0], setStartPickerValue = _useMergedState2[1];
	var _useMergedState3 = useMergedState(function() {
		return getDefaultPickerValue(1);
	}, { value: endPickerValue }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedEndPickerValue = _useMergedState4[0], setEndPickerValue = _useMergedState4[1];
	var currentPickerValue = import_react.useMemo(function() {
		var current = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex];
		return isTimePicker ? current : fillTime(generateConfig$1, current, timeDefaultValue[mergedActiveIndex]);
	}, [
		isTimePicker,
		mergedStartPickerValue,
		mergedEndPickerValue,
		mergedActiveIndex,
		generateConfig$1,
		timeDefaultValue
	]);
	var setCurrentPickerValue = function setCurrentPickerValue$1(nextPickerValue) {
		var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "panel";
		var updater = [setStartPickerValue, setEndPickerValue][mergedActiveIndex];
		updater(nextPickerValue);
		var clone = [mergedStartPickerValue, mergedEndPickerValue];
		clone[mergedActiveIndex] = nextPickerValue;
		if (onPickerValueChange && (!isSame(generateConfig$1, locale$5, mergedStartPickerValue, clone[0], pickerMode) || !isSame(generateConfig$1, locale$5, mergedEndPickerValue, clone[1], pickerMode))) onPickerValueChange(clone, {
			source,
			range: mergedActiveIndex === 1 ? "end" : "start",
			mode: modes
		});
	};
	/**
	* EndDate pickerValue is little different. It should be:
	* - If date picker (without time), endDate is not same year & month as startDate
	*   - pickerValue minus one month
	* - Else pass directly
	*/
	var getEndDatePickerValue = function getEndDatePickerValue$1(startDate, endDate) {
		if (multiplePanel) {
			var mode = {
				date: "month",
				week: "month",
				month: "year",
				quarter: "year"
			}[pickerMode];
			if (mode && !isSame(generateConfig$1, locale$5, startDate, endDate, mode)) return offsetPanelDate(generateConfig$1, pickerMode, endDate, -1);
			if (pickerMode === "year" && startDate) {
				var srcYear = Math.floor(generateConfig$1.getYear(startDate) / 10);
				var tgtYear = Math.floor(generateConfig$1.getYear(endDate) / 10);
				if (srcYear !== tgtYear) return offsetPanelDate(generateConfig$1, pickerMode, endDate, -1);
			}
		}
		return endDate;
	};
	var prevActiveIndexRef = import_react.useRef(null);
	useLayoutEffect_default(function() {
		if (open$2) {
			if (!defaultPickerValue[mergedActiveIndex]) {
				var nextPickerValue = isTimePicker ? null : generateConfig$1.getNow();
				/**
				* 1. If has prevActiveIndex, use it to avoid panel jump
				* 2. If current field has value
				*    - If `activeIndex` is 1 and `calendarValue[0]` is not same panel as `calendarValue[1]`,
				*      offset `calendarValue[1]` and set it
				*    - Else use `calendarValue[activeIndex]`
				* 3. If current field has no value but another field has value, use another field value
				* 4. Else use now (not any `calendarValue` can ref)
				*/
				if (prevActiveIndexRef.current !== null && prevActiveIndexRef.current !== mergedActiveIndex) nextPickerValue = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex ^ 1];
				else if (calendarValue[mergedActiveIndex]) nextPickerValue = mergedActiveIndex === 0 ? calendarValue[0] : getEndDatePickerValue(calendarValue[0], calendarValue[1]);
				else if (calendarValue[mergedActiveIndex ^ 1]) nextPickerValue = calendarValue[mergedActiveIndex ^ 1];
				if (nextPickerValue) {
					if (minDate && generateConfig$1.isAfter(minDate, nextPickerValue)) nextPickerValue = minDate;
					var offsetPickerValue = multiplePanel ? offsetPanelDate(generateConfig$1, pickerMode, nextPickerValue, 1) : nextPickerValue;
					if (maxDate && generateConfig$1.isAfter(offsetPickerValue, maxDate)) nextPickerValue = multiplePanel ? offsetPanelDate(generateConfig$1, pickerMode, maxDate, -1) : maxDate;
					setCurrentPickerValue(nextPickerValue, "reset");
				}
			}
		}
	}, [
		open$2,
		mergedActiveIndex,
		calendarValue[mergedActiveIndex]
	]);
	import_react.useEffect(function() {
		if (open$2) prevActiveIndexRef.current = mergedActiveIndex;
		else prevActiveIndexRef.current = null;
	}, [open$2, mergedActiveIndex]);
	useLayoutEffect_default(function() {
		if (open$2 && defaultPickerValue) {
			if (defaultPickerValue[mergedActiveIndex]) setCurrentPickerValue(defaultPickerValue[mergedActiveIndex], "reset");
		}
	}, [open$2, mergedActiveIndex]);
	return [currentPickerValue, setCurrentPickerValue];
}

//#endregion
//#region node_modules/rc-picker/es/hooks/useSyncState.js
/**
* Sync value with state.
* This should only used for internal which not affect outside calculation.
* Since it's not safe for suspense.
*/
function useSyncState$2(defaultValue, controlledValue) {
	var valueRef = import_react.useRef(defaultValue);
	var _React$useState = import_react.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
	var getter = function getter$1(useControlledValueFirst) {
		return useControlledValueFirst && controlledValue !== void 0 ? controlledValue : valueRef.current;
	};
	return [
		getter,
		function setter(nextValue) {
			valueRef.current = nextValue;
			forceUpdate({});
		},
		getter(true)
	];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useRangeValue.js
var EMPTY_VALUE = [];
function useUtil(generateConfig$1, locale$5, formatList) {
	return [function getDateTexts(dates) {
		return dates.map(function(date$1) {
			return formatValue(date$1, {
				generateConfig: generateConfig$1,
				locale: locale$5,
				format: formatList[0]
			});
		});
	}, function isSameDates(source, target) {
		var maxLen = Math.max(source.length, target.length);
		var diffIndex = -1;
		for (var i = 0; i < maxLen; i += 1) {
			var prev$1 = source[i] || null;
			var next$1 = target[i] || null;
			if (prev$1 !== next$1 && !isSameTimestamp(generateConfig$1, prev$1, next$1)) {
				diffIndex = i;
				break;
			}
		}
		return [diffIndex < 0, diffIndex !== 0];
	}];
}
function orderDates(dates, generateConfig$1) {
	return _toConsumableArray(dates).sort(function(a, b) {
		return generateConfig$1.isAfter(a, b) ? 1 : -1;
	});
}
/**
* Used for internal value management.
* It should always use `mergedValue` in render logic
*/
function useCalendarValue(mergedValue) {
	var _useSyncState = useSyncState$2(mergedValue), _useSyncState2 = _slicedToArray(_useSyncState, 2), calendarValue = _useSyncState2[0], setCalendarValue = _useSyncState2[1];
	/** Sync calendarValue & submitValue back with value */
	var syncWithValue = useEvent(function() {
		setCalendarValue(mergedValue);
	});
	import_react.useEffect(function() {
		syncWithValue();
	}, [mergedValue]);
	return [calendarValue, setCalendarValue];
}
/**
* Control the internal `value` align with prop `value` and provide a temp `calendarValue` for ui.
* `calendarValue` will be reset when blur & focus & open.
*/
function useInnerValue(generateConfig$1, locale$5, formatList, rangeValue, order, defaultValue, value, onCalendarChange, onOk) {
	var _useMergedState = useMergedState(defaultValue, { value }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
	var mergedValue = innerValue || EMPTY_VALUE;
	var _useCalendarValue = useCalendarValue(mergedValue), _useCalendarValue2 = _slicedToArray(_useCalendarValue, 2), calendarValue = _useCalendarValue2[0], setCalendarValue = _useCalendarValue2[1];
	var _useUtil = useUtil(generateConfig$1, locale$5, formatList), _useUtil2 = _slicedToArray(_useUtil, 2), getDateTexts = _useUtil2[0], isSameDates = _useUtil2[1];
	var triggerCalendarChange = useEvent(function(nextCalendarValues) {
		var clone = _toConsumableArray(nextCalendarValues);
		if (rangeValue) for (var i = 0; i < 2; i += 1) clone[i] = clone[i] || null;
		else if (order) clone = orderDates(clone.filter(function(date$1) {
			return date$1;
		}), generateConfig$1);
		var _isSameDates = isSameDates(calendarValue(), clone), _isSameDates2 = _slicedToArray(_isSameDates, 2), isSameMergedDates = _isSameDates2[0], isSameStart = _isSameDates2[1];
		if (!isSameMergedDates) {
			setCalendarValue(clone);
			if (onCalendarChange) {
				var cellTexts = getDateTexts(clone);
				onCalendarChange(clone, cellTexts, { range: isSameStart ? "end" : "start" });
			}
		}
	});
	return [
		mergedValue,
		setInnerValue,
		calendarValue,
		triggerCalendarChange,
		function triggerOk() {
			if (onOk) onOk(calendarValue());
		}
	];
}
function useRangeValue(info, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, open$2, isInvalidateDate) {
	var generateConfig$1 = info.generateConfig, locale$5 = info.locale, picker = info.picker, onChange = info.onChange, allowEmpty = info.allowEmpty, order = info.order;
	var orderOnChange = disabled.some(function(d) {
		return d;
	}) ? false : order;
	var _useUtil3 = useUtil(generateConfig$1, locale$5, formatList), _useUtil4 = _slicedToArray(_useUtil3, 2), getDateTexts = _useUtil4[0], isSameDates = _useUtil4[1];
	var _useSyncState3 = useSyncState$2(mergedValue), _useSyncState4 = _slicedToArray(_useSyncState3, 2), submitValue = _useSyncState4[0], setSubmitValue = _useSyncState4[1];
	/** Sync calendarValue & submitValue back with value */
	var syncWithValue = useEvent(function() {
		setSubmitValue(mergedValue);
	});
	import_react.useEffect(function() {
		syncWithValue();
	}, [mergedValue]);
	var triggerSubmit = useEvent(function(nextValue) {
		var isNullValue = nextValue === null;
		var clone = _toConsumableArray(nextValue || submitValue());
		if (isNullValue) {
			var maxLen = Math.max(disabled.length, clone.length);
			for (var i = 0; i < maxLen; i += 1) if (!disabled[i]) clone[i] = null;
		}
		if (orderOnChange && clone[0] && clone[1]) clone = orderDates(clone, generateConfig$1);
		triggerCalendarChange(clone);
		var _clone = clone, _clone2 = _slicedToArray(_clone, 2), start = _clone2[0], end = _clone2[1];
		var startEmpty = !start;
		var endEmpty = !end;
		var validateEmptyDateRange = allowEmpty ? (!startEmpty || allowEmpty[0]) && (!endEmpty || allowEmpty[1]) : true;
		var validateOrder = !order || startEmpty || endEmpty || isSame(generateConfig$1, locale$5, start, end, picker) || generateConfig$1.isAfter(end, start);
		var validateDates = (disabled[0] || !start || !isInvalidateDate(start, { activeIndex: 0 })) && (disabled[1] || !end || !isInvalidateDate(end, {
			from: start,
			activeIndex: 1
		}));
		var allPassed = isNullValue || validateEmptyDateRange && validateOrder && validateDates;
		if (allPassed) {
			setInnerValue(clone);
			var _isSameDates3 = isSameDates(clone, mergedValue), _isSameDates4 = _slicedToArray(_isSameDates3, 1), isSameMergedDates = _isSameDates4[0];
			if (onChange && !isSameMergedDates) onChange(isNullValue && clone.every(function(val) {
				return !val;
			}) ? null : clone, getDateTexts(clone));
		}
		return allPassed;
	});
	var flushSubmit = useEvent(function(index$2, needTriggerChange) {
		var nextSubmitValue = fillIndex(submitValue(), index$2, getCalendarValue()[index$2]);
		setSubmitValue(nextSubmitValue);
		if (needTriggerChange) triggerSubmit();
	});
	var interactiveFinished = !focused && !open$2;
	useLockEffect(!interactiveFinished, function() {
		if (interactiveFinished) {
			triggerSubmit();
			triggerCalendarChange(mergedValue);
			syncWithValue();
		}
	}, 2);
	return [flushSubmit, triggerSubmit];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/hooks/useShowNow.js
function useShowNow(picker, mode, showNow, showToday, rangePicker) {
	if (mode !== "date" && mode !== "time") return false;
	if (showNow !== void 0) return showNow;
	if (showToday !== void 0) return showToday;
	return !rangePicker && (picker === "date" || picker === "time");
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/TimePanel/TimePanelBody/util.js
function findValidateTime(date$1, getHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits, generateConfig$1) {
	var nextDate = date$1;
	function alignValidate(getUnitValue$1, setUnitValue, units) {
		var nextValue = generateConfig$1[getUnitValue$1](nextDate);
		var nextUnit = units.find(function(unit$2) {
			return unit$2.value === nextValue;
		});
		if (!nextUnit || nextUnit.disabled) {
			var validateUnits = units.filter(function(unit$2) {
				return !unit$2.disabled;
			});
			var validateUnit = _toConsumableArray(validateUnits).reverse().find(function(unit$2) {
				return unit$2.value <= nextValue;
			}) || validateUnits[0];
			if (validateUnit) {
				nextValue = validateUnit.value;
				nextDate = generateConfig$1[setUnitValue](nextDate, nextValue);
			}
		}
		return nextValue;
	}
	var nextHour = alignValidate("getHour", "setHour", getHourUnits());
	var nextMinute = alignValidate("getMinute", "setMinute", getMinuteUnits(nextHour));
	var nextSecond = alignValidate("getSecond", "setSecond", getSecondUnits(nextHour, nextMinute));
	alignValidate("getMillisecond", "setMillisecond", getMillisecondUnits(nextHour, nextMinute, nextSecond));
	return nextDate;
}

//#endregion
//#region node_modules/rc-picker/es/hooks/useTimeInfo.js
function emptyDisabled() {
	return [];
}
function generateUnits(start, end) {
	var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
	var hideDisabledOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	var disabledUnits = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
	var pad = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;
	var units = [];
	var integerStep = step >= 1 ? step | 0 : 1;
	for (var i = start; i <= end; i += integerStep) {
		var disabled = disabledUnits.includes(i);
		if (!disabled || !hideDisabledOptions) units.push({
			label: leftPad(i, pad),
			value: i,
			disabled
		});
	}
	return units;
}
/**
* Parse time props to get util info
*/
function useTimeInfo(generateConfig$1) {
	var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	var date$1 = arguments.length > 2 ? arguments[2] : void 0;
	var _ref = props || {}, use12Hours = _ref.use12Hours, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, _ref$millisecondStep = _ref.millisecondStep, millisecondStep = _ref$millisecondStep === void 0 ? 100 : _ref$millisecondStep, hideDisabledOptions = _ref.hideDisabledOptions, disabledTime = _ref.disabledTime, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds;
	var mergedDate = import_react.useMemo(function() {
		return date$1 || generateConfig$1.getNow();
	}, [date$1, generateConfig$1]);
	var isHourStepValid = 24 % hourStep === 0;
	var isMinuteStepValid = 60 % minuteStep === 0;
	var isSecondStepValid = 60 % secondStep === 0;
	warning_default(isHourStepValid, "`hourStep` ".concat(hourStep, " is invalid. It should be a factor of 24."));
	warning_default(isMinuteStepValid, "`minuteStep` ".concat(minuteStep, " is invalid. It should be a factor of 60."));
	warning_default(isSecondStepValid, "`secondStep` ".concat(secondStep, " is invalid. It should be a factor of 60."));
	var getDisabledTimes = import_react.useCallback(function(targetDate) {
		var disabledConfig = (disabledTime === null || disabledTime === void 0 ? void 0 : disabledTime(targetDate)) || {};
		return [
			disabledConfig.disabledHours || disabledHours || emptyDisabled,
			disabledConfig.disabledMinutes || disabledMinutes || emptyDisabled,
			disabledConfig.disabledSeconds || disabledSeconds || emptyDisabled,
			disabledConfig.disabledMilliseconds || emptyDisabled
		];
	}, [
		disabledTime,
		disabledHours,
		disabledMinutes,
		disabledSeconds
	]);
	var _React$useMemo = import_react.useMemo(function() {
		return getDisabledTimes(mergedDate);
	}, [mergedDate, getDisabledTimes]), _React$useMemo2 = _slicedToArray(_React$useMemo, 4), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2], mergedDisabledMilliseconds = _React$useMemo2[3];
	var getAllUnits = import_react.useCallback(function(getDisabledHours, getDisabledMinutes, getDisabledSeconds, getDisabledMilliseconds) {
		var hours = generateUnits(0, 23, hourStep, hideDisabledOptions, getDisabledHours());
		return [
			use12Hours ? hours.map(function(unit$2) {
				return _objectSpread2(_objectSpread2({}, unit$2), {}, { label: leftPad(unit$2.value % 12 || 12, 2) });
			}) : hours,
			function getMinuteUnits$1(nextHour) {
				return generateUnits(0, 59, minuteStep, hideDisabledOptions, getDisabledMinutes(nextHour));
			},
			function getSecondUnits$1(nextHour, nextMinute) {
				return generateUnits(0, 59, secondStep, hideDisabledOptions, getDisabledSeconds(nextHour, nextMinute));
			},
			function getMillisecondUnits$1(nextHour, nextMinute, nextSecond) {
				return generateUnits(0, 999, millisecondStep, hideDisabledOptions, getDisabledMilliseconds(nextHour, nextMinute, nextSecond), 3);
			}
		];
	}, [
		hideDisabledOptions,
		hourStep,
		use12Hours,
		millisecondStep,
		minuteStep,
		secondStep
	]);
	var _React$useMemo3 = import_react.useMemo(function() {
		return getAllUnits(mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds);
	}, [
		getAllUnits,
		mergedDisabledHours,
		mergedDisabledMinutes,
		mergedDisabledSeconds,
		mergedDisabledMilliseconds
	]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 4), rowHourUnits = _React$useMemo4[0], getMinuteUnits = _React$useMemo4[1], getSecondUnits = _React$useMemo4[2], getMillisecondUnits = _React$useMemo4[3];
	return [
		function getValidTime(nextTime, certainDate) {
			var getCheckHourUnits = function getCheckHourUnits$1() {
				return rowHourUnits;
			};
			var getCheckMinuteUnits = getMinuteUnits;
			var getCheckSecondUnits = getSecondUnits;
			var getCheckMillisecondUnits = getMillisecondUnits;
			if (certainDate) {
				var _getDisabledTimes = getDisabledTimes(certainDate), _getDisabledTimes2 = _slicedToArray(_getDisabledTimes, 4), targetDisabledHours = _getDisabledTimes2[0], targetDisabledMinutes = _getDisabledTimes2[1], targetDisabledSeconds = _getDisabledTimes2[2], targetDisabledMilliseconds = _getDisabledTimes2[3];
				var _getAllUnits = getAllUnits(targetDisabledHours, targetDisabledMinutes, targetDisabledSeconds, targetDisabledMilliseconds), _getAllUnits2 = _slicedToArray(_getAllUnits, 4), targetRowHourUnits = _getAllUnits2[0], targetGetMinuteUnits = _getAllUnits2[1], targetGetSecondUnits = _getAllUnits2[2], targetGetMillisecondUnits = _getAllUnits2[3];
				getCheckHourUnits = function getCheckHourUnits$1() {
					return targetRowHourUnits;
				};
				getCheckMinuteUnits = targetGetMinuteUnits;
				getCheckSecondUnits = targetGetSecondUnits;
				getCheckMillisecondUnits = targetGetMillisecondUnits;
			}
			return findValidateTime(nextTime, getCheckHourUnits, getCheckMinuteUnits, getCheckSecondUnits, getCheckMillisecondUnits, generateConfig$1);
		},
		rowHourUnits,
		getMinuteUnits,
		getSecondUnits,
		getMillisecondUnits
	];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Popup/Footer.js
var import_classnames$183 = /* @__PURE__ */ __toESM(require_classnames());
function Footer$3(props) {
	var mode = props.mode, internalMode = props.internalMode, renderExtraFooter = props.renderExtraFooter, showNow = props.showNow, showTime = props.showTime, onSubmit = props.onSubmit, onNow = props.onNow, invalid = props.invalid, needConfirm = props.needConfirm, generateConfig$1 = props.generateConfig, disabledDate = props.disabledDate;
	var _React$useContext = import_react.useContext(context_default$6), prefixCls = _React$useContext.prefixCls, locale$5 = _React$useContext.locale, _React$useContext$but = _React$useContext.button, Button$1 = _React$useContext$but === void 0 ? "button" : _React$useContext$but;
	var now$1 = generateConfig$1.getNow();
	var _useTimeInfo = useTimeInfo(generateConfig$1, showTime, now$1), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0];
	var extraNode = renderExtraFooter === null || renderExtraFooter === void 0 ? void 0 : renderExtraFooter(mode);
	var nowDisabled = disabledDate(now$1, { type: mode });
	var onInternalNow = function onInternalNow$1() {
		if (!nowDisabled) {
			var validateNow = getValidTime(now$1);
			onNow(validateNow);
		}
	};
	var nowPrefixCls = "".concat(prefixCls, "-now");
	var nowBtnPrefixCls = "".concat(nowPrefixCls, "-btn");
	var presetNode = showNow && /* @__PURE__ */ import_react.createElement("li", { className: nowPrefixCls }, /* @__PURE__ */ import_react.createElement("a", {
		className: (0, import_classnames$183.default)(nowBtnPrefixCls, nowDisabled && "".concat(nowBtnPrefixCls, "-disabled")),
		"aria-disabled": nowDisabled,
		onClick: onInternalNow
	}, internalMode === "date" ? locale$5.today : locale$5.now));
	var okNode = needConfirm && /* @__PURE__ */ import_react.createElement("li", { className: "".concat(prefixCls, "-ok") }, /* @__PURE__ */ import_react.createElement(Button$1, {
		disabled: invalid,
		onClick: onSubmit
	}, locale$5.ok));
	var rangeNode = (presetNode || okNode) && /* @__PURE__ */ import_react.createElement("ul", { className: "".concat(prefixCls, "-ranges") }, presetNode, okNode);
	if (!extraNode && !rangeNode) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-footer") }, extraNode && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-footer-extra") }, extraNode), rangeNode);
}

//#endregion
//#region node_modules/rc-picker/es/hooks/useToggleDates.js
/**
* Toggles the presence of a value in an array.
* If the value exists in the array, removed it.
* Else add it.
*/
function useToggleDates(generateConfig$1, locale$5, panelMode) {
	function toggleDates(list, target) {
		var index$2 = list.findIndex(function(date$1) {
			return isSame(generateConfig$1, locale$5, date$1, target, panelMode);
		});
		if (index$2 === -1) return [].concat(_toConsumableArray(list), [target]);
		var sliceList = _toConsumableArray(list);
		sliceList.splice(index$2, 1);
		return sliceList;
	}
	return toggleDates;
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/context.js
/** Used for each single Panel. e.g. DatePanel */
var PanelContext = /* @__PURE__ */ import_react.createContext(null);
function usePanelContext() {
	return import_react.useContext(PanelContext);
}
/**
* Get shared props for the SharedPanelProps interface.
*/
function useInfo(props, panelType) {
	var prefixCls = props.prefixCls, generateConfig$1 = props.generateConfig, locale$5 = props.locale, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, cellRender = props.cellRender, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, onHover = props.onHover, values = props.values, pickerValue = props.pickerValue, onSelect = props.onSelect, prevIcon = props.prevIcon, nextIcon = props.nextIcon, superPrevIcon = props.superPrevIcon, superNextIcon = props.superNextIcon;
	var now$1 = generateConfig$1.getNow();
	return [{
		now: now$1,
		values,
		pickerValue,
		prefixCls,
		disabledDate,
		minDate,
		maxDate,
		cellRender,
		hoverValue,
		hoverRangeValue,
		onHover,
		locale: locale$5,
		generateConfig: generateConfig$1,
		onSelect,
		panelType,
		prevIcon,
		nextIcon,
		superPrevIcon,
		superNextIcon
	}, now$1];
}
/**
* Internal usage for RangePicker to not to show the operation arrow
*/
var PickerHackContext = /* @__PURE__ */ import_react.createContext({});
PickerHackContext.displayName = "PickerHackContext";

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/PanelBody.js
var import_classnames$182 = /* @__PURE__ */ __toESM(require_classnames());
function PanelBody(props) {
	var rowNum = props.rowNum, colNum = props.colNum, baseDate = props.baseDate, getCellDate = props.getCellDate, prefixColumn = props.prefixColumn, rowClassName = props.rowClassName, titleFormat = props.titleFormat, getCellText = props.getCellText, getCellClassName = props.getCellClassName, headerCells = props.headerCells, _props$cellSelection = props.cellSelection, cellSelection = _props$cellSelection === void 0 ? true : _props$cellSelection, disabledDate = props.disabledDate;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, type$2 = _usePanelContext.panelType, now$1 = _usePanelContext.now, contextDisabledDate = _usePanelContext.disabledDate, cellRender = _usePanelContext.cellRender, onHover = _usePanelContext.onHover, hoverValue = _usePanelContext.hoverValue, hoverRangeValue = _usePanelContext.hoverRangeValue, generateConfig$1 = _usePanelContext.generateConfig, values = _usePanelContext.values, locale$5 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect;
	var mergedDisabledDate = disabledDate || contextDisabledDate;
	var cellPrefixCls = "".concat(prefixCls, "-cell");
	var _React$useContext = import_react.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
	var matchValues = function matchValues$1(date$1) {
		return values.some(function(singleValue) {
			return singleValue && isSame(generateConfig$1, locale$5, date$1, singleValue, type$2);
		});
	};
	var rows = [];
	for (var row = 0; row < rowNum; row += 1) {
		var rowNode = [];
		var rowStartDate = void 0;
		var _loop = function _loop$1() {
			var offset$2 = row * colNum + col;
			var currentDate = getCellDate(baseDate, offset$2);
			var disabled = mergedDisabledDate === null || mergedDisabledDate === void 0 ? void 0 : mergedDisabledDate(currentDate, { type: type$2 });
			if (col === 0) {
				rowStartDate = currentDate;
				if (prefixColumn) rowNode.push(prefixColumn(rowStartDate));
			}
			var inRange = false;
			var rangeStart = false;
			var rangeEnd = false;
			if (cellSelection && hoverRangeValue) {
				var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2), hoverStart = _hoverRangeValue[0], hoverEnd = _hoverRangeValue[1];
				inRange = isInRange(generateConfig$1, hoverStart, hoverEnd, currentDate);
				rangeStart = isSame(generateConfig$1, locale$5, currentDate, hoverStart, type$2);
				rangeEnd = isSame(generateConfig$1, locale$5, currentDate, hoverEnd, type$2);
			}
			var title = titleFormat ? formatValue(currentDate, {
				locale: locale$5,
				format: titleFormat,
				generateConfig: generateConfig$1
			}) : void 0;
			var inner = /* @__PURE__ */ import_react.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, getCellText(currentDate));
			rowNode.push(/* @__PURE__ */ import_react.createElement("td", {
				key: col,
				title,
				className: (0, import_classnames$182.default)(cellPrefixCls, _objectSpread2(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(cellPrefixCls, "-disabled"), disabled), "".concat(cellPrefixCls, "-hover"), (hoverValue || []).some(function(date$1) {
					return isSame(generateConfig$1, locale$5, currentDate, date$1, type$2);
				})), "".concat(cellPrefixCls, "-in-range"), inRange && !rangeStart && !rangeEnd), "".concat(cellPrefixCls, "-range-start"), rangeStart), "".concat(cellPrefixCls, "-range-end"), rangeEnd), "".concat(prefixCls, "-cell-selected"), !hoverRangeValue && type$2 !== "week" && matchValues(currentDate)), getCellClassName(currentDate))),
				onClick: function onClick() {
					if (!disabled) onSelect(currentDate);
				},
				onDoubleClick: function onDoubleClick() {
					if (!disabled && onCellDblClick) onCellDblClick();
				},
				onMouseEnter: function onMouseEnter() {
					if (!disabled) onHover === null || onHover === void 0 || onHover(currentDate);
				},
				onMouseLeave: function onMouseLeave() {
					if (!disabled) onHover === null || onHover === void 0 || onHover(null);
				}
			}, cellRender ? cellRender(currentDate, {
				prefixCls,
				originNode: inner,
				today: now$1,
				type: type$2,
				locale: locale$5
			}) : inner));
		};
		for (var col = 0; col < colNum; col += 1) _loop();
		rows.push(/* @__PURE__ */ import_react.createElement("tr", {
			key: row,
			className: rowClassName === null || rowClassName === void 0 ? void 0 : rowClassName(rowStartDate)
		}, rowNode));
	}
	return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-body") }, /* @__PURE__ */ import_react.createElement("table", { className: "".concat(prefixCls, "-content") }, headerCells && /* @__PURE__ */ import_react.createElement("thead", null, /* @__PURE__ */ import_react.createElement("tr", null, headerCells)), /* @__PURE__ */ import_react.createElement("tbody", null, rows)));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/PanelHeader.js
var import_classnames$181 = /* @__PURE__ */ __toESM(require_classnames());
var HIDDEN_STYLE$2 = { visibility: "hidden" };
function PanelHeader(props) {
	var offset$2 = props.offset, superOffset = props.superOffset, onChange = props.onChange, getStart = props.getStart, getEnd = props.getEnd, children = props.children;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, _usePanelContext$prev = _usePanelContext.prevIcon, prevIcon = _usePanelContext$prev === void 0 ? "" : _usePanelContext$prev, _usePanelContext$next = _usePanelContext.nextIcon, nextIcon = _usePanelContext$next === void 0 ? "" : _usePanelContext$next, _usePanelContext$supe = _usePanelContext.superPrevIcon, superPrevIcon = _usePanelContext$supe === void 0 ? "" : _usePanelContext$supe, _usePanelContext$supe2 = _usePanelContext.superNextIcon, superNextIcon = _usePanelContext$supe2 === void 0 ? "" : _usePanelContext$supe2, minDate = _usePanelContext.minDate, maxDate = _usePanelContext.maxDate, generateConfig$1 = _usePanelContext.generateConfig, locale$5 = _usePanelContext.locale, pickerValue = _usePanelContext.pickerValue, type$2 = _usePanelContext.panelType;
	var headerPrefixCls = "".concat(prefixCls, "-header");
	var _React$useContext = import_react.useContext(PickerHackContext), hidePrev = _React$useContext.hidePrev, hideNext = _React$useContext.hideNext, hideHeader = _React$useContext.hideHeader;
	var disabledOffsetPrev = import_react.useMemo(function() {
		if (!minDate || !offset$2 || !getEnd) return false;
		var prevPanelLimitDate = getEnd(offset$2(-1, pickerValue));
		return !isSameOrAfter(generateConfig$1, locale$5, prevPanelLimitDate, minDate, type$2);
	}, [
		minDate,
		offset$2,
		pickerValue,
		getEnd,
		generateConfig$1,
		locale$5,
		type$2
	]);
	var disabledSuperOffsetPrev = import_react.useMemo(function() {
		if (!minDate || !superOffset || !getEnd) return false;
		var prevPanelLimitDate = getEnd(superOffset(-1, pickerValue));
		return !isSameOrAfter(generateConfig$1, locale$5, prevPanelLimitDate, minDate, type$2);
	}, [
		minDate,
		superOffset,
		pickerValue,
		getEnd,
		generateConfig$1,
		locale$5,
		type$2
	]);
	var disabledOffsetNext = import_react.useMemo(function() {
		if (!maxDate || !offset$2 || !getStart) return false;
		var nextPanelLimitDate = getStart(offset$2(1, pickerValue));
		return !isSameOrAfter(generateConfig$1, locale$5, maxDate, nextPanelLimitDate, type$2);
	}, [
		maxDate,
		offset$2,
		pickerValue,
		getStart,
		generateConfig$1,
		locale$5,
		type$2
	]);
	var disabledSuperOffsetNext = import_react.useMemo(function() {
		if (!maxDate || !superOffset || !getStart) return false;
		var nextPanelLimitDate = getStart(superOffset(1, pickerValue));
		return !isSameOrAfter(generateConfig$1, locale$5, maxDate, nextPanelLimitDate, type$2);
	}, [
		maxDate,
		superOffset,
		pickerValue,
		getStart,
		generateConfig$1,
		locale$5,
		type$2
	]);
	var onOffset = function onOffset$1(distance) {
		if (offset$2) onChange(offset$2(distance, pickerValue));
	};
	var onSuperOffset = function onSuperOffset$1(distance) {
		if (superOffset) onChange(superOffset(distance, pickerValue));
	};
	if (hideHeader) return null;
	var prevBtnCls = "".concat(headerPrefixCls, "-prev-btn");
	var nextBtnCls = "".concat(headerPrefixCls, "-next-btn");
	var superPrevBtnCls = "".concat(headerPrefixCls, "-super-prev-btn");
	var superNextBtnCls = "".concat(headerPrefixCls, "-super-next-btn");
	return /* @__PURE__ */ import_react.createElement("div", { className: headerPrefixCls }, superOffset && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.previousYear,
		onClick: function onClick() {
			return onSuperOffset(-1);
		},
		tabIndex: -1,
		className: (0, import_classnames$181.default)(superPrevBtnCls, disabledSuperOffsetPrev && "".concat(superPrevBtnCls, "-disabled")),
		disabled: disabledSuperOffsetPrev,
		style: hidePrev ? HIDDEN_STYLE$2 : {}
	}, superPrevIcon), offset$2 && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.previousMonth,
		onClick: function onClick() {
			return onOffset(-1);
		},
		tabIndex: -1,
		className: (0, import_classnames$181.default)(prevBtnCls, disabledOffsetPrev && "".concat(prevBtnCls, "-disabled")),
		disabled: disabledOffsetPrev,
		style: hidePrev ? HIDDEN_STYLE$2 : {}
	}, prevIcon), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(headerPrefixCls, "-view") }, children), offset$2 && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.nextMonth,
		onClick: function onClick() {
			return onOffset(1);
		},
		tabIndex: -1,
		className: (0, import_classnames$181.default)(nextBtnCls, disabledOffsetNext && "".concat(nextBtnCls, "-disabled")),
		disabled: disabledOffsetNext,
		style: hideNext ? HIDDEN_STYLE$2 : {}
	}, nextIcon), superOffset && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.nextYear,
		onClick: function onClick() {
			return onSuperOffset(1);
		},
		tabIndex: -1,
		className: (0, import_classnames$181.default)(superNextBtnCls, disabledSuperOffsetNext && "".concat(superNextBtnCls, "-disabled")),
		disabled: disabledSuperOffsetNext,
		style: hideNext ? HIDDEN_STYLE$2 : {}
	}, superNextIcon));
}
var PanelHeader_default = PanelHeader;

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/DatePanel/index.js
var import_classnames$180 = /* @__PURE__ */ __toESM(require_classnames());
function DatePanel(props) {
	var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, _props$mode = props.mode, mode = _props$mode === void 0 ? "date" : _props$mode, disabledDate = props.disabledDate, onSelect = props.onSelect, onHover = props.onHover, showWeek = props.showWeek;
	var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
	var cellPrefixCls = "".concat(prefixCls, "-cell");
	var isWeek = mode === "week";
	var _useInfo = useInfo(props, mode), _useInfo2 = _slicedToArray(_useInfo, 2), info = _useInfo2[0], now$1 = _useInfo2[1];
	var weekFirstDay = generateConfig$1.locale.getWeekFirstDay(locale$5.locale);
	var monthStartDate = generateConfig$1.setDate(pickerValue, 1);
	var baseDate = getWeekStartDate(locale$5.locale, generateConfig$1, monthStartDate);
	var month = generateConfig$1.getMonth(pickerValue);
	var prefixColumn = (showWeek === void 0 ? isWeek : showWeek) ? function(date$1) {
		var disabled = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date$1, { type: "week" });
		return /* @__PURE__ */ import_react.createElement("td", {
			key: "week",
			className: (0, import_classnames$180.default)(cellPrefixCls, "".concat(cellPrefixCls, "-week"), _defineProperty({}, "".concat(cellPrefixCls, "-disabled"), disabled)),
			onClick: function onClick() {
				if (!disabled) onSelect(date$1);
			},
			onMouseEnter: function onMouseEnter() {
				if (!disabled) onHover === null || onHover === void 0 || onHover(date$1);
			},
			onMouseLeave: function onMouseLeave() {
				if (!disabled) onHover === null || onHover === void 0 || onHover(null);
			}
		}, /* @__PURE__ */ import_react.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, generateConfig$1.locale.getWeek(locale$5.locale, date$1)));
	} : null;
	var headerCells = [];
	var weekDaysLocale = locale$5.shortWeekDays || (generateConfig$1.locale.getShortWeekDays ? generateConfig$1.locale.getShortWeekDays(locale$5.locale) : []);
	if (prefixColumn) headerCells.push(/* @__PURE__ */ import_react.createElement("th", { key: "empty" }, /* @__PURE__ */ import_react.createElement("span", { style: {
		width: 0,
		height: 0,
		position: "absolute",
		overflow: "hidden",
		opacity: 0
	} }, locale$5.week)));
	for (var i = 0; i < WEEK_DAY_COUNT; i += 1) headerCells.push(/* @__PURE__ */ import_react.createElement("th", { key: i }, weekDaysLocale[(i + weekFirstDay) % WEEK_DAY_COUNT]));
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addDate(date$1, offset$2);
	};
	var getCellText = function getCellText$1(date$1) {
		return formatValue(date$1, {
			locale: locale$5,
			format: locale$5.cellDateFormat,
			generateConfig: generateConfig$1
		});
	};
	var getCellClassName = function getCellClassName$1(date$1) {
		return _defineProperty(_defineProperty({}, "".concat(prefixCls, "-cell-in-view"), isSameMonth$1(generateConfig$1, date$1, pickerValue)), "".concat(prefixCls, "-cell-today"), isSameDate$1(generateConfig$1, date$1, now$1));
	};
	var monthsLocale = locale$5.shortMonths || (generateConfig$1.locale.getShortMonths ? generateConfig$1.locale.getShortMonths(locale$5.locale) : []);
	var yearNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.yearSelect,
		key: "year",
		onClick: function onClick() {
			onModeChange("year", pickerValue);
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	var monthNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		"aria-label": locale$5.monthSelect,
		key: "month",
		onClick: function onClick() {
			onModeChange("month", pickerValue);
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-month-btn")
	}, locale$5.monthFormat ? formatValue(pickerValue, {
		locale: locale$5,
		format: locale$5.monthFormat,
		generateConfig: generateConfig$1
	}) : monthsLocale[month]);
	var monthYearNodes = locale$5.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$180.default)(panelPrefixCls, showWeek && "".concat(panelPrefixCls, "-show-week")) }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		offset: function offset$2(distance) {
			return generateConfig$1.addMonth(pickerValue, distance);
		},
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function getStart(date$1) {
			return generateConfig$1.setDate(date$1, 1);
		},
		getEnd: function getEnd(date$1) {
			var clone = generateConfig$1.setDate(date$1, 1);
			clone = generateConfig$1.addMonth(clone, 1);
			return generateConfig$1.addDate(clone, -1);
		}
	}, monthYearNodes), /* @__PURE__ */ import_react.createElement(PanelBody, _extends({ titleFormat: locale$5.fieldDateFormat }, props, {
		colNum: WEEK_DAY_COUNT,
		rowNum: 6,
		baseDate,
		headerCells,
		getCellDate,
		getCellText,
		getCellClassName,
		prefixColumn,
		cellSelection: !isWeek
	}))));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/TimePanel/TimePanelBody/useScrollTo.js
var SPEED_PTG = 1 / 3;
function useScrollTo(ulRef, value) {
	var scrollingRef = import_react.useRef(false);
	var scrollRafRef = import_react.useRef(null);
	var scrollDistRef = import_react.useRef(null);
	var isScrolling = function isScrolling$1() {
		return scrollingRef.current;
	};
	var stopScroll = function stopScroll$1() {
		raf_default.cancel(scrollRafRef.current);
		scrollingRef.current = false;
	};
	var scrollRafTimesRef = import_react.useRef();
	return [
		useEvent(function startScroll() {
			var ul = ulRef.current;
			scrollDistRef.current = null;
			scrollRafTimesRef.current = 0;
			if (ul) {
				var targetLi = ul.querySelector("[data-value=\"".concat(value, "\"]"));
				var firstLi = ul.querySelector("li");
				var doScroll = function doScroll$1() {
					stopScroll();
					scrollingRef.current = true;
					scrollRafTimesRef.current += 1;
					var currentTop = ul.scrollTop;
					var firstLiTop = firstLi.offsetTop;
					var targetLiTop = targetLi.offsetTop;
					var targetTop = targetLiTop - firstLiTop;
					if (targetLiTop === 0 && targetLi !== firstLi || !isVisible_default(ul)) {
						if (scrollRafTimesRef.current <= 5) scrollRafRef.current = raf_default(doScroll$1);
						return;
					}
					var nextTop = currentTop + (targetTop - currentTop) * SPEED_PTG;
					var dist = Math.abs(targetTop - nextTop);
					if (scrollDistRef.current !== null && scrollDistRef.current < dist) {
						stopScroll();
						return;
					}
					scrollDistRef.current = dist;
					if (dist <= 1) {
						ul.scrollTop = targetTop;
						stopScroll();
						return;
					}
					ul.scrollTop = nextTop;
					scrollRafRef.current = raf_default(doScroll$1);
				};
				if (targetLi && firstLi) doScroll();
			}
		}),
		stopScroll,
		isScrolling
	];
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/TimePanel/TimePanelBody/TimeColumn.js
var import_classnames$179 = /* @__PURE__ */ __toESM(require_classnames());
var SCROLL_DELAY = 300;
function flattenUnits(units) {
	return units.map(function(_ref) {
		var value = _ref.value, label = _ref.label, disabled = _ref.disabled;
		return [
			value,
			label,
			disabled
		].join(",");
	}).join(";");
}
function TimeColumn(props) {
	var units = props.units, value = props.value, optionalValue = props.optionalValue, type$2 = props.type, onChange = props.onChange, onHover = props.onHover, onDblClick = props.onDblClick, changeOnScroll = props.changeOnScroll;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, cellRender = _usePanelContext.cellRender, now$1 = _usePanelContext.now, locale$5 = _usePanelContext.locale;
	var panelPrefixCls = "".concat(prefixCls, "-time-panel");
	var cellPrefixCls = "".concat(prefixCls, "-time-panel-cell");
	var ulRef = import_react.useRef(null);
	var checkDelayRef = import_react.useRef();
	var clearDelayCheck = function clearDelayCheck$1() {
		clearTimeout(checkDelayRef.current);
	};
	var _useScrollTo = useScrollTo(ulRef, value !== null && value !== void 0 ? value : optionalValue), _useScrollTo2 = _slicedToArray(_useScrollTo, 3), syncScroll = _useScrollTo2[0], stopScroll = _useScrollTo2[1], isScrolling = _useScrollTo2[2];
	useLayoutEffect_default(function() {
		syncScroll();
		clearDelayCheck();
		return function() {
			stopScroll();
			clearDelayCheck();
		};
	}, [
		value,
		optionalValue,
		flattenUnits(units)
	]);
	var onInternalScroll = function onInternalScroll$1(event) {
		clearDelayCheck();
		var target = event.target;
		if (!isScrolling() && changeOnScroll) checkDelayRef.current = setTimeout(function() {
			var ul = ulRef.current;
			var firstLiTop = ul.querySelector("li").offsetTop;
			var liDistList = Array.from(ul.querySelectorAll("li")).map(function(li) {
				return li.offsetTop - firstLiTop;
			}).map(function(top, index$2) {
				if (units[index$2].disabled) return Number.MAX_SAFE_INTEGER;
				return Math.abs(top - target.scrollTop);
			});
			var minDist = Math.min.apply(Math, _toConsumableArray(liDistList));
			var minDistIndex = liDistList.findIndex(function(dist) {
				return dist === minDist;
			});
			var targetUnit = units[minDistIndex];
			if (targetUnit && !targetUnit.disabled) onChange(targetUnit.value);
		}, SCROLL_DELAY);
	};
	var columnPrefixCls = "".concat(panelPrefixCls, "-column");
	return /* @__PURE__ */ import_react.createElement("ul", {
		className: columnPrefixCls,
		ref: ulRef,
		"data-type": type$2,
		onScroll: onInternalScroll
	}, units.map(function(_ref2) {
		var label = _ref2.label, unitValue = _ref2.value, disabled = _ref2.disabled;
		var inner = /* @__PURE__ */ import_react.createElement("div", { className: "".concat(cellPrefixCls, "-inner") }, label);
		return /* @__PURE__ */ import_react.createElement("li", {
			key: unitValue,
			className: (0, import_classnames$179.default)(cellPrefixCls, _defineProperty(_defineProperty({}, "".concat(cellPrefixCls, "-selected"), value === unitValue), "".concat(cellPrefixCls, "-disabled"), disabled)),
			onClick: function onClick() {
				if (!disabled) onChange(unitValue);
			},
			onDoubleClick: function onDoubleClick() {
				if (!disabled && onDblClick) onDblClick();
			},
			onMouseEnter: function onMouseEnter() {
				onHover(unitValue);
			},
			onMouseLeave: function onMouseLeave() {
				onHover(null);
			},
			"data-value": unitValue
		}, cellRender ? cellRender(unitValue, {
			prefixCls,
			originNode: inner,
			today: now$1,
			type: "time",
			subType: type$2,
			locale: locale$5
		}) : inner);
	}));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/TimePanel/TimePanelBody/index.js
function isAM(hour) {
	return hour < 12;
}
function TimePanelBody(props) {
	var showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, showMillisecond = props.showMillisecond, showMeridiem = props.use12Hours, changeOnScroll = props.changeOnScroll;
	var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, values = _usePanelContext.values, generateConfig$1 = _usePanelContext.generateConfig, locale$5 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect, _usePanelContext$onHo = _usePanelContext.onHover, onHover = _usePanelContext$onHo === void 0 ? function() {} : _usePanelContext$onHo, pickerValue = _usePanelContext.pickerValue;
	var value = (values === null || values === void 0 ? void 0 : values[0]) || null;
	var _React$useContext = import_react.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
	var _useTimeInfo = useTimeInfo(generateConfig$1, props, value), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 5), getValidTime = _useTimeInfo2[0], rowHourUnits = _useTimeInfo2[1], getMinuteUnits = _useTimeInfo2[2], getSecondUnits = _useTimeInfo2[3], getMillisecondUnits = _useTimeInfo2[4];
	var getUnitValue$1 = function getUnitValue$2(func) {
		var valueUnitVal = value && generateConfig$1[func](value);
		var pickerUnitValue = pickerValue && generateConfig$1[func](pickerValue);
		return [valueUnitVal, pickerUnitValue];
	};
	var _getUnitValue = getUnitValue$1("getHour"), _getUnitValue2 = _slicedToArray(_getUnitValue, 2), hour = _getUnitValue2[0], pickerHour = _getUnitValue2[1];
	var _getUnitValue3 = getUnitValue$1("getMinute"), _getUnitValue4 = _slicedToArray(_getUnitValue3, 2), minute = _getUnitValue4[0], pickerMinute = _getUnitValue4[1];
	var _getUnitValue5 = getUnitValue$1("getSecond"), _getUnitValue6 = _slicedToArray(_getUnitValue5, 2), second = _getUnitValue6[0], pickerSecond = _getUnitValue6[1];
	var _getUnitValue7 = getUnitValue$1("getMillisecond"), _getUnitValue8 = _slicedToArray(_getUnitValue7, 2), millisecond = _getUnitValue8[0], pickerMillisecond = _getUnitValue8[1];
	var meridiem = hour === null ? null : isAM(hour) ? "am" : "pm";
	var hourUnits = import_react.useMemo(function() {
		if (!showMeridiem) return rowHourUnits;
		return isAM(hour) ? rowHourUnits.filter(function(h) {
			return isAM(h.value);
		}) : rowHourUnits.filter(function(h) {
			return !isAM(h.value);
		});
	}, [
		hour,
		rowHourUnits,
		showMeridiem
	]);
	var getEnabled = function getEnabled$1(units, val) {
		var _enabledUnits$;
		var enabledUnits = units.filter(function(unit$2) {
			return !unit$2.disabled;
		});
		return val !== null && val !== void 0 ? val : enabledUnits === null || enabledUnits === void 0 || (_enabledUnits$ = enabledUnits[0]) === null || _enabledUnits$ === void 0 ? void 0 : _enabledUnits$.value;
	};
	var validHour = getEnabled(rowHourUnits, hour);
	var minuteUnits = import_react.useMemo(function() {
		return getMinuteUnits(validHour);
	}, [getMinuteUnits, validHour]);
	var validMinute = getEnabled(minuteUnits, minute);
	var secondUnits = import_react.useMemo(function() {
		return getSecondUnits(validHour, validMinute);
	}, [
		getSecondUnits,
		validHour,
		validMinute
	]);
	var validSecond = getEnabled(secondUnits, second);
	var millisecondUnits = import_react.useMemo(function() {
		return getMillisecondUnits(validHour, validMinute, validSecond);
	}, [
		getMillisecondUnits,
		validHour,
		validMinute,
		validSecond
	]);
	var validMillisecond = getEnabled(millisecondUnits, millisecond);
	var meridiemUnits = import_react.useMemo(function() {
		if (!showMeridiem) return [];
		var base = generateConfig$1.getNow();
		var amDate = generateConfig$1.setHour(base, 6);
		var pmDate = generateConfig$1.setHour(base, 18);
		var formatMeridiem = function formatMeridiem$1(date$1, defaultLabel) {
			var cellMeridiemFormat = locale$5.cellMeridiemFormat;
			return cellMeridiemFormat ? formatValue(date$1, {
				generateConfig: generateConfig$1,
				locale: locale$5,
				format: cellMeridiemFormat
			}) : defaultLabel;
		};
		return [{
			label: formatMeridiem(amDate, "AM"),
			value: "am",
			disabled: rowHourUnits.every(function(h) {
				return h.disabled || !isAM(h.value);
			})
		}, {
			label: formatMeridiem(pmDate, "PM"),
			value: "pm",
			disabled: rowHourUnits.every(function(h) {
				return h.disabled || isAM(h.value);
			})
		}];
	}, [
		rowHourUnits,
		showMeridiem,
		generateConfig$1,
		locale$5
	]);
	/**
	* Check if time is validate or will match to validate one
	*/
	var triggerChange = function triggerChange$1(nextDate) {
		var validateDate = getValidTime(nextDate);
		onSelect(validateDate);
	};
	var triggerDateTmpl = import_react.useMemo(function() {
		var tmpl = value || pickerValue || generateConfig$1.getNow();
		var isNotNull = function isNotNull$1(num) {
			return num !== null && num !== void 0;
		};
		if (isNotNull(hour)) {
			tmpl = generateConfig$1.setHour(tmpl, hour);
			tmpl = generateConfig$1.setMinute(tmpl, minute);
			tmpl = generateConfig$1.setSecond(tmpl, second);
			tmpl = generateConfig$1.setMillisecond(tmpl, millisecond);
		} else if (isNotNull(pickerHour)) {
			tmpl = generateConfig$1.setHour(tmpl, pickerHour);
			tmpl = generateConfig$1.setMinute(tmpl, pickerMinute);
			tmpl = generateConfig$1.setSecond(tmpl, pickerSecond);
			tmpl = generateConfig$1.setMillisecond(tmpl, pickerMillisecond);
		} else if (isNotNull(validHour)) {
			tmpl = generateConfig$1.setHour(tmpl, validHour);
			tmpl = generateConfig$1.setMinute(tmpl, validMinute);
			tmpl = generateConfig$1.setSecond(tmpl, validSecond);
			tmpl = generateConfig$1.setMillisecond(tmpl, validMillisecond);
		}
		return tmpl;
	}, [
		value,
		pickerValue,
		hour,
		minute,
		second,
		millisecond,
		validHour,
		validMinute,
		validSecond,
		validMillisecond,
		pickerHour,
		pickerMinute,
		pickerSecond,
		pickerMillisecond,
		generateConfig$1
	]);
	var fillColumnValue = function fillColumnValue$1(val, func) {
		if (val === null) return null;
		return generateConfig$1[func](triggerDateTmpl, val);
	};
	var getNextHourTime = function getNextHourTime$1(val) {
		return fillColumnValue(val, "setHour");
	};
	var getNextMinuteTime = function getNextMinuteTime$1(val) {
		return fillColumnValue(val, "setMinute");
	};
	var getNextSecondTime = function getNextSecondTime$1(val) {
		return fillColumnValue(val, "setSecond");
	};
	var getNextMillisecondTime = function getNextMillisecondTime$1(val) {
		return fillColumnValue(val, "setMillisecond");
	};
	var getMeridiemTime = function getMeridiemTime$1(val) {
		if (val === null) return null;
		if (val === "am" && !isAM(hour)) return generateConfig$1.setHour(triggerDateTmpl, hour - 12);
		else if (val === "pm" && isAM(hour)) return generateConfig$1.setHour(triggerDateTmpl, hour + 12);
		return triggerDateTmpl;
	};
	var onHourChange = function onHourChange$1(val) {
		triggerChange(getNextHourTime(val));
	};
	var onMinuteChange = function onMinuteChange$1(val) {
		triggerChange(getNextMinuteTime(val));
	};
	var onSecondChange = function onSecondChange$1(val) {
		triggerChange(getNextSecondTime(val));
	};
	var onMillisecondChange = function onMillisecondChange$1(val) {
		triggerChange(getNextMillisecondTime(val));
	};
	var onMeridiemChange = function onMeridiemChange$1(val) {
		triggerChange(getMeridiemTime(val));
	};
	var onHourHover = function onHourHover$1(val) {
		onHover(getNextHourTime(val));
	};
	var onMinuteHover = function onMinuteHover$1(val) {
		onHover(getNextMinuteTime(val));
	};
	var onSecondHover = function onSecondHover$1(val) {
		onHover(getNextSecondTime(val));
	};
	var onMillisecondHover = function onMillisecondHover$1(val) {
		onHover(getNextMillisecondTime(val));
	};
	var onMeridiemHover = function onMeridiemHover$1(val) {
		onHover(getMeridiemTime(val));
	};
	var sharedColumnProps = {
		onDblClick: onCellDblClick,
		changeOnScroll
	};
	return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-content") }, showHour && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends({
		units: hourUnits,
		value: hour,
		optionalValue: pickerHour,
		type: "hour",
		onChange: onHourChange,
		onHover: onHourHover
	}, sharedColumnProps)), showMinute && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends({
		units: minuteUnits,
		value: minute,
		optionalValue: pickerMinute,
		type: "minute",
		onChange: onMinuteChange,
		onHover: onMinuteHover
	}, sharedColumnProps)), showSecond && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends({
		units: secondUnits,
		value: second,
		optionalValue: pickerSecond,
		type: "second",
		onChange: onSecondChange,
		onHover: onSecondHover
	}, sharedColumnProps)), showMillisecond && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends({
		units: millisecondUnits,
		value: millisecond,
		optionalValue: pickerMillisecond,
		type: "millisecond",
		onChange: onMillisecondChange,
		onHover: onMillisecondHover
	}, sharedColumnProps)), showMeridiem && /* @__PURE__ */ import_react.createElement(TimeColumn, _extends({
		units: meridiemUnits,
		value: meridiem,
		type: "meridiem",
		onChange: onMeridiemChange,
		onHover: onMeridiemHover
	}, sharedColumnProps)));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/TimePanel/index.js
var import_classnames$178 = /* @__PURE__ */ __toESM(require_classnames());
function TimePanel(props) {
	var prefixCls = props.prefixCls, value = props.value, locale$5 = props.locale, generateConfig$1 = props.generateConfig, showTime = props.showTime;
	var _ref = showTime || {}, format$2 = _ref.format;
	var panelPrefixCls = "".concat(prefixCls, "-time-panel");
	var _useInfo = useInfo(props, "time"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$178.default)(panelPrefixCls) }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, null, value ? formatValue(value, {
		locale: locale$5,
		format: format$2,
		generateConfig: generateConfig$1
	}) : "\xA0"), /* @__PURE__ */ import_react.createElement(TimePanelBody, showTime)));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/DateTimePanel/index.js
function DateTimePanel(props) {
	var prefixCls = props.prefixCls, generateConfig$1 = props.generateConfig, showTime = props.showTime, onSelect = props.onSelect, value = props.value, pickerValue = props.pickerValue, onHover = props.onHover;
	var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
	var _useTimeInfo = useTimeInfo(generateConfig$1, showTime), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0];
	var mergeTime = function mergeTime$1(date$1) {
		if (value) return fillTime(generateConfig$1, date$1, value);
		return fillTime(generateConfig$1, date$1, pickerValue);
	};
	return /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(DatePanel, _extends({}, props, {
		onSelect: function onDateSelect(date$1) {
			var cloneDate = mergeTime(date$1);
			onSelect(getValidTime(cloneDate, cloneDate));
		},
		onHover: function onDateHover(date$1) {
			onHover === null || onHover === void 0 || onHover(date$1 ? mergeTime(date$1) : date$1);
		}
	})), /* @__PURE__ */ import_react.createElement(TimePanel, props));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/DecadePanel/index.js
function DecadePanel(props) {
	var prefixCls = props.prefixCls, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange;
	var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
	var _useInfo = useInfo(props, "decade"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
	var getStartYear = function getStartYear$1(date$1) {
		var startYear = Math.floor(generateConfig$1.getYear(date$1) / 100) * 100;
		return generateConfig$1.setYear(date$1, startYear);
	};
	var getEndYear = function getEndYear$1(date$1) {
		var startYear = getStartYear(date$1);
		return generateConfig$1.addYear(startYear, 99);
	};
	var startYearDate = getStartYear(pickerValue);
	var endYearDate = getEndYear(pickerValue);
	var baseDate = generateConfig$1.addYear(startYearDate, -10);
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addYear(date$1, offset$2 * 10);
	};
	var getCellText = function getCellText$1(date$1) {
		var cellYearFormat = locale$5.cellYearFormat;
		var startYearStr = formatValue(date$1, {
			locale: locale$5,
			format: cellYearFormat,
			generateConfig: generateConfig$1
		});
		var endYearStr = formatValue(generateConfig$1.addYear(date$1, 9), {
			locale: locale$5,
			format: cellYearFormat,
			generateConfig: generateConfig$1
		});
		return "".concat(startYearStr, "-").concat(endYearStr);
	};
	var getCellClassName = function getCellClassName$1(date$1) {
		return _defineProperty({}, "".concat(prefixCls, "-cell-in-view"), isSameDecade(generateConfig$1, date$1, startYearDate) || isSameDecade(generateConfig$1, date$1, endYearDate) || isInRange(generateConfig$1, startYearDate, endYearDate, date$1));
	};
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		var baseStartDate = generateConfig$1.setDate(currentDate, 1);
		var baseStartMonth = generateConfig$1.setMonth(baseStartDate, 0);
		var baseStartYear = generateConfig$1.setYear(baseStartMonth, Math.floor(generateConfig$1.getYear(baseStartMonth) / 10) * 10);
		var baseEndYear = generateConfig$1.addYear(baseStartYear, 10);
		var baseEndDate = generateConfig$1.addDate(baseEndYear, -1);
		return disabledDate(baseStartYear, disabledInfo) && disabledDate(baseEndDate, disabledInfo);
	} : null;
	var yearNode = "".concat(formatValue(startYearDate, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}), "-").concat(formatValue(endYearDate, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance * 100);
		},
		onChange: onPickerValueChange,
		getStart: getStartYear,
		getEnd: getEndYear
	}, yearNode), /* @__PURE__ */ import_react.createElement(PanelBody, _extends({}, props, {
		disabledDate: mergedDisabledDate,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/MonthPanel/index.js
function MonthPanel(props) {
	var prefixCls = props.prefixCls, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-month-panel");
	var _useInfo = useInfo(props, "month"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
	var baseDate = generateConfig$1.setMonth(pickerValue, 0);
	var monthsLocale = locale$5.shortMonths || (generateConfig$1.locale.getShortMonths ? generateConfig$1.locale.getShortMonths(locale$5.locale) : []);
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addMonth(date$1, offset$2);
	};
	var getCellText = function getCellText$1(date$1) {
		var month = generateConfig$1.getMonth(date$1);
		return locale$5.monthFormat ? formatValue(date$1, {
			locale: locale$5,
			format: locale$5.monthFormat,
			generateConfig: generateConfig$1
		}) : monthsLocale[month];
	};
	var getCellClassName = function getCellClassName$1() {
		return _defineProperty({}, "".concat(prefixCls, "-cell-in-view"), true);
	};
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		var startDate = generateConfig$1.setDate(currentDate, 1);
		var nextMonthStartDate = generateConfig$1.setMonth(startDate, generateConfig$1.getMonth(startDate) + 1);
		var endDate = generateConfig$1.addDate(nextMonthStartDate, -1);
		return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
	} : null;
	var yearNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		key: "year",
		"aria-label": locale$5.yearSelect,
		onClick: function onClick() {
			onModeChange("year");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function getStart(date$1) {
			return generateConfig$1.setMonth(date$1, 0);
		},
		getEnd: function getEnd(date$1) {
			return generateConfig$1.setMonth(date$1, 11);
		}
	}, yearNode), /* @__PURE__ */ import_react.createElement(PanelBody, _extends({}, props, {
		disabledDate: mergedDisabledDate,
		titleFormat: locale$5.fieldMonthFormat,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/QuarterPanel/index.js
function QuarterPanel(props) {
	var prefixCls = props.prefixCls, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
	var _useInfo = useInfo(props, "quarter"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
	var baseDate = generateConfig$1.setMonth(pickerValue, 0);
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addMonth(date$1, offset$2 * 3);
	};
	var getCellText = function getCellText$1(date$1) {
		return formatValue(date$1, {
			locale: locale$5,
			format: locale$5.cellQuarterFormat,
			generateConfig: generateConfig$1
		});
	};
	var getCellClassName = function getCellClassName$1() {
		return _defineProperty({}, "".concat(prefixCls, "-cell-in-view"), true);
	};
	var yearNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		key: "year",
		"aria-label": locale$5.yearSelect,
		onClick: function onClick() {
			onModeChange("year");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-year-btn")
	}, formatValue(pickerValue, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance);
		},
		onChange: onPickerValueChange,
		getStart: function getStart(date$1) {
			return generateConfig$1.setMonth(date$1, 0);
		},
		getEnd: function getEnd(date$1) {
			return generateConfig$1.setMonth(date$1, 11);
		}
	}, yearNode), /* @__PURE__ */ import_react.createElement(PanelBody, _extends({}, props, {
		titleFormat: locale$5.fieldQuarterFormat,
		colNum: 4,
		rowNum: 1,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/WeekPanel/index.js
var import_classnames$177 = /* @__PURE__ */ __toESM(require_classnames());
function WeekPanel(props) {
	var prefixCls = props.prefixCls, generateConfig$1 = props.generateConfig, locale$5 = props.locale, value = props.value, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue;
	var localeName = locale$5.locale;
	var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
	return /* @__PURE__ */ import_react.createElement(DatePanel, _extends({}, props, {
		mode: "week",
		panelName: "week",
		rowClassName: function rowClassName(currentDate) {
			var rangeCls = {};
			if (hoverRangeValue) {
				var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2), rangeStart = _hoverRangeValue[0], rangeEnd = _hoverRangeValue[1];
				var isRangeStart = isSameWeek(generateConfig$1, localeName, rangeStart, currentDate);
				var isRangeEnd = isSameWeek(generateConfig$1, localeName, rangeEnd, currentDate);
				rangeCls["".concat(rowPrefixCls, "-range-start")] = isRangeStart;
				rangeCls["".concat(rowPrefixCls, "-range-end")] = isRangeEnd;
				rangeCls["".concat(rowPrefixCls, "-range-hover")] = !isRangeStart && !isRangeEnd && isInRange(generateConfig$1, rangeStart, rangeEnd, currentDate);
			}
			if (hoverValue) rangeCls["".concat(rowPrefixCls, "-hover")] = hoverValue.some(function(date$1) {
				return isSameWeek(generateConfig$1, localeName, currentDate, date$1);
			});
			return (0, import_classnames$177.default)(rowPrefixCls, _defineProperty({}, "".concat(rowPrefixCls, "-selected"), !hoverRangeValue && isSameWeek(generateConfig$1, localeName, value, currentDate)), rangeCls);
		}
	}));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/YearPanel/index.js
function YearPanel(props) {
	var prefixCls = props.prefixCls, locale$5 = props.locale, generateConfig$1 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
	var panelPrefixCls = "".concat(prefixCls, "-year-panel");
	var _useInfo = useInfo(props, "year"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
	var getStartYear = function getStartYear$1(date$1) {
		var startYear = Math.floor(generateConfig$1.getYear(date$1) / 10) * 10;
		return generateConfig$1.setYear(date$1, startYear);
	};
	var getEndYear = function getEndYear$1(date$1) {
		var startYear = getStartYear(date$1);
		return generateConfig$1.addYear(startYear, 9);
	};
	var startYearDate = getStartYear(pickerValue);
	var endYearDate = getEndYear(pickerValue);
	var baseDate = generateConfig$1.addYear(startYearDate, -1);
	var getCellDate = function getCellDate$1(date$1, offset$2) {
		return generateConfig$1.addYear(date$1, offset$2);
	};
	var getCellText = function getCellText$1(date$1) {
		return formatValue(date$1, {
			locale: locale$5,
			format: locale$5.cellYearFormat,
			generateConfig: generateConfig$1
		});
	};
	var getCellClassName = function getCellClassName$1(date$1) {
		return _defineProperty({}, "".concat(prefixCls, "-cell-in-view"), isSameYear$1(generateConfig$1, date$1, startYearDate) || isSameYear$1(generateConfig$1, date$1, endYearDate) || isInRange(generateConfig$1, startYearDate, endYearDate, date$1));
	};
	var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
		var startMonth = generateConfig$1.setMonth(currentDate, 0);
		var startDate = generateConfig$1.setDate(startMonth, 1);
		var endMonth = generateConfig$1.addYear(startDate, 1);
		var endDate = generateConfig$1.addDate(endMonth, -1);
		return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
	} : null;
	var yearNode = /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		key: "decade",
		"aria-label": locale$5.decadeSelect,
		onClick: function onClick() {
			onModeChange("decade");
		},
		tabIndex: -1,
		className: "".concat(prefixCls, "-decade-btn")
	}, formatValue(startYearDate, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}), "-", formatValue(endYearDate, {
		locale: locale$5,
		format: locale$5.yearFormat,
		generateConfig: generateConfig$1
	}));
	return /* @__PURE__ */ import_react.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ import_react.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ import_react.createElement(PanelHeader_default, {
		superOffset: function superOffset(distance) {
			return generateConfig$1.addYear(pickerValue, distance * 10);
		},
		onChange: onPickerValueChange,
		getStart: getStartYear,
		getEnd: getEndYear
	}, yearNode), /* @__PURE__ */ import_react.createElement(PanelBody, _extends({}, props, {
		disabledDate: mergedDisabledDate,
		titleFormat: locale$5.fieldYearFormat,
		colNum: 3,
		rowNum: 4,
		baseDate,
		getCellDate,
		getCellText,
		getCellClassName
	}))));
}

//#endregion
//#region node_modules/rc-picker/es/PickerPanel/index.js
var import_classnames$176 = /* @__PURE__ */ __toESM(require_classnames());
var DefaultComponents = {
	date: DatePanel,
	datetime: DateTimePanel,
	week: WeekPanel,
	month: MonthPanel,
	quarter: QuarterPanel,
	year: YearPanel,
	decade: DecadePanel,
	time: TimePanel
};
function PickerPanel(props, ref) {
	var _React$useContext;
	var locale$5 = props.locale, generateConfig$1 = props.generateConfig, direction = props.direction, prefixCls = props.prefixCls, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, multiple = props.multiple, defaultValue = props.defaultValue, value = props.value, onChange = props.onChange, onSelect = props.onSelect, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, mode = props.mode, onPanelChange = props.onPanelChange, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props.showTime, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, cellRender = props.cellRender, dateRender = props.dateRender, monthCellRender = props.monthCellRender, _props$components = props.components, components$1 = _props$components === void 0 ? {} : _props$components, hideHeader = props.hideHeader;
	var mergedPrefixCls = ((_React$useContext = import_react.useContext(context_default$6)) === null || _React$useContext === void 0 ? void 0 : _React$useContext.prefixCls) || prefixCls || "rc-picker";
	var rootRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		return { nativeElement: rootRef.current };
	});
	var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
	var filledLocale = useLocale(locale$5, localeTimeProps);
	var internalPicker = picker === "date" && showTime ? "datetime" : picker;
	var mergedShowTime = import_react.useMemo(function() {
		return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, filledLocale);
	}, [
		internalPicker,
		showTimeFormat,
		propFormat,
		timeProps,
		filledLocale
	]);
	var now$1 = generateConfig$1.getNow();
	var _useMergedState = useMergedState(picker, {
		value: mode,
		postState: function postState(val) {
			return val || "date";
		}
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedMode = _useMergedState2[0], setMergedMode = _useMergedState2[1];
	var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
	var toggleDates = useToggleDates(generateConfig$1, locale$5, internalPicker);
	var _useMergedState3 = useMergedState(defaultValue, { value }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), innerValue = _useMergedState4[0], setMergedValue = _useMergedState4[1];
	var mergedValue = import_react.useMemo(function() {
		var values = toArray$5(innerValue).filter(function(val) {
			return val;
		});
		return multiple ? values : values.slice(0, 1);
	}, [innerValue, multiple]);
	var triggerChange = useEvent(function(nextValue) {
		setMergedValue(nextValue);
		if (onChange && (nextValue === null || mergedValue.length !== nextValue.length || mergedValue.some(function(ori, index$2) {
			return !isSame(generateConfig$1, locale$5, ori, nextValue[index$2], internalPicker);
		}))) onChange === null || onChange === void 0 || onChange(multiple ? nextValue : nextValue[0]);
	});
	var onInternalSelect = useEvent(function(newDate) {
		onSelect === null || onSelect === void 0 || onSelect(newDate);
		if (mergedMode === picker) {
			var nextValues = multiple ? toggleDates(mergedValue, newDate) : [newDate];
			triggerChange(nextValues);
		}
	});
	var _useMergedState5 = useMergedState(defaultPickerValue || mergedValue[0] || now$1, { value: pickerValue }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedPickerValue = _useMergedState6[0], setInternalPickerValue = _useMergedState6[1];
	import_react.useEffect(function() {
		if (mergedValue[0] && !pickerValue) setInternalPickerValue(mergedValue[0]);
	}, [mergedValue[0]]);
	var triggerPanelChange = function triggerPanelChange$1(viewDate, nextMode) {
		onPanelChange === null || onPanelChange === void 0 || onPanelChange(viewDate || pickerValue, nextMode || mergedMode);
	};
	var setPickerValue = function setPickerValue$1(nextPickerValue) {
		var triggerPanelEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
		setInternalPickerValue(nextPickerValue);
		onPickerValueChange === null || onPickerValueChange === void 0 || onPickerValueChange(nextPickerValue);
		if (triggerPanelEvent) triggerPanelChange(nextPickerValue);
	};
	var triggerModeChange = function triggerModeChange$1(nextMode, viewDate) {
		setMergedMode(nextMode);
		if (viewDate) setPickerValue(viewDate);
		triggerPanelChange(viewDate, nextMode);
	};
	var onPanelValueSelect = function onPanelValueSelect$1(nextValue) {
		onInternalSelect(nextValue);
		setPickerValue(nextValue);
		if (mergedMode !== picker) {
			var decadeYearQueue = ["decade", "year"];
			var decadeYearMonthQueue = [].concat(decadeYearQueue, ["month"]);
			var queue = {
				quarter: [].concat(decadeYearQueue, ["quarter"]),
				week: [].concat(_toConsumableArray(decadeYearMonthQueue), ["week"]),
				date: [].concat(_toConsumableArray(decadeYearMonthQueue), ["date"])
			}[picker] || decadeYearMonthQueue;
			var index$2 = queue.indexOf(mergedMode);
			var nextMode = queue[index$2 + 1];
			if (nextMode) triggerModeChange(nextMode, nextValue);
		}
	};
	var hoverRangeDate = import_react.useMemo(function() {
		var start;
		var end;
		if (Array.isArray(hoverRangeValue)) {
			var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2);
			start = _hoverRangeValue[0];
			end = _hoverRangeValue[1];
		} else start = hoverRangeValue;
		if (!start && !end) return null;
		start = start || end;
		end = end || start;
		return generateConfig$1.isAfter(start, end) ? [end, start] : [start, end];
	}, [hoverRangeValue, generateConfig$1]);
	var onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender);
	var PanelComponent = components$1[internalMode] || DefaultComponents[internalMode] || DatePanel;
	var parentHackContext = import_react.useContext(PickerHackContext);
	var pickerPanelContext = import_react.useMemo(function() {
		return _objectSpread2(_objectSpread2({}, parentHackContext), {}, { hideHeader });
	}, [parentHackContext, hideHeader]);
	warning_default(!mergedValue || mergedValue.every(function(val) {
		return generateConfig$1.isValidate(val);
	}), "Invalidate date pass to `value` or `defaultValue`.");
	var panelCls = "".concat(mergedPrefixCls, "-panel");
	var panelProps = pickProps(props, [
		"showWeek",
		"prevIcon",
		"nextIcon",
		"superPrevIcon",
		"superNextIcon",
		"disabledDate",
		"minDate",
		"maxDate",
		"onHover"
	]);
	return /* @__PURE__ */ import_react.createElement(PickerHackContext.Provider, { value: pickerPanelContext }, /* @__PURE__ */ import_react.createElement("div", {
		ref: rootRef,
		tabIndex,
		className: (0, import_classnames$176.default)(panelCls, _defineProperty({}, "".concat(panelCls, "-rtl"), direction === "rtl"))
	}, /* @__PURE__ */ import_react.createElement(PanelComponent, _extends({}, panelProps, {
		showTime: mergedShowTime,
		prefixCls: mergedPrefixCls,
		locale: filledLocale,
		generateConfig: generateConfig$1,
		onModeChange: triggerModeChange,
		pickerValue: mergedPickerValue,
		onPickerValueChange: function onPickerValueChange$1(nextPickerValue) {
			setPickerValue(nextPickerValue, true);
		},
		value: mergedValue[0],
		onSelect: onPanelValueSelect,
		values: mergedValue,
		cellRender: onInternalCellRender,
		hoverRangeValue: hoverRangeDate,
		hoverValue
	}))));
}
var RefPanelPicker = /* @__PURE__ */ import_react.memo(/* @__PURE__ */ import_react.forwardRef(PickerPanel));
RefPanelPicker.displayName = "PanelPicker";
var PickerPanel_default = RefPanelPicker;

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Popup/PopupPanel.js
function PopupPanel(props) {
	var picker = props.picker, multiplePanel = props.multiplePanel, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, needConfirm = props.needConfirm, onSubmit = props.onSubmit, range$1 = props.range, hoverValue = props.hoverValue;
	var _React$useContext = import_react.useContext(context_default$6), prefixCls = _React$useContext.prefixCls, generateConfig$1 = _React$useContext.generateConfig;
	var internalOffsetDate = import_react.useCallback(function(date$1, offset$2) {
		return offsetPanelDate(generateConfig$1, picker, date$1, offset$2);
	}, [generateConfig$1, picker]);
	var nextPickerValue = import_react.useMemo(function() {
		return internalOffsetDate(pickerValue, 1);
	}, [pickerValue, internalOffsetDate]);
	var onSecondPickerValueChange = function onSecondPickerValueChange$1(nextDate) {
		onPickerValueChange(internalOffsetDate(nextDate, -1));
	};
	var sharedContext = { onCellDblClick: function onCellDblClick() {
		if (needConfirm) onSubmit();
	} };
	var hideHeader = picker === "time";
	var pickerProps = _objectSpread2(_objectSpread2({}, props), {}, {
		hoverValue: null,
		hoverRangeValue: null,
		hideHeader
	});
	if (range$1) pickerProps.hoverRangeValue = hoverValue;
	else pickerProps.hoverValue = hoverValue;
	if (multiplePanel) return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-panels") }, /* @__PURE__ */ import_react.createElement(PickerHackContext.Provider, { value: _objectSpread2(_objectSpread2({}, sharedContext), {}, { hideNext: true }) }, /* @__PURE__ */ import_react.createElement(PickerPanel_default, pickerProps)), /* @__PURE__ */ import_react.createElement(PickerHackContext.Provider, { value: _objectSpread2(_objectSpread2({}, sharedContext), {}, { hidePrev: true }) }, /* @__PURE__ */ import_react.createElement(PickerPanel_default, _extends({}, pickerProps, {
		pickerValue: nextPickerValue,
		onPickerValueChange: onSecondPickerValueChange
	}))));
	return /* @__PURE__ */ import_react.createElement(PickerHackContext.Provider, { value: _objectSpread2({}, sharedContext) }, /* @__PURE__ */ import_react.createElement(PickerPanel_default, pickerProps));
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Popup/PresetPanel.js
function executeValue(value) {
	return typeof value === "function" ? value() : value;
}
function PresetPanel(props) {
	var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
	if (!presets.length) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-presets") }, /* @__PURE__ */ import_react.createElement("ul", null, presets.map(function(_ref, index$2) {
		var label = _ref.label, value = _ref.value;
		return /* @__PURE__ */ import_react.createElement("li", {
			key: index$2,
			onClick: function onClick() {
				_onClick(executeValue(value));
			},
			onMouseEnter: function onMouseEnter() {
				onHover(executeValue(value));
			},
			onMouseLeave: function onMouseLeave() {
				onHover(null);
			}
		}, label);
	})));
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Popup/index.js
var import_classnames$175 = /* @__PURE__ */ __toESM(require_classnames());
function Popup(props) {
	var panelRender = props.panelRender, internalMode = props.internalMode, picker = props.picker, showNow = props.showNow, range$1 = props.range, multiple = props.multiple, _props$activeInfo = props.activeInfo, activeInfo = _props$activeInfo === void 0 ? [
		0,
		0,
		0
	] : _props$activeInfo, presets = props.presets, onPresetHover = props.onPresetHover, onPresetSubmit = props.onPresetSubmit, onFocus = props.onFocus, onBlur = props.onBlur, onPanelMouseDown = props.onPanelMouseDown, direction = props.direction, value = props.value, onSelect = props.onSelect, isInvalid = props.isInvalid, defaultOpenValue = props.defaultOpenValue, onOk = props.onOk, onSubmit = props.onSubmit;
	var _React$useContext = import_react.useContext(context_default$6), prefixCls = _React$useContext.prefixCls;
	var panelPrefixCls = "".concat(prefixCls, "-panel");
	var rtl = direction === "rtl";
	var arrowRef = import_react.useRef(null);
	var wrapperRef = import_react.useRef(null);
	var _React$useState = import_react.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), containerWidth = _React$useState2[0], setContainerWidth = _React$useState2[1];
	var _React$useState3 = import_react.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), containerOffset = _React$useState4[0], setContainerOffset = _React$useState4[1];
	var _React$useState5 = import_react.useState(0), _React$useState6 = _slicedToArray(_React$useState5, 2), arrowOffset = _React$useState6[0], setArrowOffset = _React$useState6[1];
	var onResize$1 = function onResize$2(info) {
		if (info.width) setContainerWidth(info.width);
	};
	var _activeInfo = _slicedToArray(activeInfo, 3), activeInputLeft = _activeInfo[0], activeInputRight = _activeInfo[1], selectorWidth = _activeInfo[2];
	var _React$useState7 = import_react.useState(0), _React$useState8 = _slicedToArray(_React$useState7, 2), retryTimes = _React$useState8[0], setRetryTimes = _React$useState8[1];
	import_react.useEffect(function() {
		setRetryTimes(10);
	}, [activeInputLeft]);
	import_react.useEffect(function() {
		if (range$1 && wrapperRef.current) {
			var _arrowRef$current;
			var arrowWidth = ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.offsetWidth) || 0;
			var wrapperRect = wrapperRef.current.getBoundingClientRect();
			if (!wrapperRect.height || wrapperRect.right < 0) {
				setRetryTimes(function(times) {
					return Math.max(0, times - 1);
				});
				return;
			}
			var nextArrowOffset = (rtl ? activeInputRight - arrowWidth : activeInputLeft) - wrapperRect.left;
			setArrowOffset(nextArrowOffset);
			if (containerWidth && containerWidth < selectorWidth) {
				var offset$2 = rtl ? wrapperRect.right - (activeInputRight - arrowWidth + containerWidth) : activeInputLeft + arrowWidth - wrapperRect.left - containerWidth;
				setContainerOffset(Math.max(0, offset$2));
			} else setContainerOffset(0);
		}
	}, [
		retryTimes,
		rtl,
		containerWidth,
		activeInputLeft,
		activeInputRight,
		selectorWidth,
		range$1
	]);
	function filterEmpty(list) {
		return list.filter(function(item) {
			return item;
		});
	}
	var valueList = import_react.useMemo(function() {
		return filterEmpty(toArray$5(value));
	}, [value]);
	var isTimePickerEmptyValue = picker === "time" && !valueList.length;
	var footerSubmitValue = import_react.useMemo(function() {
		if (isTimePickerEmptyValue) return filterEmpty([defaultOpenValue]);
		return valueList;
	}, [
		isTimePickerEmptyValue,
		valueList,
		defaultOpenValue
	]);
	var popupPanelValue = isTimePickerEmptyValue ? defaultOpenValue : valueList;
	var disableSubmit = import_react.useMemo(function() {
		if (!footerSubmitValue.length) return true;
		return footerSubmitValue.some(function(val) {
			return isInvalid(val);
		});
	}, [footerSubmitValue, isInvalid]);
	var mergedNodes = /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-panel-layout") }, /* @__PURE__ */ import_react.createElement(PresetPanel, {
		prefixCls,
		presets,
		onClick: onPresetSubmit,
		onHover: onPresetHover
	}), /* @__PURE__ */ import_react.createElement("div", null, /* @__PURE__ */ import_react.createElement(PopupPanel, _extends({}, props, { value: popupPanelValue })), /* @__PURE__ */ import_react.createElement(Footer$3, _extends({}, props, {
		showNow: multiple ? false : showNow,
		invalid: disableSubmit,
		onSubmit: function onFooterSubmit() {
			if (isTimePickerEmptyValue) onSelect(defaultOpenValue);
			onOk();
			onSubmit();
		}
	}))));
	if (panelRender) mergedNodes = panelRender(mergedNodes);
	var containerPrefixCls = "".concat(panelPrefixCls, "-container");
	var marginLeft = "marginLeft";
	var marginRight = "marginRight";
	var renderNode = /* @__PURE__ */ import_react.createElement("div", {
		onMouseDown: onPanelMouseDown,
		tabIndex: -1,
		className: (0, import_classnames$175.default)(containerPrefixCls, "".concat(prefixCls, "-").concat(internalMode, "-panel-container")),
		style: _defineProperty(_defineProperty({}, rtl ? marginRight : marginLeft, containerOffset), rtl ? marginLeft : marginRight, "auto"),
		onFocus,
		onBlur
	}, mergedNodes);
	if (range$1) renderNode = /* @__PURE__ */ import_react.createElement("div", {
		onMouseDown: onPanelMouseDown,
		ref: wrapperRef,
		className: (0, import_classnames$175.default)("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper"))
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: arrowRef,
		className: "".concat(prefixCls, "-range-arrow"),
		style: { left: arrowOffset }
	}), /* @__PURE__ */ import_react.createElement(es_default, { onResize: onResize$1 }, renderNode));
	return renderNode;
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/hooks/useInputProps.js
function useInputProps(props, postProps) {
	var format$2 = props.format, maskFormat = props.maskFormat, generateConfig$1 = props.generateConfig, locale$5 = props.locale, preserveInvalidOnBlur = props.preserveInvalidOnBlur, inputReadOnly = props.inputReadOnly, required$2 = props.required, ariaRequired = props["aria-required"], onSubmit = props.onSubmit, _onFocus = props.onFocus, _onBlur = props.onBlur, onInputChange = props.onInputChange, onInvalid = props.onInvalid, open$2 = props.open, onOpenChange = props.onOpenChange, _onKeyDown = props.onKeyDown, _onChange = props.onChange, activeHelp = props.activeHelp, name = props.name, autoComplete = props.autoComplete, id = props.id, value = props.value, invalid = props.invalid, placeholder = props.placeholder, disabled = props.disabled, activeIndex = props.activeIndex, allHelp = props.allHelp, picker = props.picker;
	var parseDate = function parseDate$1(str, formatStr) {
		var parsed = generateConfig$1.locale.parse(locale$5.locale, str, [formatStr]);
		return parsed && generateConfig$1.isValidate(parsed) ? parsed : null;
	};
	var firstFormat = format$2[0];
	var getText = import_react.useCallback(function(date$1) {
		return formatValue(date$1, {
			locale: locale$5,
			format: firstFormat,
			generateConfig: generateConfig$1
		});
	}, [
		locale$5,
		generateConfig$1,
		firstFormat
	]);
	var valueTexts = import_react.useMemo(function() {
		return value.map(getText);
	}, [value, getText]);
	var size = import_react.useMemo(function() {
		var defaultSize = picker === "time" ? 8 : 10;
		var length$1 = typeof firstFormat === "function" ? firstFormat(generateConfig$1.getNow()).length : firstFormat.length;
		return Math.max(defaultSize, length$1) + 2;
	}, [
		firstFormat,
		picker,
		generateConfig$1
	]);
	var _validateFormat = function validateFormat(text) {
		for (var i = 0; i < format$2.length; i += 1) {
			var singleFormat = format$2[i];
			if (typeof singleFormat === "string") {
				var parsed = parseDate(text, singleFormat);
				if (parsed) return parsed;
			}
		}
		return false;
	};
	return [function getInputProps(index$2) {
		function getProp(propValue) {
			return index$2 !== void 0 ? propValue[index$2] : propValue;
		}
		var pickedAttrs = pickAttrs(props, {
			aria: true,
			data: true
		});
		var inputProps = _objectSpread2(_objectSpread2({}, pickedAttrs), {}, {
			format: maskFormat,
			validateFormat: function validateFormat(text) {
				return !!_validateFormat(text);
			},
			preserveInvalidOnBlur,
			readOnly: inputReadOnly,
			required: required$2,
			"aria-required": ariaRequired,
			name,
			autoComplete,
			size,
			id: getProp(id),
			value: getProp(valueTexts) || "",
			invalid: getProp(invalid),
			placeholder: getProp(placeholder),
			active: activeIndex === index$2,
			helped: allHelp || activeHelp && activeIndex === index$2,
			disabled: getProp(disabled),
			onFocus: function onFocus(event) {
				_onFocus(event, index$2);
			},
			onBlur: function onBlur(event) {
				_onBlur(event, index$2);
			},
			onSubmit,
			onChange: function onChange(text) {
				onInputChange();
				var parsed = _validateFormat(text);
				if (parsed) {
					onInvalid(false, index$2);
					_onChange(parsed, index$2);
					return;
				}
				onInvalid(!!text, index$2);
			},
			onHelp: function onHelp() {
				onOpenChange(true, { index: index$2 });
			},
			onKeyDown: function onKeyDown$1(event) {
				var prevented = false;
				_onKeyDown === null || _onKeyDown === void 0 || _onKeyDown(event, function() {
					warning_default(false, "`preventDefault` callback is deprecated. Please call `event.preventDefault` directly.");
					prevented = true;
				});
				if (!event.defaultPrevented && !prevented) switch (event.key) {
					case "Escape":
						onOpenChange(false, { index: index$2 });
						break;
					case "Enter":
						if (!open$2) onOpenChange(true);
						break;
				}
			}
		}, postProps === null || postProps === void 0 ? void 0 : postProps({ valueTexts }));
		Object.keys(inputProps).forEach(function(key) {
			if (inputProps[key] === void 0) delete inputProps[key];
		});
		return inputProps;
	}, getText];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/hooks/useRootProps.js
var propNames = ["onMouseEnter", "onMouseLeave"];
function useRootProps(props) {
	return import_react.useMemo(function() {
		return pickProps(props, propNames);
	}, [props]);
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/Icon.js
var _excluded$44 = ["icon", "type"], _excluded2$8 = ["onClear"];
function Icon$1(props) {
	var icon = props.icon, type$2 = props.type, restProps = _objectWithoutProperties(props, _excluded$44);
	var _React$useContext = import_react.useContext(context_default$6), prefixCls = _React$useContext.prefixCls;
	return icon ? /* @__PURE__ */ import_react.createElement("span", _extends({ className: "".concat(prefixCls, "-").concat(type$2) }, restProps), icon) : null;
}
function ClearIcon(_ref) {
	var onClear = _ref.onClear, restProps = _objectWithoutProperties(_ref, _excluded2$8);
	return /* @__PURE__ */ import_react.createElement(Icon$1, _extends({}, restProps, {
		type: "clear",
		role: "button",
		onMouseDown: function onMouseDown(e$2) {
			e$2.preventDefault();
		},
		onClick: function onClick(e$2) {
			e$2.stopPropagation();
			onClear();
		}
	}));
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/MaskFormat.js
var FORMAT_KEYS = [
	"YYYY",
	"MM",
	"DD",
	"HH",
	"mm",
	"ss",
	"SSS"
];
var REPLACE_KEY = "";
var MaskFormat = /* @__PURE__ */ function() {
	function MaskFormat$1(format$2) {
		_classCallCheck(this, MaskFormat$1);
		_defineProperty(this, "format", void 0);
		_defineProperty(this, "maskFormat", void 0);
		_defineProperty(this, "cells", void 0);
		_defineProperty(this, "maskCells", void 0);
		this.format = format$2;
		var replaceKeys = FORMAT_KEYS.map(function(key) {
			return "(".concat(key, ")");
		}).join("|");
		var replaceReg = new RegExp(replaceKeys, "g");
		this.maskFormat = format$2.replace(replaceReg, function(key) {
			return REPLACE_KEY.repeat(key.length);
		});
		var cellReg = new RegExp("(".concat(FORMAT_KEYS.join("|"), ")"));
		var strCells = (format$2.split(cellReg) || []).filter(function(str) {
			return str;
		});
		var offset$2 = 0;
		this.cells = strCells.map(function(text) {
			var mask = FORMAT_KEYS.includes(text);
			var start = offset$2;
			var end = offset$2 + text.length;
			offset$2 = end;
			return {
				text,
				mask,
				start,
				end
			};
		});
		this.maskCells = this.cells.filter(function(cell) {
			return cell.mask;
		});
	}
	_createClass(MaskFormat$1, [
		{
			key: "getSelection",
			value: function getSelection(maskCellIndex) {
				var _ref = this.maskCells[maskCellIndex] || {}, start = _ref.start, end = _ref.end;
				return [start || 0, end || 0];
			}
		},
		{
			key: "match",
			value: function match$1(text) {
				for (var i = 0; i < this.maskFormat.length; i += 1) {
					var maskChar = this.maskFormat[i];
					var textChar = text[i];
					if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar) return false;
				}
				return true;
			}
		},
		{
			key: "size",
			value: function size() {
				return this.maskCells.length;
			}
		},
		{
			key: "getMaskCellIndex",
			value: function getMaskCellIndex(anchorIndex) {
				var closetDist = Number.MAX_SAFE_INTEGER;
				var closetIndex = 0;
				for (var i = 0; i < this.maskCells.length; i += 1) {
					var _this$maskCells$i = this.maskCells[i], start = _this$maskCells$i.start, end = _this$maskCells$i.end;
					if (anchorIndex >= start && anchorIndex <= end) return i;
					var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));
					if (dist < closetDist) {
						closetDist = dist;
						closetIndex = i;
					}
				}
				return closetIndex;
			}
		}
	]);
	return MaskFormat$1;
}();

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/util.js
function getMaskRange(key) {
	return {
		YYYY: [
			0,
			9999,
			(/* @__PURE__ */ new Date()).getFullYear()
		],
		MM: [1, 12],
		DD: [1, 31],
		HH: [0, 23],
		mm: [0, 59],
		ss: [0, 59],
		SSS: [0, 999]
	}[key];
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/Input.js
var import_classnames$174 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$43 = [
	"active",
	"showActiveCls",
	"suffixIcon",
	"format",
	"validateFormat",
	"onChange",
	"onInput",
	"helped",
	"onHelp",
	"onSubmit",
	"onKeyDown",
	"preserveInvalidOnBlur",
	"invalid",
	"clearIcon"
];
var Input$3 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var active = props.active, _props$showActiveCls = props.showActiveCls, showActiveCls = _props$showActiveCls === void 0 ? true : _props$showActiveCls, suffixIcon = props.suffixIcon, format$2 = props.format, validateFormat = props.validateFormat, onChange = props.onChange;
	props.onInput;
	var helped = props.helped, onHelp = props.onHelp, onSubmit = props.onSubmit, onKeyDown$1 = props.onKeyDown, _props$preserveInvali = props.preserveInvalidOnBlur, preserveInvalidOnBlur = _props$preserveInvali === void 0 ? false : _props$preserveInvali, invalid = props.invalid, clearIcon = props.clearIcon, restProps = _objectWithoutProperties(props, _excluded$43);
	var value = props.value, onFocus = props.onFocus, onBlur = props.onBlur, onMouseUp = props.onMouseUp;
	var _React$useContext = import_react.useContext(context_default$6), prefixCls = _React$useContext.prefixCls, _React$useContext$inp = _React$useContext.input, Component$2 = _React$useContext$inp === void 0 ? "input" : _React$useContext$inp;
	var inputPrefixCls = "".concat(prefixCls, "-input");
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
	var _React$useState3 = import_react.useState(value), _React$useState4 = _slicedToArray(_React$useState3, 2), internalInputValue = _React$useState4[0], setInputValue = _React$useState4[1];
	var _React$useState5 = import_react.useState(""), _React$useState6 = _slicedToArray(_React$useState5, 2), focusCellText = _React$useState6[0], setFocusCellText = _React$useState6[1];
	var _React$useState7 = import_react.useState(null), _React$useState8 = _slicedToArray(_React$useState7, 2), focusCellIndex = _React$useState8[0], setFocusCellIndex = _React$useState8[1];
	var _React$useState9 = import_react.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), forceSelectionSyncMark = _React$useState10[0], forceSelectionSync = _React$useState10[1];
	var inputValue = internalInputValue || "";
	import_react.useEffect(function() {
		setInputValue(value);
	}, [value]);
	var holderRef = import_react.useRef();
	var inputRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		return {
			nativeElement: holderRef.current,
			inputElement: inputRef.current,
			focus: function focus(options) {
				inputRef.current.focus(options);
			},
			blur: function blur() {
				inputRef.current.blur();
			}
		};
	});
	var maskFormat = import_react.useMemo(function() {
		return new MaskFormat(format$2 || "");
	}, [format$2]);
	var _React$useMemo = import_react.useMemo(function() {
		if (helped) return [0, 0];
		return maskFormat.getSelection(focusCellIndex);
	}, [
		maskFormat,
		focusCellIndex,
		helped
	]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), selectionStart = _React$useMemo2[0], selectionEnd = _React$useMemo2[1];
	var onModify = function onModify$1(text) {
		if (text && text !== format$2 && text !== value) onHelp();
	};
	/**
	* Triggered by paste, keyDown and focus to show format
	*/
	var triggerInputChange = useEvent(function(text) {
		if (validateFormat(text)) onChange(text);
		setInputValue(text);
		onModify(text);
	});
	var onInternalChange = function onInternalChange$1(event) {
		if (!format$2) {
			var text = event.target.value;
			onModify(text);
			setInputValue(text);
			onChange(text);
		}
	};
	var onFormatPaste = function onFormatPaste$1(event) {
		var pasteText = event.clipboardData.getData("text");
		if (validateFormat(pasteText)) triggerInputChange(pasteText);
	};
	var mouseDownRef = import_react.useRef(false);
	var onFormatMouseDown = function onFormatMouseDown$1() {
		mouseDownRef.current = true;
	};
	var onFormatMouseUp = function onFormatMouseUp$1(event) {
		var _ref = event.target, start = _ref.selectionStart;
		var closeMaskIndex = maskFormat.getMaskCellIndex(start);
		setFocusCellIndex(closeMaskIndex);
		forceSelectionSync({});
		onMouseUp === null || onMouseUp === void 0 || onMouseUp(event);
		mouseDownRef.current = false;
	};
	var onFormatFocus = function onFormatFocus$1(event) {
		setFocused(true);
		setFocusCellIndex(0);
		setFocusCellText("");
		onFocus(event);
	};
	var onSharedBlur = function onSharedBlur$1(event) {
		onBlur(event);
	};
	var onFormatBlur = function onFormatBlur$1(event) {
		setFocused(false);
		onSharedBlur(event);
	};
	useLockEffect(active, function() {
		if (!active && !preserveInvalidOnBlur) setInputValue(value);
	});
	var onSharedKeyDown = function onSharedKeyDown$1(event) {
		if (event.key === "Enter" && validateFormat(inputValue)) onSubmit();
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event);
	};
	var onFormatKeyDown = function onFormatKeyDown$1(event) {
		onSharedKeyDown(event);
		var key = event.key;
		var nextCellText = null;
		var nextFillText = null;
		var maskCellLen = selectionEnd - selectionStart;
		var cellFormat = format$2.slice(selectionStart, selectionEnd);
		var offsetCellIndex = function offsetCellIndex$1(offset$2) {
			setFocusCellIndex(function(idx) {
				var nextIndex = idx + offset$2;
				nextIndex = Math.max(nextIndex, 0);
				nextIndex = Math.min(nextIndex, maskFormat.size() - 1);
				return nextIndex;
			});
		};
		var offsetCellValue = function offsetCellValue$1(offset$2) {
			var _getMaskRange = getMaskRange(cellFormat), _getMaskRange2 = _slicedToArray(_getMaskRange, 3), rangeStart = _getMaskRange2[0], rangeEnd = _getMaskRange2[1], rangeDefault = _getMaskRange2[2];
			var currentText = inputValue.slice(selectionStart, selectionEnd);
			var currentTextNum = Number(currentText);
			if (isNaN(currentTextNum)) return String(rangeDefault ? rangeDefault : offset$2 > 0 ? rangeStart : rangeEnd);
			var num = currentTextNum + offset$2;
			var range$1 = rangeEnd - rangeStart + 1;
			return String(rangeStart + (range$1 + num - rangeStart) % range$1);
		};
		switch (key) {
			case "Backspace":
			case "Delete":
				nextCellText = "";
				nextFillText = cellFormat;
				break;
			case "ArrowLeft":
				nextCellText = "";
				offsetCellIndex(-1);
				break;
			case "ArrowRight":
				nextCellText = "";
				offsetCellIndex(1);
				break;
			case "ArrowUp":
				nextCellText = "";
				nextFillText = offsetCellValue(1);
				break;
			case "ArrowDown":
				nextCellText = "";
				nextFillText = offsetCellValue(-1);
				break;
			default:
				if (!isNaN(Number(key))) {
					nextCellText = focusCellText + key;
					nextFillText = nextCellText;
				}
				break;
		}
		if (nextCellText !== null) {
			setFocusCellText(nextCellText);
			if (nextCellText.length >= maskCellLen) {
				offsetCellIndex(1);
				setFocusCellText("");
			}
		}
		if (nextFillText !== null) {
			var nextFocusValue = inputValue.slice(0, selectionStart) + leftPad(nextFillText, maskCellLen) + inputValue.slice(selectionEnd);
			triggerInputChange(nextFocusValue.slice(0, format$2.length));
		}
		forceSelectionSync({});
	};
	var rafRef = import_react.useRef();
	useLayoutEffect_default(function() {
		if (!focused || !format$2 || mouseDownRef.current) return;
		if (!maskFormat.match(inputValue)) {
			triggerInputChange(format$2);
			return;
		}
		inputRef.current.setSelectionRange(selectionStart, selectionEnd);
		rafRef.current = raf_default(function() {
			inputRef.current.setSelectionRange(selectionStart, selectionEnd);
		});
		return function() {
			raf_default.cancel(rafRef.current);
		};
	}, [
		maskFormat,
		format$2,
		focused,
		inputValue,
		focusCellIndex,
		selectionStart,
		selectionEnd,
		forceSelectionSyncMark,
		triggerInputChange
	]);
	var inputProps = format$2 ? {
		onFocus: onFormatFocus,
		onBlur: onFormatBlur,
		onKeyDown: onFormatKeyDown,
		onMouseDown: onFormatMouseDown,
		onMouseUp: onFormatMouseUp,
		onPaste: onFormatPaste
	} : {};
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: holderRef,
		className: (0, import_classnames$174.default)(inputPrefixCls, _defineProperty(_defineProperty({}, "".concat(inputPrefixCls, "-active"), active && showActiveCls), "".concat(inputPrefixCls, "-placeholder"), helped))
	}, /* @__PURE__ */ import_react.createElement(Component$2, _extends({
		ref: inputRef,
		"aria-invalid": invalid,
		autoComplete: "off"
	}, restProps, {
		onKeyDown: onSharedKeyDown,
		onBlur: onSharedBlur
	}, inputProps, {
		value: inputValue,
		onChange: onInternalChange
	})), /* @__PURE__ */ import_react.createElement(Icon$1, {
		type: "suffix",
		icon: suffixIcon
	}), clearIcon);
});
Input$3.displayName = "Input";
var Input_default$2 = Input$3;

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/RangeSelector.js
var import_classnames$173 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$42 = [
	"id",
	"prefix",
	"clearIcon",
	"suffixIcon",
	"separator",
	"activeIndex",
	"activeHelp",
	"allHelp",
	"focused",
	"onFocus",
	"onBlur",
	"onKeyDown",
	"locale",
	"generateConfig",
	"placeholder",
	"className",
	"style",
	"onClick",
	"onClear",
	"value",
	"onChange",
	"onSubmit",
	"onInputChange",
	"format",
	"maskFormat",
	"preserveInvalidOnBlur",
	"onInvalid",
	"disabled",
	"invalid",
	"inputReadOnly",
	"direction",
	"onOpenChange",
	"onActiveInfo",
	"placement",
	"onMouseDown",
	"required",
	"aria-required",
	"autoFocus",
	"tabIndex"
], _excluded2$7 = ["index"];
function RangeSelector(props, ref) {
	var id = props.id, prefix = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, _props$separator = props.separator, separator = _props$separator === void 0 ? "~" : _props$separator, activeIndex = props.activeIndex;
	props.activeHelp;
	props.allHelp;
	var focused = props.focused;
	props.onFocus;
	props.onBlur;
	props.onKeyDown;
	props.locale;
	props.generateConfig;
	var placeholder = props.placeholder, className = props.className, style$1 = props.style, onClick = props.onClick, onClear = props.onClear, value = props.value;
	props.onChange;
	props.onSubmit;
	props.onInputChange;
	props.format;
	props.maskFormat;
	props.preserveInvalidOnBlur;
	props.onInvalid;
	var disabled = props.disabled, invalid = props.invalid;
	props.inputReadOnly;
	var direction = props.direction;
	props.onOpenChange;
	var onActiveInfo = props.onActiveInfo;
	props.placement;
	var _onMouseDown = props.onMouseDown;
	props.required;
	props["aria-required"];
	var autoFocus = props.autoFocus, tabIndex = props.tabIndex, restProps = _objectWithoutProperties(props, _excluded$42);
	var rtl = direction === "rtl";
	var _React$useContext = import_react.useContext(context_default$6), prefixCls = _React$useContext.prefixCls;
	var ids = import_react.useMemo(function() {
		if (typeof id === "string") return [id];
		var mergedId = id || {};
		return [mergedId.start, mergedId.end];
	}, [id]);
	var rootRef = import_react.useRef();
	var inputStartRef = import_react.useRef();
	var inputEndRef = import_react.useRef();
	var getInput = function getInput$1(index$2) {
		var _index;
		return (_index = [inputStartRef, inputEndRef][index$2]) === null || _index === void 0 ? void 0 : _index.current;
	};
	import_react.useImperativeHandle(ref, function() {
		return {
			nativeElement: rootRef.current,
			focus: function focus(options) {
				if (_typeof(options) === "object") {
					var _getInput;
					var _ref = options || {}, _ref$index = _ref.index, _index2 = _ref$index === void 0 ? 0 : _ref$index, rest = _objectWithoutProperties(_ref, _excluded2$7);
					(_getInput = getInput(_index2)) === null || _getInput === void 0 || _getInput.focus(rest);
				} else {
					var _getInput2;
					(_getInput2 = getInput(options !== null && options !== void 0 ? options : 0)) === null || _getInput2 === void 0 || _getInput2.focus();
				}
			},
			blur: function blur() {
				var _getInput3, _getInput4;
				(_getInput3 = getInput(0)) === null || _getInput3 === void 0 || _getInput3.blur();
				(_getInput4 = getInput(1)) === null || _getInput4 === void 0 || _getInput4.blur();
			}
		};
	});
	var rootProps = useRootProps(restProps);
	var mergedPlaceholder = import_react.useMemo(function() {
		return Array.isArray(placeholder) ? placeholder : [placeholder, placeholder];
	}, [placeholder]);
	var _useInputProps = useInputProps(_objectSpread2(_objectSpread2({}, props), {}, {
		id: ids,
		placeholder: mergedPlaceholder
	})), _useInputProps2 = _slicedToArray(_useInputProps, 1), getInputProps = _useInputProps2[0];
	var _React$useState = import_react.useState({
		position: "absolute",
		width: 0
	}), _React$useState2 = _slicedToArray(_React$useState, 2), activeBarStyle = _React$useState2[0], setActiveBarStyle = _React$useState2[1];
	var syncActiveOffset = useEvent(function() {
		var input = getInput(activeIndex);
		if (input) {
			var inputRect = input.nativeElement.getBoundingClientRect();
			var parentRect = rootRef.current.getBoundingClientRect();
			var rectOffset = inputRect.left - parentRect.left;
			setActiveBarStyle(function(ori) {
				return _objectSpread2(_objectSpread2({}, ori), {}, {
					width: inputRect.width,
					left: rectOffset
				});
			});
			onActiveInfo([
				inputRect.left,
				inputRect.right,
				parentRect.width
			]);
		}
	});
	import_react.useEffect(function() {
		syncActiveOffset();
	}, [activeIndex]);
	var showClear = clearIcon && (value[0] && !disabled[0] || value[1] && !disabled[1]);
	var startAutoFocus = autoFocus && !disabled[0];
	var endAutoFocus = autoFocus && !startAutoFocus && !disabled[1];
	return /* @__PURE__ */ import_react.createElement(es_default, { onResize: syncActiveOffset }, /* @__PURE__ */ import_react.createElement("div", _extends({}, rootProps, {
		className: (0, import_classnames$173.default)(prefixCls, "".concat(prefixCls, "-range"), _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled.every(function(i) {
			return i;
		})), "".concat(prefixCls, "-invalid"), invalid.some(function(i) {
			return i;
		})), "".concat(prefixCls, "-rtl"), rtl), className),
		style: style$1,
		ref: rootRef,
		onClick,
		onMouseDown: function onMouseDown(e$2) {
			var target = e$2.target;
			if (target !== inputStartRef.current.inputElement && target !== inputEndRef.current.inputElement) e$2.preventDefault();
			_onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e$2);
		}
	}), prefix && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-prefix") }, prefix), /* @__PURE__ */ import_react.createElement(Input_default$2, _extends({ ref: inputStartRef }, getInputProps(0), {
		autoFocus: startAutoFocus,
		tabIndex,
		"date-range": "start"
	})), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-range-separator") }, separator), /* @__PURE__ */ import_react.createElement(Input_default$2, _extends({ ref: inputEndRef }, getInputProps(1), {
		autoFocus: endAutoFocus,
		tabIndex,
		"date-range": "end"
	})), /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-active-bar"),
		style: activeBarStyle
	}), /* @__PURE__ */ import_react.createElement(Icon$1, {
		type: "suffix",
		icon: suffixIcon
	}), showClear && /* @__PURE__ */ import_react.createElement(ClearIcon, {
		icon: clearIcon,
		onClear
	})));
}
var RefRangeSelector = /* @__PURE__ */ import_react.forwardRef(RangeSelector);
RefRangeSelector.displayName = "RangeSelector";
var RangeSelector_default = RefRangeSelector;

//#endregion
//#region node_modules/rc-picker/es/PickerInput/RangePicker.js
function separateConfig(config, defaultConfig$1) {
	var singleConfig = config !== null && config !== void 0 ? config : defaultConfig$1;
	if (Array.isArray(singleConfig)) return singleConfig;
	return [singleConfig, singleConfig];
}
/** Used for change event, it should always be not undefined */
function getActiveRange(activeIndex) {
	return activeIndex === 1 ? "end" : "start";
}
function RangePicker$1(props, ref) {
	var _useFilledProps = useFilledProps(props, function() {
		var disabled$1 = props.disabled, allowEmpty$1 = props.allowEmpty;
		var mergedDisabled = separateConfig(disabled$1, false);
		var mergedAllowEmpty = separateConfig(allowEmpty$1, false);
		return {
			disabled: mergedDisabled,
			allowEmpty: mergedAllowEmpty
		};
	}), _useFilledProps2 = _slicedToArray(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
	var prefixCls = filledProps.prefixCls, styles = filledProps.styles, classNames$252 = filledProps.classNames, defaultValue = filledProps.defaultValue, value = filledProps.value, needConfirm = filledProps.needConfirm, onKeyDown$1 = filledProps.onKeyDown, disabled = filledProps.disabled, allowEmpty = filledProps.allowEmpty, disabledDate = filledProps.disabledDate, minDate = filledProps.minDate, maxDate = filledProps.maxDate, defaultOpen = filledProps.defaultOpen, open$2 = filledProps.open, onOpenChange = filledProps.onOpenChange, locale$5 = filledProps.locale, generateConfig$1 = filledProps.generateConfig, picker = filledProps.picker, showNow = filledProps.showNow, showToday = filledProps.showToday, showTime = filledProps.showTime, mode = filledProps.mode, onPanelChange = filledProps.onPanelChange, onCalendarChange = filledProps.onCalendarChange, onOk = filledProps.onOk, defaultPickerValue = filledProps.defaultPickerValue, pickerValue = filledProps.pickerValue, onPickerValueChange = filledProps.onPickerValueChange, inputReadOnly = filledProps.inputReadOnly, suffixIcon = filledProps.suffixIcon, onFocus = filledProps.onFocus, onBlur = filledProps.onBlur, presets = filledProps.presets, ranges = filledProps.ranges, components$1 = filledProps.components, cellRender = filledProps.cellRender, dateRender = filledProps.dateRender, monthCellRender = filledProps.monthCellRender, onClick = filledProps.onClick;
	var selectorRef = usePickerRef(ref);
	var _useOpen = useOpen(open$2, defaultOpen, disabled, onOpenChange), _useOpen2 = _slicedToArray(_useOpen, 2), mergedOpen = _useOpen2[0], setMergeOpen = _useOpen2[1];
	var triggerOpen = function triggerOpen$1(nextOpen, config) {
		if (disabled.some(function(fieldDisabled) {
			return !fieldDisabled;
		}) || !nextOpen) setMergeOpen(nextOpen, config);
	};
	var _useInnerValue = useInnerValue(generateConfig$1, locale$5, formatList, true, false, defaultValue, value, onCalendarChange, onOk), _useInnerValue2 = _slicedToArray(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
	var calendarValue = getCalendarValue();
	var _useRangeActive = useRangeActive(disabled, allowEmpty, mergedOpen), _useRangeActive2 = _slicedToArray(_useRangeActive, 9), focused = _useRangeActive2[0], triggerFocus$1 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3], setActiveIndex = _useRangeActive2[4], nextActiveIndex = _useRangeActive2[5], activeIndexList = _useRangeActive2[6], updateSubmitIndex = _useRangeActive2[7], hasActiveSubmitValue = _useRangeActive2[8];
	var onSharedFocus = function onSharedFocus$1(event, index$2) {
		triggerFocus$1(true);
		onFocus === null || onFocus === void 0 || onFocus(event, { range: getActiveRange(index$2 !== null && index$2 !== void 0 ? index$2 : activeIndex) });
	};
	var onSharedBlur = function onSharedBlur$1(event, index$2) {
		triggerFocus$1(false);
		onBlur === null || onBlur === void 0 || onBlur(event, { range: getActiveRange(index$2 !== null && index$2 !== void 0 ? index$2 : activeIndex) });
	};
	/** Used for Popup panel */
	var mergedShowTime = import_react.useMemo(function() {
		if (!showTime) return null;
		var disabledTime = showTime.disabledTime;
		var proxyDisabledTime = disabledTime ? function(date$1) {
			var range$1 = getActiveRange(activeIndex);
			var fromDate = getFromDate(calendarValue, activeIndexList, activeIndex);
			return disabledTime(date$1, range$1, { from: fromDate });
		} : void 0;
		return _objectSpread2(_objectSpread2({}, showTime), {}, { disabledTime: proxyDisabledTime });
	}, [
		showTime,
		activeIndex,
		calendarValue,
		activeIndexList
	]);
	var _useMergedState = useMergedState([picker, picker], { value: mode }), _useMergedState2 = _slicedToArray(_useMergedState, 2), modes = _useMergedState2[0], setModes = _useMergedState2[1];
	var mergedMode = modes[activeIndex] || picker;
	/** Extends from `mergedMode` to patch `datetime` mode */
	var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
	var multiplePanel = internalMode === picker && internalMode !== "time";
	var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday, true);
	var _useRangeValue = useRangeValue(filledProps, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, mergedOpen, isInvalidateDate), _useRangeValue2 = _slicedToArray(_useRangeValue, 2), flushSubmit = _useRangeValue2[0], triggerSubmitChange = _useRangeValue2[1];
	var mergedDisabledDate = useRangeDisabledDate(calendarValue, disabled, activeIndexList, generateConfig$1, locale$5, disabledDate);
	var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate, allowEmpty), _useFieldsInvalidate2 = _slicedToArray(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
	var _useRangePickerValue = useRangePickerValue(generateConfig$1, locale$5, calendarValue, modes, mergedOpen, activeIndex, internalPicker, multiplePanel, defaultPickerValue, pickerValue, mergedShowTime === null || mergedShowTime === void 0 ? void 0 : mergedShowTime.defaultOpenValue, onPickerValueChange, minDate, maxDate), _useRangePickerValue2 = _slicedToArray(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
	var triggerModeChange = useEvent(function(nextPickerValue, nextMode, triggerEvent) {
		var clone = fillIndex(modes, activeIndex, nextMode);
		if (clone[0] !== modes[0] || clone[1] !== modes[1]) setModes(clone);
		if (onPanelChange && triggerEvent !== false) {
			var clonePickerValue = _toConsumableArray(calendarValue);
			if (nextPickerValue) clonePickerValue[activeIndex] = nextPickerValue;
			onPanelChange(clonePickerValue, clone);
		}
	});
	var fillCalendarValue = function fillCalendarValue$1(date$1, index$2) {
		return fillIndex(calendarValue, index$2, date$1);
	};
	/**
	* Trigger by confirm operation.
	* This function has already handle the `needConfirm` check logic.
	* - Selector: enter key
	* - Panel: OK button
	*/
	var triggerPartConfirm = function triggerPartConfirm$1(date$1, skipFocus) {
		var nextValue = calendarValue;
		if (date$1) nextValue = fillCalendarValue(date$1, activeIndex);
		updateSubmitIndex(activeIndex);
		var nextIndex = nextActiveIndex(nextValue);
		triggerCalendarChange(nextValue);
		flushSubmit(activeIndex, nextIndex === null);
		if (nextIndex === null) triggerOpen(false, { force: true });
		else if (!skipFocus) selectorRef.current.focus({ index: nextIndex });
	};
	var onSelectorClick = function onSelectorClick$1(event) {
		var _activeElement;
		var rootNode = event.target.getRootNode();
		if (!selectorRef.current.nativeElement.contains((_activeElement = rootNode.activeElement) !== null && _activeElement !== void 0 ? _activeElement : document.activeElement)) {
			var enabledIndex = disabled.findIndex(function(d) {
				return !d;
			});
			if (enabledIndex >= 0) selectorRef.current.focus({ index: enabledIndex });
		}
		triggerOpen(true);
		onClick === null || onClick === void 0 || onClick(event);
	};
	var onSelectorClear = function onSelectorClear$1() {
		triggerSubmitChange(null);
		triggerOpen(false, { force: true });
	};
	var _React$useState = import_react.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
	var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), internalHoverValues = _React$useState4[0], setInternalHoverValues = _React$useState4[1];
	var hoverValues = import_react.useMemo(function() {
		return internalHoverValues || calendarValue;
	}, [calendarValue, internalHoverValues]);
	import_react.useEffect(function() {
		if (!mergedOpen) setInternalHoverValues(null);
	}, [mergedOpen]);
	var _React$useState5 = import_react.useState([
		0,
		0,
		0
	]), _React$useState6 = _slicedToArray(_React$useState5, 2), activeInfo = _React$useState6[0], setActiveInfo = _React$useState6[1];
	var presetList = usePresets(presets, ranges);
	var onPresetHover = function onPresetHover$1(nextValues) {
		setInternalHoverValues(nextValues);
		setHoverSource("preset");
	};
	var onPresetSubmit = function onPresetSubmit$1(nextValues) {
		if (triggerSubmitChange(nextValues)) triggerOpen(false, { force: true });
	};
	var onNow = function onNow$1(now$1) {
		triggerPartConfirm(now$1);
	};
	var onPanelHover = function onPanelHover$1(date$1) {
		setInternalHoverValues(date$1 ? fillCalendarValue(date$1, activeIndex) : null);
		setHoverSource("cell");
	};
	var onPanelFocus = function onPanelFocus$1(event) {
		triggerOpen(true);
		onSharedFocus(event);
	};
	var onPanelMouseDown = function onPanelMouseDown$1() {
		lastOperation("panel");
	};
	var onPanelSelect = function onPanelSelect$1(date$1) {
		var clone = fillIndex(calendarValue, activeIndex, date$1);
		triggerCalendarChange(clone);
		if (!needConfirm && !complexPicker && internalPicker === internalMode) triggerPartConfirm(date$1);
	};
	var onPopupClose = function onPopupClose$1() {
		triggerOpen(false);
	};
	var onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender, getActiveRange(activeIndex));
	var panelValue = calendarValue[activeIndex] || null;
	var isPopupInvalidateDate = useEvent(function(date$1) {
		return isInvalidateDate(date$1, { activeIndex });
	});
	var panelProps = import_react.useMemo(function() {
		var domProps = pickAttrs(filledProps, false);
		return omit(filledProps, [].concat(_toConsumableArray(Object.keys(domProps)), [
			"onChange",
			"onCalendarChange",
			"style",
			"className",
			"onPanelChange",
			"disabledTime"
		]));
	}, [filledProps]);
	var panel = /* @__PURE__ */ import_react.createElement(Popup, _extends({}, panelProps, {
		showNow: mergedShowNow,
		showTime: mergedShowTime,
		range: true,
		multiplePanel,
		activeInfo,
		disabledDate: mergedDisabledDate,
		onFocus: onPanelFocus,
		onBlur: onSharedBlur,
		onPanelMouseDown,
		picker,
		mode: mergedMode,
		internalMode,
		onPanelChange: triggerModeChange,
		format: maskFormat,
		value: panelValue,
		isInvalid: isPopupInvalidateDate,
		onChange: null,
		onSelect: onPanelSelect,
		pickerValue: currentPickerValue,
		defaultOpenValue: toArray$5(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue)[activeIndex],
		onPickerValueChange: setCurrentPickerValue,
		hoverValue: hoverValues,
		onHover: onPanelHover,
		needConfirm,
		onSubmit: triggerPartConfirm,
		onOk: triggerOk,
		presets: presetList,
		onPresetHover,
		onPresetSubmit,
		onNow,
		cellRender: onInternalCellRender
	}));
	var onSelectorChange = function onSelectorChange$1(date$1, index$2) {
		var clone = fillCalendarValue(date$1, index$2);
		triggerCalendarChange(clone);
	};
	var onSelectorInputChange = function onSelectorInputChange$1() {
		lastOperation("input");
	};
	var onSelectorFocus = function onSelectorFocus$1(event, index$2) {
		var activeListLen = activeIndexList.length;
		var lastActiveIndex = activeIndexList[activeListLen - 1];
		if (activeListLen && lastActiveIndex !== index$2 && needConfirm && !allowEmpty[lastActiveIndex] && !hasActiveSubmitValue(lastActiveIndex) && calendarValue[lastActiveIndex]) {
			selectorRef.current.focus({ index: lastActiveIndex });
			return;
		}
		lastOperation("input");
		triggerOpen(true, { inherit: true });
		if (activeIndex !== index$2 && mergedOpen && !needConfirm && complexPicker) triggerPartConfirm(null, true);
		setActiveIndex(index$2);
		onSharedFocus(event, index$2);
	};
	var onSelectorBlur = function onSelectorBlur$1(event, index$2) {
		triggerOpen(false);
		if (!needConfirm && lastOperation() === "input") {
			var nextIndex = nextActiveIndex(calendarValue);
			flushSubmit(activeIndex, nextIndex === null);
		}
		onSharedBlur(event, index$2);
	};
	var onSelectorKeyDown = function onSelectorKeyDown$1(event, preventDefault) {
		if (event.key === "Tab") triggerPartConfirm(null, true);
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event, preventDefault);
	};
	var context = import_react.useMemo(function() {
		return {
			prefixCls,
			locale: locale$5,
			generateConfig: generateConfig$1,
			button: components$1.button,
			input: components$1.input
		};
	}, [
		prefixCls,
		locale$5,
		generateConfig$1,
		components$1.button,
		components$1.input
	]);
	useLayoutEffect_default(function() {
		if (mergedOpen && activeIndex !== void 0) triggerModeChange(null, picker, false);
	}, [
		mergedOpen,
		activeIndex,
		picker
	]);
	useLayoutEffect_default(function() {
		var lastOp = lastOperation();
		if (!mergedOpen && lastOp === "input") {
			triggerOpen(false);
			triggerPartConfirm(null, true);
		}
		if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
			triggerOpen(true);
			triggerPartConfirm();
		}
	}, [mergedOpen]);
	var isIndexEmpty = function isIndexEmpty$1(index$2) {
		return !(value !== null && value !== void 0 && value[index$2]) && !(defaultValue !== null && defaultValue !== void 0 && defaultValue[index$2]);
	};
	if (disabled.some(function(fieldDisabled, index$2) {
		return fieldDisabled && isIndexEmpty(index$2) && !allowEmpty[index$2];
	})) warning_default(false, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
	return /* @__PURE__ */ import_react.createElement(context_default$6.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(PickerTrigger_default, _extends({}, pickTriggerProps(filledProps), {
		popupElement: panel,
		popupStyle: styles.popup,
		popupClassName: classNames$252.popup,
		visible: mergedOpen,
		onClose: onPopupClose,
		range: true
	}), /* @__PURE__ */ import_react.createElement(RangeSelector_default, _extends({}, filledProps, {
		ref: selectorRef,
		suffixIcon,
		activeIndex: focused || mergedOpen ? activeIndex : null,
		activeHelp: !!internalHoverValues,
		allHelp: !!internalHoverValues && hoverSource === "preset",
		focused,
		onFocus: onSelectorFocus,
		onBlur: onSelectorBlur,
		onKeyDown: onSelectorKeyDown,
		onSubmit: triggerPartConfirm,
		value: hoverValues,
		maskFormat,
		onChange: onSelectorChange,
		onInputChange: onSelectorInputChange,
		format: formatList,
		inputReadOnly,
		disabled,
		open: mergedOpen,
		onOpenChange: triggerOpen,
		onClick: onSelectorClick,
		onClear: onSelectorClear,
		invalid: submitInvalidates,
		onInvalid: onSelectorInvalid,
		onActiveInfo: setActiveInfo
	}))));
}
var RefRangePicker = /* @__PURE__ */ import_react.forwardRef(RangePicker$1);
RefRangePicker.displayName = "RefRangePicker";
var RangePicker_default = RefRangePicker;

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/SingleSelector/MultipleDates.js
var import_classnames$172 = /* @__PURE__ */ __toESM(require_classnames());
function MultipleDates(props) {
	var prefixCls = props.prefixCls, value = props.value, onRemove = props.onRemove, _props$removeIcon = props.removeIcon, removeIcon = _props$removeIcon === void 0 ? "" : _props$removeIcon, formatDate = props.formatDate, disabled = props.disabled, maxTagCount = props.maxTagCount, placeholder = props.placeholder;
	var selectorCls = "".concat(prefixCls, "-selector");
	var selectionCls = "".concat(prefixCls, "-selection");
	var overflowCls = "".concat(selectionCls, "-overflow");
	function renderSelector(content, onClose) {
		return /* @__PURE__ */ import_react.createElement("span", {
			className: (0, import_classnames$172.default)("".concat(selectionCls, "-item")),
			title: typeof content === "string" ? content : null
		}, /* @__PURE__ */ import_react.createElement("span", { className: "".concat(selectionCls, "-item-content") }, content), !disabled && onClose && /* @__PURE__ */ import_react.createElement("span", {
			onMouseDown: function onMouseDown(e$2) {
				e$2.preventDefault();
			},
			onClick: onClose,
			className: "".concat(selectionCls, "-item-remove")
		}, removeIcon));
	}
	function renderItem$1(date$1) {
		var displayLabel = formatDate(date$1);
		return renderSelector(displayLabel, function onClose(event) {
			if (event) event.stopPropagation();
			onRemove(date$1);
		});
	}
	function renderRest(omittedValues) {
		var content = "+ ".concat(omittedValues.length, " ...");
		return renderSelector(content);
	}
	return /* @__PURE__ */ import_react.createElement("div", { className: selectorCls }, /* @__PURE__ */ import_react.createElement(es_default$31, {
		prefixCls: overflowCls,
		data: value,
		renderItem: renderItem$1,
		renderRest,
		itemKey: function itemKey$2(date$1) {
			return formatDate(date$1);
		},
		maxCount: maxTagCount
	}), !value.length && /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-selection-placeholder") }, placeholder));
}

//#endregion
//#region node_modules/rc-picker/es/PickerInput/Selector/SingleSelector/index.js
var import_classnames$171 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$41 = [
	"id",
	"open",
	"prefix",
	"clearIcon",
	"suffixIcon",
	"activeHelp",
	"allHelp",
	"focused",
	"onFocus",
	"onBlur",
	"onKeyDown",
	"locale",
	"generateConfig",
	"placeholder",
	"className",
	"style",
	"onClick",
	"onClear",
	"internalPicker",
	"value",
	"onChange",
	"onSubmit",
	"onInputChange",
	"multiple",
	"maxTagCount",
	"format",
	"maskFormat",
	"preserveInvalidOnBlur",
	"onInvalid",
	"disabled",
	"invalid",
	"inputReadOnly",
	"direction",
	"onOpenChange",
	"onMouseDown",
	"required",
	"aria-required",
	"autoFocus",
	"tabIndex",
	"removeIcon"
];
function SingleSelector(props, ref) {
	props.id;
	var open$2 = props.open, prefix = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon;
	props.activeHelp;
	props.allHelp;
	var focused = props.focused;
	props.onFocus;
	props.onBlur;
	props.onKeyDown;
	var locale$5 = props.locale, generateConfig$1 = props.generateConfig, placeholder = props.placeholder, className = props.className, style$1 = props.style, onClick = props.onClick, onClear = props.onClear, internalPicker = props.internalPicker, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit;
	props.onInputChange;
	var multiple = props.multiple, maxTagCount = props.maxTagCount;
	props.format;
	props.maskFormat;
	props.preserveInvalidOnBlur;
	props.onInvalid;
	var disabled = props.disabled, invalid = props.invalid;
	props.inputReadOnly;
	var direction = props.direction;
	props.onOpenChange;
	var _onMouseDown = props.onMouseDown;
	props.required;
	props["aria-required"];
	var autoFocus = props.autoFocus, tabIndex = props.tabIndex, removeIcon = props.removeIcon, restProps = _objectWithoutProperties(props, _excluded$41);
	var rtl = direction === "rtl";
	var _React$useContext = import_react.useContext(context_default$6), prefixCls = _React$useContext.prefixCls;
	var rootRef = import_react.useRef();
	var inputRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		return {
			nativeElement: rootRef.current,
			focus: function focus(options) {
				var _inputRef$current;
				(_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
			},
			blur: function blur() {
				var _inputRef$current2;
				(_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
			}
		};
	});
	var rootProps = useRootProps(restProps);
	var onSingleChange = function onSingleChange$1(date$1) {
		onChange([date$1]);
	};
	var onMultipleRemove = function onMultipleRemove$1(date$1) {
		var nextValues = value.filter(function(oriDate) {
			return oriDate && !isSame(generateConfig$1, locale$5, oriDate, date$1, internalPicker);
		});
		onChange(nextValues);
		if (!open$2) onSubmit();
	};
	var _useInputProps = useInputProps(_objectSpread2(_objectSpread2({}, props), {}, { onChange: onSingleChange }), function(_ref) {
		return {
			value: _ref.valueTexts[0] || "",
			active: focused
		};
	}), _useInputProps2 = _slicedToArray(_useInputProps, 2), getInputProps = _useInputProps2[0], getText = _useInputProps2[1];
	var showClear = !!(clearIcon && value.length && !disabled);
	var selectorNode = multiple ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(MultipleDates, {
		prefixCls,
		value,
		onRemove: onMultipleRemove,
		formatDate: getText,
		maxTagCount,
		disabled,
		removeIcon,
		placeholder
	}), /* @__PURE__ */ import_react.createElement("input", {
		className: "".concat(prefixCls, "-multiple-input"),
		value: value.map(getText).join(","),
		ref: inputRef,
		readOnly: true,
		autoFocus,
		tabIndex
	}), /* @__PURE__ */ import_react.createElement(Icon$1, {
		type: "suffix",
		icon: suffixIcon
	}), showClear && /* @__PURE__ */ import_react.createElement(ClearIcon, {
		icon: clearIcon,
		onClear
	})) : /* @__PURE__ */ import_react.createElement(Input_default$2, _extends({ ref: inputRef }, getInputProps(), {
		autoFocus,
		tabIndex,
		suffixIcon,
		clearIcon: showClear && /* @__PURE__ */ import_react.createElement(ClearIcon, {
			icon: clearIcon,
			onClear
		}),
		showActiveCls: false
	}));
	return /* @__PURE__ */ import_react.createElement("div", _extends({}, rootProps, {
		className: (0, import_classnames$171.default)(prefixCls, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-invalid"), invalid), "".concat(prefixCls, "-rtl"), rtl), className),
		style: style$1,
		ref: rootRef,
		onClick,
		onMouseDown: function onMouseDown(e$2) {
			var _inputRef$current3;
			if (e$2.target !== ((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.inputElement)) e$2.preventDefault();
			_onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e$2);
		}
	}), prefix && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-prefix") }, prefix), selectorNode);
}
var RefSingleSelector = /* @__PURE__ */ import_react.forwardRef(SingleSelector);
RefSingleSelector.displayName = "SingleSelector";
var SingleSelector_default = RefSingleSelector;

//#endregion
//#region node_modules/rc-picker/es/PickerInput/SinglePicker.js
/** Internal usage. For cross function get same aligned props */
function Picker(props, ref) {
	var _useFilledProps = useFilledProps(props), _useFilledProps2 = _slicedToArray(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
	var _ref = filledProps, prefixCls = _ref.prefixCls, styles = _ref.styles, classNames$252 = _ref.classNames, order = _ref.order, defaultValue = _ref.defaultValue, value = _ref.value, needConfirm = _ref.needConfirm, onChange = _ref.onChange, onKeyDown$1 = _ref.onKeyDown, disabled = _ref.disabled, disabledDate = _ref.disabledDate, minDate = _ref.minDate, maxDate = _ref.maxDate, defaultOpen = _ref.defaultOpen, open$2 = _ref.open, onOpenChange = _ref.onOpenChange, locale$5 = _ref.locale, generateConfig$1 = _ref.generateConfig, picker = _ref.picker, showNow = _ref.showNow, showToday = _ref.showToday, showTime = _ref.showTime, mode = _ref.mode, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, onOk = _ref.onOk, multiple = _ref.multiple, defaultPickerValue = _ref.defaultPickerValue, pickerValue = _ref.pickerValue, onPickerValueChange = _ref.onPickerValueChange, inputReadOnly = _ref.inputReadOnly, suffixIcon = _ref.suffixIcon, removeIcon = _ref.removeIcon, onFocus = _ref.onFocus, onBlur = _ref.onBlur, presets = _ref.presets, components$1 = _ref.components, cellRender = _ref.cellRender, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, onClick = _ref.onClick;
	var selectorRef = usePickerRef(ref);
	function pickerParam(values) {
		if (values === null) return null;
		return multiple ? values : values[0];
	}
	var toggleDates = useToggleDates(generateConfig$1, locale$5, internalPicker);
	var _useOpen = useOpen(open$2, defaultOpen, [disabled], onOpenChange), _useOpen2 = _slicedToArray(_useOpen, 2), mergedOpen = _useOpen2[0], triggerOpen = _useOpen2[1];
	var _useInnerValue = useInnerValue(generateConfig$1, locale$5, formatList, false, order, defaultValue, value, function onInternalCalendarChange(dates, dateStrings, info) {
		if (onCalendarChange) {
			var filteredInfo = _objectSpread2({}, info);
			delete filteredInfo.range;
			onCalendarChange(pickerParam(dates), pickerParam(dateStrings), filteredInfo);
		}
	}, function onInternalOk(dates) {
		onOk === null || onOk === void 0 || onOk(pickerParam(dates));
	}), _useInnerValue2 = _slicedToArray(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
	var calendarValue = getCalendarValue();
	var _useRangeActive = useRangeActive([disabled]), _useRangeActive2 = _slicedToArray(_useRangeActive, 4), focused = _useRangeActive2[0], triggerFocus$1 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3];
	var onSharedFocus = function onSharedFocus$1(event) {
		triggerFocus$1(true);
		onFocus === null || onFocus === void 0 || onFocus(event, {});
	};
	var onSharedBlur = function onSharedBlur$1(event) {
		triggerFocus$1(false);
		onBlur === null || onBlur === void 0 || onBlur(event, {});
	};
	var _useMergedState = useMergedState(picker, { value: mode }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedMode = _useMergedState2[0], setMode = _useMergedState2[1];
	/** Extends from `mergedMode` to patch `datetime` mode */
	var internalMode = mergedMode === "date" && showTime ? "datetime" : mergedMode;
	var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday);
	var onInternalChange = onChange && function(dates, dateStrings) {
		onChange(pickerParam(dates), pickerParam(dateStrings));
	};
	var _useRangeValue = useRangeValue(_objectSpread2(_objectSpread2({}, filledProps), {}, { onChange: onInternalChange }), mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, [], formatList, focused, mergedOpen, isInvalidateDate), _useRangeValue2 = _slicedToArray(_useRangeValue, 2), triggerSubmitChange = _useRangeValue2[1];
	var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate), _useFieldsInvalidate2 = _slicedToArray(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
	var submitInvalidate = import_react.useMemo(function() {
		return submitInvalidates.some(function(invalidated) {
			return invalidated;
		});
	}, [submitInvalidates]);
	var _useRangePickerValue = useRangePickerValue(generateConfig$1, locale$5, calendarValue, [mergedMode], mergedOpen, activeIndex, internalPicker, false, defaultPickerValue, pickerValue, toArray$5(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue), function onInternalPickerValueChange(dates, info) {
		if (onPickerValueChange) {
			var cleanInfo = _objectSpread2(_objectSpread2({}, info), {}, { mode: info.mode[0] });
			delete cleanInfo.range;
			onPickerValueChange(dates[0], cleanInfo);
		}
	}, minDate, maxDate), _useRangePickerValue2 = _slicedToArray(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
	var triggerModeChange = useEvent(function(nextPickerValue, nextMode, triggerEvent) {
		setMode(nextMode);
		if (onPanelChange && triggerEvent !== false) {
			var lastPickerValue = nextPickerValue || calendarValue[calendarValue.length - 1];
			onPanelChange(lastPickerValue, nextMode);
		}
	});
	/**
	* Different with RangePicker, confirm should check `multiple` logic.
	* This will never provide `date` instead.
	*/
	var triggerConfirm = function triggerConfirm$1() {
		triggerSubmitChange(getCalendarValue());
		triggerOpen(false, { force: true });
	};
	var onSelectorClick = function onSelectorClick$1(event) {
		if (!disabled && !selectorRef.current.nativeElement.contains(document.activeElement)) selectorRef.current.focus();
		triggerOpen(true);
		onClick === null || onClick === void 0 || onClick(event);
	};
	var onSelectorClear = function onSelectorClear$1() {
		triggerSubmitChange(null);
		triggerOpen(false, { force: true });
	};
	var _React$useState = import_react.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
	var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), internalHoverValue = _React$useState4[0], setInternalHoverValue = _React$useState4[1];
	var hoverValues = import_react.useMemo(function() {
		var values = [internalHoverValue].concat(_toConsumableArray(calendarValue)).filter(function(date$1) {
			return date$1;
		});
		return multiple ? values : values.slice(0, 1);
	}, [
		calendarValue,
		internalHoverValue,
		multiple
	]);
	var selectorValues = import_react.useMemo(function() {
		if (!multiple && internalHoverValue) return [internalHoverValue];
		return calendarValue.filter(function(date$1) {
			return date$1;
		});
	}, [
		calendarValue,
		internalHoverValue,
		multiple
	]);
	import_react.useEffect(function() {
		if (!mergedOpen) setInternalHoverValue(null);
	}, [mergedOpen]);
	var presetList = usePresets(presets);
	var onPresetHover = function onPresetHover$1(nextValue) {
		setInternalHoverValue(nextValue);
		setHoverSource("preset");
	};
	var onPresetSubmit = function onPresetSubmit$1(nextValue) {
		var nextCalendarValues = multiple ? toggleDates(getCalendarValue(), nextValue) : [nextValue];
		if (triggerSubmitChange(nextCalendarValues) && !multiple) triggerOpen(false, { force: true });
	};
	var onNow = function onNow$1(now$1) {
		onPresetSubmit(now$1);
	};
	var onPanelHover = function onPanelHover$1(date$1) {
		setInternalHoverValue(date$1);
		setHoverSource("cell");
	};
	var onPanelFocus = function onPanelFocus$1(event) {
		triggerOpen(true);
		onSharedFocus(event);
	};
	var onPanelSelect = function onPanelSelect$1(date$1) {
		lastOperation("panel");
		if (multiple && internalMode !== picker) return;
		var nextValues = multiple ? toggleDates(getCalendarValue(), date$1) : [date$1];
		triggerCalendarChange(nextValues);
		if (!needConfirm && !complexPicker && internalPicker === internalMode) triggerConfirm();
	};
	var onPopupClose = function onPopupClose$1() {
		triggerOpen(false);
	};
	var onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender);
	var panelProps = import_react.useMemo(function() {
		var domProps = pickAttrs(filledProps, false);
		var restProps = omit(filledProps, [].concat(_toConsumableArray(Object.keys(domProps)), [
			"onChange",
			"onCalendarChange",
			"style",
			"className",
			"onPanelChange"
		]));
		return _objectSpread2(_objectSpread2({}, restProps), {}, { multiple: filledProps.multiple });
	}, [filledProps]);
	var panel = /* @__PURE__ */ import_react.createElement(Popup, _extends({}, panelProps, {
		showNow: mergedShowNow,
		showTime,
		disabledDate,
		onFocus: onPanelFocus,
		onBlur: onSharedBlur,
		picker,
		mode: mergedMode,
		internalMode,
		onPanelChange: triggerModeChange,
		format: maskFormat,
		value: calendarValue,
		isInvalid: isInvalidateDate,
		onChange: null,
		onSelect: onPanelSelect,
		pickerValue: currentPickerValue,
		defaultOpenValue: showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue,
		onPickerValueChange: setCurrentPickerValue,
		hoverValue: hoverValues,
		onHover: onPanelHover,
		needConfirm,
		onSubmit: triggerConfirm,
		onOk: triggerOk,
		presets: presetList,
		onPresetHover,
		onPresetSubmit,
		onNow,
		cellRender: onInternalCellRender
	}));
	var onSelectorChange = function onSelectorChange$1(date$1) {
		triggerCalendarChange(date$1);
	};
	var onSelectorInputChange = function onSelectorInputChange$1() {
		lastOperation("input");
	};
	var onSelectorFocus = function onSelectorFocus$1(event) {
		lastOperation("input");
		triggerOpen(true, { inherit: true });
		onSharedFocus(event);
	};
	var onSelectorBlur = function onSelectorBlur$1(event) {
		triggerOpen(false);
		onSharedBlur(event);
	};
	var onSelectorKeyDown = function onSelectorKeyDown$1(event, preventDefault) {
		if (event.key === "Tab") triggerConfirm();
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event, preventDefault);
	};
	var context = import_react.useMemo(function() {
		return {
			prefixCls,
			locale: locale$5,
			generateConfig: generateConfig$1,
			button: components$1.button,
			input: components$1.input
		};
	}, [
		prefixCls,
		locale$5,
		generateConfig$1,
		components$1.button,
		components$1.input
	]);
	useLayoutEffect_default(function() {
		if (mergedOpen && activeIndex !== void 0) triggerModeChange(null, picker, false);
	}, [
		mergedOpen,
		activeIndex,
		picker
	]);
	useLayoutEffect_default(function() {
		var lastOp = lastOperation();
		if (!mergedOpen && lastOp === "input") {
			triggerOpen(false);
			triggerConfirm();
		}
		if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") triggerConfirm();
	}, [mergedOpen]);
	return /* @__PURE__ */ import_react.createElement(context_default$6.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(PickerTrigger_default, _extends({}, pickTriggerProps(filledProps), {
		popupElement: panel,
		popupStyle: styles.popup,
		popupClassName: classNames$252.popup,
		visible: mergedOpen,
		onClose: onPopupClose
	}), /* @__PURE__ */ import_react.createElement(SingleSelector_default, _extends({}, filledProps, {
		ref: selectorRef,
		suffixIcon,
		removeIcon,
		activeHelp: !!internalHoverValue,
		allHelp: !!internalHoverValue && hoverSource === "preset",
		focused,
		onFocus: onSelectorFocus,
		onBlur: onSelectorBlur,
		onKeyDown: onSelectorKeyDown,
		onSubmit: triggerConfirm,
		value: selectorValues,
		maskFormat,
		onChange: onSelectorChange,
		onInputChange: onSelectorInputChange,
		internalPicker,
		format: formatList,
		inputReadOnly,
		disabled,
		open: mergedOpen,
		onOpenChange: triggerOpen,
		onClick: onSelectorClick,
		onClear: onSelectorClear,
		invalid: submitInvalidate,
		onInvalid: function onInvalid(invalid) {
			onSelectorInvalid(invalid, 0);
		}
	}))));
}
var RefPicker = /* @__PURE__ */ import_react.forwardRef(Picker);
RefPicker.displayName = "RefPicker";
var SinglePicker_default = RefPicker;

//#endregion
//#region node_modules/rc-picker/es/index.js
var es_default$19 = SinglePicker_default;

//#endregion
//#region node_modules/antd/es/radio/context.js
var RadioGroupContext = /* @__PURE__ */ import_react.createContext(null);
const RadioGroupContextProvider = RadioGroupContext.Provider;
var context_default$5 = RadioGroupContext;
const RadioOptionTypeContext = /* @__PURE__ */ import_react.createContext(null);
const RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;

//#endregion
//#region node_modules/rc-checkbox/es/index.js
var import_classnames$170 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$40 = [
	"prefixCls",
	"className",
	"style",
	"checked",
	"disabled",
	"defaultChecked",
	"type",
	"title",
	"onChange"
];
var Checkbox$3 = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-checkbox" : _props$prefixCls, className = props.className, style$1 = props.style, checked = props.checked, disabled = props.disabled, _props$defaultChecked = props.defaultChecked, defaultChecked = _props$defaultChecked === void 0 ? false : _props$defaultChecked, _props$type = props.type, type$2 = _props$type === void 0 ? "checkbox" : _props$type, title = props.title, onChange = props.onChange, inputProps = _objectWithoutProperties(props, _excluded$40);
	var inputRef = (0, import_react.useRef)(null);
	var holderRef = (0, import_react.useRef)(null);
	var _useMergedState = useMergedState(defaultChecked, { value: checked }), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValue = _useMergedState2[0], setRawValue = _useMergedState2[1];
	(0, import_react.useImperativeHandle)(ref, function() {
		return {
			focus: function focus(options) {
				var _inputRef$current;
				(_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
			},
			blur: function blur() {
				var _inputRef$current2;
				(_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
			},
			input: inputRef.current,
			nativeElement: holderRef.current
		};
	});
	var classString = (0, import_classnames$170.default)(prefixCls, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-checked"), rawValue), "".concat(prefixCls, "-disabled"), disabled));
	return /* @__PURE__ */ import_react.createElement("span", {
		className: classString,
		title,
		style: style$1,
		ref: holderRef
	}, /* @__PURE__ */ import_react.createElement("input", _extends({}, inputProps, {
		className: "".concat(prefixCls, "-input"),
		ref: inputRef,
		onChange: function handleChange(e$2) {
			if (disabled) return;
			if (!("checked" in props)) setRawValue(e$2.target.checked);
			onChange === null || onChange === void 0 || onChange({
				target: _objectSpread2(_objectSpread2({}, props), {}, {
					type: type$2,
					checked: e$2.target.checked
				}),
				stopPropagation: function stopPropagation() {
					e$2.stopPropagation();
				},
				preventDefault: function preventDefault() {
					e$2.preventDefault();
				},
				nativeEvent: e$2.nativeEvent
			});
		},
		disabled,
		checked: !!rawValue,
		type: type$2
	})), /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-inner") }));
});
var es_default$26 = Checkbox$3;

//#endregion
//#region node_modules/antd/es/checkbox/useBubbleLock.js
/**
* When click on the label,
* the event will be stopped to prevent the label from being clicked twice.
* label click -> input click -> label click again
*/
function useBubbleLock(onOriginInputClick) {
	const labelClickLockRef = import_react.useRef(null);
	const clearLock = () => {
		raf_default.cancel(labelClickLockRef.current);
		labelClickLockRef.current = null;
	};
	const onLabelClick = () => {
		clearLock();
		labelClickLockRef.current = raf_default(() => {
			labelClickLockRef.current = null;
		});
	};
	const onInputClick = (e$2) => {
		if (labelClickLockRef.current) {
			e$2.stopPropagation();
			clearLock();
		}
		onOriginInputClick === null || onOriginInputClick === void 0 || onOriginInputClick(e$2);
	};
	return [onLabelClick, onInputClick];
}

//#endregion
//#region node_modules/antd/es/radio/style/index.js
var getGroupRadioStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	const groupPrefixCls = `${componentCls}-group`;
	return { [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		display: "inline-block",
		fontSize: 0,
		[`&${groupPrefixCls}-rtl`]: { direction: "rtl" },
		[`&${groupPrefixCls}-block`]: { display: "flex" },
		[`${antCls}-badge ${antCls}-badge-count`]: { zIndex: 1 },
		[`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: { borderInlineStart: "none" }
	}) };
};
var getRadioBasicStyle = (token$1) => {
	const { componentCls, wrapperMarginInlineEnd, colorPrimary, radioSize, motionDurationSlow, motionDurationMid, motionEaseInOutCirc, colorBgContainer, colorBorder, lineWidth, colorBgContainerDisabled, colorTextDisabled, paddingXS, dotColorDisabled, lineType, radioColor, radioBgColor, calc } = token$1;
	const radioInnerPrefixCls = `${componentCls}-inner`;
	const radioDotDisabledSize = calc(radioSize).sub(calc(4).mul(2));
	const radioSizeCalc = calc(1).mul(radioSize).equal({ unit: true });
	return { [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		display: "inline-flex",
		alignItems: "baseline",
		marginInlineStart: 0,
		marginInlineEnd: wrapperMarginInlineEnd,
		cursor: "pointer",
		"&:last-child": { marginInlineEnd: 0 },
		[`&${componentCls}-wrapper-rtl`]: { direction: "rtl" },
		"&-disabled": {
			cursor: "not-allowed",
			color: token$1.colorTextDisabled
		},
		"&::after": {
			display: "inline-block",
			width: 0,
			overflow: "hidden",
			content: "\"\\a0\""
		},
		"&-block": {
			flex: 1,
			justifyContent: "center"
		},
		[`${componentCls}-checked::after`]: {
			position: "absolute",
			insetBlockStart: 0,
			insetInlineStart: 0,
			width: "100%",
			height: "100%",
			border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
			borderRadius: "50%",
			visibility: "hidden",
			opacity: 0,
			content: "\"\""
		},
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "relative",
			display: "inline-block",
			outline: "none",
			cursor: "pointer",
			alignSelf: "center",
			borderRadius: "50%"
		}),
		[`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: { borderColor: colorPrimary },
		[`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: genFocusOutline(token$1),
		[`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: { visibility: "visible" },
		[`${componentCls}-inner`]: {
			"&::after": {
				boxSizing: "border-box",
				position: "absolute",
				insetBlockStart: "50%",
				insetInlineStart: "50%",
				display: "block",
				width: radioSizeCalc,
				height: radioSizeCalc,
				marginBlockStart: calc(1).mul(radioSize).div(-2).equal({ unit: true }),
				marginInlineStart: calc(1).mul(radioSize).div(-2).equal({ unit: true }),
				backgroundColor: radioColor,
				borderBlockStart: 0,
				borderInlineStart: 0,
				borderRadius: radioSizeCalc,
				transform: "scale(0)",
				opacity: 0,
				transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
				content: "\"\""
			},
			boxSizing: "border-box",
			position: "relative",
			insetBlockStart: 0,
			insetInlineStart: 0,
			display: "block",
			width: radioSizeCalc,
			height: radioSizeCalc,
			backgroundColor: colorBgContainer,
			borderColor: colorBorder,
			borderStyle: "solid",
			borderWidth: lineWidth,
			borderRadius: "50%",
			transition: `all ${motionDurationMid}`
		},
		[`${componentCls}-input`]: {
			position: "absolute",
			inset: 0,
			zIndex: 1,
			cursor: "pointer",
			opacity: 0
		},
		[`${componentCls}-checked`]: { [radioInnerPrefixCls]: {
			borderColor: colorPrimary,
			backgroundColor: radioBgColor,
			"&::after": {
				transform: `scale(${token$1.calc(token$1.dotSize).div(radioSize).equal()})`,
				opacity: 1,
				transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
			}
		} },
		[`${componentCls}-disabled`]: {
			cursor: "not-allowed",
			[radioInnerPrefixCls]: {
				backgroundColor: colorBgContainerDisabled,
				borderColor: colorBorder,
				cursor: "not-allowed",
				"&::after": { backgroundColor: dotColorDisabled }
			},
			[`${componentCls}-input`]: { cursor: "not-allowed" },
			[`${componentCls}-disabled + span`]: {
				color: colorTextDisabled,
				cursor: "not-allowed"
			},
			[`&${componentCls}-checked`]: { [radioInnerPrefixCls]: { "&::after": { transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal()})` } } }
		},
		[`span${componentCls} + *`]: {
			paddingInlineStart: paddingXS,
			paddingInlineEnd: paddingXS
		}
	}) };
};
var getRadioButtonStyle = (token$1) => {
	const { buttonColor, controlHeight, componentCls, lineWidth, lineType, colorBorder, motionDurationMid, buttonPaddingInline, fontSize, buttonBg, fontSizeLG, controlHeightLG, controlHeightSM, paddingXS, borderRadius, borderRadiusSM, borderRadiusLG, buttonCheckedBg, buttonSolidCheckedColor, colorTextDisabled, colorBgContainerDisabled, buttonCheckedBgDisabled, buttonCheckedColorDisabled, colorPrimary, colorPrimaryHover, colorPrimaryActive, buttonSolidCheckedBg, buttonSolidCheckedHoverBg, buttonSolidCheckedActiveBg, calc } = token$1;
	return { [`${componentCls}-button-wrapper`]: {
		position: "relative",
		display: "inline-block",
		height: controlHeight,
		margin: 0,
		paddingInline: buttonPaddingInline,
		paddingBlock: 0,
		color: buttonColor,
		fontSize,
		lineHeight: unit(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
		background: buttonBg,
		border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
		borderBlockStartWidth: calc(lineWidth).add(.02).equal(),
		borderInlineEndWidth: lineWidth,
		cursor: "pointer",
		transition: [
			`color ${motionDurationMid}`,
			`background ${motionDurationMid}`,
			`box-shadow ${motionDurationMid}`
		].join(","),
		a: { color: buttonColor },
		[`> ${componentCls}-button`]: {
			position: "absolute",
			insetBlockStart: 0,
			insetInlineStart: 0,
			zIndex: -1,
			width: "100%",
			height: "100%"
		},
		"&:not(:last-child)": { marginInlineEnd: calc(lineWidth).mul(-1).equal() },
		"&:first-child": {
			borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
			borderStartStartRadius: borderRadius,
			borderEndStartRadius: borderRadius
		},
		"&:last-child": {
			borderStartEndRadius: borderRadius,
			borderEndEndRadius: borderRadius
		},
		"&:first-child:last-child": { borderRadius },
		[`${componentCls}-group-large &`]: {
			height: controlHeightLG,
			fontSize: fontSizeLG,
			lineHeight: unit(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
			"&:first-child": {
				borderStartStartRadius: borderRadiusLG,
				borderEndStartRadius: borderRadiusLG
			},
			"&:last-child": {
				borderStartEndRadius: borderRadiusLG,
				borderEndEndRadius: borderRadiusLG
			}
		},
		[`${componentCls}-group-small &`]: {
			height: controlHeightSM,
			paddingInline: calc(paddingXS).sub(lineWidth).equal(),
			paddingBlock: 0,
			lineHeight: unit(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
			"&:first-child": {
				borderStartStartRadius: borderRadiusSM,
				borderEndStartRadius: borderRadiusSM
			},
			"&:last-child": {
				borderStartEndRadius: borderRadiusSM,
				borderEndEndRadius: borderRadiusSM
			}
		},
		"&:hover": {
			position: "relative",
			color: colorPrimary
		},
		"&:has(:focus-visible)": genFocusOutline(token$1),
		[`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
			width: 0,
			height: 0,
			opacity: 0,
			pointerEvents: "none"
		},
		[`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
			zIndex: 1,
			color: colorPrimary,
			background: buttonCheckedBg,
			borderColor: colorPrimary,
			"&::before": { backgroundColor: colorPrimary },
			"&:first-child": { borderColor: colorPrimary },
			"&:hover": {
				color: colorPrimaryHover,
				borderColor: colorPrimaryHover,
				"&::before": { backgroundColor: colorPrimaryHover }
			},
			"&:active": {
				color: colorPrimaryActive,
				borderColor: colorPrimaryActive,
				"&::before": { backgroundColor: colorPrimaryActive }
			}
		},
		[`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
			color: buttonSolidCheckedColor,
			background: buttonSolidCheckedBg,
			borderColor: buttonSolidCheckedBg,
			"&:hover": {
				color: buttonSolidCheckedColor,
				background: buttonSolidCheckedHoverBg,
				borderColor: buttonSolidCheckedHoverBg
			},
			"&:active": {
				color: buttonSolidCheckedColor,
				background: buttonSolidCheckedActiveBg,
				borderColor: buttonSolidCheckedActiveBg
			}
		},
		"&-disabled": {
			color: colorTextDisabled,
			backgroundColor: colorBgContainerDisabled,
			borderColor: colorBorder,
			cursor: "not-allowed",
			"&:first-child, &:hover": {
				color: colorTextDisabled,
				backgroundColor: colorBgContainerDisabled,
				borderColor: colorBorder
			}
		},
		[`&-disabled${componentCls}-button-wrapper-checked`]: {
			color: buttonCheckedColorDisabled,
			backgroundColor: buttonCheckedBgDisabled,
			borderColor: colorBorder,
			boxShadow: "none"
		},
		"&-block": {
			flex: 1,
			textAlign: "center"
		}
	} };
};
const prepareComponentToken$37 = (token$1) => {
	const { wireframe, padding, marginXS, lineWidth, fontSizeLG, colorText, colorBgContainer, colorTextDisabled, controlItemBgActiveDisabled, colorTextLightSolid, colorPrimary, colorPrimaryHover, colorPrimaryActive, colorWhite } = token$1;
	const dotPadding = 4;
	const radioSize = fontSizeLG;
	const radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
	return {
		radioSize,
		dotSize: radioDotSize,
		dotColorDisabled: colorTextDisabled,
		buttonSolidCheckedColor: colorTextLightSolid,
		buttonSolidCheckedBg: colorPrimary,
		buttonSolidCheckedHoverBg: colorPrimaryHover,
		buttonSolidCheckedActiveBg: colorPrimaryActive,
		buttonBg: colorBgContainer,
		buttonCheckedBg: colorBgContainer,
		buttonColor: colorText,
		buttonCheckedBgDisabled: controlItemBgActiveDisabled,
		buttonCheckedColorDisabled: colorTextDisabled,
		buttonPaddingInline: padding - lineWidth,
		wrapperMarginInlineEnd: marginXS,
		radioColor: wireframe ? colorPrimary : colorWhite,
		radioBgColor: wireframe ? colorBgContainer : colorPrimary
	};
};
var style_default$44 = genStyleHooks("Radio", (token$1) => {
	const { controlOutline, controlOutlineWidth } = token$1;
	const radioFocusShadow = `0 0 0 ${unit(controlOutlineWidth)} ${controlOutline}`;
	const radioToken = merge(token$1, {
		radioFocusShadow,
		radioButtonFocusShadow: radioFocusShadow
	});
	return [
		getGroupRadioStyle(radioToken),
		getRadioBasicStyle(radioToken),
		getRadioButtonStyle(radioToken)
	];
}, prepareComponentToken$37, { unitless: {
	radioSize: true,
	dotSize: true
} });

//#endregion
//#region node_modules/antd/es/radio/radio.js
var import_classnames$169 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$83 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var InternalRadio = (props, ref) => {
	var _a, _b;
	const groupContext = import_react.useContext(context_default$5);
	const radioOptionTypeContext = import_react.useContext(RadioOptionTypeContext);
	const { getPrefixCls, direction, radio } = import_react.useContext(ConfigContext);
	const innerRef = import_react.useRef(null);
	const mergedRef = composeRef(ref, innerRef);
	const { isFormItemInput } = import_react.useContext(FormItemInputContext);
	devUseWarning("Radio")(!("optionType" in props), "usage", "`optionType` is only support in Radio.Group.");
	const onChange = (e$2) => {
		var _a$1, _b$1;
		(_a$1 = props.onChange) === null || _a$1 === void 0 || _a$1.call(props, e$2);
		(_b$1 = groupContext === null || groupContext === void 0 ? void 0 : groupContext.onChange) === null || _b$1 === void 0 || _b$1.call(groupContext, e$2);
	};
	const { prefixCls: customizePrefixCls, className, rootClassName, children, style: style$1, title } = props, restProps = __rest$83(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"children",
		"style",
		"title"
	]);
	const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
	const isButtonType = ((groupContext === null || groupContext === void 0 ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button";
	const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
	const rootCls = useCSSVarCls_default(radioPrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$44(radioPrefixCls, rootCls);
	const radioProps = Object.assign({}, restProps);
	const disabled = import_react.useContext(DisabledContext_default);
	if (groupContext) {
		radioProps.name = groupContext.name;
		radioProps.onChange = onChange;
		radioProps.checked = props.value === groupContext.value;
		radioProps.disabled = (_a = radioProps.disabled) !== null && _a !== void 0 ? _a : groupContext.disabled;
	}
	radioProps.disabled = (_b = radioProps.disabled) !== null && _b !== void 0 ? _b : disabled;
	const wrapperClassString = (0, import_classnames$169.default)(`${prefixCls}-wrapper`, {
		[`${prefixCls}-wrapper-checked`]: radioProps.checked,
		[`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
		[`${prefixCls}-wrapper-rtl`]: direction === "rtl",
		[`${prefixCls}-wrapper-in-form-item`]: isFormItemInput,
		[`${prefixCls}-wrapper-block`]: !!(groupContext === null || groupContext === void 0 ? void 0 : groupContext.block)
	}, radio === null || radio === void 0 ? void 0 : radio.className, className, rootClassName, hashId, cssVarCls, rootCls);
	const [onLabelClick, onInputClick] = useBubbleLock(radioProps.onClick);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(wave_default, {
		component: "Radio",
		disabled: radioProps.disabled
	}, /* @__PURE__ */ import_react.createElement("label", {
		className: wrapperClassString,
		style: Object.assign(Object.assign({}, radio === null || radio === void 0 ? void 0 : radio.style), style$1),
		onMouseEnter: props.onMouseEnter,
		onMouseLeave: props.onMouseLeave,
		title,
		onClick: onLabelClick
	}, /* @__PURE__ */ import_react.createElement(es_default$26, Object.assign({}, radioProps, {
		className: (0, import_classnames$169.default)(radioProps.className, { [TARGET_CLS]: !isButtonType }),
		type: "radio",
		prefixCls,
		ref: mergedRef,
		onClick: onInputClick
	})), children !== void 0 ? /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-label` }, children) : null)));
};
var Radio$1 = /* @__PURE__ */ import_react.forwardRef(InternalRadio);
Radio$1.displayName = "Radio";
var radio_default$1 = Radio$1;

//#endregion
//#region node_modules/antd/es/form/util.js
var formItemNameBlackList = ["parentNode"];
var defaultItemNamePrefixCls = "form_item";
function toArray$4(candidate) {
	if (candidate === void 0 || candidate === false) return [];
	return Array.isArray(candidate) ? candidate : [candidate];
}
function getFieldId(namePath, formName) {
	if (!namePath.length) return;
	const mergedId = namePath.join("_");
	if (formName) return `${formName}_${mergedId}`;
	return formItemNameBlackList.includes(mergedId) ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
}
/**
* Get merged status by meta or passed `validateStatus`.
*/
function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus) {
	let status = defaultValidateStatus;
	if (validateStatus !== void 0) status = validateStatus;
	else if (meta.validating) status = "validating";
	else if (errors.length) status = "error";
	else if (warnings.length) status = "warning";
	else if (meta.touched || hasFeedback && meta.validated) status = "success";
	return status;
}

//#endregion
//#region node_modules/antd/es/form/hooks/useForm.js
var __rest$82 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function toNamePathStr(name) {
	return toArray$4(name).join("_");
}
function getFieldDOMNode(name, wrapForm) {
	const field = wrapForm.getFieldInstance(name);
	const fieldDom = getDOM(field);
	if (fieldDom) return fieldDom;
	const fieldId = getFieldId(toArray$4(name), wrapForm.__INTERNAL__.name);
	if (fieldId) return document.getElementById(fieldId);
}
function useForm(form) {
	const [rcForm] = useForm_default();
	const itemsRef = import_react.useRef({});
	const wrapForm = import_react.useMemo(() => form !== null && form !== void 0 ? form : Object.assign(Object.assign({}, rcForm), {
		__INTERNAL__: { itemRef: (name) => (node$1) => {
			const namePathStr = toNamePathStr(name);
			if (node$1) itemsRef.current[namePathStr] = node$1;
			else delete itemsRef.current[namePathStr];
		} },
		scrollToField: (name, options = {}) => {
			const { focus } = options, restOpt = __rest$82(options, ["focus"]);
			const node$1 = getFieldDOMNode(name, wrapForm);
			if (node$1) {
				e(node$1, Object.assign({
					scrollMode: "if-needed",
					block: "nearest"
				}, restOpt));
				if (focus) wrapForm.focusField(name);
			}
		},
		focusField: (name) => {
			var _a, _b;
			const itemRef = wrapForm.getFieldInstance(name);
			if (typeof (itemRef === null || itemRef === void 0 ? void 0 : itemRef.focus) === "function") itemRef.focus();
			else (_b = (_a = getFieldDOMNode(name, wrapForm)) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 || _b.call(_a);
		},
		getFieldInstance: (name) => {
			const namePathStr = toNamePathStr(name);
			return itemsRef.current[namePathStr];
		}
	}), [form, rcForm]);
	return [wrapForm];
}

//#endregion
//#region node_modules/antd/es/radio/group.js
var import_classnames$168 = /* @__PURE__ */ __toESM(require_classnames());
var RadioGroup = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { name: formItemName } = import_react.useContext(FormItemInputContext);
	const defaultName = useId_default(toNamePathStr(formItemName));
	const { prefixCls: customizePrefixCls, className, rootClassName, options, buttonStyle = "outline", disabled, children, size: customizeSize, style: style$1, id, optionType, name = defaultName, defaultValue, value: customizedValue, block = false, onChange, onMouseEnter, onMouseLeave, onFocus, onBlur } = props;
	const [value, setValue] = useMergedState(defaultValue, { value: customizedValue });
	const onRadioChange = import_react.useCallback((event) => {
		const lastValue = value;
		const val = event.target.value;
		if (!("value" in props)) setValue(val);
		if (val !== lastValue) onChange === null || onChange === void 0 || onChange(event);
	}, [
		value,
		setValue,
		onChange
	]);
	const prefixCls = getPrefixCls("radio", customizePrefixCls);
	const groupPrefixCls = `${prefixCls}-group`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$44(prefixCls, rootCls);
	let childrenToRender = children;
	if (options && options.length > 0) childrenToRender = options.map((option) => {
		if (typeof option === "string" || typeof option === "number") return /* @__PURE__ */ import_react.createElement(radio_default$1, {
			key: option.toString(),
			prefixCls,
			disabled,
			value: option,
			checked: value === option
		}, option);
		return /* @__PURE__ */ import_react.createElement(radio_default$1, {
			key: `radio-group-value-options-${option.value}`,
			prefixCls,
			disabled: option.disabled || disabled,
			value: option.value,
			checked: value === option.value,
			title: option.title,
			style: option.style,
			className: option.className,
			id: option.id,
			required: option.required
		}, option.label);
	});
	const mergedSize = useSize_default(customizeSize);
	const classString = (0, import_classnames$168.default)(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
		[`${groupPrefixCls}-${mergedSize}`]: mergedSize,
		[`${groupPrefixCls}-rtl`]: direction === "rtl",
		[`${groupPrefixCls}-block`]: block
	}, className, rootClassName, hashId, cssVarCls, rootCls);
	const memoizedValue = import_react.useMemo(() => ({
		onChange: onRadioChange,
		value,
		disabled,
		name,
		optionType,
		block
	}), [
		onRadioChange,
		value,
		disabled,
		name,
		optionType,
		block
	]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({}, pickAttrs(props, {
		aria: true,
		data: true
	}), {
		className: classString,
		style: style$1,
		onMouseEnter,
		onMouseLeave,
		onFocus,
		onBlur,
		id,
		ref
	}), /* @__PURE__ */ import_react.createElement(RadioGroupContextProvider, { value: memoizedValue }, childrenToRender)));
});
var group_default = /* @__PURE__ */ import_react.memo(RadioGroup);

//#endregion
//#region node_modules/antd/es/radio/radioButton.js
var __rest$81 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var RadioButton = (props, ref) => {
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls } = props, radioProps = __rest$81(props, ["prefixCls"]);
	const prefixCls = getPrefixCls("radio", customizePrefixCls);
	return /* @__PURE__ */ import_react.createElement(RadioOptionTypeContextProvider, { value: "button" }, /* @__PURE__ */ import_react.createElement(radio_default$1, Object.assign({ prefixCls }, radioProps, {
		type: "radio",
		ref
	})));
};
var radioButton_default = /* @__PURE__ */ import_react.forwardRef(RadioButton);

//#endregion
//#region node_modules/antd/es/radio/index.js
var Radio = radio_default$1;
Radio.Button = radioButton_default;
Radio.Group = group_default;
Radio.__ANT_RADIO = true;
var radio_default = Radio;

//#endregion
//#region node_modules/antd/es/calendar/Header.js
var YEAR_SELECT_OFFSET = 10;
var YEAR_SELECT_TOTAL = 20;
function YearSelect(props) {
	const { fullscreen, validRange, generateConfig: generateConfig$1, locale: locale$5, prefixCls, value, onChange, divRef } = props;
	const year = generateConfig$1.getYear(value || generateConfig$1.getNow());
	let start = year - YEAR_SELECT_OFFSET;
	let end = start + YEAR_SELECT_TOTAL;
	if (validRange) {
		start = generateConfig$1.getYear(validRange[0]);
		end = generateConfig$1.getYear(validRange[1]) + 1;
	}
	const suffix = locale$5 && locale$5.year === "" ? "" : "";
	const options = [];
	for (let index$2 = start; index$2 < end; index$2++) options.push({
		label: `${index$2}${suffix}`,
		value: index$2
	});
	return /* @__PURE__ */ import_react.createElement(select_default, {
		size: fullscreen ? void 0 : "small",
		options,
		value: year,
		className: `${prefixCls}-year-select`,
		onChange: (numYear) => {
			let newDate = generateConfig$1.setYear(value, numYear);
			if (validRange) {
				const [startDate, endDate] = validRange;
				const newYear = generateConfig$1.getYear(newDate);
				const newMonth = generateConfig$1.getMonth(newDate);
				if (newYear === generateConfig$1.getYear(endDate) && newMonth > generateConfig$1.getMonth(endDate)) newDate = generateConfig$1.setMonth(newDate, generateConfig$1.getMonth(endDate));
				if (newYear === generateConfig$1.getYear(startDate) && newMonth < generateConfig$1.getMonth(startDate)) newDate = generateConfig$1.setMonth(newDate, generateConfig$1.getMonth(startDate));
			}
			onChange(newDate);
		},
		getPopupContainer: () => divRef.current
	});
}
function MonthSelect(props) {
	const { prefixCls, fullscreen, validRange, value, generateConfig: generateConfig$1, locale: locale$5, onChange, divRef } = props;
	const month = generateConfig$1.getMonth(value || generateConfig$1.getNow());
	let start = 0;
	let end = 11;
	if (validRange) {
		const [rangeStart, rangeEnd] = validRange;
		const currentYear = generateConfig$1.getYear(value);
		if (generateConfig$1.getYear(rangeEnd) === currentYear) end = generateConfig$1.getMonth(rangeEnd);
		if (generateConfig$1.getYear(rangeStart) === currentYear) start = generateConfig$1.getMonth(rangeStart);
	}
	const months = locale$5.shortMonths || generateConfig$1.locale.getShortMonths(locale$5.locale);
	const options = [];
	for (let index$2 = start; index$2 <= end; index$2 += 1) options.push({
		label: months[index$2],
		value: index$2
	});
	return /* @__PURE__ */ import_react.createElement(select_default, {
		size: fullscreen ? void 0 : "small",
		className: `${prefixCls}-month-select`,
		value: month,
		options,
		onChange: (newMonth) => {
			onChange(generateConfig$1.setMonth(value, newMonth));
		},
		getPopupContainer: () => divRef.current
	});
}
function ModeSwitch(props) {
	const { prefixCls, locale: locale$5, mode, fullscreen, onModeChange } = props;
	return /* @__PURE__ */ import_react.createElement(group_default, {
		onChange: ({ target: { value } }) => {
			onModeChange(value);
		},
		value: mode,
		size: fullscreen ? void 0 : "small",
		className: `${prefixCls}-mode-switch`
	}, /* @__PURE__ */ import_react.createElement(radioButton_default, { value: "month" }, locale$5.month), /* @__PURE__ */ import_react.createElement(radioButton_default, { value: "year" }, locale$5.year));
}
function CalendarHeader(props) {
	const { prefixCls, fullscreen, mode, onChange, onModeChange } = props;
	const divRef = import_react.useRef(null);
	const formItemInputContext = (0, import_react.useContext)(FormItemInputContext);
	const mergedFormItemInputContext = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, formItemInputContext), { isFormItemInput: false }), [formItemInputContext]);
	const sharedProps = Object.assign(Object.assign({}, props), {
		fullscreen,
		divRef
	});
	return /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-header`,
		ref: divRef
	}, /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: mergedFormItemInputContext }, /* @__PURE__ */ import_react.createElement(YearSelect, Object.assign({}, sharedProps, { onChange: (v) => {
		onChange(v, "year");
	} })), mode === "month" && /* @__PURE__ */ import_react.createElement(MonthSelect, Object.assign({}, sharedProps, { onChange: (v) => {
		onChange(v, "month");
	} }))), /* @__PURE__ */ import_react.createElement(ModeSwitch, Object.assign({}, sharedProps, { onModeChange })));
}
var Header_default$1 = CalendarHeader;

//#endregion
//#region node_modules/antd/es/input/style/token.js
function initInputToken(token$1) {
	return merge(token$1, { inputAffixPadding: token$1.paddingXXS });
}
const initComponentToken$1 = (token$1) => {
	const { controlHeight, fontSize, lineHeight, lineWidth, controlHeightSM, controlHeightLG, fontSizeLG, lineHeightLG, paddingSM, controlPaddingHorizontalSM, controlPaddingHorizontal, colorFillAlter, colorPrimaryHover, colorPrimary, controlOutlineWidth, controlOutline, colorErrorOutline, colorWarningOutline, colorBgContainer, inputFontSize, inputFontSizeLG, inputFontSizeSM } = token$1;
	const mergedFontSize = inputFontSize || fontSize;
	const mergedFontSizeSM = inputFontSizeSM || mergedFontSize;
	const mergedFontSizeLG = inputFontSizeLG || fontSizeLG;
	const paddingBlock = Math.round((controlHeight - mergedFontSize * lineHeight) / 2 * 10) / 10 - lineWidth;
	const paddingBlockSM = Math.round((controlHeightSM - mergedFontSizeSM * lineHeight) / 2 * 10) / 10 - lineWidth;
	const paddingBlockLG = Math.ceil((controlHeightLG - mergedFontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth;
	return {
		paddingBlock: Math.max(paddingBlock, 0),
		paddingBlockSM: Math.max(paddingBlockSM, 0),
		paddingBlockLG: Math.max(paddingBlockLG, 0),
		paddingInline: paddingSM - lineWidth,
		paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
		paddingInlineLG: controlPaddingHorizontal - lineWidth,
		addonBg: colorFillAlter,
		activeBorderColor: colorPrimary,
		hoverBorderColor: colorPrimaryHover,
		activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
		errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
		warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
		hoverBg: colorBgContainer,
		activeBg: colorBgContainer,
		inputFontSize: mergedFontSize,
		inputFontSizeLG: mergedFontSizeLG,
		inputFontSizeSM: mergedFontSizeSM
	};
};

//#endregion
//#region node_modules/antd/es/input/style/variants.js
const genHoverStyle = (token$1) => ({
	borderColor: token$1.hoverBorderColor,
	backgroundColor: token$1.hoverBg
});
const genDisabledStyle = (token$1) => ({
	color: token$1.colorTextDisabled,
	backgroundColor: token$1.colorBgContainerDisabled,
	borderColor: token$1.colorBorder,
	boxShadow: "none",
	cursor: "not-allowed",
	opacity: 1,
	"input[disabled], textarea[disabled]": { cursor: "not-allowed" },
	"&:hover:not([disabled])": Object.assign({}, genHoverStyle(merge(token$1, {
		hoverBorderColor: token$1.colorBorder,
		hoverBg: token$1.colorBgContainerDisabled
	})))
});
const genBaseOutlinedStyle = (token$1, options) => ({
	background: token$1.colorBgContainer,
	borderWidth: token$1.lineWidth,
	borderStyle: token$1.lineType,
	borderColor: options.borderColor,
	"&:hover": {
		borderColor: options.hoverBorderColor,
		backgroundColor: token$1.hoverBg
	},
	"&:focus, &:focus-within": {
		borderColor: options.activeBorderColor,
		boxShadow: options.activeShadow,
		outline: 0,
		backgroundColor: token$1.activeBg
	}
});
var genOutlinedStatusStyle = (token$1, options) => ({
	[`&${token$1.componentCls}-status-${options.status}:not(${token$1.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseOutlinedStyle(token$1, options)), { [`${token$1.componentCls}-prefix, ${token$1.componentCls}-suffix`]: { color: options.affixColor } }),
	[`&${token$1.componentCls}-status-${options.status}${token$1.componentCls}-disabled`]: { borderColor: options.borderColor }
});
const genOutlinedStyle = (token$1, extraStyles) => ({ "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle(token$1, {
	borderColor: token$1.colorBorder,
	hoverBorderColor: token$1.hoverBorderColor,
	activeBorderColor: token$1.activeBorderColor,
	activeShadow: token$1.activeShadow
})), { [`&${token$1.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token$1)) }), genOutlinedStatusStyle(token$1, {
	status: "error",
	borderColor: token$1.colorError,
	hoverBorderColor: token$1.colorErrorBorderHover,
	activeBorderColor: token$1.colorError,
	activeShadow: token$1.errorActiveShadow,
	affixColor: token$1.colorError
})), genOutlinedStatusStyle(token$1, {
	status: "warning",
	borderColor: token$1.colorWarning,
	hoverBorderColor: token$1.colorWarningBorderHover,
	activeBorderColor: token$1.colorWarning,
	activeShadow: token$1.warningActiveShadow,
	affixColor: token$1.colorWarning
})), extraStyles) });
var genOutlinedGroupStatusStyle = (token$1, options) => ({ [`&${token$1.componentCls}-group-wrapper-status-${options.status}`]: { [`${token$1.componentCls}-group-addon`]: {
	borderColor: options.addonBorderColor,
	color: options.addonColor
} } });
const genOutlinedGroupStyle = (token$1) => ({ "&-outlined": Object.assign(Object.assign(Object.assign({ [`${token$1.componentCls}-group`]: {
	"&-addon": {
		background: token$1.addonBg,
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
	},
	"&-addon:first-child": { borderInlineEnd: 0 },
	"&-addon:last-child": { borderInlineStart: 0 }
} }, genOutlinedGroupStatusStyle(token$1, {
	status: "error",
	addonBorderColor: token$1.colorError,
	addonColor: token$1.colorErrorText
})), genOutlinedGroupStatusStyle(token$1, {
	status: "warning",
	addonBorderColor: token$1.colorWarning,
	addonColor: token$1.colorWarningText
})), { [`&${token$1.componentCls}-group-wrapper-disabled`]: { [`${token$1.componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token$1)) } }) });
const genBorderlessStyle = (token$1, extraStyles) => {
	const { componentCls } = token$1;
	return { "&-borderless": Object.assign({
		background: "transparent",
		border: "none",
		"&:focus, &:focus-within": { outline: "none" },
		[`&${componentCls}-disabled, &[disabled]`]: {
			color: token$1.colorTextDisabled,
			cursor: "not-allowed"
		},
		[`&${componentCls}-status-error`]: { "&, & input, & textarea": { color: token$1.colorError } },
		[`&${componentCls}-status-warning`]: { "&, & input, & textarea": { color: token$1.colorWarning } }
	}, extraStyles) };
};
var genBaseFilledStyle = (token$1, options) => {
	var _a;
	return {
		background: options.bg,
		borderWidth: token$1.lineWidth,
		borderStyle: token$1.lineType,
		borderColor: "transparent",
		"input&, & input, textarea&, & textarea": { color: (_a = options === null || options === void 0 ? void 0 : options.inputColor) !== null && _a !== void 0 ? _a : "unset" },
		"&:hover": { background: options.hoverBg },
		"&:focus, &:focus-within": {
			outline: 0,
			borderColor: options.activeBorderColor,
			backgroundColor: token$1.activeBg
		}
	};
};
var genFilledStatusStyle = (token$1, options) => ({ [`&${token$1.componentCls}-status-${options.status}:not(${token$1.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseFilledStyle(token$1, options)), { [`${token$1.componentCls}-prefix, ${token$1.componentCls}-suffix`]: { color: options.affixColor } }) });
const genFilledStyle = (token$1, extraStyles) => ({ "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle(token$1, {
	bg: token$1.colorFillTertiary,
	hoverBg: token$1.colorFillSecondary,
	activeBorderColor: token$1.activeBorderColor
})), { [`&${token$1.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token$1)) }), genFilledStatusStyle(token$1, {
	status: "error",
	bg: token$1.colorErrorBg,
	hoverBg: token$1.colorErrorBgHover,
	activeBorderColor: token$1.colorError,
	inputColor: token$1.colorErrorText,
	affixColor: token$1.colorError
})), genFilledStatusStyle(token$1, {
	status: "warning",
	bg: token$1.colorWarningBg,
	hoverBg: token$1.colorWarningBgHover,
	activeBorderColor: token$1.colorWarning,
	inputColor: token$1.colorWarningText,
	affixColor: token$1.colorWarning
})), extraStyles) });
var genFilledGroupStatusStyle = (token$1, options) => ({ [`&${token$1.componentCls}-group-wrapper-status-${options.status}`]: { [`${token$1.componentCls}-group-addon`]: {
	background: options.addonBg,
	color: options.addonColor
} } });
const genFilledGroupStyle = (token$1) => ({ "&-filled": Object.assign(Object.assign(Object.assign({ [`${token$1.componentCls}-group-addon`]: {
	background: token$1.colorFillTertiary,
	"&:last-child": { position: "static" }
} }, genFilledGroupStatusStyle(token$1, {
	status: "error",
	addonBg: token$1.colorErrorBg,
	addonColor: token$1.colorErrorText
})), genFilledGroupStatusStyle(token$1, {
	status: "warning",
	addonBg: token$1.colorWarningBg,
	addonColor: token$1.colorWarningText
})), { [`&${token$1.componentCls}-group-wrapper-disabled`]: { [`${token$1.componentCls}-group`]: {
	"&-addon": {
		background: token$1.colorFillTertiary,
		color: token$1.colorTextDisabled
	},
	"&-addon:first-child": {
		borderInlineStart: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
		borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
		borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
	},
	"&-addon:last-child": {
		borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
		borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
		borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
	}
} } }) });
const genBaseUnderlinedStyle = (token$1, options) => ({
	background: token$1.colorBgContainer,
	borderWidth: `${unit(token$1.lineWidth)} 0`,
	borderStyle: `${token$1.lineType} none`,
	borderColor: `transparent transparent ${options.borderColor} transparent`,
	borderRadius: 0,
	"&:hover": {
		borderColor: `transparent transparent ${options.borderColor} transparent`,
		backgroundColor: token$1.hoverBg
	},
	"&:focus, &:focus-within": {
		borderColor: `transparent transparent ${options.activeBorderColor} transparent`,
		outline: 0,
		backgroundColor: token$1.activeBg
	}
});
var genUnderlinedStatusStyle = (token$1, options) => ({
	[`&${token$1.componentCls}-status-${options.status}:not(${token$1.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseUnderlinedStyle(token$1, options)), { [`${token$1.componentCls}-prefix, ${token$1.componentCls}-suffix`]: { color: options.affixColor } }),
	[`&${token$1.componentCls}-status-${options.status}${token$1.componentCls}-disabled`]: { borderColor: `transparent transparent ${options.borderColor} transparent` }
});
const genUnderlinedStyle = (token$1, extraStyles) => ({ "&-underlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseUnderlinedStyle(token$1, {
	borderColor: token$1.colorBorder,
	hoverBorderColor: token$1.hoverBorderColor,
	activeBorderColor: token$1.activeBorderColor,
	activeShadow: token$1.activeShadow
})), {
	[`&${token$1.componentCls}-disabled, &[disabled]`]: {
		color: token$1.colorTextDisabled,
		boxShadow: "none",
		cursor: "not-allowed",
		"&:hover": { borderColor: `transparent transparent ${token$1.colorBorder} transparent` }
	},
	"input[disabled], textarea[disabled]": { cursor: "not-allowed" }
}), genUnderlinedStatusStyle(token$1, {
	status: "error",
	borderColor: token$1.colorError,
	hoverBorderColor: token$1.colorErrorBorderHover,
	activeBorderColor: token$1.colorError,
	activeShadow: token$1.errorActiveShadow,
	affixColor: token$1.colorError
})), genUnderlinedStatusStyle(token$1, {
	status: "warning",
	borderColor: token$1.colorWarning,
	hoverBorderColor: token$1.colorWarningBorderHover,
	activeBorderColor: token$1.colorWarning,
	activeShadow: token$1.warningActiveShadow,
	affixColor: token$1.colorWarning
})), extraStyles) });

//#endregion
//#region node_modules/antd/es/input/style/index.js
const genPlaceholderStyle = (color) => ({
	"&::-moz-placeholder": { opacity: 1 },
	"&::placeholder": {
		color,
		userSelect: "none"
	},
	"&:placeholder-shown": { textOverflow: "ellipsis" }
});
var genInputLargeStyle = (token$1) => {
	const { paddingBlockLG, lineHeightLG, borderRadiusLG, paddingInlineLG } = token$1;
	return {
		padding: `${unit(paddingBlockLG)} ${unit(paddingInlineLG)}`,
		fontSize: token$1.inputFontSizeLG,
		lineHeight: lineHeightLG,
		borderRadius: borderRadiusLG
	};
};
const genInputSmallStyle = (token$1) => ({
	padding: `${unit(token$1.paddingBlockSM)} ${unit(token$1.paddingInlineSM)}`,
	fontSize: token$1.inputFontSizeSM,
	borderRadius: token$1.borderRadiusSM
});
const genBasicInputStyle = (token$1) => Object.assign(Object.assign({
	position: "relative",
	display: "inline-block",
	width: "100%",
	minWidth: 0,
	padding: `${unit(token$1.paddingBlock)} ${unit(token$1.paddingInline)}`,
	color: token$1.colorText,
	fontSize: token$1.inputFontSize,
	lineHeight: token$1.lineHeight,
	borderRadius: token$1.borderRadius,
	transition: `all ${token$1.motionDurationMid}`
}, genPlaceholderStyle(token$1.colorTextPlaceholder)), {
	"&-lg": Object.assign({}, genInputLargeStyle(token$1)),
	"&-sm": Object.assign({}, genInputSmallStyle(token$1)),
	"&-rtl, &-textarea-rtl": { direction: "rtl" }
});
const genInputGroupStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	return {
		position: "relative",
		display: "table",
		width: "100%",
		borderCollapse: "separate",
		borderSpacing: 0,
		"&[class*='col-']": {
			paddingInlineEnd: token$1.paddingXS,
			"&:last-child": { paddingInlineEnd: 0 }
		},
		[`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token$1)),
		[`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token$1)),
		[`&-lg ${antCls}-select-single ${antCls}-select-selector`]: { height: token$1.controlHeightLG },
		[`&-sm ${antCls}-select-single ${antCls}-select-selector`]: { height: token$1.controlHeightSM },
		[`> ${componentCls}`]: {
			display: "table-cell",
			"&:not(:first-child):not(:last-child)": { borderRadius: 0 }
		},
		[`${componentCls}-group`]: {
			"&-addon, &-wrap": {
				display: "table-cell",
				width: 1,
				whiteSpace: "nowrap",
				verticalAlign: "middle",
				"&:not(:first-child):not(:last-child)": { borderRadius: 0 }
			},
			"&-wrap > *": { display: "block !important" },
			"&-addon": {
				position: "relative",
				padding: `0 ${unit(token$1.paddingInline)}`,
				color: token$1.colorText,
				fontWeight: "normal",
				fontSize: token$1.inputFontSize,
				textAlign: "center",
				borderRadius: token$1.borderRadius,
				transition: `all ${token$1.motionDurationSlow}`,
				lineHeight: 1,
				[`${antCls}-select`]: {
					margin: `${unit(token$1.calc(token$1.paddingBlock).add(1).mul(-1).equal())} ${unit(token$1.calc(token$1.paddingInline).mul(-1).equal())}`,
					[`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: { [`${antCls}-select-selector`]: {
						backgroundColor: "inherit",
						border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
						boxShadow: "none"
					} }
				},
				[`${antCls}-cascader-picker`]: {
					margin: `-9px ${unit(token$1.calc(token$1.paddingInline).mul(-1).equal())}`,
					backgroundColor: "transparent",
					[`${antCls}-cascader-input`]: {
						textAlign: "start",
						border: 0,
						boxShadow: "none"
					}
				}
			}
		},
		[componentCls]: {
			width: "100%",
			marginBottom: 0,
			textAlign: "inherit",
			"&:focus": {
				zIndex: 1,
				borderInlineEndWidth: 1
			},
			"&:hover": {
				zIndex: 1,
				borderInlineEndWidth: 1,
				[`${componentCls}-search-with-button &`]: { zIndex: 0 }
			}
		},
		[`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
			borderStartEndRadius: 0,
			borderEndEndRadius: 0,
			[`${antCls}-select ${antCls}-select-selector`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			}
		},
		[`> ${componentCls}-affix-wrapper`]: {
			[`&:not(:first-child) ${componentCls}`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			},
			[`&:not(:last-child) ${componentCls}`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			}
		},
		[`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0,
			[`${antCls}-select ${antCls}-select-selector`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			}
		},
		[`${componentCls}-affix-wrapper`]: {
			"&:not(:last-child)": {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0,
				[`${componentCls}-search &`]: {
					borderStartStartRadius: token$1.borderRadius,
					borderEndStartRadius: token$1.borderRadius
				}
			},
			[`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			}
		},
		[`&${componentCls}-group-compact`]: Object.assign(Object.assign({ display: "block" }, clearFix()), {
			[`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: { "&:not(:first-child):not(:last-child)": {
				borderInlineEndWidth: token$1.lineWidth,
				"&:hover, &:focus": { zIndex: 1 }
			} },
			"& > *": {
				display: "inline-flex",
				float: "none",
				verticalAlign: "top",
				borderRadius: 0
			},
			[`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: { display: "inline-flex" },
			"& > *:not(:last-child)": {
				marginInlineEnd: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				borderInlineEndWidth: token$1.lineWidth
			},
			[componentCls]: { float: "none" },
			[`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
				borderInlineEndWidth: token$1.lineWidth,
				borderRadius: 0,
				"&:hover, &:focus": { zIndex: 1 }
			},
			[`& > ${antCls}-select-focused`]: { zIndex: 1 },
			[`& > ${antCls}-select > ${antCls}-select-arrow`]: { zIndex: 1 },
			[`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
				borderStartStartRadius: token$1.borderRadius,
				borderEndStartRadius: token$1.borderRadius
			},
			[`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
				borderInlineEndWidth: token$1.lineWidth,
				borderStartEndRadius: token$1.borderRadius,
				borderEndEndRadius: token$1.borderRadius
			},
			[`& > ${antCls}-select-auto-complete ${componentCls}`]: { verticalAlign: "top" },
			[`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
				marginInlineStart: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				[`${componentCls}-affix-wrapper`]: { borderRadius: 0 }
			},
			[`${componentCls}-group-wrapper:not(:last-child)`]: { [`&${componentCls}-search > ${componentCls}-group`]: {
				[`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: { borderRadius: 0 },
				[`& > ${componentCls}`]: {
					borderStartStartRadius: token$1.borderRadius,
					borderStartEndRadius: 0,
					borderEndEndRadius: 0,
					borderEndStartRadius: token$1.borderRadius
				}
			} }
		})
	};
};
const genInputStyle$1 = (token$1) => {
	const { componentCls, controlHeightSM, lineWidth, calc } = token$1;
	const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(16).div(2).equal();
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), genBasicInputStyle(token$1)), genOutlinedStyle(token$1)), genFilledStyle(token$1)), genBorderlessStyle(token$1)), genUnderlinedStyle(token$1)), {
		"&[type=\"color\"]": {
			height: token$1.controlHeight,
			[`&${componentCls}-lg`]: { height: token$1.controlHeightLG },
			[`&${componentCls}-sm`]: {
				height: controlHeightSM,
				paddingTop: colorSmallPadding,
				paddingBottom: colorSmallPadding
			}
		},
		"&[type=\"search\"]::-webkit-search-cancel-button, &[type=\"search\"]::-webkit-search-decoration": { appearance: "none" }
	}) };
};
var genAllowClearStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-clear-icon`]: {
		margin: 0,
		padding: 0,
		lineHeight: 0,
		color: token$1.colorTextQuaternary,
		fontSize: token$1.fontSizeIcon,
		verticalAlign: -1,
		cursor: "pointer",
		transition: `color ${token$1.motionDurationSlow}`,
		border: "none",
		outline: "none",
		backgroundColor: "transparent",
		"&:hover": { color: token$1.colorIcon },
		"&:active": { color: token$1.colorText },
		"&-hidden": { visibility: "hidden" },
		"&-has-suffix": { margin: `0 ${unit(token$1.inputAffixPadding)}` }
	} };
};
const genAffixStyle = (token$1) => {
	const { componentCls, inputAffixPadding, colorTextDescription, motionDurationSlow, colorIcon, colorIconHover, iconCls } = token$1;
	const affixCls = `${componentCls}-affix-wrapper`;
	const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
	return {
		[affixCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token$1)), {
			display: "inline-flex",
			[`&:not(${componentCls}-disabled):hover`]: {
				zIndex: 1,
				[`${componentCls}-search-with-button &`]: { zIndex: 0 }
			},
			"&-focused, &:focus": { zIndex: 1 },
			[`> input${componentCls}`]: { padding: 0 },
			[`> input${componentCls}, > textarea${componentCls}`]: {
				fontSize: "inherit",
				border: "none",
				borderRadius: 0,
				outline: "none",
				background: "transparent",
				color: "inherit",
				"&::-ms-reveal": { display: "none" },
				"&:focus": { boxShadow: "none !important" }
			},
			"&::before": {
				display: "inline-block",
				width: 0,
				visibility: "hidden",
				content: "\"\\a0\""
			},
			[componentCls]: {
				"&-prefix, &-suffix": {
					display: "flex",
					flex: "none",
					alignItems: "center",
					"> *:not(:last-child)": { marginInlineEnd: token$1.paddingXS }
				},
				"&-show-count-suffix": {
					color: colorTextDescription,
					direction: "ltr"
				},
				"&-show-count-has-suffix": { marginInlineEnd: token$1.paddingXXS },
				"&-prefix": { marginInlineEnd: inputAffixPadding },
				"&-suffix": { marginInlineStart: inputAffixPadding }
			}
		}), genAllowClearStyle(token$1)), { [`${iconCls}${componentCls}-password-icon`]: {
			color: colorIcon,
			cursor: "pointer",
			transition: `all ${motionDurationSlow}`,
			"&:hover": { color: colorIconHover }
		} }),
		[`${componentCls}-underlined`]: { borderRadius: 0 },
		[affixClsDisabled]: { [`${iconCls}${componentCls}-password-icon`]: {
			color: colorIcon,
			cursor: "not-allowed",
			"&:hover": { color: colorIcon }
		} }
	};
};
var genGroupStyle = (token$1) => {
	const { componentCls, borderRadiusLG, borderRadiusSM } = token$1;
	return { [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), genInputGroupStyle(token$1)), {
		"&-rtl": { direction: "rtl" },
		"&-wrapper": Object.assign(Object.assign(Object.assign({
			display: "inline-block",
			width: "100%",
			textAlign: "start",
			verticalAlign: "top",
			"&-rtl": { direction: "rtl" },
			"&-lg": { [`${componentCls}-group-addon`]: {
				borderRadius: borderRadiusLG,
				fontSize: token$1.inputFontSizeLG
			} },
			"&-sm": { [`${componentCls}-group-addon`]: { borderRadius: borderRadiusSM } }
		}, genOutlinedGroupStyle(token$1)), genFilledGroupStyle(token$1)), {
			[`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: { borderRadius: 0 } },
			[`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			} },
			[`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			} },
			[`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: { [`${componentCls}-affix-wrapper`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			} },
			[`&:not(${componentCls}-compact-first-item)${componentCls}-compact-item`]: { [`${componentCls}-affix-wrapper`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			} }
		})
	}) };
};
var genSearchInputStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	const searchPrefixCls = `${componentCls}-search`;
	return { [searchPrefixCls]: {
		[componentCls]: { "&:not([disabled]):hover, &:not([disabled]):focus": { [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-color-primary):not(${antCls}-btn-variant-text)`]: { borderInlineStartColor: token$1.colorPrimaryHover } } },
		[`${componentCls}-affix-wrapper`]: {
			height: token$1.controlHeight,
			borderRadius: 0
		},
		[`${componentCls}-lg`]: { lineHeight: token$1.calc(token$1.lineHeightLG).sub(2e-4).equal() },
		[`> ${componentCls}-group`]: { [`> ${componentCls}-group-addon:last-child`]: {
			insetInlineStart: -1,
			padding: 0,
			border: 0,
			[`${searchPrefixCls}-button`]: {
				marginInlineEnd: -1,
				borderStartStartRadius: 0,
				borderEndStartRadius: 0,
				boxShadow: "none"
			},
			[`${searchPrefixCls}-button:not(${antCls}-btn-color-primary)`]: {
				color: token$1.colorTextDescription,
				"&:not([disabled]):hover": { color: token$1.colorPrimaryHover },
				"&:active": { color: token$1.colorPrimaryActive },
				[`&${antCls}-btn-loading::before`]: { inset: 0 }
			}
		} },
		[`${searchPrefixCls}-button`]: {
			height: token$1.controlHeight,
			"&:hover, &:focus": { zIndex: 1 }
		},
		"&-large": { [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: { height: token$1.controlHeightLG } },
		"&-small": { [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: { height: token$1.controlHeightSM } },
		"&-rtl": { direction: "rtl" },
		[`&${componentCls}-compact-item`]: {
			[`&:not(${componentCls}-compact-last-item)`]: { [`${componentCls}-group-addon`]: { [`${componentCls}-search-button`]: {
				marginInlineEnd: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				borderRadius: 0
			} } },
			[`&:not(${componentCls}-compact-first-item)`]: { [`${componentCls},${componentCls}-affix-wrapper`]: { borderRadius: 0 } },
			[`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: { "&:hover, &:focus, &:active": { zIndex: 2 } },
			[`> ${componentCls}-affix-wrapper-focused`]: { zIndex: 2 }
		}
	} };
};
var genRangeStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-out-of-range`]: { [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: { color: token$1.colorError } } };
};
const useSharedStyle = genStyleHooks(["Input", "Shared"], (token$1) => {
	const inputToken = merge(token$1, initInputToken(token$1));
	return [genInputStyle$1(inputToken), genAffixStyle(inputToken)];
}, initComponentToken$1, { resetFont: false });
var style_default$24 = genStyleHooks(["Input", "Component"], (token$1) => {
	const inputToken = merge(token$1, initInputToken(token$1));
	return [
		genGroupStyle(inputToken),
		genSearchInputStyle(inputToken),
		genRangeStyle(inputToken),
		genCompactItemStyle(inputToken)
	];
}, initComponentToken$1, { resetFont: false });

//#endregion
//#region node_modules/antd/es/date-picker/style/multiple.js
var genSize = (token$1, suffix) => {
	const { componentCls, controlHeight } = token$1;
	const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
	const multipleSelectorUnit = getMultipleSelectorUnit(token$1);
	return [{ [`${componentCls}-multiple${suffixCls}`]: {
		paddingBlock: multipleSelectorUnit.containerPadding,
		paddingInlineStart: multipleSelectorUnit.basePadding,
		minHeight: controlHeight,
		[`${componentCls}-selection-item`]: {
			height: multipleSelectorUnit.itemHeight,
			lineHeight: unit(multipleSelectorUnit.itemLineHeight)
		}
	} }];
};
var genPickerMultipleStyle = (token$1) => {
	const { componentCls, calc, lineWidth } = token$1;
	const smallToken = merge(token$1, {
		fontHeight: token$1.fontSize,
		selectHeight: token$1.controlHeightSM,
		multipleSelectItemHeight: token$1.multipleItemHeightSM,
		borderRadius: token$1.borderRadiusSM,
		borderRadiusSM: token$1.borderRadiusXS,
		controlHeight: token$1.controlHeightSM
	});
	const largeToken = merge(token$1, {
		fontHeight: calc(token$1.multipleItemHeightLG).sub(calc(lineWidth).mul(2).equal()).equal(),
		fontSize: token$1.fontSizeLG,
		selectHeight: token$1.controlHeightLG,
		multipleSelectItemHeight: token$1.multipleItemHeightLG,
		borderRadius: token$1.borderRadiusLG,
		borderRadiusSM: token$1.borderRadius,
		controlHeight: token$1.controlHeightLG
	});
	return [
		genSize(smallToken, "small"),
		genSize(token$1),
		genSize(largeToken, "large"),
		{ [`${componentCls}${componentCls}-multiple`]: Object.assign(Object.assign({
			width: "100%",
			cursor: "text",
			[`${componentCls}-selector`]: {
				flex: "auto",
				padding: 0,
				position: "relative",
				"&:after": { margin: 0 },
				[`${componentCls}-selection-placeholder`]: {
					position: "absolute",
					top: "50%",
					insetInlineStart: token$1.inputPaddingHorizontalBase,
					insetInlineEnd: 0,
					transform: "translateY(-50%)",
					transition: `all ${token$1.motionDurationSlow}`,
					overflow: "hidden",
					whiteSpace: "nowrap",
					textOverflow: "ellipsis",
					flex: 1,
					color: token$1.colorTextPlaceholder,
					pointerEvents: "none"
				}
			}
		}, genOverflowStyle(token$1)), { [`${componentCls}-multiple-input`]: {
			width: 0,
			height: 0,
			border: 0,
			visibility: "hidden",
			position: "absolute",
			zIndex: -1
		} }) }
	];
};
var multiple_default = genPickerMultipleStyle;

//#endregion
//#region node_modules/antd/es/date-picker/style/panel.js
var genPickerCellInnerStyle = (token$1) => {
	const { pickerCellCls, pickerCellInnerCls, cellHeight, borderRadiusSM, motionDurationMid, cellHoverBg, lineWidth, lineType, colorPrimary, cellActiveWithRangeBg, colorTextLightSolid, colorTextDisabled, cellBgDisabled, colorFillSecondary } = token$1;
	return {
		"&::before": {
			position: "absolute",
			top: "50%",
			insetInlineStart: 0,
			insetInlineEnd: 0,
			zIndex: 1,
			height: cellHeight,
			transform: "translateY(-50%)",
			content: "\"\"",
			pointerEvents: "none"
		},
		[pickerCellInnerCls]: {
			position: "relative",
			zIndex: 2,
			display: "inline-block",
			minWidth: cellHeight,
			height: cellHeight,
			lineHeight: unit(cellHeight),
			borderRadius: borderRadiusSM,
			transition: `background ${motionDurationMid}`
		},
		[`&:hover:not(${pickerCellCls}-in-view):not(${pickerCellCls}-disabled),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-disabled)`]: { [pickerCellInnerCls]: { background: cellHoverBg } },
		[`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: { "&::before": {
			position: "absolute",
			top: 0,
			insetInlineEnd: 0,
			bottom: 0,
			insetInlineStart: 0,
			zIndex: 1,
			border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
			borderRadius: borderRadiusSM,
			content: "\"\""
		} },
		[`&-in-view${pickerCellCls}-in-range,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
			position: "relative",
			[`&:not(${pickerCellCls}-disabled):before`]: { background: cellActiveWithRangeBg }
		},
		[`&-in-view${pickerCellCls}-selected,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
			[`&:not(${pickerCellCls}-disabled) ${pickerCellInnerCls}`]: {
				color: colorTextLightSolid,
				background: colorPrimary
			},
			[`&${pickerCellCls}-disabled ${pickerCellInnerCls}`]: { background: colorFillSecondary }
		},
		[`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-disabled):before`]: { insetInlineStart: "50%" },
		[`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-disabled):before`]: { insetInlineEnd: "50%" },
		[`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
			borderStartStartRadius: borderRadiusSM,
			borderEndStartRadius: borderRadiusSM,
			borderStartEndRadius: 0,
			borderEndEndRadius: 0
		},
		[`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
			borderStartStartRadius: 0,
			borderEndStartRadius: 0,
			borderStartEndRadius: borderRadiusSM,
			borderEndEndRadius: borderRadiusSM
		},
		"&-disabled": {
			color: colorTextDisabled,
			cursor: "not-allowed",
			[pickerCellInnerCls]: { background: "transparent" },
			"&::before": { background: cellBgDisabled }
		},
		[`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: { borderColor: colorTextDisabled }
	};
};
const genPanelStyle$1 = (token$1) => {
	const { componentCls, pickerCellCls, pickerCellInnerCls, pickerYearMonthCellWidth, pickerControlIconSize, cellWidth, paddingSM, paddingXS, paddingXXS, colorBgContainer, lineWidth, lineType, borderRadiusLG, colorPrimary, colorTextHeading, colorSplit, pickerControlIconBorderWidth, colorIcon, textHeight, motionDurationMid, colorIconHover, fontWeightStrong, cellHeight, pickerCellPaddingVertical, colorTextDisabled, colorText, fontSize, motionDurationSlow, withoutTimeCellHeight, pickerQuarterPanelContentHeight, borderRadiusSM, colorTextLightSolid, cellHoverBg, timeColumnHeight, timeColumnWidth, timeCellHeight, controlItemBgActive, marginXXS, pickerDatePanelPaddingHorizontal, pickerControlIconMargin } = token$1;
	const pickerPanelWidth = token$1.calc(cellWidth).mul(7).add(token$1.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
	return { [componentCls]: {
		"&-panel": {
			display: "inline-flex",
			flexDirection: "column",
			textAlign: "center",
			background: colorBgContainer,
			borderRadius: borderRadiusLG,
			outline: "none",
			"&-focused": { borderColor: colorPrimary },
			"&-rtl": {
				[`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: { transform: "rotate(45deg)" },
				[`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: { transform: "rotate(-135deg)" },
				[`${componentCls}-time-panel`]: { [`${componentCls}-content`]: {
					direction: "ltr",
					"> *": { direction: "rtl" }
				} }
			}
		},
		[`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
			display: "flex",
			flexDirection: "column",
			width: pickerPanelWidth
		},
		"&-header": {
			display: "flex",
			padding: `0 ${unit(paddingXS)}`,
			color: colorTextHeading,
			borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			"> *": { flex: "none" },
			button: {
				padding: 0,
				color: colorIcon,
				lineHeight: unit(textHeight),
				background: "transparent",
				border: 0,
				cursor: "pointer",
				transition: `color ${motionDurationMid}`,
				fontSize: "inherit",
				display: "inline-flex",
				alignItems: "center",
				justifyContent: "center",
				"&:empty": { display: "none" }
			},
			"> button": {
				minWidth: "1.6em",
				fontSize,
				"&:hover": { color: colorIconHover },
				"&:disabled": {
					opacity: .25,
					pointerEvents: "none"
				}
			},
			"&-view": {
				flex: "auto",
				fontWeight: fontWeightStrong,
				lineHeight: unit(textHeight),
				"> button": {
					color: "inherit",
					fontWeight: "inherit",
					verticalAlign: "top",
					"&:not(:first-child)": { marginInlineStart: paddingXS },
					"&:hover": { color: colorPrimary }
				}
			}
		},
		[`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
			position: "relative",
			width: pickerControlIconSize,
			height: pickerControlIconSize,
			"&::before": {
				position: "absolute",
				top: 0,
				insetInlineStart: 0,
				width: pickerControlIconSize,
				height: pickerControlIconSize,
				border: `0 solid currentcolor`,
				borderBlockStartWidth: pickerControlIconBorderWidth,
				borderInlineStartWidth: pickerControlIconBorderWidth,
				content: "\"\""
			}
		},
		[`&-super-prev-icon,
        &-super-next-icon`]: { "&::after": {
			position: "absolute",
			top: pickerControlIconMargin,
			insetInlineStart: pickerControlIconMargin,
			display: "inline-block",
			width: pickerControlIconSize,
			height: pickerControlIconSize,
			border: "0 solid currentcolor",
			borderBlockStartWidth: pickerControlIconBorderWidth,
			borderInlineStartWidth: pickerControlIconBorderWidth,
			content: "\"\""
		} },
		"&-prev-icon, &-super-prev-icon": { transform: "rotate(-45deg)" },
		"&-next-icon, &-super-next-icon": { transform: "rotate(135deg)" },
		"&-content": {
			width: "100%",
			tableLayout: "fixed",
			borderCollapse: "collapse",
			"th, td": {
				position: "relative",
				minWidth: cellHeight,
				fontWeight: "normal"
			},
			th: {
				height: token$1.calc(cellHeight).add(token$1.calc(pickerCellPaddingVertical).mul(2)).equal(),
				color: colorText,
				verticalAlign: "middle"
			}
		},
		"&-cell": Object.assign({
			padding: `${unit(pickerCellPaddingVertical)} 0`,
			color: colorTextDisabled,
			cursor: "pointer",
			"&-in-view": { color: colorText }
		}, genPickerCellInnerStyle(token$1)),
		[`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
			[`${componentCls}-content`]: { height: token$1.calc(withoutTimeCellHeight).mul(4).equal() },
			[pickerCellInnerCls]: { padding: `0 ${unit(paddingXS)}` }
		},
		"&-quarter-panel": { [`${componentCls}-content`]: { height: pickerQuarterPanelContentHeight } },
		"&-decade-panel": {
			[pickerCellInnerCls]: { padding: `0 ${unit(token$1.calc(paddingXS).div(2).equal())}` },
			[`${componentCls}-cell::before`]: { display: "none" }
		},
		[`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
			[`${componentCls}-body`]: { padding: `0 ${unit(paddingXS)}` },
			[pickerCellInnerCls]: { width: pickerYearMonthCellWidth }
		},
		"&-date-panel": {
			[`${componentCls}-body`]: { padding: `${unit(paddingXS)} ${unit(pickerDatePanelPaddingHorizontal)}` },
			[`${componentCls}-content th`]: {
				boxSizing: "border-box",
				padding: 0
			}
		},
		"&-week-panel-row": {
			td: {
				"&:before": { transition: `background ${motionDurationMid}` },
				"&:first-child:before": {
					borderStartStartRadius: borderRadiusSM,
					borderEndStartRadius: borderRadiusSM
				},
				"&:last-child:before": {
					borderStartEndRadius: borderRadiusSM,
					borderEndEndRadius: borderRadiusSM
				}
			},
			"&:hover td:before": { background: cellHoverBg },
			"&-range-start td, &-range-end td, &-selected td, &-hover td": { [`&${pickerCellCls}`]: {
				"&:before": { background: colorPrimary },
				[`&${componentCls}-cell-week`]: { color: new FastColor(colorTextLightSolid).setA(.5).toHexString() },
				[pickerCellInnerCls]: { color: colorTextLightSolid }
			} },
			"&-range-hover td:before": { background: controlItemBgActive }
		},
		"&-week-panel, &-date-panel-show-week": {
			[`${componentCls}-body`]: { padding: `${unit(paddingXS)} ${unit(paddingSM)}` },
			[`${componentCls}-content th`]: { width: "auto" }
		},
		"&-datetime-panel": {
			display: "flex",
			[`${componentCls}-time-panel`]: { borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}` },
			[`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: { transition: `opacity ${motionDurationSlow}` },
			"&-active": { [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
				opacity: .3,
				"&-active": { opacity: 1 }
			} }
		},
		"&-time-panel": {
			width: "auto",
			minWidth: "auto",
			[`${componentCls}-content`]: {
				display: "flex",
				flex: "auto",
				height: timeColumnHeight
			},
			"&-column": {
				flex: "1 0 auto",
				width: timeColumnWidth,
				margin: `${unit(paddingXXS)} 0`,
				padding: 0,
				overflowY: "hidden",
				textAlign: "start",
				listStyle: "none",
				transition: `background ${motionDurationMid}`,
				overflowX: "hidden",
				"&::-webkit-scrollbar": {
					width: 8,
					backgroundColor: "transparent"
				},
				"&::-webkit-scrollbar-thumb": {
					backgroundColor: token$1.colorTextTertiary,
					borderRadius: token$1.borderRadiusSM
				},
				"&": {
					scrollbarWidth: "thin",
					scrollbarColor: `${token$1.colorTextTertiary} transparent`
				},
				"&::after": {
					display: "block",
					height: `calc(100% - ${unit(timeCellHeight)})`,
					content: "\"\""
				},
				"&:not(:first-child)": { borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}` },
				"&-active": { background: new FastColor(controlItemBgActive).setA(.2).toHexString() },
				"&:hover": { overflowY: "auto" },
				"> li": {
					margin: 0,
					padding: 0,
					[`&${componentCls}-time-panel-cell`]: {
						marginInline: marginXXS,
						[`${componentCls}-time-panel-cell-inner`]: {
							display: "block",
							width: token$1.calc(timeColumnWidth).sub(token$1.calc(marginXXS).mul(2)).equal(),
							height: timeCellHeight,
							margin: 0,
							paddingBlock: 0,
							paddingInlineEnd: 0,
							paddingInlineStart: token$1.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
							color: colorText,
							lineHeight: unit(timeCellHeight),
							borderRadius: borderRadiusSM,
							cursor: "pointer",
							transition: `background ${motionDurationMid}`,
							"&:hover": { background: cellHoverBg }
						},
						"&-selected": { [`${componentCls}-time-panel-cell-inner`]: { background: controlItemBgActive } },
						"&-disabled": { [`${componentCls}-time-panel-cell-inner`]: {
							color: colorTextDisabled,
							background: "transparent",
							cursor: "not-allowed"
						} }
					}
				}
			}
		}
	} };
};
var genPickerPanelStyle = (token$1) => {
	const { componentCls, textHeight, lineWidth, paddingSM, antCls, colorPrimary, cellActiveWithRangeBg, colorPrimaryBorder, lineType, colorSplit } = token$1;
	return { [`${componentCls}-dropdown`]: {
		[`${componentCls}-footer`]: {
			borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			"&-extra": {
				padding: `0 ${unit(paddingSM)}`,
				lineHeight: unit(token$1.calc(textHeight).sub(token$1.calc(lineWidth).mul(2)).equal()),
				textAlign: "start",
				"&:not(:last-child)": { borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}` }
			}
		},
		[`${componentCls}-panels + ${componentCls}-footer ${componentCls}-ranges`]: { justifyContent: "space-between" },
		[`${componentCls}-ranges`]: {
			marginBlock: 0,
			paddingInline: unit(paddingSM),
			overflow: "hidden",
			textAlign: "start",
			listStyle: "none",
			display: "flex",
			justifyContent: "center",
			alignItems: "center",
			"> li": {
				lineHeight: unit(token$1.calc(textHeight).sub(token$1.calc(lineWidth).mul(2)).equal()),
				display: "inline-block"
			},
			[`${componentCls}-now-btn-disabled`]: {
				pointerEvents: "none",
				color: token$1.colorTextDisabled
			},
			[`${componentCls}-preset > ${antCls}-tag-blue`]: {
				color: colorPrimary,
				background: cellActiveWithRangeBg,
				borderColor: colorPrimaryBorder,
				cursor: "pointer"
			},
			[`${componentCls}-ok`]: {
				paddingBlock: token$1.calc(lineWidth).mul(2).equal(),
				marginInlineStart: "auto"
			}
		}
	} };
};
var panel_default$1 = genPickerPanelStyle;

//#endregion
//#region node_modules/antd/es/date-picker/style/token.js
const initPickerPanelToken = (token$1) => {
	const { componentCls, controlHeightLG, paddingXXS, padding } = token$1;
	return {
		pickerCellCls: `${componentCls}-cell`,
		pickerCellInnerCls: `${componentCls}-cell-inner`,
		pickerYearMonthCellWidth: token$1.calc(controlHeightLG).mul(1.5).equal(),
		pickerQuarterPanelContentHeight: token$1.calc(controlHeightLG).mul(1.4).equal(),
		pickerCellPaddingVertical: token$1.calc(paddingXXS).add(token$1.calc(paddingXXS).div(2)).equal(),
		pickerCellBorderGap: 2,
		pickerControlIconSize: 7,
		pickerControlIconMargin: 4,
		pickerControlIconBorderWidth: 1.5,
		pickerDatePanelPaddingHorizontal: token$1.calc(padding).add(token$1.calc(paddingXXS).div(2)).equal()
	};
};
const initPanelComponentToken = (token$1) => {
	const { colorBgContainerDisabled, controlHeight, controlHeightSM, controlHeightLG, paddingXXS, lineWidth } = token$1;
	const dblPaddingXXS = paddingXXS * 2;
	const dblLineWidth = lineWidth * 2;
	const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
	const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
	const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
	return {
		INTERNAL_FIXED_ITEM_MARGIN: Math.floor(paddingXXS / 2),
		cellHoverBg: token$1.controlItemBgHover,
		cellActiveWithRangeBg: token$1.controlItemBgActive,
		cellHoverWithRangeBg: new FastColor(token$1.colorPrimary).lighten(35).toHexString(),
		cellRangeBorderColor: new FastColor(token$1.colorPrimary).lighten(20).toHexString(),
		cellBgDisabled: colorBgContainerDisabled,
		timeColumnWidth: controlHeightLG * 1.4,
		timeColumnHeight: 224,
		timeCellHeight: 28,
		cellWidth: controlHeightSM * 1.5,
		cellHeight: controlHeightSM,
		textHeight: controlHeightLG,
		withoutTimeCellHeight: controlHeightLG * 1.65,
		multipleItemBg: token$1.colorFillSecondary,
		multipleItemBorderColor: "transparent",
		multipleItemHeight,
		multipleItemHeightSM,
		multipleItemHeightLG,
		multipleSelectorBgDisabled: colorBgContainerDisabled,
		multipleItemColorDisabled: token$1.colorTextDisabled,
		multipleItemBorderColorDisabled: "transparent"
	};
};
const prepareComponentToken$36 = (token$1) => Object.assign(Object.assign(Object.assign(Object.assign({}, initComponentToken$1(token$1)), initPanelComponentToken(token$1)), getArrowToken(token$1)), {
	presetsWidth: 120,
	presetsMaxWidth: 200,
	zIndexPopup: token$1.zIndexPopupBase + 50
});

//#endregion
//#region node_modules/antd/es/date-picker/style/variants.js
var genVariantsStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: [Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedStyle(token$1)), genUnderlinedStyle(token$1)), genFilledStyle(token$1)), genBorderlessStyle(token$1)), {
		"&-outlined": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token$1.multipleItemBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
		} },
		"&-filled": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token$1.colorBgContainer,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`
		} },
		"&-borderless": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token$1.multipleItemBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
		} },
		"&-underlined": { [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
			background: token$1.multipleItemBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.multipleItemBorderColor}`
		} }
	}] };
};
var variants_default = genVariantsStyle;

//#endregion
//#region node_modules/antd/es/date-picker/style/index.js
var genPickerPadding = (paddingBlock, paddingInline) => {
	return { padding: `${unit(paddingBlock)} ${unit(paddingInline)}` };
};
var genPickerStatusStyle = (token$1) => {
	const { componentCls, colorError, colorWarning } = token$1;
	return { [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
		[`&${componentCls}-status-error`]: { [`${componentCls}-active-bar`]: { background: colorError } },
		[`&${componentCls}-status-warning`]: { [`${componentCls}-active-bar`]: { background: colorWarning } }
	} };
};
var genPickerStyle$1 = (token$1) => {
	var _a;
	const { componentCls, antCls, paddingInline, lineWidth, lineType, colorBorder, borderRadius, motionDurationMid, colorTextDisabled, colorTextPlaceholder, fontSizeLG, inputFontSizeLG, fontSizeSM, inputFontSizeSM, controlHeightSM, paddingInlineSM, paddingXS, marginXS, colorIcon, lineWidthBold, colorPrimary, motionDurationSlow, zIndexPopup, paddingXXS, sizePopupArrow, colorBgElevated, borderRadiusLG, boxShadowSecondary, borderRadiusSM, colorSplit, cellHoverBg, presetsWidth, presetsMaxWidth, boxShadowPopoverArrow, fontHeight, lineHeightLG } = token$1;
	return [
		{ [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), genPickerPadding(token$1.paddingBlock, token$1.paddingInline)), {
			position: "relative",
			display: "inline-flex",
			alignItems: "center",
			lineHeight: 1,
			borderRadius,
			transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}, background ${motionDurationMid}`,
			[`${componentCls}-prefix`]: {
				flex: "0 0 auto",
				marginInlineEnd: token$1.inputAffixPadding
			},
			[`${componentCls}-input`]: {
				position: "relative",
				display: "inline-flex",
				alignItems: "center",
				width: "100%",
				"> input": Object.assign(Object.assign({
					position: "relative",
					display: "inline-block",
					width: "100%",
					color: "inherit",
					fontSize: (_a = token$1.inputFontSize) !== null && _a !== void 0 ? _a : token$1.fontSize,
					lineHeight: token$1.lineHeight,
					transition: `all ${motionDurationMid}`
				}, genPlaceholderStyle(colorTextPlaceholder)), {
					flex: "auto",
					minWidth: 1,
					height: "auto",
					padding: 0,
					background: "transparent",
					border: 0,
					fontFamily: "inherit",
					"&:focus": {
						boxShadow: "none",
						outline: 0
					},
					"&[disabled]": {
						background: "transparent",
						color: colorTextDisabled,
						cursor: "not-allowed"
					}
				}),
				"&-placeholder": { "> input": { color: colorTextPlaceholder } }
			},
			"&-large": Object.assign(Object.assign({}, genPickerPadding(token$1.paddingBlockLG, token$1.paddingInlineLG)), { [`${componentCls}-input > input`]: {
				fontSize: inputFontSizeLG !== null && inputFontSizeLG !== void 0 ? inputFontSizeLG : fontSizeLG,
				lineHeight: lineHeightLG
			} }),
			"&-small": Object.assign(Object.assign({}, genPickerPadding(token$1.paddingBlockSM, token$1.paddingInlineSM)), { [`${componentCls}-input > input`]: { fontSize: inputFontSizeSM !== null && inputFontSizeSM !== void 0 ? inputFontSizeSM : fontSizeSM } }),
			[`${componentCls}-suffix`]: {
				display: "flex",
				flex: "none",
				alignSelf: "center",
				marginInlineStart: token$1.calc(paddingXS).div(2).equal(),
				color: colorTextDisabled,
				lineHeight: 1,
				pointerEvents: "none",
				transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
				"> *": {
					verticalAlign: "top",
					"&:not(:last-child)": { marginInlineEnd: marginXS }
				}
			},
			[`${componentCls}-clear`]: {
				position: "absolute",
				top: "50%",
				insetInlineEnd: 0,
				color: colorTextDisabled,
				lineHeight: 1,
				transform: "translateY(-50%)",
				cursor: "pointer",
				opacity: 0,
				transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
				"> *": { verticalAlign: "top" },
				"&:hover": { color: colorIcon }
			},
			"&:hover": {
				[`${componentCls}-clear`]: { opacity: 1 },
				[`${componentCls}-suffix:not(:last-child)`]: { opacity: 0 }
			},
			[`${componentCls}-separator`]: {
				position: "relative",
				display: "inline-block",
				width: "1em",
				height: fontSizeLG,
				color: colorTextDisabled,
				fontSize: fontSizeLG,
				verticalAlign: "top",
				cursor: "default",
				[`${componentCls}-focused &`]: { color: colorIcon },
				[`${componentCls}-range-separator &`]: { [`${componentCls}-disabled &`]: { cursor: "not-allowed" } }
			},
			"&-range": {
				position: "relative",
				display: "inline-flex",
				[`${componentCls}-active-bar`]: {
					bottom: token$1.calc(lineWidth).mul(-1).equal(),
					height: lineWidthBold,
					background: colorPrimary,
					opacity: 0,
					transition: `all ${motionDurationSlow} ease-out`,
					pointerEvents: "none"
				},
				[`&${componentCls}-focused`]: { [`${componentCls}-active-bar`]: { opacity: 1 } },
				[`${componentCls}-range-separator`]: {
					alignItems: "center",
					padding: `0 ${unit(paddingXS)}`,
					lineHeight: 1
				}
			},
			"&-range, &-multiple": {
				[`${componentCls}-clear`]: { insetInlineEnd: paddingInline },
				[`&${componentCls}-small`]: { [`${componentCls}-clear`]: { insetInlineEnd: paddingInlineSM } }
			},
			"&-dropdown": Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), genPanelStyle$1(token$1)), {
				pointerEvents: "none",
				position: "absolute",
				top: -9999,
				left: {
					_skip_check_: true,
					value: -9999
				},
				zIndex: zIndexPopup,
				[`&${componentCls}-dropdown-hidden`]: { display: "none" },
				"&-rtl": { direction: "rtl" },
				[`&${componentCls}-dropdown-placement-bottomLeft,
            &${componentCls}-dropdown-placement-bottomRight`]: { [`${componentCls}-range-arrow`]: {
					top: 0,
					display: "block",
					transform: "translateY(-100%)"
				} },
				[`&${componentCls}-dropdown-placement-topLeft,
            &${componentCls}-dropdown-placement-topRight`]: { [`${componentCls}-range-arrow`]: {
					bottom: 0,
					display: "block",
					transform: "translateY(100%) rotate(180deg)"
				} },
				[`&${antCls}-slide-up-appear, &${antCls}-slide-up-enter`]: { [`${componentCls}-range-arrow${componentCls}-range-arrow`]: { transition: "none" } },
				[`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: { animationName: slideDownIn },
				[`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: { animationName: slideUpIn },
				[`&${antCls}-slide-up-leave ${componentCls}-panel-container`]: { pointerEvents: "none" },
				[`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: { animationName: slideDownOut },
				[`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: { animationName: slideUpOut },
				[`${componentCls}-panel > ${componentCls}-time-panel`]: { paddingTop: paddingXXS },
				[`${componentCls}-range-wrapper`]: {
					display: "flex",
					position: "relative"
				},
				[`${componentCls}-range-arrow`]: Object.assign(Object.assign({
					position: "absolute",
					zIndex: 1,
					display: "none",
					paddingInline: token$1.calc(paddingInline).mul(1.5).equal(),
					boxSizing: "content-box",
					transition: `all ${motionDurationSlow} ease-out`
				}, genRoundedArrow(token$1, colorBgElevated, boxShadowPopoverArrow)), { "&:before": { insetInlineStart: token$1.calc(paddingInline).mul(1.5).equal() } }),
				[`${componentCls}-panel-container`]: {
					overflow: "hidden",
					verticalAlign: "top",
					background: colorBgElevated,
					borderRadius: borderRadiusLG,
					boxShadow: boxShadowSecondary,
					transition: `margin ${motionDurationSlow}`,
					display: "inline-block",
					pointerEvents: "auto",
					[`${componentCls}-panel-layout`]: {
						display: "flex",
						flexWrap: "nowrap",
						alignItems: "stretch"
					},
					[`${componentCls}-presets`]: {
						display: "flex",
						flexDirection: "column",
						minWidth: presetsWidth,
						maxWidth: presetsMaxWidth,
						ul: {
							height: 0,
							flex: "auto",
							listStyle: "none",
							overflow: "auto",
							margin: 0,
							padding: paddingXS,
							borderInlineEnd: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
							li: Object.assign(Object.assign({}, textEllipsis), {
								borderRadius: borderRadiusSM,
								paddingInline: paddingXS,
								paddingBlock: token$1.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
								cursor: "pointer",
								transition: `all ${motionDurationSlow}`,
								"+ li": { marginTop: marginXS },
								"&:hover": { background: cellHoverBg }
							})
						}
					},
					[`${componentCls}-panels`]: {
						display: "inline-flex",
						flexWrap: "nowrap",
						"&:last-child": { [`${componentCls}-panel`]: { borderWidth: 0 } }
					},
					[`${componentCls}-panel`]: {
						verticalAlign: "top",
						background: "transparent",
						borderRadius: 0,
						borderWidth: 0,
						[`${componentCls}-content, table`]: { textAlign: "center" },
						"&-focused": { borderColor: colorBorder }
					}
				}
			}),
			"&-dropdown-range": {
				padding: `${unit(token$1.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
				"&-hidden": { display: "none" }
			},
			"&-rtl": {
				direction: "rtl",
				[`${componentCls}-separator`]: { transform: "scale(-1, 1)" },
				[`${componentCls}-footer`]: { "&-extra": { direction: "rtl" } }
			}
		}) },
		initSlideMotion(token$1, "slide-up"),
		initSlideMotion(token$1, "slide-down"),
		initMoveMotion(token$1, "move-up"),
		initMoveMotion(token$1, "move-down")
	];
};
var style_default$32 = genStyleHooks("DatePicker", (token$1) => {
	const pickerToken = merge(initInputToken(token$1), initPickerPanelToken(token$1), {
		inputPaddingHorizontalBase: token$1.calc(token$1.paddingSM).sub(1).equal(),
		multipleSelectItemHeight: token$1.multipleItemHeight,
		selectHeight: token$1.controlHeight
	});
	return [
		panel_default$1(pickerToken),
		genPickerStyle$1(pickerToken),
		variants_default(pickerToken),
		genPickerStatusStyle(pickerToken),
		multiple_default(pickerToken),
		genCompactItemStyle(token$1, { focusElCls: `${token$1.componentCls}-focused` })
	];
}, prepareComponentToken$36);

//#endregion
//#region node_modules/antd/es/calendar/style/index.js
const genCalendarStyles = (token$1) => {
	const { calendarCls, componentCls, fullBg, fullPanelBg, itemActiveBg } = token$1;
	return {
		[calendarCls]: Object.assign(Object.assign(Object.assign({}, genPanelStyle$1(token$1)), resetComponent(token$1)), {
			background: fullBg,
			"&-rtl": { direction: "rtl" },
			[`${calendarCls}-header`]: {
				display: "flex",
				justifyContent: "flex-end",
				padding: `${unit(token$1.paddingSM)} 0`,
				[`${calendarCls}-year-select`]: { minWidth: token$1.yearControlWidth },
				[`${calendarCls}-month-select`]: {
					minWidth: token$1.monthControlWidth,
					marginInlineStart: token$1.marginXS
				},
				[`${calendarCls}-mode-switch`]: { marginInlineStart: token$1.marginXS }
			}
		}),
		[`${calendarCls} ${componentCls}-panel`]: {
			background: fullPanelBg,
			border: 0,
			borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
			borderRadius: 0,
			[`${componentCls}-month-panel, ${componentCls}-date-panel`]: { width: "auto" },
			[`${componentCls}-body`]: { padding: `${unit(token$1.paddingXS)} 0` },
			[`${componentCls}-content`]: { width: "100%" }
		},
		[`${calendarCls}-mini`]: {
			borderRadius: token$1.borderRadiusLG,
			[`${calendarCls}-header`]: {
				paddingInlineEnd: token$1.paddingXS,
				paddingInlineStart: token$1.paddingXS
			},
			[`${componentCls}-panel`]: { borderRadius: `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}` },
			[`${componentCls}-content`]: {
				height: token$1.miniContentHeight,
				th: {
					height: "auto",
					padding: 0,
					lineHeight: unit(token$1.weekHeight)
				}
			},
			[`${componentCls}-cell::before`]: { pointerEvents: "none" }
		},
		[`${calendarCls}${calendarCls}-full`]: {
			[`${componentCls}-panel`]: {
				display: "block",
				width: "100%",
				textAlign: "end",
				background: fullBg,
				border: 0,
				[`${componentCls}-body`]: {
					"th, td": { padding: 0 },
					th: {
						height: "auto",
						paddingInlineEnd: token$1.paddingSM,
						paddingBottom: token$1.paddingXXS,
						lineHeight: unit(token$1.weekHeight)
					}
				}
			},
			[`${componentCls}-cell-week ${componentCls}-cell-inner`]: {
				display: "block",
				borderRadius: 0,
				borderTop: `${unit(token$1.lineWidthBold)} ${token$1.lineType} ${token$1.colorSplit}`,
				width: "100%",
				height: token$1.calc(token$1.dateValueHeight).add(token$1.dateContentHeight).add(token$1.calc(token$1.paddingXS).div(2)).add(token$1.lineWidthBold).equal()
			},
			[`${componentCls}-cell`]: {
				"&::before": { display: "none" },
				"&:hover": { [`${calendarCls}-date`]: { background: token$1.controlItemBgHover } },
				[`${calendarCls}-date-today::before`]: { display: "none" },
				[`&-in-view${componentCls}-cell-selected`]: { [`${calendarCls}-date, ${calendarCls}-date-today`]: { background: itemActiveBg } },
				"&-selected, &-selected:hover": { [`${calendarCls}-date, ${calendarCls}-date-today`]: { [`${calendarCls}-date-value`]: { color: token$1.colorPrimary } } }
			},
			[`${calendarCls}-date`]: {
				display: "block",
				width: "auto",
				height: "auto",
				margin: `0 ${unit(token$1.calc(token$1.marginXS).div(2).equal())}`,
				padding: `${unit(token$1.calc(token$1.paddingXS).div(2).equal())} ${unit(token$1.paddingXS)} 0`,
				border: 0,
				borderTop: `${unit(token$1.lineWidthBold)} ${token$1.lineType} ${token$1.colorSplit}`,
				borderRadius: 0,
				transition: `background ${token$1.motionDurationSlow}`,
				"&-value": {
					lineHeight: unit(token$1.dateValueHeight),
					transition: `color ${token$1.motionDurationSlow}`
				},
				"&-content": {
					position: "static",
					width: "auto",
					height: token$1.dateContentHeight,
					overflowY: "auto",
					color: token$1.colorText,
					lineHeight: token$1.lineHeight,
					textAlign: "start"
				},
				"&-today": {
					borderColor: token$1.colorPrimary,
					[`${calendarCls}-date-value`]: { color: token$1.colorText }
				}
			}
		},
		[`@media only screen and (max-width: ${unit(token$1.screenXS)}) `]: { [calendarCls]: { [`${calendarCls}-header`]: {
			display: "block",
			[`${calendarCls}-year-select`]: { width: "50%" },
			[`${calendarCls}-month-select`]: { width: `calc(50% - ${unit(token$1.paddingXS)})` },
			[`${calendarCls}-mode-switch`]: {
				width: "100%",
				marginTop: token$1.marginXS,
				marginInlineStart: 0,
				"> label": {
					width: "50%",
					textAlign: "center"
				}
			}
		} } }
	};
};
const prepareComponentToken$35 = (token$1) => Object.assign({
	fullBg: token$1.colorBgContainer,
	fullPanelBg: token$1.colorBgContainer,
	itemActiveBg: token$1.controlItemBgActive,
	yearControlWidth: 80,
	monthControlWidth: 70,
	miniContentHeight: 256
}, initPanelComponentToken(token$1));
var style_default$43 = genStyleHooks("Calendar", (token$1) => {
	const calendarCls = `${token$1.componentCls}-calendar`;
	const calendarToken = merge(token$1, initPickerPanelToken(token$1), {
		calendarCls,
		pickerCellInnerCls: `${token$1.componentCls}-cell-inner`,
		dateValueHeight: token$1.controlHeightSM,
		weekHeight: token$1.calc(token$1.controlHeightSM).mul(.75).equal(),
		dateContentHeight: token$1.calc(token$1.calc(token$1.fontHeightSM).add(token$1.marginXS)).mul(3).add(token$1.calc(token$1.lineWidth).mul(2)).equal()
	});
	return genCalendarStyles(calendarToken);
}, prepareComponentToken$35);

//#endregion
//#region node_modules/antd/es/calendar/generateCalendar.js
var import_classnames$167 = /* @__PURE__ */ __toESM(require_classnames());
var isSameYear = (date1, date2, config) => {
	const { getYear } = config;
	return date1 && date2 && getYear(date1) === getYear(date2);
};
var isSameMonth = (date1, date2, config) => {
	const { getMonth } = config;
	return isSameYear(date1, date2, config) && getMonth(date1) === getMonth(date2);
};
var isSameDate = (date1, date2, config) => {
	const { getDate } = config;
	return isSameMonth(date1, date2, config) && getDate(date1) === getDate(date2);
};
var generateCalendar = (generateConfig$1) => {
	const Calendar$1 = (props) => {
		const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, dateFullCellRender, dateCellRender, monthFullCellRender, monthCellRender, cellRender, fullCellRender, headerRender, value, defaultValue, disabledDate, mode, validRange, fullscreen = true, showWeek, onChange, onPanelChange, onSelect } = props;
		const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("calendar");
		const prefixCls = getPrefixCls("picker", customizePrefixCls);
		const calendarPrefixCls = `${prefixCls}-calendar`;
		const [wrapCSSVar, hashId, cssVarCls] = style_default$43(prefixCls, calendarPrefixCls);
		const today = generateConfig$1.getNow();
		{
			const warning$4 = devUseWarning("Calendar");
			[
				["dateFullCellRender", "fullCellRender"],
				["dateCellRender", "cellRender"],
				["monthFullCellRender", "fullCellRender"],
				["monthCellRender", "cellRender"]
			].forEach(([deprecatedName, newName]) => {
				warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
			});
		}
		const [mergedValue, setMergedValue] = useMergedState(() => value || generateConfig$1.getNow(), {
			defaultValue,
			value
		});
		const [mergedMode, setMergedMode] = useMergedState("month", { value: mode });
		const panelMode = import_react.useMemo(() => mergedMode === "year" ? "month" : "date", [mergedMode]);
		const mergedDisabledDate = import_react.useCallback((date$1) => {
			return (validRange ? generateConfig$1.isAfter(validRange[0], date$1) || generateConfig$1.isAfter(date$1, validRange[1]) : false) || !!(disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date$1));
		}, [disabledDate, validRange]);
		const triggerPanelChange = (date$1, newMode) => {
			onPanelChange === null || onPanelChange === void 0 || onPanelChange(date$1, newMode);
		};
		const triggerChange = (date$1) => {
			setMergedValue(date$1);
			if (!isSameDate(date$1, mergedValue, generateConfig$1)) {
				if (panelMode === "date" && !isSameMonth(date$1, mergedValue, generateConfig$1) || panelMode === "month" && !isSameYear(date$1, mergedValue, generateConfig$1)) triggerPanelChange(date$1, mergedMode);
				onChange === null || onChange === void 0 || onChange(date$1);
			}
		};
		const triggerModeChange = (newMode) => {
			setMergedMode(newMode);
			triggerPanelChange(mergedValue, newMode);
		};
		const onInternalSelect = (date$1, source) => {
			triggerChange(date$1);
			onSelect === null || onSelect === void 0 || onSelect(date$1, { source });
		};
		const dateRender = import_react.useCallback((date$1, info) => {
			if (fullCellRender) return fullCellRender(date$1, info);
			if (dateFullCellRender) return dateFullCellRender(date$1);
			return /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$167.default)(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, { [`${calendarPrefixCls}-date-today`]: isSameDate(today, date$1, generateConfig$1) }) }, /* @__PURE__ */ import_react.createElement("div", { className: `${calendarPrefixCls}-date-value` }, String(generateConfig$1.getDate(date$1)).padStart(2, "0")), /* @__PURE__ */ import_react.createElement("div", { className: `${calendarPrefixCls}-date-content` }, cellRender ? cellRender(date$1, info) : dateCellRender === null || dateCellRender === void 0 ? void 0 : dateCellRender(date$1)));
		}, [
			dateFullCellRender,
			dateCellRender,
			cellRender,
			fullCellRender
		]);
		const monthRender = import_react.useCallback((date$1, info) => {
			if (fullCellRender) return fullCellRender(date$1, info);
			if (monthFullCellRender) return monthFullCellRender(date$1);
			const months = info.locale.shortMonths || generateConfig$1.locale.getShortMonths(info.locale.locale);
			return /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$167.default)(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, { [`${calendarPrefixCls}-date-today`]: isSameMonth(today, date$1, generateConfig$1) }) }, /* @__PURE__ */ import_react.createElement("div", { className: `${calendarPrefixCls}-date-value` }, months[generateConfig$1.getMonth(date$1)]), /* @__PURE__ */ import_react.createElement("div", { className: `${calendarPrefixCls}-date-content` }, cellRender ? cellRender(date$1, info) : monthCellRender === null || monthCellRender === void 0 ? void 0 : monthCellRender(date$1)));
		}, [
			monthFullCellRender,
			monthCellRender,
			cellRender,
			fullCellRender
		]);
		const [contextLocale] = useLocale_default("Calendar", en_US_default$3);
		const locale$5 = Object.assign(Object.assign({}, contextLocale), props.locale);
		const mergedCellRender = (current, info) => {
			if (info.type === "date") return dateRender(current, info);
			if (info.type === "month") return monthRender(current, Object.assign(Object.assign({}, info), { locale: locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.lang }));
		};
		return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
			className: (0, import_classnames$167.default)(calendarPrefixCls, {
				[`${calendarPrefixCls}-full`]: fullscreen,
				[`${calendarPrefixCls}-mini`]: !fullscreen,
				[`${calendarPrefixCls}-rtl`]: direction === "rtl"
			}, contextClassName, className, rootClassName, hashId, cssVarCls),
			style: Object.assign(Object.assign({}, contextStyle), style$1)
		}, headerRender ? headerRender({
			value: mergedValue,
			type: mergedMode,
			onChange: (nextDate) => {
				onInternalSelect(nextDate, "customize");
			},
			onTypeChange: triggerModeChange
		}) : /* @__PURE__ */ import_react.createElement(Header_default$1, {
			prefixCls: calendarPrefixCls,
			value: mergedValue,
			generateConfig: generateConfig$1,
			mode: mergedMode,
			fullscreen,
			locale: locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.lang,
			validRange,
			onChange: onInternalSelect,
			onModeChange: triggerModeChange
		}), /* @__PURE__ */ import_react.createElement(PickerPanel_default, {
			value: mergedValue,
			prefixCls,
			locale: locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.lang,
			generateConfig: generateConfig$1,
			cellRender: mergedCellRender,
			onSelect: (nextDate) => {
				onInternalSelect(nextDate, panelMode);
			},
			mode: panelMode,
			picker: panelMode,
			disabledDate: mergedDisabledDate,
			hideHeader: true,
			showWeek
		})));
	};
	Calendar$1.displayName = "Calendar";
	return Calendar$1;
};
var generateCalendar_default = generateCalendar;

//#endregion
//#region node_modules/antd/es/calendar/index.js
var Calendar = generateCalendar_default(dayjs_default);
Calendar.generateCalendar = generateCalendar_default;
var calendar_default = Calendar;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/PlusOutlined.js
var PlusOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" }
		}]
	},
	"name": "plus",
	"theme": "outlined"
};
var PlusOutlined_default$1 = PlusOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/PlusOutlined.js
/**![plus](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ4MiAxNTJoNjBxOCAwIDggOHY3MDRxMCA4LTggOGgtNjBxLTggMC04LThWMTYwcTAtOCA4LTh6IiAvPjxwYXRoIGQ9Ik0xOTIgNDc0aDY3MnE4IDAgOCA4djYwcTAgOC04IDhIMTYwcS04IDAtOC04di02MHEwLTggOC04eiIgLz48L3N2Zz4=) */
var RefIcon$36 = /* @__PURE__ */ import_react.forwardRef(function PlusOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: PlusOutlined_default$1
	}));
});
RefIcon$36.displayName = "PlusOutlined";
var PlusOutlined_default = RefIcon$36;

//#endregion
//#region node_modules/rc-tabs/es/TabContext.js
var TabContext_default = /* @__PURE__ */ (0, import_react.createContext)(null);

//#endregion
//#region node_modules/rc-tabs/es/hooks/useIndicator.js
var useIndicator = function useIndicator$1(options) {
	var activeTabOffset = options.activeTabOffset, horizontal = options.horizontal, rtl = options.rtl, _options$indicator = options.indicator, indicator = _options$indicator === void 0 ? {} : _options$indicator;
	var size = indicator.size, _indicator$align = indicator.align, align = _indicator$align === void 0 ? "center" : _indicator$align;
	var _useState = (0, import_react.useState)(), _useState2 = _slicedToArray(_useState, 2), inkStyle = _useState2[0], setInkStyle = _useState2[1];
	var inkBarRafRef = (0, import_react.useRef)();
	var getLength = import_react.useCallback(function(origin) {
		if (typeof size === "function") return size(origin);
		if (typeof size === "number") return size;
		return origin;
	}, [size]);
	function cleanInkBarRaf() {
		raf_default.cancel(inkBarRafRef.current);
	}
	(0, import_react.useEffect)(function() {
		var newInkStyle = {};
		if (activeTabOffset) if (horizontal) {
			newInkStyle.width = getLength(activeTabOffset.width);
			var key = rtl ? "right" : "left";
			if (align === "start") newInkStyle[key] = activeTabOffset[key];
			if (align === "center") {
				newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
				newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)";
			}
			if (align === "end") {
				newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
				newInkStyle.transform = "translateX(-100%)";
			}
		} else {
			newInkStyle.height = getLength(activeTabOffset.height);
			if (align === "start") newInkStyle.top = activeTabOffset.top;
			if (align === "center") {
				newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
				newInkStyle.transform = "translateY(-50%)";
			}
			if (align === "end") {
				newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
				newInkStyle.transform = "translateY(-100%)";
			}
		}
		cleanInkBarRaf();
		inkBarRafRef.current = raf_default(function() {
			if (!(inkStyle && newInkStyle && Object.keys(newInkStyle).every(function(key$1) {
				var newValue = newInkStyle[key$1];
				var oldValue = inkStyle[key$1];
				return typeof newValue === "number" && typeof oldValue === "number" ? Math.round(newValue) === Math.round(oldValue) : newValue === oldValue;
			}))) setInkStyle(newInkStyle);
		});
		return cleanInkBarRaf;
	}, [
		JSON.stringify(activeTabOffset),
		horizontal,
		rtl,
		align,
		getLength
	]);
	return { style: inkStyle };
};
var useIndicator_default = useIndicator;

//#endregion
//#region node_modules/rc-tabs/es/hooks/useOffsets.js
var DEFAULT_SIZE$2 = {
	width: 0,
	height: 0,
	left: 0,
	top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
	return (0, import_react.useMemo)(function() {
		var _tabs$;
		var map = /* @__PURE__ */ new Map();
		var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE$2;
		var rightOffset = lastOffset.left + lastOffset.width;
		for (var i = 0; i < tabs.length; i += 1) {
			var key = tabs[i].key;
			var data = tabSizes.get(key);
			if (!data) {
				var _tabs;
				data = tabSizes.get((_tabs = tabs[i - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE$2;
			}
			var entity = map.get(key) || _objectSpread2({}, data);
			entity.right = rightOffset - entity.left - entity.width;
			map.set(key, entity);
		}
		return map;
	}, [
		tabs.map(function(tab) {
			return tab.key;
		}).join("_"),
		tabSizes,
		holderScrollWidth
	]);
}

//#endregion
//#region node_modules/rc-tabs/es/hooks/useSyncState.js
function useSyncState$1(defaultState, onChange) {
	var stateRef = import_react.useRef(defaultState);
	var _React$useState = import_react.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
	function setState(updater) {
		var newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
		if (newValue !== stateRef.current) onChange(newValue, stateRef.current);
		stateRef.current = newValue;
		forceUpdate({});
	}
	return [stateRef.current, setState];
}

//#endregion
//#region node_modules/rc-tabs/es/hooks/useTouchMove.js
var MIN_SWIPE_DISTANCE = .1;
var STOP_SWIPE_DISTANCE = .01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = Math.pow(.995, REFRESH_INTERVAL);
function useTouchMove(ref, onOffset) {
	var _useState = (0, import_react.useState)(), _useState2 = _slicedToArray(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
	var _useState3 = (0, import_react.useState)(0), _useState4 = _slicedToArray(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
	var _useState5 = (0, import_react.useState)(0), _useState6 = _slicedToArray(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
	var _useState7 = (0, import_react.useState)(), _useState8 = _slicedToArray(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
	var motionRef = (0, import_react.useRef)();
	function onTouchStart(e$2) {
		var _e$touches$ = e$2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
		setTouchPosition({
			x: screenX,
			y: screenY
		});
		window.clearInterval(motionRef.current);
	}
	function onTouchMove(e$2) {
		if (!touchPosition) return;
		var _e$touches$2 = e$2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
		setTouchPosition({
			x: screenX,
			y: screenY
		});
		var offsetX = screenX - touchPosition.x;
		var offsetY = screenY - touchPosition.y;
		onOffset(offsetX, offsetY);
		var now$1 = Date.now();
		setLastTimestamp(now$1);
		setLastTimeDiff(now$1 - lastTimestamp);
		setLastOffset({
			x: offsetX,
			y: offsetY
		});
	}
	function onTouchEnd() {
		if (!touchPosition) return;
		setTouchPosition(null);
		setLastOffset(null);
		if (lastOffset) {
			var distanceX = lastOffset.x / lastTimeDiff;
			var distanceY = lastOffset.y / lastTimeDiff;
			var absX = Math.abs(distanceX);
			var absY = Math.abs(distanceY);
			if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
			var currentX = distanceX;
			var currentY = distanceY;
			motionRef.current = window.setInterval(function() {
				if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
					window.clearInterval(motionRef.current);
					return;
				}
				currentX *= SPEED_OFF_MULTIPLE;
				currentY *= SPEED_OFF_MULTIPLE;
				onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
			}, REFRESH_INTERVAL);
		}
	}
	var lastWheelDirectionRef = (0, import_react.useRef)();
	function onWheel(e$2) {
		var deltaX = e$2.deltaX, deltaY = e$2.deltaY;
		var mixed = 0;
		var absX = Math.abs(deltaX);
		var absY = Math.abs(deltaY);
		if (absX === absY) mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
		else if (absX > absY) {
			mixed = deltaX;
			lastWheelDirectionRef.current = "x";
		} else {
			mixed = deltaY;
			lastWheelDirectionRef.current = "y";
		}
		if (onOffset(-mixed, -mixed)) e$2.preventDefault();
	}
	var touchEventsRef = (0, import_react.useRef)(null);
	touchEventsRef.current = {
		onTouchStart,
		onTouchMove,
		onTouchEnd,
		onWheel
	};
	import_react.useEffect(function() {
		function onProxyTouchStart(e$2) {
			touchEventsRef.current.onTouchStart(e$2);
		}
		function onProxyTouchMove(e$2) {
			touchEventsRef.current.onTouchMove(e$2);
		}
		function onProxyTouchEnd(e$2) {
			touchEventsRef.current.onTouchEnd(e$2);
		}
		function onProxyWheel(e$2) {
			touchEventsRef.current.onWheel(e$2);
		}
		document.addEventListener("touchmove", onProxyTouchMove, { passive: false });
		document.addEventListener("touchend", onProxyTouchEnd, { passive: true });
		ref.current.addEventListener("touchstart", onProxyTouchStart, { passive: true });
		ref.current.addEventListener("wheel", onProxyWheel, { passive: false });
		return function() {
			document.removeEventListener("touchmove", onProxyTouchMove);
			document.removeEventListener("touchend", onProxyTouchEnd);
		};
	}, []);
}

//#endregion
//#region node_modules/rc-tabs/es/hooks/useUpdate.js
/**
* Help to merge callback with `useLayoutEffect`.
* One time will only trigger once.
*/
function useUpdate(callback) {
	var _useState = (0, import_react.useState)(0), _useState2 = _slicedToArray(_useState, 2), count = _useState2[0], setCount = _useState2[1];
	var effectRef = (0, import_react.useRef)(0);
	var callbackRef = (0, import_react.useRef)();
	callbackRef.current = callback;
	useLayoutUpdateEffect(function() {
		var _callbackRef$current;
		(_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 || _callbackRef$current.call(callbackRef);
	}, [count]);
	return function() {
		if (effectRef.current !== count) return;
		effectRef.current += 1;
		setCount(effectRef.current);
	};
}
function useUpdateState(defaultState) {
	var batchRef = (0, import_react.useRef)([]);
	var _useState3 = (0, import_react.useState)({}), _useState4 = _slicedToArray(_useState3, 2), forceUpdate = _useState4[1];
	var state = (0, import_react.useRef)(typeof defaultState === "function" ? defaultState() : defaultState);
	var flushUpdate = useUpdate(function() {
		var current = state.current;
		batchRef.current.forEach(function(callback) {
			current = callback(current);
		});
		batchRef.current = [];
		state.current = current;
		forceUpdate({});
	});
	function updater(callback) {
		batchRef.current.push(callback);
		flushUpdate();
	}
	return [state.current, updater];
}

//#endregion
//#region node_modules/rc-tabs/es/hooks/useVisibleRange.js
var DEFAULT_SIZE$1 = {
	width: 0,
	height: 0,
	left: 0,
	top: 0,
	right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
	var tabs = _ref.tabs, tabPosition = _ref.tabPosition, rtl = _ref.rtl;
	var charUnit;
	var position$2;
	var transformSize;
	if (["top", "bottom"].includes(tabPosition)) {
		charUnit = "width";
		position$2 = rtl ? "right" : "left";
		transformSize = Math.abs(transform);
	} else {
		charUnit = "height";
		position$2 = "top";
		transformSize = -transform;
	}
	return (0, import_react.useMemo)(function() {
		if (!tabs.length) return [0, 0];
		var len = tabs.length;
		var endIndex = len;
		for (var i = 0; i < len; i += 1) {
			var offset$2 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE$1;
			if (Math.floor(offset$2[position$2] + offset$2[charUnit]) > Math.floor(transformSize + visibleTabContentValue)) {
				endIndex = i - 1;
				break;
			}
		}
		var startIndex = 0;
		for (var _i = len - 1; _i >= 0; _i -= 1) if ((tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE$1)[position$2] < transformSize) {
			startIndex = _i + 1;
			break;
		}
		return startIndex > endIndex ? [0, -1] : [startIndex, endIndex];
	}, [
		tabOffsets,
		visibleTabContentValue,
		tabContentSizeValue,
		addNodeSizeValue,
		operationNodeSizeValue,
		transformSize,
		tabPosition,
		tabs.map(function(tab) {
			return tab.key;
		}).join("_"),
		rtl
	]);
}

//#endregion
//#region node_modules/rc-tabs/es/util.js
/**
* We trade Map as deps which may change with same value but different ref object.
* We should make it as hash for deps
* */
function stringify(obj) {
	var tgt;
	if (obj instanceof Map) {
		tgt = {};
		obj.forEach(function(v, k) {
			tgt[k] = v;
		});
	} else tgt = obj;
	return JSON.stringify(tgt);
}
var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
function genDataNodeKey(key) {
	return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
}
function getRemovable(closable, closeIcon, editable, disabled) {
	if (!editable || disabled || closable === false || closable === void 0 && (closeIcon === false || closeIcon === null)) return false;
	return true;
}

//#endregion
//#region node_modules/rc-tabs/es/TabNavList/AddButton.js
var AddButton = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, editable = props.editable, locale$5 = props.locale, style$1 = props.style;
	if (!editable || editable.showAdd === false) return null;
	return /* @__PURE__ */ import_react.createElement("button", {
		ref,
		type: "button",
		className: "".concat(prefixCls, "-nav-add"),
		style: style$1,
		"aria-label": (locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.addAriaLabel) || "Add tab",
		onClick: function onClick(event) {
			editable.onEdit("add", { event });
		}
	}, editable.addIcon || "+");
});
var AddButton_default = AddButton;

//#endregion
//#region node_modules/rc-tabs/es/TabNavList/ExtraContent.js
var ExtraContent = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var position$2 = props.position, prefixCls = props.prefixCls, extra = props.extra;
	if (!extra) return null;
	var content;
	var assertExtra = {};
	if (_typeof(extra) === "object" && !/* @__PURE__ */ import_react.isValidElement(extra)) assertExtra = extra;
	else assertExtra.right = extra;
	if (position$2 === "right") content = assertExtra.right;
	if (position$2 === "left") content = assertExtra.left;
	return content ? /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-extra-content"),
		ref
	}, content) : null;
});
ExtraContent.displayName = "ExtraContent";
var ExtraContent_default = ExtraContent;

//#endregion
//#region node_modules/rc-tabs/es/TabNavList/OperationNode.js
var import_classnames$166 = /* @__PURE__ */ __toESM(require_classnames());
var OperationNode = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, id = props.id, tabs = props.tabs, locale$5 = props.locale, mobile = props.mobile, _props$more = props.more, moreProps = _props$more === void 0 ? {} : _props$more, style$1 = props.style, className = props.className, editable = props.editable, tabBarGutter = props.tabBarGutter, rtl = props.rtl, removeAriaLabel = props.removeAriaLabel, onTabClick = props.onTabClick, getPopupContainer = props.getPopupContainer, popupClassName = props.popupClassName;
	var _useState = (0, import_react.useState)(false), _useState2 = _slicedToArray(_useState, 2), open$2 = _useState2[0], setOpen = _useState2[1];
	var _useState3 = (0, import_react.useState)(null), _useState4 = _slicedToArray(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
	var _moreProps$icon = moreProps.icon, moreIcon = _moreProps$icon === void 0 ? "More" : _moreProps$icon;
	var popupId = "".concat(id, "-more-popup");
	var dropdownPrefix = "".concat(prefixCls, "-dropdown");
	var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
	var dropdownAriaLabel = locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.dropdownAriaLabel;
	function onRemoveTab(event, key) {
		event.preventDefault();
		event.stopPropagation();
		editable.onEdit("remove", {
			key,
			event
		});
	}
	var menu = /* @__PURE__ */ import_react.createElement(es_default$14, {
		onClick: function onClick(_ref) {
			var key = _ref.key, domEvent = _ref.domEvent;
			onTabClick(key, domEvent);
			setOpen(false);
		},
		prefixCls: "".concat(dropdownPrefix, "-menu"),
		id: popupId,
		tabIndex: -1,
		role: "listbox",
		"aria-activedescendant": selectedItemId,
		selectedKeys: [selectedKey],
		"aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
	}, tabs.map(function(tab) {
		var closable = tab.closable, disabled = tab.disabled, closeIcon = tab.closeIcon, key = tab.key, label = tab.label;
		var removable = getRemovable(closable, closeIcon, editable, disabled);
		return /* @__PURE__ */ import_react.createElement(MenuItem_default, {
			key,
			id: "".concat(popupId, "-").concat(key),
			role: "option",
			"aria-controls": id && "".concat(id, "-panel-").concat(key),
			disabled
		}, /* @__PURE__ */ import_react.createElement("span", null, label), removable && /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			"aria-label": removeAriaLabel || "remove",
			tabIndex: 0,
			className: "".concat(dropdownPrefix, "-menu-item-remove"),
			onClick: function onClick(e$2) {
				e$2.stopPropagation();
				onRemoveTab(e$2, key);
			}
		}, closeIcon || editable.removeIcon || ""));
	}));
	function selectOffset(offset$2) {
		var enabledTabs = tabs.filter(function(tab$1) {
			return !tab$1.disabled;
		});
		var selectedIndex = enabledTabs.findIndex(function(tab$1) {
			return tab$1.key === selectedKey;
		}) || 0;
		var len = enabledTabs.length;
		for (var i = 0; i < len; i += 1) {
			selectedIndex = (selectedIndex + offset$2 + len) % len;
			var tab = enabledTabs[selectedIndex];
			if (!tab.disabled) {
				setSelectedKey(tab.key);
				return;
			}
		}
	}
	function onKeyDown$1(e$2) {
		var which = e$2.which;
		if (!open$2) {
			if ([
				KeyCode_default.DOWN,
				KeyCode_default.SPACE,
				KeyCode_default.ENTER
			].includes(which)) {
				setOpen(true);
				e$2.preventDefault();
			}
			return;
		}
		switch (which) {
			case KeyCode_default.UP:
				selectOffset(-1);
				e$2.preventDefault();
				break;
			case KeyCode_default.DOWN:
				selectOffset(1);
				e$2.preventDefault();
				break;
			case KeyCode_default.ESC:
				setOpen(false);
				break;
			case KeyCode_default.SPACE:
			case KeyCode_default.ENTER:
				if (selectedKey !== null) onTabClick(selectedKey, e$2);
				break;
		}
	}
	(0, import_react.useEffect)(function() {
		var ele = document.getElementById(selectedItemId);
		if (ele && ele.scrollIntoView) ele.scrollIntoView(false);
	}, [selectedKey]);
	(0, import_react.useEffect)(function() {
		if (!open$2) setSelectedKey(null);
	}, [open$2]);
	var moreStyle = _defineProperty({}, rtl ? "marginRight" : "marginLeft", tabBarGutter);
	if (!tabs.length) {
		moreStyle.visibility = "hidden";
		moreStyle.order = 1;
	}
	var overlayClassName = (0, import_classnames$166.default)(_defineProperty({}, "".concat(dropdownPrefix, "-rtl"), rtl));
	var moreNode = mobile ? null : /* @__PURE__ */ import_react.createElement(es_default$30, _extends({
		prefixCls: dropdownPrefix,
		overlay: menu,
		visible: tabs.length ? open$2 : false,
		onVisibleChange: setOpen,
		overlayClassName: (0, import_classnames$166.default)(overlayClassName, popupClassName),
		mouseEnterDelay: .1,
		mouseLeaveDelay: .1,
		getPopupContainer
	}, moreProps), /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		className: "".concat(prefixCls, "-nav-more"),
		style: moreStyle,
		"aria-haspopup": "listbox",
		"aria-controls": popupId,
		id: "".concat(id, "-more"),
		"aria-expanded": open$2,
		onKeyDown: onKeyDown$1
	}, moreIcon));
	return /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$166.default)("".concat(prefixCls, "-nav-operations"), className),
		style: style$1,
		ref
	}, moreNode, /* @__PURE__ */ import_react.createElement(AddButton_default, {
		prefixCls,
		locale: locale$5,
		editable
	}));
});
var OperationNode_default = /* @__PURE__ */ import_react.memo(OperationNode, function(_, next$1) {
	return next$1.tabMoving;
});

//#endregion
//#region node_modules/rc-tabs/es/TabNavList/TabNode.js
var import_classnames$165 = /* @__PURE__ */ __toESM(require_classnames());
var TabNode = function TabNode$1(props) {
	var prefixCls = props.prefixCls, id = props.id, active = props.active, focus = props.focus, _props$tab = props.tab, key = _props$tab.key, label = _props$tab.label, disabled = _props$tab.disabled, closeIcon = _props$tab.closeIcon, icon = _props$tab.icon, closable = props.closable, renderWrapper = props.renderWrapper, removeAriaLabel = props.removeAriaLabel, editable = props.editable, onClick = props.onClick, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown$1 = props.onKeyDown, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, style$1 = props.style, tabCount = props.tabCount, currentPosition = props.currentPosition;
	var tabPrefix = "".concat(prefixCls, "-tab");
	var removable = getRemovable(closable, closeIcon, editable, disabled);
	function onInternalClick(e$2) {
		if (disabled) return;
		onClick(e$2);
	}
	function onRemoveTab(event) {
		event.preventDefault();
		event.stopPropagation();
		editable.onEdit("remove", {
			key,
			event
		});
	}
	var labelNode = import_react.useMemo(function() {
		return icon && typeof label === "string" ? /* @__PURE__ */ import_react.createElement("span", null, label) : label;
	}, [label, icon]);
	var btnRef = import_react.useRef(null);
	import_react.useEffect(function() {
		if (focus && btnRef.current) btnRef.current.focus();
	}, [focus]);
	var node$1 = /* @__PURE__ */ import_react.createElement("div", {
		key,
		"data-node-key": genDataNodeKey(key),
		className: (0, import_classnames$165.default)(tabPrefix, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(tabPrefix, "-with-remove"), removable), "".concat(tabPrefix, "-active"), active), "".concat(tabPrefix, "-disabled"), disabled), "".concat(tabPrefix, "-focus"), focus)),
		style: style$1,
		onClick: onInternalClick
	}, /* @__PURE__ */ import_react.createElement("div", {
		ref: btnRef,
		role: "tab",
		"aria-selected": active,
		id: id && "".concat(id, "-tab-").concat(key),
		className: "".concat(tabPrefix, "-btn"),
		"aria-controls": id && "".concat(id, "-panel-").concat(key),
		"aria-disabled": disabled,
		tabIndex: disabled ? null : active ? 0 : -1,
		onClick: function onClick$1(e$2) {
			e$2.stopPropagation();
			onInternalClick(e$2);
		},
		onKeyDown: onKeyDown$1,
		onMouseDown,
		onMouseUp,
		onFocus,
		onBlur
	}, focus && /* @__PURE__ */ import_react.createElement("div", {
		"aria-live": "polite",
		style: {
			width: 0,
			height: 0,
			position: "absolute",
			overflow: "hidden",
			opacity: 0
		}
	}, "Tab ".concat(currentPosition, " of ").concat(tabCount)), icon && /* @__PURE__ */ import_react.createElement("span", { className: "".concat(tabPrefix, "-icon") }, icon), label && labelNode), removable && /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		role: "tab",
		"aria-label": removeAriaLabel || "remove",
		tabIndex: active ? 0 : -1,
		className: "".concat(tabPrefix, "-remove"),
		onClick: function onClick$1(e$2) {
			e$2.stopPropagation();
			onRemoveTab(e$2);
		}
	}, closeIcon || editable.removeIcon || ""));
	return renderWrapper ? renderWrapper(node$1) : node$1;
};
var TabNode_default = TabNode;

//#endregion
//#region node_modules/rc-tabs/es/TabNavList/index.js
var import_classnames$164 = /* @__PURE__ */ __toESM(require_classnames());
var getTabSize = function getTabSize$1(tab, containerRect) {
	var offsetWidth = tab.offsetWidth, offsetHeight = tab.offsetHeight, offsetTop = tab.offsetTop, offsetLeft = tab.offsetLeft;
	var _tab$getBoundingClien = tab.getBoundingClientRect(), width = _tab$getBoundingClien.width, height = _tab$getBoundingClien.height, left = _tab$getBoundingClien.left, top = _tab$getBoundingClien.top;
	if (Math.abs(width - offsetWidth) < 1) return [
		width,
		height,
		left - containerRect.left,
		top - containerRect.top
	];
	return [
		offsetWidth,
		offsetHeight,
		offsetLeft,
		offsetTop
	];
};
var getSize$1 = function getSize$2(refObj) {
	var _ref = refObj.current || {}, _ref$offsetWidth = _ref.offsetWidth, offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth, _ref$offsetHeight = _ref.offsetHeight, offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
	if (refObj.current) {
		var _refObj$current$getBo = refObj.current.getBoundingClientRect(), width = _refObj$current$getBo.width, height = _refObj$current$getBo.height;
		if (Math.abs(width - offsetWidth) < 1) return [width, height];
	}
	return [offsetWidth, offsetHeight];
};
/**
* Convert `SizeInfo` to unit value. Such as [123, 456] with `top` position get `123`
*/
var getUnitValue = function getUnitValue$1(size, tabPositionTopOrBottom) {
	return size[tabPositionTopOrBottom ? 0 : 1];
};
var TabNavList = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var className = props.className, style$1 = props.style, id = props.id, animated = props.animated, activeKey = props.activeKey, rtl = props.rtl, extra = props.extra, editable = props.editable, locale$5 = props.locale, tabPosition = props.tabPosition, tabBarGutter = props.tabBarGutter, children = props.children, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, indicator = props.indicator;
	var _React$useContext = import_react.useContext(TabContext_default), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
	var containerRef = (0, import_react.useRef)(null);
	var extraLeftRef = (0, import_react.useRef)(null);
	var extraRightRef = (0, import_react.useRef)(null);
	var tabsWrapperRef = (0, import_react.useRef)(null);
	var tabListRef = (0, import_react.useRef)(null);
	var operationsRef = (0, import_react.useRef)(null);
	var innerAddButtonRef = (0, import_react.useRef)(null);
	var tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
	var _useSyncState = useSyncState$1(0, function(next$1, prev$1) {
		if (tabPositionTopOrBottom && onTabScroll) onTabScroll({ direction: next$1 > prev$1 ? "left" : "right" });
	}), _useSyncState2 = _slicedToArray(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
	var _useSyncState3 = useSyncState$1(0, function(next$1, prev$1) {
		if (!tabPositionTopOrBottom && onTabScroll) onTabScroll({ direction: next$1 > prev$1 ? "top" : "bottom" });
	}), _useSyncState4 = _slicedToArray(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
	var _useState = (0, import_react.useState)([0, 0]), _useState2 = _slicedToArray(_useState, 2), containerExcludeExtraSize = _useState2[0], setContainerExcludeExtraSize = _useState2[1];
	var _useState3 = (0, import_react.useState)([0, 0]), _useState4 = _slicedToArray(_useState3, 2), tabContentSize = _useState4[0], setTabContentSize = _useState4[1];
	var _useState5 = (0, import_react.useState)([0, 0]), _useState6 = _slicedToArray(_useState5, 2), addSize = _useState6[0], setAddSize = _useState6[1];
	var _useState7 = (0, import_react.useState)([0, 0]), _useState8 = _slicedToArray(_useState7, 2), operationSize = _useState8[0], setOperationSize = _useState8[1];
	var _useUpdateState = useUpdateState(/* @__PURE__ */ new Map()), _useUpdateState2 = _slicedToArray(_useUpdateState, 2), tabSizes = _useUpdateState2[0], setTabSizes = _useUpdateState2[1];
	var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
	var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
	var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
	var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
	var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
	var needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);
	var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
	var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
	var transformMin = 0;
	var transformMax = 0;
	if (!tabPositionTopOrBottom) {
		transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
		transformMax = 0;
	} else if (rtl) {
		transformMin = 0;
		transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
	} else {
		transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
		transformMax = 0;
	}
	function alignInRange(value) {
		if (value < transformMin) return transformMin;
		if (value > transformMax) return transformMax;
		return value;
	}
	var touchMovingRef = (0, import_react.useRef)(null);
	var _useState9 = (0, import_react.useState)(), _useState10 = _slicedToArray(_useState9, 2), lockAnimation = _useState10[0], setLockAnimation = _useState10[1];
	function doLockAnimation() {
		setLockAnimation(Date.now());
	}
	function clearTouchMoving() {
		if (touchMovingRef.current) clearTimeout(touchMovingRef.current);
	}
	useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
		function doMove(setState, offset$2) {
			setState(function(value) {
				return alignInRange(value + offset$2);
			});
		}
		if (!needScroll) return false;
		if (tabPositionTopOrBottom) doMove(setTransformLeft, offsetX);
		else doMove(setTransformTop, offsetY);
		clearTouchMoving();
		doLockAnimation();
		return true;
	});
	(0, import_react.useEffect)(function() {
		clearTouchMoving();
		if (lockAnimation) touchMovingRef.current = setTimeout(function() {
			setLockAnimation(0);
		}, 100);
		return clearTouchMoving;
	}, [lockAnimation]);
	var _useVisibleRange = useVisibleRange(tabOffsets, visibleTabContentValue, tabPositionTopOrBottom ? transformLeft : transformTop, tabContentSizeValue, addSizeValue, operationSizeValue, _objectSpread2(_objectSpread2({}, props), {}, { tabs })), _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2), visibleStart = _useVisibleRange2[0], visibleEnd = _useVisibleRange2[1];
	var scrollToTab = useEvent(function() {
		var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : activeKey;
		var tabOffset = tabOffsets.get(key) || {
			width: 0,
			height: 0,
			left: 0,
			right: 0,
			top: 0
		};
		if (tabPositionTopOrBottom) {
			var newTransform = transformLeft;
			if (rtl) {
				if (tabOffset.right < transformLeft) newTransform = tabOffset.right;
				else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
			} else if (tabOffset.left < -transformLeft) newTransform = -tabOffset.left;
			else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
			setTransformTop(0);
			setTransformLeft(alignInRange(newTransform));
		} else {
			var _newTransform = transformTop;
			if (tabOffset.top < -transformTop) _newTransform = -tabOffset.top;
			else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
			setTransformLeft(0);
			setTransformTop(alignInRange(_newTransform));
		}
	});
	var _useState11 = (0, import_react.useState)(), _useState12 = _slicedToArray(_useState11, 2), focusKey = _useState12[0], setFocusKey = _useState12[1];
	var _useState13 = (0, import_react.useState)(false), _useState14 = _slicedToArray(_useState13, 2), isMouse = _useState14[0], setIsMouse = _useState14[1];
	var enabledTabs = tabs.filter(function(tab) {
		return !tab.disabled;
	}).map(function(tab) {
		return tab.key;
	});
	var onOffset = function onOffset$1(offset$2) {
		var currentIndex = enabledTabs.indexOf(focusKey || activeKey);
		var len = enabledTabs.length;
		var nextIndex = (currentIndex + offset$2 + len) % len;
		var newKey = enabledTabs[nextIndex];
		setFocusKey(newKey);
	};
	var handleRemoveTab = function handleRemoveTab$1(removalTabKey, e$2) {
		var removeIndex = enabledTabs.indexOf(removalTabKey);
		var removeTab = tabs.find(function(tab) {
			return tab.key === removalTabKey;
		});
		if (getRemovable(removeTab === null || removeTab === void 0 ? void 0 : removeTab.closable, removeTab === null || removeTab === void 0 ? void 0 : removeTab.closeIcon, editable, removeTab === null || removeTab === void 0 ? void 0 : removeTab.disabled)) {
			e$2.preventDefault();
			e$2.stopPropagation();
			editable.onEdit("remove", {
				key: removalTabKey,
				event: e$2
			});
			if (removeIndex === enabledTabs.length - 1) onOffset(-1);
			else onOffset(1);
		}
	};
	var handleMouseDown = function handleMouseDown$1(key, e$2) {
		setIsMouse(true);
		if (e$2.button === 1) handleRemoveTab(key, e$2);
	};
	var handleKeyDown = function handleKeyDown$1(e$2) {
		var code = e$2.code;
		var isRTL = rtl && tabPositionTopOrBottom;
		var firstEnabledTab = enabledTabs[0];
		var lastEnabledTab = enabledTabs[enabledTabs.length - 1];
		switch (code) {
			case "ArrowLeft":
				if (tabPositionTopOrBottom) onOffset(isRTL ? 1 : -1);
				break;
			case "ArrowRight":
				if (tabPositionTopOrBottom) onOffset(isRTL ? -1 : 1);
				break;
			case "ArrowUp":
				e$2.preventDefault();
				if (!tabPositionTopOrBottom) onOffset(-1);
				break;
			case "ArrowDown":
				e$2.preventDefault();
				if (!tabPositionTopOrBottom) onOffset(1);
				break;
			case "Home":
				e$2.preventDefault();
				setFocusKey(firstEnabledTab);
				break;
			case "End":
				e$2.preventDefault();
				setFocusKey(lastEnabledTab);
				break;
			case "Enter":
			case "Space":
				e$2.preventDefault();
				onTabClick(focusKey !== null && focusKey !== void 0 ? focusKey : activeKey, e$2);
				break;
			case "Backspace":
			case "Delete":
				handleRemoveTab(focusKey, e$2);
				break;
		}
	};
	var tabNodeStyle = {};
	if (tabPositionTopOrBottom) tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter;
	else tabNodeStyle.marginTop = tabBarGutter;
	var tabNodes = tabs.map(function(tab, i) {
		var key = tab.key;
		return /* @__PURE__ */ import_react.createElement(TabNode_default, {
			id,
			prefixCls,
			key,
			tab,
			style: i === 0 ? void 0 : tabNodeStyle,
			closable: tab.closable,
			editable,
			active: key === activeKey,
			focus: key === focusKey,
			renderWrapper: children,
			removeAriaLabel: locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.removeAriaLabel,
			tabCount: enabledTabs.length,
			currentPosition: i + 1,
			onClick: function onClick(e$2) {
				onTabClick(key, e$2);
			},
			onKeyDown: handleKeyDown,
			onFocus: function onFocus() {
				if (!isMouse) setFocusKey(key);
				scrollToTab(key);
				doLockAnimation();
				if (!tabsWrapperRef.current) return;
				if (!rtl) tabsWrapperRef.current.scrollLeft = 0;
				tabsWrapperRef.current.scrollTop = 0;
			},
			onBlur: function onBlur() {
				setFocusKey(void 0);
			},
			onMouseDown: function onMouseDown(e$2) {
				return handleMouseDown(key, e$2);
			},
			onMouseUp: function onMouseUp() {
				setIsMouse(false);
			}
		});
	});
	var updateTabSizes = function updateTabSizes$1() {
		return setTabSizes(function() {
			var _tabListRef$current;
			var newSizes = /* @__PURE__ */ new Map();
			var listRect = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.getBoundingClientRect();
			tabs.forEach(function(_ref2) {
				var _tabListRef$current2;
				var key = _ref2.key;
				var btnNode = (_tabListRef$current2 = tabListRef.current) === null || _tabListRef$current2 === void 0 ? void 0 : _tabListRef$current2.querySelector("[data-node-key=\"".concat(genDataNodeKey(key), "\"]"));
				if (btnNode) {
					var _getTabSize = getTabSize(btnNode, listRect), _getTabSize2 = _slicedToArray(_getTabSize, 4), width = _getTabSize2[0], height = _getTabSize2[1], left = _getTabSize2[2], top = _getTabSize2[3];
					newSizes.set(key, {
						width,
						height,
						left,
						top
					});
				}
			});
			return newSizes;
		});
	};
	(0, import_react.useEffect)(function() {
		updateTabSizes();
	}, [tabs.map(function(tab) {
		return tab.key;
	}).join("_")]);
	var onListHolderResize = useUpdate(function() {
		var containerSize = getSize$1(containerRef);
		var extraLeftSize = getSize$1(extraLeftRef);
		var extraRightSize = getSize$1(extraRightRef);
		setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
		var newAddSize = getSize$1(innerAddButtonRef);
		setAddSize(newAddSize);
		var newOperationSize = getSize$1(operationsRef);
		setOperationSize(newOperationSize);
		var tabContentFullSize = getSize$1(tabListRef);
		setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
		updateTabSizes();
	});
	var startHiddenTabs = tabs.slice(0, visibleStart);
	var endHiddenTabs = tabs.slice(visibleEnd + 1);
	var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs));
	var activeTabOffset = tabOffsets.get(activeKey);
	var _useIndicator = useIndicator_default({
		activeTabOffset,
		horizontal: tabPositionTopOrBottom,
		indicator,
		rtl
	}), indicatorStyle = _useIndicator.style;
	(0, import_react.useEffect)(function() {
		scrollToTab();
	}, [
		activeKey,
		transformMin,
		transformMax,
		stringify(activeTabOffset),
		stringify(tabOffsets),
		tabPositionTopOrBottom
	]);
	(0, import_react.useEffect)(function() {
		onListHolderResize();
	}, [rtl]);
	var hasDropdown = !!hiddenTabs.length;
	var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
	var pingLeft;
	var pingRight;
	var pingTop;
	var pingBottom;
	if (tabPositionTopOrBottom) if (rtl) {
		pingRight = transformLeft > 0;
		pingLeft = transformLeft !== transformMax;
	} else {
		pingLeft = transformLeft < 0;
		pingRight = transformLeft !== transformMin;
	}
	else {
		pingTop = transformTop < 0;
		pingBottom = transformTop !== transformMin;
	}
	return /* @__PURE__ */ import_react.createElement(es_default, { onResize: onListHolderResize }, /* @__PURE__ */ import_react.createElement("div", {
		ref: useComposeRef(ref, containerRef),
		role: "tablist",
		"aria-orientation": tabPositionTopOrBottom ? "horizontal" : "vertical",
		className: (0, import_classnames$164.default)("".concat(prefixCls, "-nav"), className),
		style: style$1,
		onKeyDown: function onKeyDown$1() {
			doLockAnimation();
		}
	}, /* @__PURE__ */ import_react.createElement(ExtraContent_default, {
		ref: extraLeftRef,
		position: "left",
		extra,
		prefixCls
	}), /* @__PURE__ */ import_react.createElement(es_default, { onResize: onListHolderResize }, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$164.default)(wrapPrefix, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(wrapPrefix, "-ping-left"), pingLeft), "".concat(wrapPrefix, "-ping-right"), pingRight), "".concat(wrapPrefix, "-ping-top"), pingTop), "".concat(wrapPrefix, "-ping-bottom"), pingBottom)),
		ref: tabsWrapperRef
	}, /* @__PURE__ */ import_react.createElement(es_default, { onResize: onListHolderResize }, /* @__PURE__ */ import_react.createElement("div", {
		ref: tabListRef,
		className: "".concat(prefixCls, "-nav-list"),
		style: {
			transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
			transition: lockAnimation ? "none" : void 0
		}
	}, tabNodes, /* @__PURE__ */ import_react.createElement(AddButton_default, {
		ref: innerAddButtonRef,
		prefixCls,
		locale: locale$5,
		editable,
		style: _objectSpread2(_objectSpread2({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, { visibility: hasDropdown ? "hidden" : null })
	}), /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$164.default)("".concat(prefixCls, "-ink-bar"), _defineProperty({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
		style: indicatorStyle
	}))))), /* @__PURE__ */ import_react.createElement(OperationNode_default, _extends({}, props, {
		removeAriaLabel: locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.removeAriaLabel,
		ref: operationsRef,
		prefixCls,
		tabs: hiddenTabs,
		className: !hasDropdown && operationsHiddenClassName,
		tabMoving: !!lockAnimation
	})), /* @__PURE__ */ import_react.createElement(ExtraContent_default, {
		ref: extraRightRef,
		position: "right",
		extra,
		prefixCls
	})));
});
var TabNavList_default = TabNavList;

//#endregion
//#region node_modules/rc-tabs/es/TabPanelList/TabPane.js
var import_classnames$163 = /* @__PURE__ */ __toESM(require_classnames());
var TabPane$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, className = props.className, style$1 = props.style, id = props.id, active = props.active, tabKey = props.tabKey, children = props.children;
	return /* @__PURE__ */ import_react.createElement("div", {
		id: id && "".concat(id, "-panel-").concat(tabKey),
		role: "tabpanel",
		tabIndex: active ? 0 : -1,
		"aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
		"aria-hidden": !active,
		style: style$1,
		className: (0, import_classnames$163.default)(prefixCls, active && "".concat(prefixCls, "-active"), className),
		ref
	}, children);
});
TabPane$1.displayName = "TabPane";
var TabPane_default$1 = TabPane$1;

//#endregion
//#region node_modules/rc-tabs/es/TabNavList/Wrapper.js
var _excluded$39 = ["renderTabBar"], _excluded2$6 = ["label", "key"];
var TabNavListWrapper = function TabNavListWrapper$1(_ref) {
	var renderTabBar = _ref.renderTabBar, restProps = _objectWithoutProperties(_ref, _excluded$39);
	var _React$useContext = import_react.useContext(TabContext_default), tabs = _React$useContext.tabs;
	if (renderTabBar) {
		var tabNavBarProps = _objectSpread2(_objectSpread2({}, restProps), {}, { panes: tabs.map(function(_ref2) {
			var label = _ref2.label, key = _ref2.key, restTabProps = _objectWithoutProperties(_ref2, _excluded2$6);
			return /* @__PURE__ */ import_react.createElement(TabPane_default$1, _extends({
				tab: label,
				key,
				tabKey: key
			}, restTabProps));
		}) });
		return renderTabBar(tabNavBarProps, TabNavList_default);
	}
	return /* @__PURE__ */ import_react.createElement(TabNavList_default, restProps);
};
TabNavListWrapper.displayName = "TabNavListWrapper";
var Wrapper_default = TabNavListWrapper;

//#endregion
//#region node_modules/rc-tabs/es/TabPanelList/index.js
var import_classnames$162 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$38 = [
	"key",
	"forceRender",
	"style",
	"className",
	"destroyInactiveTabPane"
];
var TabPanelList = function TabPanelList$1(props) {
	var id = props.id, activeKey = props.activeKey, animated = props.animated, tabPosition = props.tabPosition, destroyInactiveTabPane = props.destroyInactiveTabPane;
	var _React$useContext = import_react.useContext(TabContext_default), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
	var tabPaneAnimated = animated.tabPane;
	var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
	return /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$162.default)("".concat(prefixCls, "-content-holder")) }, /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$162.default)("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated)) }, tabs.map(function(item) {
		var key = item.key, forceRender = item.forceRender, paneStyle = item.style, paneClassName = item.className, itemDestroyInactiveTabPane = item.destroyInactiveTabPane, restTabProps = _objectWithoutProperties(item, _excluded$38);
		var active = key === activeKey;
		return /* @__PURE__ */ import_react.createElement(es_default$2, _extends({
			key,
			visible: active,
			forceRender,
			removeOnLeave: !!(destroyInactiveTabPane || itemDestroyInactiveTabPane),
			leavedClassName: "".concat(tabPanePrefixCls, "-hidden")
		}, animated.tabPaneMotion), function(_ref, ref) {
			var motionStyle = _ref.style, motionClassName = _ref.className;
			return /* @__PURE__ */ import_react.createElement(TabPane_default$1, _extends({}, restTabProps, {
				prefixCls: tabPanePrefixCls,
				id,
				tabKey: key,
				animated: tabPaneAnimated,
				active,
				style: _objectSpread2(_objectSpread2({}, paneStyle), motionStyle),
				className: (0, import_classnames$162.default)(paneClassName, motionClassName),
				ref
			}));
		});
	})));
};
var TabPanelList_default = TabPanelList;

//#endregion
//#region node_modules/rc-tabs/es/hooks/useAnimateConfig.js
function useAnimateConfig$1() {
	var animated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
		inkBar: true,
		tabPane: false
	};
	var mergedAnimated;
	if (animated === false) mergedAnimated = {
		inkBar: false,
		tabPane: false
	};
	else if (animated === true) mergedAnimated = {
		inkBar: true,
		tabPane: false
	};
	else mergedAnimated = _objectSpread2({ inkBar: true }, _typeof(animated) === "object" ? animated : {});
	if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) mergedAnimated.tabPane = true;
	if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
		warning_default(false, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work.");
		mergedAnimated.tabPane = false;
	}
	return mergedAnimated;
}

//#endregion
//#region node_modules/rc-tabs/es/Tabs.js
var import_classnames$161 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$37 = [
	"id",
	"prefixCls",
	"className",
	"items",
	"direction",
	"activeKey",
	"defaultActiveKey",
	"editable",
	"animated",
	"tabPosition",
	"tabBarGutter",
	"tabBarStyle",
	"tabBarExtraContent",
	"locale",
	"more",
	"destroyInactiveTabPane",
	"renderTabBar",
	"onChange",
	"onTabClick",
	"onTabScroll",
	"getPopupContainer",
	"popupClassName",
	"indicator"
];
/**
* Should added antd:
* - type
*
* Removed:
* - onNextClick
* - onPrevClick
* - keyboard
*/
var uuid$1 = 0;
var Tabs$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var id = props.id, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tabs" : _props$prefixCls, className = props.className, items = props.items, direction = props.direction, activeKey = props.activeKey, defaultActiveKey = props.defaultActiveKey, editable = props.editable, animated = props.animated, _props$tabPosition = props.tabPosition, tabPosition = _props$tabPosition === void 0 ? "top" : _props$tabPosition, tabBarGutter = props.tabBarGutter, tabBarStyle = props.tabBarStyle, tabBarExtraContent = props.tabBarExtraContent, locale$5 = props.locale, more = props.more, destroyInactiveTabPane = props.destroyInactiveTabPane, renderTabBar = props.renderTabBar, onChange = props.onChange, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, getPopupContainer = props.getPopupContainer, popupClassName = props.popupClassName, indicator = props.indicator, restProps = _objectWithoutProperties(props, _excluded$37);
	var tabs = import_react.useMemo(function() {
		return (items || []).filter(function(item) {
			return item && _typeof(item) === "object" && "key" in item;
		});
	}, [items]);
	var rtl = direction === "rtl";
	var mergedAnimated = useAnimateConfig$1(animated);
	var _useState = (0, import_react.useState)(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
	(0, import_react.useEffect)(function() {
		setMobile(isMobile_default());
	}, []);
	var _useMergedState = useMergedState(function() {
		var _tabs$;
		return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
	}, {
		value: activeKey,
		defaultValue: defaultActiveKey
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
	var _useState3 = (0, import_react.useState)(function() {
		return tabs.findIndex(function(tab) {
			return tab.key === mergedActiveKey;
		});
	}), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
	(0, import_react.useEffect)(function() {
		var newActiveIndex = tabs.findIndex(function(tab) {
			return tab.key === mergedActiveKey;
		});
		if (newActiveIndex === -1) {
			var _tabs$newActiveIndex;
			newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
			setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
		}
		setActiveIndex(newActiveIndex);
	}, [
		tabs.map(function(tab) {
			return tab.key;
		}).join("_"),
		mergedActiveKey,
		activeIndex
	]);
	var _useMergedState3 = useMergedState(null, { value: id }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
	(0, import_react.useEffect)(function() {
		if (!id) {
			setMergedId("rc-tabs-".concat(uuid$1));
			uuid$1 += 1;
		}
	}, []);
	function onInternalTabClick(key, e$2) {
		onTabClick === null || onTabClick === void 0 || onTabClick(key, e$2);
		var isActiveChanged = key !== mergedActiveKey;
		setMergedActiveKey(key);
		if (isActiveChanged) onChange === null || onChange === void 0 || onChange(key);
	}
	var sharedProps = {
		id: mergedId,
		activeKey: mergedActiveKey,
		animated: mergedAnimated,
		tabPosition,
		rtl,
		mobile
	};
	var tabNavBarProps = _objectSpread2(_objectSpread2({}, sharedProps), {}, {
		editable,
		locale: locale$5,
		more,
		tabBarGutter,
		onTabClick: onInternalTabClick,
		onTabScroll,
		extra: tabBarExtraContent,
		style: tabBarStyle,
		panes: null,
		getPopupContainer,
		popupClassName,
		indicator
	});
	return /* @__PURE__ */ import_react.createElement(TabContext_default.Provider, { value: {
		tabs,
		prefixCls
	} }, /* @__PURE__ */ import_react.createElement("div", _extends({
		ref,
		id,
		className: (0, import_classnames$161.default)(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), _defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-mobile"), mobile), "".concat(prefixCls, "-editable"), editable), "".concat(prefixCls, "-rtl"), rtl), className)
	}, restProps), /* @__PURE__ */ import_react.createElement(Wrapper_default, _extends({}, tabNavBarProps, { renderTabBar })), /* @__PURE__ */ import_react.createElement(TabPanelList_default, _extends({ destroyInactiveTabPane }, sharedProps, { animated: mergedAnimated }))));
});
Tabs$1.displayName = "Tabs";
var Tabs_default = Tabs$1;

//#endregion
//#region node_modules/rc-tabs/es/index.js
var es_default$29 = Tabs_default;

//#endregion
//#region node_modules/antd/es/tabs/hooks/useAnimateConfig.js
var motion = {
	motionAppear: false,
	motionEnter: true,
	motionLeave: true
};
function useAnimateConfig(prefixCls, animated = {
	inkBar: true,
	tabPane: false
}) {
	let mergedAnimated;
	if (animated === false) mergedAnimated = {
		inkBar: false,
		tabPane: false
	};
	else if (animated === true) mergedAnimated = {
		inkBar: true,
		tabPane: true
	};
	else mergedAnimated = Object.assign({ inkBar: true }, typeof animated === "object" ? animated : {});
	if (mergedAnimated.tabPane) mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, motion), { motionName: getTransitionName(prefixCls, "switch") });
	return mergedAnimated;
}

//#endregion
//#region node_modules/antd/es/tabs/hooks/useLegacyItems.js
var __rest$80 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function filter$1(items) {
	return items.filter((item) => item);
}
function useLegacyItems$1(items, children) {
	devUseWarning("Tabs").deprecated(!children, "Tabs.TabPane", "items");
	if (items) return items.map((item) => {
		var _a;
		const mergedDestroyOnHidden = (_a = item.destroyOnHidden) !== null && _a !== void 0 ? _a : item.destroyInactiveTabPane;
		return Object.assign(Object.assign({}, item), { destroyInactiveTabPane: mergedDestroyOnHidden });
	});
	const childrenItems = toArray(children).map((node$1) => {
		if (/* @__PURE__ */ import_react.isValidElement(node$1)) {
			const { key, props } = node$1;
			const _a = props || {}, { tab } = _a, restProps = __rest$80(_a, ["tab"]);
			return Object.assign(Object.assign({ key: String(key) }, restProps), { label: tab });
		}
		return null;
	});
	return filter$1(childrenItems);
}
var useLegacyItems_default$1 = useLegacyItems$1;

//#endregion
//#region node_modules/antd/es/tabs/style/motion.js
var genMotionStyle$2 = (token$1) => {
	const { componentCls, motionDurationSlow } = token$1;
	return [{ [componentCls]: { [`${componentCls}-switch`]: {
		"&-appear, &-enter": {
			transition: "none",
			"&-start": { opacity: 0 },
			"&-active": {
				opacity: 1,
				transition: `opacity ${motionDurationSlow}`
			}
		},
		"&-leave": {
			position: "absolute",
			transition: "none",
			inset: 0,
			"&-start": { opacity: 1 },
			"&-active": {
				opacity: 0,
				transition: `opacity ${motionDurationSlow}`
			}
		}
	} } }, [initSlideMotion(token$1, "slide-up"), initSlideMotion(token$1, "slide-down")]];
};
var motion_default$3 = genMotionStyle$2;

//#endregion
//#region node_modules/antd/es/tabs/style/index.js
var genCardStyle$1 = (token$1) => {
	const { componentCls, tabsCardPadding, cardBg, cardGutter, colorBorderSecondary, itemSelectedColor } = token$1;
	return { [`${componentCls}-card`]: {
		[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: {
				margin: 0,
				padding: tabsCardPadding,
				background: cardBg,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
				transition: `all ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`
			},
			[`${componentCls}-tab-active`]: {
				color: itemSelectedColor,
				background: token$1.colorBgContainer
			},
			[`${componentCls}-tab-focus:has(${componentCls}-tab-btn:focus-visible)`]: genFocusOutline(token$1, -3),
			[`& ${componentCls}-tab${componentCls}-tab-focus ${componentCls}-tab-btn:focus-visible`]: { outline: "none" },
			[`${componentCls}-ink-bar`]: { visibility: "hidden" }
		},
		[`&${componentCls}-top, &${componentCls}-bottom`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-tab + ${componentCls}-tab`]: { marginLeft: {
			_skip_check_: true,
			value: unit(cardGutter)
		} } } },
		[`&${componentCls}-top`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: { borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0` },
			[`${componentCls}-tab-active`]: { borderBottomColor: token$1.colorBgContainer }
		} },
		[`&${componentCls}-bottom`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: { borderRadius: `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}` },
			[`${componentCls}-tab-active`]: { borderTopColor: token$1.colorBgContainer }
		} },
		[`&${componentCls}-left, &${componentCls}-right`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-tab + ${componentCls}-tab`]: { marginTop: unit(cardGutter) } } },
		[`&${componentCls}-left`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: { borderRadius: {
				_skip_check_: true,
				value: `${unit(token$1.borderRadiusLG)} 0 0 ${unit(token$1.borderRadiusLG)}`
			} },
			[`${componentCls}-tab-active`]: { borderRightColor: {
				_skip_check_: true,
				value: token$1.colorBgContainer
			} }
		} },
		[`&${componentCls}-right`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			[`${componentCls}-tab`]: { borderRadius: {
				_skip_check_: true,
				value: `0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0`
			} },
			[`${componentCls}-tab-active`]: { borderLeftColor: {
				_skip_check_: true,
				value: token$1.colorBgContainer
			} }
		} }
	} };
};
var genDropdownStyle = (token$1) => {
	const { componentCls, itemHoverColor, dropdownEdgeChildVerticalPadding } = token$1;
	return { [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "absolute",
		top: -9999,
		left: {
			_skip_check_: true,
			value: -9999
		},
		zIndex: token$1.zIndexPopup,
		display: "block",
		"&-hidden": { display: "none" },
		[`${componentCls}-dropdown-menu`]: {
			maxHeight: token$1.tabsDropdownHeight,
			margin: 0,
			padding: `${unit(dropdownEdgeChildVerticalPadding)} 0`,
			overflowX: "hidden",
			overflowY: "auto",
			textAlign: {
				_skip_check_: true,
				value: "left"
			},
			listStyleType: "none",
			backgroundColor: token$1.colorBgContainer,
			backgroundClip: "padding-box",
			borderRadius: token$1.borderRadiusLG,
			outline: "none",
			boxShadow: token$1.boxShadowSecondary,
			"&-item": Object.assign(Object.assign({}, textEllipsis), {
				display: "flex",
				alignItems: "center",
				minWidth: token$1.tabsDropdownWidth,
				margin: 0,
				padding: `${unit(token$1.paddingXXS)} ${unit(token$1.paddingSM)}`,
				color: token$1.colorText,
				fontWeight: "normal",
				fontSize: token$1.fontSize,
				lineHeight: token$1.lineHeight,
				cursor: "pointer",
				transition: `all ${token$1.motionDurationSlow}`,
				"> span": {
					flex: 1,
					whiteSpace: "nowrap"
				},
				"&-remove": {
					flex: "none",
					marginLeft: {
						_skip_check_: true,
						value: token$1.marginSM
					},
					color: token$1.colorIcon,
					fontSize: token$1.fontSizeSM,
					background: "transparent",
					border: 0,
					cursor: "pointer",
					"&:hover": { color: itemHoverColor }
				},
				"&:hover": { background: token$1.controlItemBgHover },
				"&-disabled": { "&, &:hover": {
					color: token$1.colorTextDisabled,
					background: "transparent",
					cursor: "not-allowed"
				} }
			})
		}
	}) };
};
var genPositionStyle = (token$1) => {
	const { componentCls, margin, colorBorderSecondary, horizontalMargin, verticalItemPadding, verticalItemMargin, calc } = token$1;
	return {
		[`${componentCls}-top, ${componentCls}-bottom`]: {
			flexDirection: "column",
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
				margin: horizontalMargin,
				"&::before": {
					position: "absolute",
					right: {
						_skip_check_: true,
						value: 0
					},
					left: {
						_skip_check_: true,
						value: 0
					},
					borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
					content: "''"
				},
				[`${componentCls}-ink-bar`]: {
					height: token$1.lineWidthBold,
					"&-animated": { transition: `width ${token$1.motionDurationSlow}, left ${token$1.motionDurationSlow},
            right ${token$1.motionDurationSlow}` }
				},
				[`${componentCls}-nav-wrap`]: {
					"&::before, &::after": {
						top: 0,
						bottom: 0,
						width: token$1.controlHeight
					},
					"&::before": {
						left: {
							_skip_check_: true,
							value: 0
						},
						boxShadow: token$1.boxShadowTabsOverflowLeft
					},
					"&::after": {
						right: {
							_skip_check_: true,
							value: 0
						},
						boxShadow: token$1.boxShadowTabsOverflowRight
					},
					[`&${componentCls}-nav-wrap-ping-left::before`]: { opacity: 1 },
					[`&${componentCls}-nav-wrap-ping-right::after`]: { opacity: 1 }
				}
			}
		},
		[`${componentCls}-top`]: { [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
			"&::before": { bottom: 0 },
			[`${componentCls}-ink-bar`]: { bottom: 0 }
		} },
		[`${componentCls}-bottom`]: {
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
				order: 1,
				marginTop: margin,
				marginBottom: 0,
				"&::before": { top: 0 },
				[`${componentCls}-ink-bar`]: { top: 0 }
			},
			[`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: { order: 0 }
		},
		[`${componentCls}-left, ${componentCls}-right`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
			flexDirection: "column",
			minWidth: calc(token$1.controlHeight).mul(1.25).equal(),
			[`${componentCls}-tab`]: {
				padding: verticalItemPadding,
				textAlign: "center"
			},
			[`${componentCls}-tab + ${componentCls}-tab`]: { margin: verticalItemMargin },
			[`${componentCls}-nav-wrap`]: {
				flexDirection: "column",
				"&::before, &::after": {
					right: {
						_skip_check_: true,
						value: 0
					},
					left: {
						_skip_check_: true,
						value: 0
					},
					height: token$1.controlHeight
				},
				"&::before": {
					top: 0,
					boxShadow: token$1.boxShadowTabsOverflowTop
				},
				"&::after": {
					bottom: 0,
					boxShadow: token$1.boxShadowTabsOverflowBottom
				},
				[`&${componentCls}-nav-wrap-ping-top::before`]: { opacity: 1 },
				[`&${componentCls}-nav-wrap-ping-bottom::after`]: { opacity: 1 }
			},
			[`${componentCls}-ink-bar`]: {
				width: token$1.lineWidthBold,
				"&-animated": { transition: `height ${token$1.motionDurationSlow}, top ${token$1.motionDurationSlow}` }
			},
			[`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
				flex: "1 0 auto",
				flexDirection: "column"
			}
		} },
		[`${componentCls}-left`]: {
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-ink-bar`]: { right: {
				_skip_check_: true,
				value: 0
			} } },
			[`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
				marginLeft: {
					_skip_check_: true,
					value: unit(calc(token$1.lineWidth).mul(-1).equal())
				},
				borderLeft: {
					_skip_check_: true,
					value: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
				},
				[`> ${componentCls}-content > ${componentCls}-tabpane`]: { paddingLeft: {
					_skip_check_: true,
					value: token$1.paddingLG
				} }
			}
		},
		[`${componentCls}-right`]: {
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
				order: 1,
				[`${componentCls}-ink-bar`]: { left: {
					_skip_check_: true,
					value: 0
				} }
			},
			[`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
				order: 0,
				marginRight: {
					_skip_check_: true,
					value: calc(token$1.lineWidth).mul(-1).equal()
				},
				borderRight: {
					_skip_check_: true,
					value: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
				},
				[`> ${componentCls}-content > ${componentCls}-tabpane`]: { paddingRight: {
					_skip_check_: true,
					value: token$1.paddingLG
				} }
			}
		}
	};
};
var genSizeStyle$2 = (token$1) => {
	const { componentCls, cardPaddingSM, cardPaddingLG, cardHeightSM, cardHeightLG, horizontalItemPaddingSM, horizontalItemPaddingLG } = token$1;
	return {
		[componentCls]: {
			"&-small": { [`> ${componentCls}-nav`]: { [`${componentCls}-tab`]: {
				padding: horizontalItemPaddingSM,
				fontSize: token$1.titleFontSizeSM
			} } },
			"&-large": { [`> ${componentCls}-nav`]: { [`${componentCls}-tab`]: {
				padding: horizontalItemPaddingLG,
				fontSize: token$1.titleFontSizeLG,
				lineHeight: token$1.lineHeightLG
			} } }
		},
		[`${componentCls}-card`]: {
			[`&${componentCls}-small`]: {
				[`> ${componentCls}-nav`]: {
					[`${componentCls}-tab`]: { padding: cardPaddingSM },
					[`${componentCls}-nav-add`]: {
						minWidth: cardHeightSM,
						minHeight: cardHeightSM
					}
				},
				[`&${componentCls}-bottom`]: { [`> ${componentCls}-nav ${componentCls}-tab`]: { borderRadius: `0 0 ${unit(token$1.borderRadius)} ${unit(token$1.borderRadius)}` } },
				[`&${componentCls}-top`]: { [`> ${componentCls}-nav ${componentCls}-tab`]: { borderRadius: `${unit(token$1.borderRadius)} ${unit(token$1.borderRadius)} 0 0` } },
				[`&${componentCls}-right`]: { [`> ${componentCls}-nav ${componentCls}-tab`]: { borderRadius: {
					_skip_check_: true,
					value: `0 ${unit(token$1.borderRadius)} ${unit(token$1.borderRadius)} 0`
				} } },
				[`&${componentCls}-left`]: { [`> ${componentCls}-nav ${componentCls}-tab`]: { borderRadius: {
					_skip_check_: true,
					value: `${unit(token$1.borderRadius)} 0 0 ${unit(token$1.borderRadius)}`
				} } }
			},
			[`&${componentCls}-large`]: { [`> ${componentCls}-nav`]: {
				[`${componentCls}-tab`]: { padding: cardPaddingLG },
				[`${componentCls}-nav-add`]: {
					minWidth: cardHeightLG,
					minHeight: cardHeightLG
				}
			} }
		}
	};
};
var genTabStyle = (token$1) => {
	const { componentCls, itemActiveColor, itemHoverColor, iconCls, tabsHorizontalItemMargin, horizontalItemPadding, itemSelectedColor, itemColor } = token$1;
	const tabCls = `${componentCls}-tab`;
	return {
		[tabCls]: {
			position: "relative",
			WebkitTouchCallout: "none",
			WebkitTapHighlightColor: "transparent",
			display: "inline-flex",
			alignItems: "center",
			padding: horizontalItemPadding,
			fontSize: token$1.titleFontSize,
			background: "transparent",
			border: 0,
			outline: "none",
			cursor: "pointer",
			color: itemColor,
			"&-btn, &-remove": { "&:focus:not(:focus-visible), &:active": { color: itemActiveColor } },
			"&-btn": {
				outline: "none",
				transition: `all ${token$1.motionDurationSlow}`,
				[`${tabCls}-icon:not(:last-child)`]: { marginInlineEnd: token$1.marginSM }
			},
			"&-remove": Object.assign({
				flex: "none",
				lineHeight: 1,
				marginRight: {
					_skip_check_: true,
					value: token$1.calc(token$1.marginXXS).mul(-1).equal()
				},
				marginLeft: {
					_skip_check_: true,
					value: token$1.marginXS
				},
				color: token$1.colorIcon,
				fontSize: token$1.fontSizeSM,
				background: "transparent",
				border: "none",
				outline: "none",
				cursor: "pointer",
				transition: `all ${token$1.motionDurationSlow}`,
				"&:hover": { color: token$1.colorTextHeading }
			}, genFocusStyle(token$1)),
			"&:hover": { color: itemHoverColor },
			[`&${tabCls}-active ${tabCls}-btn`]: {
				color: itemSelectedColor,
				textShadow: token$1.tabsActiveTextShadow
			},
			[`&${tabCls}-focus ${tabCls}-btn:focus-visible`]: genFocusOutline(token$1),
			[`&${tabCls}-disabled`]: {
				color: token$1.colorTextDisabled,
				cursor: "not-allowed"
			},
			[`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: { "&:focus, &:active": { color: token$1.colorTextDisabled } },
			[`& ${tabCls}-remove ${iconCls}`]: {
				margin: 0,
				verticalAlign: "middle"
			},
			[`${iconCls}:not(:last-child)`]: { marginRight: {
				_skip_check_: true,
				value: token$1.marginSM
			} }
		},
		[`${tabCls} + ${tabCls}`]: { margin: {
			_skip_check_: true,
			value: tabsHorizontalItemMargin
		} }
	};
};
var genRtlStyle$3 = (token$1) => {
	const { componentCls, tabsHorizontalItemMarginRTL, iconCls, cardGutter, calc } = token$1;
	return {
		[`${componentCls}-rtl`]: {
			direction: "rtl",
			[`${componentCls}-nav`]: { [`${componentCls}-tab`]: {
				margin: {
					_skip_check_: true,
					value: tabsHorizontalItemMarginRTL
				},
				[`${componentCls}-tab:last-of-type`]: { marginLeft: {
					_skip_check_: true,
					value: 0
				} },
				[iconCls]: {
					marginRight: {
						_skip_check_: true,
						value: 0
					},
					marginLeft: {
						_skip_check_: true,
						value: unit(token$1.marginSM)
					}
				},
				[`${componentCls}-tab-remove`]: {
					marginRight: {
						_skip_check_: true,
						value: unit(token$1.marginXS)
					},
					marginLeft: {
						_skip_check_: true,
						value: unit(calc(token$1.marginXXS).mul(-1).equal())
					},
					[iconCls]: { margin: 0 }
				}
			} },
			[`&${componentCls}-left`]: {
				[`> ${componentCls}-nav`]: { order: 1 },
				[`> ${componentCls}-content-holder`]: { order: 0 }
			},
			[`&${componentCls}-right`]: {
				[`> ${componentCls}-nav`]: { order: 0 },
				[`> ${componentCls}-content-holder`]: { order: 1 }
			},
			[`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-tab + ${componentCls}-tab`]: {
				marginRight: {
					_skip_check_: true,
					value: cardGutter
				},
				marginLeft: {
					_skip_check_: true,
					value: 0
				}
			} } }
		},
		[`${componentCls}-dropdown-rtl`]: { direction: "rtl" },
		[`${componentCls}-menu-item`]: { [`${componentCls}-dropdown-rtl`]: { textAlign: {
			_skip_check_: true,
			value: "right"
		} } }
	};
};
var genTabsStyle = (token$1) => {
	const { componentCls, tabsCardPadding, cardHeight, cardGutter, itemHoverColor, itemActiveColor, colorBorderSecondary } = token$1;
	return {
		[componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
			display: "flex",
			[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
				position: "relative",
				display: "flex",
				flex: "none",
				alignItems: "center",
				[`${componentCls}-nav-wrap`]: {
					position: "relative",
					display: "flex",
					flex: "auto",
					alignSelf: "stretch",
					overflow: "hidden",
					whiteSpace: "nowrap",
					transform: "translate(0)",
					"&::before, &::after": {
						position: "absolute",
						zIndex: 1,
						opacity: 0,
						transition: `opacity ${token$1.motionDurationSlow}`,
						content: "''",
						pointerEvents: "none"
					}
				},
				[`${componentCls}-nav-list`]: {
					position: "relative",
					display: "flex",
					transition: `opacity ${token$1.motionDurationSlow}`
				},
				[`${componentCls}-nav-operations`]: {
					display: "flex",
					alignSelf: "stretch"
				},
				[`${componentCls}-nav-operations-hidden`]: {
					position: "absolute",
					visibility: "hidden",
					pointerEvents: "none"
				},
				[`${componentCls}-nav-more`]: {
					position: "relative",
					padding: tabsCardPadding,
					background: "transparent",
					border: 0,
					color: token$1.colorText,
					"&::after": {
						position: "absolute",
						right: {
							_skip_check_: true,
							value: 0
						},
						bottom: 0,
						left: {
							_skip_check_: true,
							value: 0
						},
						height: token$1.calc(token$1.controlHeightLG).div(8).equal(),
						transform: "translateY(100%)",
						content: "''"
					}
				},
				[`${componentCls}-nav-add`]: Object.assign({
					minWidth: cardHeight,
					minHeight: cardHeight,
					marginLeft: {
						_skip_check_: true,
						value: cardGutter
					},
					background: "transparent",
					border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
					borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0`,
					outline: "none",
					cursor: "pointer",
					color: token$1.colorText,
					transition: `all ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`,
					"&:hover": { color: itemHoverColor },
					"&:active, &:focus:not(:focus-visible)": { color: itemActiveColor }
				}, genFocusStyle(token$1, -3))
			},
			[`${componentCls}-extra-content`]: { flex: "none" },
			[`${componentCls}-ink-bar`]: {
				position: "absolute",
				background: token$1.inkBarColor,
				pointerEvents: "none"
			}
		}), genTabStyle(token$1)), {
			[`${componentCls}-content`]: {
				position: "relative",
				width: "100%"
			},
			[`${componentCls}-content-holder`]: {
				flex: "auto",
				minWidth: 0,
				minHeight: 0
			},
			[`${componentCls}-tabpane`]: Object.assign(Object.assign({}, genFocusStyle(token$1)), { "&-hidden": { display: "none" } })
		}),
		[`${componentCls}-centered`]: { [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: { [`${componentCls}-nav-wrap`]: { [`&:not([class*='${componentCls}-nav-wrap-ping']) > ${componentCls}-nav-list`]: { margin: "auto" } } } }
	};
};
const prepareComponentToken$34 = (token$1) => {
	const { cardHeight, cardHeightSM, cardHeightLG, controlHeight, controlHeightLG } = token$1;
	const mergedCardHeight = cardHeight || controlHeightLG;
	const mergedCardHeightSM = cardHeightSM || controlHeight;
	const mergedCardHeightLG = cardHeightLG || controlHeightLG + 8;
	return {
		zIndexPopup: token$1.zIndexPopupBase + 50,
		cardBg: token$1.colorFillAlter,
		cardHeight: mergedCardHeight,
		cardHeightSM: mergedCardHeightSM,
		cardHeightLG: mergedCardHeightLG,
		cardPadding: `${(mergedCardHeight - token$1.fontHeight) / 2 - token$1.lineWidth}px ${token$1.padding}px`,
		cardPaddingSM: `${(mergedCardHeightSM - token$1.fontHeight) / 2 - token$1.lineWidth}px ${token$1.paddingXS}px`,
		cardPaddingLG: `${(mergedCardHeightLG - token$1.fontHeightLG) / 2 - token$1.lineWidth}px ${token$1.padding}px`,
		titleFontSize: token$1.fontSize,
		titleFontSizeLG: token$1.fontSizeLG,
		titleFontSizeSM: token$1.fontSize,
		inkBarColor: token$1.colorPrimary,
		horizontalMargin: `0 0 ${token$1.margin}px 0`,
		horizontalItemGutter: 32,
		horizontalItemMargin: ``,
		horizontalItemMarginRTL: ``,
		horizontalItemPadding: `${token$1.paddingSM}px 0`,
		horizontalItemPaddingSM: `${token$1.paddingXS}px 0`,
		horizontalItemPaddingLG: `${token$1.padding}px 0`,
		verticalItemPadding: `${token$1.paddingXS}px ${token$1.paddingLG}px`,
		verticalItemMargin: `${token$1.margin}px 0 0 0`,
		itemColor: token$1.colorText,
		itemSelectedColor: token$1.colorPrimary,
		itemHoverColor: token$1.colorPrimaryHover,
		itemActiveColor: token$1.colorPrimaryActive,
		cardGutter: token$1.marginXXS / 2
	};
};
var style_default$42 = genStyleHooks("Tabs", (token$1) => {
	const tabsToken = merge(token$1, {
		tabsCardPadding: token$1.cardPadding,
		dropdownEdgeChildVerticalPadding: token$1.paddingXXS,
		tabsActiveTextShadow: "0 0 0.25px currentcolor",
		tabsDropdownHeight: 200,
		tabsDropdownWidth: 120,
		tabsHorizontalItemMargin: `0 0 0 ${unit(token$1.horizontalItemGutter)}`,
		tabsHorizontalItemMarginRTL: `0 0 0 ${unit(token$1.horizontalItemGutter)}`
	});
	return [
		genSizeStyle$2(tabsToken),
		genRtlStyle$3(tabsToken),
		genPositionStyle(tabsToken),
		genDropdownStyle(tabsToken),
		genCardStyle$1(tabsToken),
		genTabsStyle(tabsToken),
		motion_default$3(tabsToken)
	];
}, prepareComponentToken$34);

//#endregion
//#region node_modules/antd/es/tabs/TabPane.js
var TabPane = () => null;
TabPane.displayName = "DeprecatedTabPane";
var TabPane_default = TabPane;

//#endregion
//#region node_modules/antd/es/tabs/index.js
var import_classnames$160 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$79 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Tabs = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
	const { type: type$2, className, rootClassName, size: customSize, onEdit, hideAdd, centered, addIcon, removeIcon, moreIcon, more, popupClassName, children, items, animated, style: style$1, indicatorSize, indicator, destroyInactiveTabPane, destroyOnHidden } = props, otherProps = __rest$79(props, [
		"type",
		"className",
		"rootClassName",
		"size",
		"onEdit",
		"hideAdd",
		"centered",
		"addIcon",
		"removeIcon",
		"moreIcon",
		"more",
		"popupClassName",
		"children",
		"items",
		"animated",
		"style",
		"indicatorSize",
		"indicator",
		"destroyInactiveTabPane",
		"destroyOnHidden"
	]);
	const { prefixCls: customizePrefixCls } = otherProps;
	const { direction, tabs, getPrefixCls, getPopupContainer } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("tabs", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$42(prefixCls, rootCls);
	const tabsRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: tabsRef.current }));
	let editable;
	if (type$2 === "editable-card") editable = {
		onEdit: (editType, { key, event }) => {
			onEdit === null || onEdit === void 0 || onEdit(editType === "add" ? event : key, editType);
		},
		removeIcon: (_a = removeIcon !== null && removeIcon !== void 0 ? removeIcon : tabs === null || tabs === void 0 ? void 0 : tabs.removeIcon) !== null && _a !== void 0 ? _a : /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null),
		addIcon: (addIcon !== null && addIcon !== void 0 ? addIcon : tabs === null || tabs === void 0 ? void 0 : tabs.addIcon) || /* @__PURE__ */ import_react.createElement(PlusOutlined_default, null),
		showAdd: hideAdd !== true
	};
	const rootPrefixCls = getPrefixCls();
	{
		const warning$4 = devUseWarning("Tabs");
		warning$4(!("onPrevClick" in props) && !("onNextClick" in props), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead.");
		warning$4(!(indicatorSize || (tabs === null || tabs === void 0 ? void 0 : tabs.indicatorSize)), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.");
		warning$4.deprecated(!("destroyInactiveTabPane" in props || (items === null || items === void 0 ? void 0 : items.some((item) => "destroyInactiveTabPane" in item))), "destroyInactiveTabPane", "destroyOnHidden");
	}
	const size = useSize_default(customSize);
	const mergedItems = useLegacyItems_default$1(items, children);
	const mergedAnimated = useAnimateConfig(prefixCls, animated);
	const mergedStyle = Object.assign(Object.assign({}, tabs === null || tabs === void 0 ? void 0 : tabs.style), style$1);
	const mergedIndicator = {
		align: (_b = indicator === null || indicator === void 0 ? void 0 : indicator.align) !== null && _b !== void 0 ? _b : (_c = tabs === null || tabs === void 0 ? void 0 : tabs.indicator) === null || _c === void 0 ? void 0 : _c.align,
		size: (_g = (_e = (_d = indicator === null || indicator === void 0 ? void 0 : indicator.size) !== null && _d !== void 0 ? _d : indicatorSize) !== null && _e !== void 0 ? _e : (_f = tabs === null || tabs === void 0 ? void 0 : tabs.indicator) === null || _f === void 0 ? void 0 : _f.size) !== null && _g !== void 0 ? _g : tabs === null || tabs === void 0 ? void 0 : tabs.indicatorSize
	};
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$29, Object.assign({
		ref: tabsRef,
		direction,
		getPopupContainer
	}, otherProps, {
		items: mergedItems,
		className: (0, import_classnames$160.default)({
			[`${prefixCls}-${size}`]: size,
			[`${prefixCls}-card`]: ["card", "editable-card"].includes(type$2),
			[`${prefixCls}-editable-card`]: type$2 === "editable-card",
			[`${prefixCls}-centered`]: centered
		}, tabs === null || tabs === void 0 ? void 0 : tabs.className, className, rootClassName, hashId, cssVarCls, rootCls),
		popupClassName: (0, import_classnames$160.default)(popupClassName, hashId, cssVarCls, rootCls),
		style: mergedStyle,
		editable,
		more: Object.assign({
			icon: (_l = (_k = (_j = (_h = tabs === null || tabs === void 0 ? void 0 : tabs.more) === null || _h === void 0 ? void 0 : _h.icon) !== null && _j !== void 0 ? _j : tabs === null || tabs === void 0 ? void 0 : tabs.moreIcon) !== null && _k !== void 0 ? _k : moreIcon) !== null && _l !== void 0 ? _l : /* @__PURE__ */ import_react.createElement(EllipsisOutlined_default, null),
			transitionName: `${rootPrefixCls}-slide-up`
		}, more),
		prefixCls,
		animated: mergedAnimated,
		indicator: mergedIndicator,
		destroyInactiveTabPane: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyInactiveTabPane
	})));
});
Tabs.TabPane = TabPane_default;
Tabs.displayName = "Tabs";
var tabs_default = Tabs;

//#endregion
//#region node_modules/antd/es/card/Grid.js
var import_classnames$159 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$78 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Grid = (_a) => {
	var { prefixCls, className, hoverable = true } = _a, props = __rest$78(_a, [
		"prefixCls",
		"className",
		"hoverable"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefix = getPrefixCls("card", prefixCls);
	const classString = (0, import_classnames$159.default)(`${prefix}-grid`, className, { [`${prefix}-grid-hoverable`]: hoverable });
	return /* @__PURE__ */ import_react.createElement("div", Object.assign({}, props, { className: classString }));
};
var Grid_default = Grid;

//#endregion
//#region node_modules/antd/es/card/style/index.js
var genCardHeadStyle = (token$1) => {
	const { antCls, componentCls, headerHeight, headerPadding, tabsMarginBottom } = token$1;
	return Object.assign(Object.assign({
		display: "flex",
		justifyContent: "center",
		flexDirection: "column",
		minHeight: headerHeight,
		marginBottom: -1,
		padding: `0 ${unit(headerPadding)}`,
		color: token$1.colorTextHeading,
		fontWeight: token$1.fontWeightStrong,
		fontSize: token$1.headerFontSize,
		background: token$1.headerBg,
		borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorderSecondary}`,
		borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0`
	}, clearFix()), {
		"&-wrapper": {
			width: "100%",
			display: "flex",
			alignItems: "center"
		},
		"&-title": Object.assign(Object.assign({
			display: "inline-block",
			flex: 1
		}, textEllipsis), { [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
			insetInlineStart: 0,
			marginTop: 0,
			marginBottom: 0
		} }),
		[`${antCls}-tabs-top`]: {
			clear: "both",
			marginBottom: tabsMarginBottom,
			color: token$1.colorText,
			fontWeight: "normal",
			fontSize: token$1.fontSize,
			"&-bar": { borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorderSecondary}` }
		}
	});
};
var genCardGridStyle = (token$1) => {
	const { cardPaddingBase, colorBorderSecondary, cardShadow, lineWidth } = token$1;
	return {
		width: "33.33%",
		padding: cardPaddingBase,
		border: 0,
		borderRadius: 0,
		boxShadow: `
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary},
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary} inset,
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary} inset;
    `,
		transition: `all ${token$1.motionDurationMid}`,
		"&-hoverable:hover": {
			position: "relative",
			zIndex: 1,
			boxShadow: cardShadow
		}
	};
};
var genCardActionsStyle = (token$1) => {
	const { componentCls, iconCls, actionsLiMargin, cardActionsIconSize, colorBorderSecondary, actionsBg } = token$1;
	return Object.assign(Object.assign({
		margin: 0,
		padding: 0,
		listStyle: "none",
		background: actionsBg,
		borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
		display: "flex",
		borderRadius: `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}`
	}, clearFix()), { "& > li": {
		margin: actionsLiMargin,
		color: token$1.colorTextDescription,
		textAlign: "center",
		"> span": {
			position: "relative",
			display: "block",
			minWidth: token$1.calc(token$1.cardActionsIconSize).mul(2).equal(),
			fontSize: token$1.fontSize,
			lineHeight: token$1.lineHeight,
			cursor: "pointer",
			"&:hover": {
				color: token$1.colorPrimary,
				transition: `color ${token$1.motionDurationMid}`
			},
			[`a:not(${componentCls}-btn), > ${iconCls}`]: {
				display: "inline-block",
				width: "100%",
				color: token$1.colorIcon,
				lineHeight: unit(token$1.fontHeight),
				transition: `color ${token$1.motionDurationMid}`,
				"&:hover": { color: token$1.colorPrimary }
			},
			[`> ${iconCls}`]: {
				fontSize: cardActionsIconSize,
				lineHeight: unit(token$1.calc(cardActionsIconSize).mul(token$1.lineHeight).equal())
			}
		},
		"&:not(:last-child)": { borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}` }
	} });
};
var genCardMetaStyle = (token$1) => Object.assign(Object.assign({
	margin: `${unit(token$1.calc(token$1.marginXXS).mul(-1).equal())} 0`,
	display: "flex"
}, clearFix()), {
	"&-avatar": { paddingInlineEnd: token$1.padding },
	"&-detail": {
		overflow: "hidden",
		flex: 1,
		"> div:not(:last-child)": { marginBottom: token$1.marginXS }
	},
	"&-title": Object.assign({
		color: token$1.colorTextHeading,
		fontWeight: token$1.fontWeightStrong,
		fontSize: token$1.fontSizeLG
	}, textEllipsis),
	"&-description": { color: token$1.colorTextDescription }
});
var genCardTypeInnerStyle = (token$1) => {
	const { componentCls, colorFillAlter, headerPadding, bodyPadding } = token$1;
	return {
		[`${componentCls}-head`]: {
			padding: `0 ${unit(headerPadding)}`,
			background: colorFillAlter,
			"&-title": { fontSize: token$1.fontSize }
		},
		[`${componentCls}-body`]: { padding: `${unit(token$1.padding)} ${unit(bodyPadding)}` }
	};
};
var genCardLoadingStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		overflow: "hidden",
		[`${componentCls}-body`]: { userSelect: "none" }
	};
};
var genCardStyle = (token$1) => {
	const { componentCls, cardShadow, cardHeadPadding, colorBorderSecondary, boxShadowTertiary, bodyPadding, extraColor } = token$1;
	return {
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "relative",
			background: token$1.colorBgContainer,
			borderRadius: token$1.borderRadiusLG,
			[`&:not(${componentCls}-bordered)`]: { boxShadow: boxShadowTertiary },
			[`${componentCls}-head`]: genCardHeadStyle(token$1),
			[`${componentCls}-extra`]: {
				marginInlineStart: "auto",
				color: extraColor,
				fontWeight: "normal",
				fontSize: token$1.fontSize
			},
			[`${componentCls}-body`]: Object.assign({
				padding: bodyPadding,
				borderRadius: `0 0 ${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)}`
			}, clearFix()),
			[`${componentCls}-grid`]: genCardGridStyle(token$1),
			[`${componentCls}-cover`]: { "> *": {
				display: "block",
				width: "100%",
				borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0`
			} },
			[`${componentCls}-actions`]: genCardActionsStyle(token$1),
			[`${componentCls}-meta`]: genCardMetaStyle(token$1)
		}),
		[`${componentCls}-bordered`]: {
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${colorBorderSecondary}`,
			[`${componentCls}-cover`]: {
				marginTop: -1,
				marginInlineStart: -1,
				marginInlineEnd: -1
			}
		},
		[`${componentCls}-hoverable`]: {
			cursor: "pointer",
			transition: `box-shadow ${token$1.motionDurationMid}, border-color ${token$1.motionDurationMid}`,
			"&:hover": {
				borderColor: "transparent",
				boxShadow: cardShadow
			}
		},
		[`${componentCls}-contain-grid`]: {
			borderRadius: `${unit(token$1.borderRadiusLG)} ${unit(token$1.borderRadiusLG)} 0 0 `,
			[`${componentCls}-body`]: {
				display: "flex",
				flexWrap: "wrap"
			},
			[`&:not(${componentCls}-loading) ${componentCls}-body`]: {
				marginBlockStart: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				marginInlineStart: token$1.calc(token$1.lineWidth).mul(-1).equal(),
				padding: 0
			}
		},
		[`${componentCls}-contain-tabs`]: { [`> div${componentCls}-head`]: {
			minHeight: 0,
			[`${componentCls}-head-title, ${componentCls}-extra`]: { paddingTop: cardHeadPadding }
		} },
		[`${componentCls}-type-inner`]: genCardTypeInnerStyle(token$1),
		[`${componentCls}-loading`]: genCardLoadingStyle(token$1),
		[`${componentCls}-rtl`]: { direction: "rtl" }
	};
};
var genCardSizeStyle = (token$1) => {
	const { componentCls, bodyPaddingSM, headerPaddingSM, headerHeightSM, headerFontSizeSM } = token$1;
	return {
		[`${componentCls}-small`]: {
			[`> ${componentCls}-head`]: {
				minHeight: headerHeightSM,
				padding: `0 ${unit(headerPaddingSM)}`,
				fontSize: headerFontSizeSM,
				[`> ${componentCls}-head-wrapper`]: { [`> ${componentCls}-extra`]: { fontSize: token$1.fontSize } }
			},
			[`> ${componentCls}-body`]: { padding: bodyPaddingSM }
		},
		[`${componentCls}-small${componentCls}-contain-tabs`]: { [`> ${componentCls}-head`]: { [`${componentCls}-head-title, ${componentCls}-extra`]: {
			paddingTop: 0,
			display: "flex",
			alignItems: "center"
		} } }
	};
};
const prepareComponentToken$33 = (token$1) => {
	var _a, _b;
	return {
		headerBg: "transparent",
		headerFontSize: token$1.fontSizeLG,
		headerFontSizeSM: token$1.fontSize,
		headerHeight: token$1.fontSizeLG * token$1.lineHeightLG + token$1.padding * 2,
		headerHeightSM: token$1.fontSize * token$1.lineHeight + token$1.paddingXS * 2,
		actionsBg: token$1.colorBgContainer,
		actionsLiMargin: `${token$1.paddingSM}px 0`,
		tabsMarginBottom: -token$1.padding - token$1.lineWidth,
		extraColor: token$1.colorText,
		bodyPaddingSM: 12,
		headerPaddingSM: 12,
		bodyPadding: (_a = token$1.bodyPadding) !== null && _a !== void 0 ? _a : token$1.paddingLG,
		headerPadding: (_b = token$1.headerPadding) !== null && _b !== void 0 ? _b : token$1.paddingLG
	};
};
var style_default$41 = genStyleHooks("Card", (token$1) => {
	const cardToken = merge(token$1, {
		cardShadow: token$1.boxShadowCard,
		cardHeadPadding: token$1.padding,
		cardPaddingBase: token$1.paddingLG,
		cardActionsIconSize: token$1.fontSize
	});
	return [genCardStyle(cardToken), genCardSizeStyle(cardToken)];
}, prepareComponentToken$33);

//#endregion
//#region node_modules/antd/es/card/Card.js
var import_classnames$158 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$77 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var ActionNode = (props) => {
	const { actionClasses, actions = [], actionStyle } = props;
	return /* @__PURE__ */ import_react.createElement("ul", {
		className: actionClasses,
		style: actionStyle
	}, actions.map((action, index$2) => {
		const key = `action-${index$2}`;
		return /* @__PURE__ */ import_react.createElement("li", {
			style: { width: `${100 / actions.length}%` },
			key
		}, /* @__PURE__ */ import_react.createElement("span", null, action));
	}));
};
var Card$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, extra, headStyle = {}, bodyStyle = {}, title, loading, bordered, variant: customVariant, size: customizeSize, type: type$2, cover, actions, tabList, children, activeTabKey, defaultActiveTabKey, tabBarExtraContent, hoverable, tabProps = {}, classNames: customClassNames, styles: customStyles } = props, others = __rest$77(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"style",
		"extra",
		"headStyle",
		"bodyStyle",
		"title",
		"loading",
		"bordered",
		"variant",
		"size",
		"type",
		"cover",
		"actions",
		"tabList",
		"children",
		"activeTabKey",
		"defaultActiveTabKey",
		"tabBarExtraContent",
		"hoverable",
		"tabProps",
		"classNames",
		"styles"
	]);
	const { getPrefixCls, direction, card } = import_react.useContext(ConfigContext);
	const [variant] = useVariants_default("card", customVariant, bordered);
	{
		const warning$4 = devUseWarning("Card");
		[
			["headStyle", "styles.header"],
			["bodyStyle", "styles.body"],
			["bordered", "variant"]
		].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const onTabChange = (key) => {
		var _a;
		(_a = props.onTabChange) === null || _a === void 0 || _a.call(props, key);
	};
	const moduleClass = (moduleName) => {
		var _a;
		return (0, import_classnames$158.default)((_a = card === null || card === void 0 ? void 0 : card.classNames) === null || _a === void 0 ? void 0 : _a[moduleName], customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames[moduleName]);
	};
	const moduleStyle = (moduleName) => {
		var _a;
		return Object.assign(Object.assign({}, (_a = card === null || card === void 0 ? void 0 : card.styles) === null || _a === void 0 ? void 0 : _a[moduleName]), customStyles === null || customStyles === void 0 ? void 0 : customStyles[moduleName]);
	};
	const isContainGrid = import_react.useMemo(() => {
		let containGrid = false;
		import_react.Children.forEach(children, (element) => {
			if ((element === null || element === void 0 ? void 0 : element.type) === Grid_default) containGrid = true;
		});
		return containGrid;
	}, [children]);
	const prefixCls = getPrefixCls("card", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$41(prefixCls);
	const loadingBlock = /* @__PURE__ */ import_react.createElement(skeleton_default, {
		loading: true,
		active: true,
		paragraph: { rows: 4 },
		title: false
	}, children);
	const hasActiveTabKey = activeTabKey !== void 0;
	const extraProps = Object.assign(Object.assign({}, tabProps), {
		[hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
		tabBarExtraContent
	});
	let head;
	const mergedSize = useSize_default(customizeSize);
	const tabSize = !mergedSize || mergedSize === "default" ? "large" : mergedSize;
	const tabs = tabList ? /* @__PURE__ */ import_react.createElement(tabs_default, Object.assign({ size: tabSize }, extraProps, {
		className: `${prefixCls}-head-tabs`,
		onChange: onTabChange,
		items: tabList.map((_a) => {
			var { tab } = _a, item = __rest$77(_a, ["tab"]);
			return Object.assign({ label: tab }, item);
		})
	})) : null;
	if (title || extra || tabs) {
		const headClasses = (0, import_classnames$158.default)(`${prefixCls}-head`, moduleClass("header"));
		const titleClasses = (0, import_classnames$158.default)(`${prefixCls}-head-title`, moduleClass("title"));
		const extraClasses = (0, import_classnames$158.default)(`${prefixCls}-extra`, moduleClass("extra"));
		const mergedHeadStyle = Object.assign(Object.assign({}, headStyle), moduleStyle("header"));
		head = /* @__PURE__ */ import_react.createElement("div", {
			className: headClasses,
			style: mergedHeadStyle
		}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-head-wrapper` }, title && /* @__PURE__ */ import_react.createElement("div", {
			className: titleClasses,
			style: moduleStyle("title")
		}, title), extra && /* @__PURE__ */ import_react.createElement("div", {
			className: extraClasses,
			style: moduleStyle("extra")
		}, extra)), tabs);
	}
	const coverClasses = (0, import_classnames$158.default)(`${prefixCls}-cover`, moduleClass("cover"));
	const coverDom = cover ? /* @__PURE__ */ import_react.createElement("div", {
		className: coverClasses,
		style: moduleStyle("cover")
	}, cover) : null;
	const bodyClasses = (0, import_classnames$158.default)(`${prefixCls}-body`, moduleClass("body"));
	const mergedBodyStyle = Object.assign(Object.assign({}, bodyStyle), moduleStyle("body"));
	const body = /* @__PURE__ */ import_react.createElement("div", {
		className: bodyClasses,
		style: mergedBodyStyle
	}, loading ? loadingBlock : children);
	const actionClasses = (0, import_classnames$158.default)(`${prefixCls}-actions`, moduleClass("actions"));
	const actionDom = (actions === null || actions === void 0 ? void 0 : actions.length) ? /* @__PURE__ */ import_react.createElement(ActionNode, {
		actionClasses,
		actionStyle: moduleStyle("actions"),
		actions
	}) : null;
	const divProps = omit(others, ["onTabChange"]);
	const classString = (0, import_classnames$158.default)(prefixCls, card === null || card === void 0 ? void 0 : card.className, {
		[`${prefixCls}-loading`]: loading,
		[`${prefixCls}-bordered`]: variant !== "borderless",
		[`${prefixCls}-hoverable`]: hoverable,
		[`${prefixCls}-contain-grid`]: isContainGrid,
		[`${prefixCls}-contain-tabs`]: tabList === null || tabList === void 0 ? void 0 : tabList.length,
		[`${prefixCls}-${mergedSize}`]: mergedSize,
		[`${prefixCls}-type-${type$2}`]: !!type$2,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, rootClassName, hashId, cssVarCls);
	const mergedStyle = Object.assign(Object.assign({}, card === null || card === void 0 ? void 0 : card.style), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({ ref }, divProps, {
		className: classString,
		style: mergedStyle
	}), head, coverDom, body, actionDom));
});
var Card_default = Card$1;

//#endregion
//#region node_modules/antd/es/card/Meta.js
var import_classnames$157 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$76 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Meta$1 = (props) => {
	const { prefixCls: customizePrefixCls, className, avatar, title, description } = props, others = __rest$76(props, [
		"prefixCls",
		"className",
		"avatar",
		"title",
		"description"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("card", customizePrefixCls);
	const classString = (0, import_classnames$157.default)(`${prefixCls}-meta`, className);
	const avatarDom = avatar ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-meta-avatar` }, avatar) : null;
	const titleDom = title ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-meta-title` }, title) : null;
	const descriptionDom = description ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-meta-description` }, description) : null;
	const MetaDetail = titleDom || descriptionDom ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-meta-detail` }, titleDom, descriptionDom) : null;
	return /* @__PURE__ */ import_react.createElement("div", Object.assign({}, others, { className: classString }), avatarDom, MetaDetail);
};
var Meta_default = Meta$1;

//#endregion
//#region node_modules/antd/es/card/index.js
var Card = Card_default;
Card.Grid = Grid_default;
Card.Meta = Meta_default;
Card.displayName = "Card";
var card_default = Card;

//#endregion
//#region node_modules/@ant-design/react-slick/es/initial-state.js
var initialState = {
	animating: false,
	autoplaying: null,
	currentDirection: 0,
	currentLeft: null,
	currentSlide: 0,
	direction: 1,
	dragging: false,
	edgeDragged: false,
	initialized: false,
	lazyLoadedList: [],
	listHeight: null,
	listWidth: null,
	scrolling: false,
	slideCount: null,
	slideHeight: null,
	slideWidth: null,
	swipeLeft: null,
	swiped: false,
	swiping: false,
	touchObject: {
		startX: 0,
		startY: 0,
		curX: 0,
		curY: 0
	},
	trackStyle: {},
	trackWidth: 0,
	targetSlide: 0
};
var initial_state_default = initialState;

//#endregion
//#region node_modules/throttle-debounce/esm/index.js
/**
* Throttle execution of a function. Especially useful for rate limiting
* execution of handlers on events like resize and scroll.
*
* @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
*                                            are most useful.
* @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
*                                            as-is, to `callback` when the throttled-function is executed.
* @param {object} [options] -              An object to configure options.
* @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
*                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
*                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
*                                            `delay` milliseconds, the internal counter is reset).
* @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
*                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
*                                            callback will never executed if both noLeading = true and noTrailing = true.
* @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
*                                            false (at end), schedule `callback` to execute after `delay` ms.
*
* @returns {Function} A new, throttled, function.
*/
function throttle(delay, callback, options) {
	var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
	var timeoutID;
	var cancelled = false;
	var lastExec = 0;
	function clearExistingTimeout() {
		if (timeoutID) clearTimeout(timeoutID);
	}
	function cancel(options$1) {
		var _ref2 = options$1 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
		clearExistingTimeout();
		cancelled = !upcomingOnly;
	}
	function wrapper() {
		for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) arguments_[_key] = arguments[_key];
		var self$1 = this;
		var elapsed = Date.now() - lastExec;
		if (cancelled) return;
		function exec() {
			lastExec = Date.now();
			callback.apply(self$1, arguments_);
		}
		function clear() {
			timeoutID = void 0;
		}
		if (!noLeading && debounceMode && !timeoutID) exec();
		clearExistingTimeout();
		if (debounceMode === void 0 && elapsed > delay) if (noLeading) {
			lastExec = Date.now();
			if (!noTrailing) timeoutID = setTimeout(debounceMode ? clear : exec, delay);
		} else exec();
		else if (noTrailing !== true) timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
	}
	wrapper.cancel = cancel;
	return wrapper;
}
/**
* Debounce execution of a function. Debouncing, unlike throttling,
* guarantees that a function is only executed a single time, either at the
* very beginning of a series of calls, or at the very end.
*
* @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
* @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
*                                        to `callback` when the debounced-function is executed.
* @param {object} [options] -           An object to configure options.
* @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
*                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
*                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
*
* @returns {Function} A new, debounced function.
*/
function debounce(delay, callback, options) {
	var _ref = options || {}, _ref$atBegin = _ref.atBegin;
	return throttle(delay, callback, { debounceMode: (_ref$atBegin === void 0 ? false : _ref$atBegin) !== false });
}

//#endregion
//#region node_modules/@ant-design/react-slick/es/default-props.js
var defaultProps$1 = {
	accessibility: true,
	adaptiveHeight: false,
	afterChange: null,
	appendDots: function appendDots(dots) {
		return /* @__PURE__ */ import_react.createElement("ul", { style: { display: "block" } }, dots);
	},
	arrows: true,
	autoplay: false,
	autoplaySpeed: 3e3,
	beforeChange: null,
	centerMode: false,
	centerPadding: "50px",
	className: "",
	cssEase: "ease",
	customPaging: function customPaging(i) {
		return /* @__PURE__ */ import_react.createElement("button", null, i + 1);
	},
	dots: false,
	dotsClass: "slick-dots",
	draggable: true,
	easing: "linear",
	edgeFriction: .35,
	fade: false,
	focusOnSelect: false,
	infinite: true,
	initialSlide: 0,
	lazyLoad: null,
	nextArrow: null,
	onEdge: null,
	onInit: null,
	onLazyLoadError: null,
	onReInit: null,
	pauseOnDotsHover: false,
	pauseOnFocus: false,
	pauseOnHover: true,
	prevArrow: null,
	responsive: null,
	rows: 1,
	rtl: false,
	slide: "div",
	slidesPerRow: 1,
	slidesToScroll: 1,
	slidesToShow: 1,
	speed: 500,
	swipe: true,
	swipeEvent: null,
	swipeToSlide: false,
	touchMove: true,
	touchThreshold: 5,
	useCSS: true,
	useTransform: true,
	variableWidth: false,
	vertical: false,
	waitForAnimate: true,
	asNavFor: null
};
var default_props_default = defaultProps$1;

//#endregion
//#region node_modules/@ant-design/react-slick/es/utils/innerSliderUtils.js
function clamp(number$1, lowerBound, upperBound) {
	return Math.max(lowerBound, Math.min(number$1, upperBound));
}
var safePreventDefault = function safePreventDefault$1(event) {
	if (![
		"onTouchStart",
		"onTouchMove",
		"onWheel"
	].includes(event._reactName)) event.preventDefault();
};
var getOnDemandLazySlides = function getOnDemandLazySlides$1(spec) {
	var onDemandSlides = [];
	var startIndex = lazyStartIndex(spec);
	var endIndex = lazyEndIndex(spec);
	for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) if (spec.lazyLoadedList.indexOf(slideIndex) < 0) onDemandSlides.push(slideIndex);
	return onDemandSlides;
};
var lazyStartIndex = function lazyStartIndex$1(spec) {
	return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex$1(spec) {
	return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft$1(spec) {
	return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight$1(spec) {
	return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
var getWidth = function getWidth$2(elem) {
	return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight$1(elem) {
	return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection$1(touchObject) {
	var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	var xDist = touchObject.startX - touchObject.curX, yDist = touchObject.startY - touchObject.curY, r$1 = Math.atan2(yDist, xDist), swipeAngle = Math.round(r$1 * 180 / Math.PI);
	if (swipeAngle < 0) swipeAngle = 360 - Math.abs(swipeAngle);
	if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) return "left";
	if (swipeAngle >= 135 && swipeAngle <= 225) return "right";
	if (verticalSwiping === true) if (swipeAngle >= 35 && swipeAngle <= 135) return "up";
	else return "down";
	return "vertical";
};
var canGoNext = function canGoNext$1(spec) {
	var canGo = true;
	if (!spec.infinite) {
		if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) canGo = false;
		else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) canGo = false;
	}
	return canGo;
};
var extractObject = function extractObject$1(spec, keys$1) {
	var newObject = {};
	keys$1.forEach(function(key) {
		return newObject[key] = spec[key];
	});
	return newObject;
};
var initializedState = function initializedState$1(spec) {
	var slideCount = import_react.Children.count(spec.children);
	var listNode = spec.listRef;
	var listWidth = Math.ceil(getWidth(listNode));
	var trackNode = spec.trackRef && spec.trackRef.node;
	var trackWidth = Math.ceil(getWidth(trackNode));
	var slideWidth;
	if (!spec.vertical) {
		var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
		if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") centerPaddingAdj *= listWidth / 100;
		slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
	} else slideWidth = listWidth;
	var slideHeight = listNode && getHeight(listNode.querySelector("[data-index=\"0\"]"));
	var listHeight = slideHeight * spec.slidesToShow;
	var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
	if (spec.rtl && spec.currentSlide === void 0) currentSlide = slideCount - 1 - spec.initialSlide;
	var lazyLoadedList = spec.lazyLoadedList || [];
	var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, {
		currentSlide,
		lazyLoadedList
	}));
	lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
	var state = {
		slideCount,
		slideWidth,
		listWidth,
		trackWidth,
		currentSlide,
		slideHeight,
		listHeight,
		lazyLoadedList
	};
	if (spec.autoplaying === null && spec.autoplay) state["autoplaying"] = "playing";
	return state;
};
var slideHandler = function slideHandler$1(spec) {
	var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index$2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
	var lazyLoadedList = spec.lazyLoadedList;
	if (waitForAnimate && animating) return {};
	var animationSlide = index$2, finalSlide, animationLeft, finalLeft;
	var state = {}, nextState = {};
	var targetSlide = infinite ? index$2 : clamp(index$2, 0, slideCount - 1);
	if (fade) {
		if (!infinite && (index$2 < 0 || index$2 >= slideCount)) return {};
		if (index$2 < 0) animationSlide = index$2 + slideCount;
		else if (index$2 >= slideCount) animationSlide = index$2 - slideCount;
		if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) lazyLoadedList = lazyLoadedList.concat(animationSlide);
		state = {
			animating: true,
			currentSlide: animationSlide,
			lazyLoadedList,
			targetSlide: animationSlide
		};
		nextState = {
			animating: false,
			targetSlide: animationSlide
		};
	} else {
		finalSlide = animationSlide;
		if (animationSlide < 0) {
			finalSlide = animationSlide + slideCount;
			if (!infinite) finalSlide = 0;
			else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;
		} else if (!canGoNext(spec) && animationSlide > currentSlide) animationSlide = finalSlide = currentSlide;
		else if (centerMode && animationSlide >= slideCount) {
			animationSlide = infinite ? slideCount : slideCount - 1;
			finalSlide = infinite ? 0 : slideCount - 1;
		} else if (animationSlide >= slideCount) {
			finalSlide = animationSlide - slideCount;
			if (!infinite) finalSlide = slideCount - slidesToShow;
			else if (slideCount % slidesToScroll !== 0) finalSlide = 0;
		}
		if (!infinite && animationSlide + slidesToShow >= slideCount) finalSlide = slideCount - slidesToShow;
		animationLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, { slideIndex: animationSlide }));
		finalLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, { slideIndex: finalSlide }));
		if (!infinite) {
			if (animationLeft === finalLeft) animationSlide = finalSlide;
			animationLeft = finalLeft;
		}
		if (lazyLoad) lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, { currentSlide: animationSlide })));
		if (!useCSS) state = {
			currentSlide: finalSlide,
			trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: finalLeft })),
			lazyLoadedList,
			targetSlide
		};
		else {
			state = {
				animating: true,
				currentSlide: finalSlide,
				trackStyle: getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: animationLeft })),
				lazyLoadedList,
				targetSlide
			};
			nextState = {
				animating: false,
				currentSlide: finalSlide,
				trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: finalLeft })),
				swipeLeft: null,
				targetSlide
			};
		}
	}
	return {
		state,
		nextState
	};
};
var changeSlide = function changeSlide$1(spec, options) {
	var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
	var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
	unevenOffset = slideCount % slidesToScroll !== 0;
	indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
	if (options.message === "previous") {
		slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
		targetSlide = currentSlide - slideOffset;
		if (lazyLoad && !infinite) {
			previousInt = currentSlide - slideOffset;
			targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
		}
		if (!infinite) targetSlide = previousTargetSlide - slidesToScroll;
	} else if (options.message === "next") {
		slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
		targetSlide = currentSlide + slideOffset;
		if (lazyLoad && !infinite) targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
		if (!infinite) targetSlide = previousTargetSlide + slidesToScroll;
	} else if (options.message === "dots") targetSlide = options.index * options.slidesToScroll;
	else if (options.message === "children") {
		targetSlide = options.index;
		if (infinite) {
			var direction = siblingDirection(_objectSpread2(_objectSpread2({}, spec), {}, { targetSlide }));
			if (targetSlide > options.currentSlide && direction === "left") targetSlide = targetSlide - slideCount;
			else if (targetSlide < options.currentSlide && direction === "right") targetSlide = targetSlide + slideCount;
		}
	} else if (options.message === "index") targetSlide = Number(options.index);
	return targetSlide;
};
var keyHandler = function keyHandler$1(e$2, accessibility, rtl) {
	if (e$2.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility) return "";
	if (e$2.keyCode === 37) return rtl ? "next" : "previous";
	if (e$2.keyCode === 39) return rtl ? "previous" : "next";
	return "";
};
var swipeStart = function swipeStart$1(e$2, swipe, draggable) {
	e$2.target.tagName === "IMG" && safePreventDefault(e$2);
	if (!swipe || !draggable && e$2.type.indexOf("mouse") !== -1) return "";
	return {
		dragging: true,
		touchObject: {
			startX: e$2.touches ? e$2.touches[0].pageX : e$2.clientX,
			startY: e$2.touches ? e$2.touches[0].pageY : e$2.clientY,
			curX: e$2.touches ? e$2.touches[0].pageX : e$2.clientX,
			curY: e$2.touches ? e$2.touches[0].pageY : e$2.clientY
		}
	};
};
var swipeMove = function swipeMove$1(e$2, spec) {
	var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
	if (scrolling) return;
	if (animating) return safePreventDefault(e$2);
	if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e$2);
	var swipeLeft, state = {};
	var curLeft = getTrackLeft(spec);
	touchObject.curX = e$2.touches ? e$2.touches[0].pageX : e$2.clientX;
	touchObject.curY = e$2.touches ? e$2.touches[0].pageY : e$2.clientY;
	touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
	var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
	if (!verticalSwiping && !swiping && verticalSwipeLength > 10) return { scrolling: true };
	if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;
	var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
	if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
	var dotCount = Math.ceil(slideCount / slidesToScroll);
	var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
	var touchSwipeLength = touchObject.swipeLength;
	if (!infinite) {
		if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
			touchSwipeLength = touchObject.swipeLength * edgeFriction;
			if (edgeDragged === false && onEdge) {
				onEdge(swipeDirection);
				state["edgeDragged"] = true;
			}
		}
	}
	if (!swiped && swipeEvent) {
		swipeEvent(swipeDirection);
		state["swiped"] = true;
	}
	if (!vertical) if (!rtl) swipeLeft = curLeft + touchSwipeLength * positionOffset;
	else swipeLeft = curLeft - touchSwipeLength * positionOffset;
	else swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
	if (verticalSwiping) swipeLeft = curLeft + touchSwipeLength * positionOffset;
	state = _objectSpread2(_objectSpread2({}, state), {}, {
		touchObject,
		swipeLeft,
		trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: swipeLeft }))
	});
	if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * .8) return state;
	if (touchObject.swipeLength > 10) {
		state["swiping"] = true;
		safePreventDefault(e$2);
	}
	return state;
};
var swipeEnd = function swipeEnd$1(e$2, spec) {
	var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
	if (!dragging) {
		if (swipe) safePreventDefault(e$2);
		return {};
	}
	var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
	var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
	var state = {
		dragging: false,
		edgeDragged: false,
		scrolling: false,
		swiping: false,
		swiped: false,
		swipeLeft: null,
		touchObject: {}
	};
	if (scrolling) return state;
	if (!touchObject.swipeLength) return state;
	if (touchObject.swipeLength > minSwipe) {
		safePreventDefault(e$2);
		if (onSwipe) onSwipe(swipeDirection);
		var slideCount, newSlide;
		var activeSlide = infinite ? currentSlide : targetSlide;
		switch (swipeDirection) {
			case "left":
			case "up":
				newSlide = activeSlide + getSlideCount(spec);
				slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
				state["currentDirection"] = 0;
				break;
			case "right":
			case "down":
				newSlide = activeSlide - getSlideCount(spec);
				slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
				state["currentDirection"] = 1;
				break;
			default: slideCount = activeSlide;
		}
		state["triggerSlideHandler"] = slideCount;
	} else {
		var currentLeft = getTrackLeft(spec);
		state["trackStyle"] = getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, { left: currentLeft }));
	}
	return state;
};
var getNavigableIndexes = function getNavigableIndexes$1(spec) {
	var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
	var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
	var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
	var indexes = [];
	while (breakpoint < max) {
		indexes.push(breakpoint);
		breakpoint = counter + spec.slidesToScroll;
		counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
	}
	return indexes;
};
var checkNavigable = function checkNavigable$1(spec, index$2) {
	var navigables = getNavigableIndexes(spec);
	var prevNavigable = 0;
	if (index$2 > navigables[navigables.length - 1]) index$2 = navigables[navigables.length - 1];
	else for (var n$1 in navigables) {
		if (index$2 < navigables[n$1]) {
			index$2 = prevNavigable;
			break;
		}
		prevNavigable = navigables[n$1];
	}
	return index$2;
};
var getSlideCount = function getSlideCount$1(spec) {
	var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
	if (spec.swipeToSlide) {
		var swipedSlide;
		var slickList = spec.listRef;
		var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
		Array.from(slides).every(function(slide) {
			if (!spec.vertical) {
				if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
					swipedSlide = slide;
					return false;
				}
			} else if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
				swipedSlide = slide;
				return false;
			}
			return true;
		});
		if (!swipedSlide) return 0;
		var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
		return Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
	} else return spec.slidesToScroll;
};
var checkSpecKeys = function checkSpecKeys$1(spec, keysArray) {
	return keysArray.reduce(function(value, key) {
		return value && spec.hasOwnProperty(key);
	}, true) ? null : console.error("Keys Missing:", spec);
};
var getTrackCSS = function getTrackCSS$1(spec) {
	checkSpecKeys(spec, [
		"left",
		"variableWidth",
		"slideCount",
		"slidesToShow",
		"slideWidth"
	]);
	var trackWidth, trackHeight;
	if (!spec.vertical) trackWidth = getTotalSlides(spec) * spec.slideWidth;
	else trackHeight = (spec.unslick ? spec.slideCount : spec.slideCount + 2 * spec.slidesToShow) * spec.slideHeight;
	var style$1 = {
		opacity: 1,
		transition: "",
		WebkitTransition: ""
	};
	if (spec.useTransform) {
		var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
		var transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
		var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
		style$1 = _objectSpread2(_objectSpread2({}, style$1), {}, {
			WebkitTransform,
			transform,
			msTransform
		});
	} else if (spec.vertical) style$1["top"] = spec.left;
	else style$1["left"] = spec.left;
	if (spec.fade) style$1 = { opacity: 1 };
	if (trackWidth) style$1.width = trackWidth;
	if (trackHeight) style$1.height = trackHeight;
	if (window && !window.addEventListener && window.attachEvent) if (!spec.vertical) style$1.marginLeft = spec.left + "px";
	else style$1.marginTop = spec.left + "px";
	return style$1;
};
var getTrackAnimateCSS = function getTrackAnimateCSS$1(spec) {
	checkSpecKeys(spec, [
		"left",
		"variableWidth",
		"slideCount",
		"slidesToShow",
		"slideWidth",
		"speed",
		"cssEase"
	]);
	var style$1 = getTrackCSS(spec);
	if (spec.useTransform) {
		style$1.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
		style$1.transition = "transform " + spec.speed + "ms " + spec.cssEase;
	} else if (spec.vertical) style$1.transition = "top " + spec.speed + "ms " + spec.cssEase;
	else style$1.transition = "left " + spec.speed + "ms " + spec.cssEase;
	return style$1;
};
var getTrackLeft = function getTrackLeft$1(spec) {
	if (spec.unslick) return 0;
	checkSpecKeys(spec, [
		"slideIndex",
		"trackRef",
		"infinite",
		"centerMode",
		"slideCount",
		"slidesToShow",
		"slidesToScroll",
		"slideWidth",
		"listWidth",
		"variableWidth",
		"slideHeight"
	]);
	var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
	var slideOffset = 0;
	var targetLeft;
	var targetSlide;
	var verticalOffset = 0;
	if (fade || spec.slideCount === 1) return 0;
	var slidesToOffset = 0;
	if (infinite) {
		slidesToOffset = -getPreClones(spec);
		if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
		if (centerMode) slidesToOffset += parseInt(slidesToShow / 2);
	} else {
		if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) slidesToOffset = slidesToShow - slideCount % slidesToScroll;
		if (centerMode) slidesToOffset = parseInt(slidesToShow / 2);
	}
	slideOffset = slidesToOffset * slideWidth;
	verticalOffset = slidesToOffset * slideHeight;
	if (!vertical) targetLeft = slideIndex * slideWidth * -1 + slideOffset;
	else targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
	if (variableWidth === true) {
		var targetSlideIndex;
		var trackElem = trackRef && trackRef.node;
		targetSlideIndex = slideIndex + getPreClones(spec);
		targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
		targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
		if (centerMode === true) {
			targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
			targetSlide = trackElem && trackElem.children[targetSlideIndex];
			targetLeft = 0;
			for (var slide = 0; slide < targetSlideIndex; slide++) targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
			targetLeft -= parseInt(spec.centerPadding);
			targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
		}
	}
	return targetLeft;
};
var getPreClones = function getPreClones$1(spec) {
	if (spec.unslick || !spec.infinite) return 0;
	if (spec.variableWidth) return spec.slideCount;
	return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones$1(spec) {
	if (spec.unslick || !spec.infinite) return 0;
	return spec.slideCount;
};
var getTotalSlides = function getTotalSlides$1(spec) {
	return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection$1(spec) {
	if (spec.targetSlide > spec.currentSlide) {
		if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) return "left";
		return "right";
	} else {
		if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) return "right";
		return "left";
	}
};
var slidesOnRight = function slidesOnRight$1(_ref) {
	var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;
	if (centerMode) {
		var right = (slidesToShow - 1) / 2 + 1;
		if (parseInt(centerPadding) > 0) right += 1;
		if (rtl && slidesToShow % 2 === 0) right += 1;
		return right;
	}
	if (rtl) return 0;
	return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft$1(_ref2) {
	var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
	if (centerMode) {
		var left = (slidesToShow - 1) / 2 + 1;
		if (parseInt(centerPadding) > 0) left += 1;
		if (!rtl && slidesToShow % 2 === 0) left += 1;
		return left;
	}
	if (rtl) return slidesToShow - 1;
	return 0;
};
var canUseDOM = function canUseDOM$1() {
	return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var validSettings = Object.keys(default_props_default);
function filterSettings(settings) {
	return validSettings.reduce(function(acc, settingName) {
		if (settings.hasOwnProperty(settingName)) acc[settingName] = settings[settingName];
		return acc;
	}, {});
}

//#endregion
//#region node_modules/@ant-design/react-slick/es/track.js
var import_classnames$156 = /* @__PURE__ */ __toESM(require_classnames());
function _callSuper$4(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var getSlideClasses = function getSlideClasses$1(spec) {
	var slickActive, slickCenter, slickCloned;
	var centerOffset, index$2;
	if (spec.rtl) index$2 = spec.slideCount - 1 - spec.index;
	else index$2 = spec.index;
	slickCloned = index$2 < 0 || index$2 >= spec.slideCount;
	if (spec.centerMode) {
		centerOffset = Math.floor(spec.slidesToShow / 2);
		slickCenter = (index$2 - spec.currentSlide) % spec.slideCount === 0;
		if (index$2 > spec.currentSlide - centerOffset - 1 && index$2 <= spec.currentSlide + centerOffset) slickActive = true;
	} else slickActive = spec.currentSlide <= index$2 && index$2 < spec.currentSlide + spec.slidesToShow;
	var focusedSlide;
	if (spec.targetSlide < 0) focusedSlide = spec.targetSlide + spec.slideCount;
	else if (spec.targetSlide >= spec.slideCount) focusedSlide = spec.targetSlide - spec.slideCount;
	else focusedSlide = spec.targetSlide;
	var slickCurrent = index$2 === focusedSlide;
	return {
		"slick-slide": true,
		"slick-active": slickActive,
		"slick-center": slickCenter,
		"slick-cloned": slickCloned,
		"slick-current": slickCurrent
	};
};
var getSlideStyle = function getSlideStyle$1(spec) {
	var style$1 = {};
	if (spec.variableWidth === void 0 || spec.variableWidth === false) style$1.width = spec.slideWidth;
	if (spec.fade) {
		style$1.position = "relative";
		if (spec.vertical && spec.slideHeight) style$1.top = -spec.index * parseInt(spec.slideHeight);
		else style$1.left = -spec.index * parseInt(spec.slideWidth);
		style$1.opacity = spec.currentSlide === spec.index ? 1 : 0;
		style$1.zIndex = spec.currentSlide === spec.index ? 999 : 998;
		if (spec.useCSS) style$1.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
	}
	return style$1;
};
var getKey$1 = function getKey$3(child, fallbackKey) {
	return child.key + "-" + fallbackKey;
};
var renderSlides = function renderSlides$1(spec) {
	var key;
	var slides = [];
	var preCloneSlides = [];
	var postCloneSlides = [];
	var childrenCount = import_react.Children.count(spec.children);
	var startIndex = lazyStartIndex(spec);
	var endIndex = lazyEndIndex(spec);
	import_react.Children.forEach(spec.children, function(elem, index$2) {
		var child;
		var childOnClickOptions = {
			message: "children",
			index: index$2,
			slidesToScroll: spec.slidesToScroll,
			currentSlide: spec.currentSlide
		};
		if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index$2) >= 0) child = elem;
		else child = /* @__PURE__ */ import_react.createElement("div", null);
		var childStyle = getSlideStyle(_objectSpread2(_objectSpread2({}, spec), {}, { index: index$2 }));
		var slideClass = child.props.className || "";
		var slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index: index$2 }));
		slides.push(/* @__PURE__ */ import_react.cloneElement(child, {
			key: "original" + getKey$1(child, index$2),
			"data-index": index$2,
			className: (0, import_classnames$156.default)(slideClasses, slideClass),
			tabIndex: "-1",
			"aria-hidden": !slideClasses["slick-active"],
			style: _objectSpread2(_objectSpread2({ outline: "none" }, child.props.style || {}), childStyle),
			onClick: function onClick(e$2) {
				child.props && child.props.onClick && child.props.onClick(e$2);
				if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
			}
		}));
		if (spec.infinite && childrenCount > 1 && spec.fade === false && !spec.unslick) {
			var preCloneNo = childrenCount - index$2;
			if (preCloneNo <= getPreClones(spec)) {
				key = -preCloneNo;
				if (key >= startIndex) child = elem;
				slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index: key }));
				preCloneSlides.push(/* @__PURE__ */ import_react.cloneElement(child, {
					key: "precloned" + getKey$1(child, key),
					"data-index": key,
					tabIndex: "-1",
					className: (0, import_classnames$156.default)(slideClasses, slideClass),
					"aria-hidden": !slideClasses["slick-active"],
					style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
					onClick: function onClick(e$2) {
						child.props && child.props.onClick && child.props.onClick(e$2);
						if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
					}
				}));
			}
			key = childrenCount + index$2;
			if (key < endIndex) child = elem;
			slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, { index: key }));
			postCloneSlides.push(/* @__PURE__ */ import_react.cloneElement(child, {
				key: "postcloned" + getKey$1(child, key),
				"data-index": key,
				tabIndex: "-1",
				className: (0, import_classnames$156.default)(slideClasses, slideClass),
				"aria-hidden": !slideClasses["slick-active"],
				style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
				onClick: function onClick(e$2) {
					child.props && child.props.onClick && child.props.onClick(e$2);
					if (spec.focusOnSelect) spec.focusOnSelect(childOnClickOptions);
				}
			}));
		}
	});
	if (spec.rtl) return preCloneSlides.concat(slides, postCloneSlides).reverse();
	else return preCloneSlides.concat(slides, postCloneSlides);
};
var Track$1 = /* @__PURE__ */ function(_React$PureComponent) {
	function Track$2() {
		var _this;
		_classCallCheck(this, Track$2);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$4(this, Track$2, [].concat(args));
		_defineProperty(_this, "node", null);
		_defineProperty(_this, "handleRef", function(ref) {
			_this.node = ref;
		});
		return _this;
	}
	_inherits(Track$2, _React$PureComponent);
	return _createClass(Track$2, [{
		key: "render",
		value: function render$1() {
			var slides = renderSlides(this.props);
			var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;
			var mouseEvents = {
				onMouseEnter,
				onMouseOver,
				onMouseLeave
			};
			return /* @__PURE__ */ import_react.createElement("div", _extends({
				ref: this.handleRef,
				className: "slick-track",
				style: this.props.trackStyle
			}, mouseEvents), slides);
		}
	}]);
}(import_react.PureComponent);

//#endregion
//#region node_modules/@ant-design/react-slick/es/dots.js
var import_classnames$155 = /* @__PURE__ */ __toESM(require_classnames());
function _callSuper$3(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var getDotCount = function getDotCount$1(spec) {
	var dots;
	if (spec.infinite) dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
	else dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
	return dots;
};
var Dots = /* @__PURE__ */ function(_React$PureComponent) {
	function Dots$1() {
		_classCallCheck(this, Dots$1);
		return _callSuper$3(this, Dots$1, arguments);
	}
	_inherits(Dots$1, _React$PureComponent);
	return _createClass(Dots$1, [{
		key: "clickHandler",
		value: function clickHandler(options, e$2) {
			e$2.preventDefault();
			this.props.clickHandler(options);
		}
	}, {
		key: "render",
		value: function render$1() {
			var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;
			var dotCount = getDotCount({
				slideCount,
				slidesToScroll,
				slidesToShow,
				infinite
			});
			var mouseEvents = {
				onMouseEnter,
				onMouseOver,
				onMouseLeave
			};
			var dots = [];
			for (var i = 0; i < dotCount; i++) {
				var _rightBound = (i + 1) * slidesToScroll - 1;
				var rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
				var _leftBound = rightBound - (slidesToScroll - 1);
				var leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
				var className = (0, import_classnames$155.default)({ "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound });
				var dotOptions = {
					message: "dots",
					index: i,
					slidesToScroll,
					currentSlide
				};
				var onClick = this.clickHandler.bind(this, dotOptions);
				dots = dots.concat(/* @__PURE__ */ import_react.createElement("li", {
					key: i,
					className
				}, /* @__PURE__ */ import_react.cloneElement(this.props.customPaging(i), { onClick })));
			}
			return /* @__PURE__ */ import_react.cloneElement(this.props.appendDots(dots), _objectSpread2({ className: this.props.dotsClass }, mouseEvents));
		}
	}]);
}(import_react.PureComponent);

//#endregion
//#region node_modules/@ant-design/react-slick/es/arrows.js
var import_classnames$154 = /* @__PURE__ */ __toESM(require_classnames());
function _callSuper$2(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var PrevArrow = /* @__PURE__ */ function(_React$PureComponent) {
	function PrevArrow$1() {
		_classCallCheck(this, PrevArrow$1);
		return _callSuper$2(this, PrevArrow$1, arguments);
	}
	_inherits(PrevArrow$1, _React$PureComponent);
	return _createClass(PrevArrow$1, [{
		key: "clickHandler",
		value: function clickHandler(options, e$2) {
			if (e$2) e$2.preventDefault();
			this.props.clickHandler(options, e$2);
		}
	}, {
		key: "render",
		value: function render$1() {
			var prevClasses = {
				"slick-arrow": true,
				"slick-prev": true
			};
			var prevHandler = this.clickHandler.bind(this, { message: "previous" });
			if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
				prevClasses["slick-disabled"] = true;
				prevHandler = null;
			}
			var prevArrowProps = {
				key: "0",
				"data-role": "none",
				className: (0, import_classnames$154.default)(prevClasses),
				style: { display: "block" },
				onClick: prevHandler
			};
			var customProps = {
				currentSlide: this.props.currentSlide,
				slideCount: this.props.slideCount
			};
			var prevArrow;
			if (this.props.prevArrow) prevArrow = /* @__PURE__ */ import_react.cloneElement(this.props.prevArrow, _objectSpread2(_objectSpread2({}, prevArrowProps), customProps));
			else prevArrow = /* @__PURE__ */ import_react.createElement("button", _extends({
				key: "0",
				type: "button"
			}, prevArrowProps), " ", "Previous");
			return prevArrow;
		}
	}]);
}(import_react.PureComponent);
var NextArrow = /* @__PURE__ */ function(_React$PureComponent2) {
	function NextArrow$1() {
		_classCallCheck(this, NextArrow$1);
		return _callSuper$2(this, NextArrow$1, arguments);
	}
	_inherits(NextArrow$1, _React$PureComponent2);
	return _createClass(NextArrow$1, [{
		key: "clickHandler",
		value: function clickHandler(options, e$2) {
			if (e$2) e$2.preventDefault();
			this.props.clickHandler(options, e$2);
		}
	}, {
		key: "render",
		value: function render$1() {
			var nextClasses = {
				"slick-arrow": true,
				"slick-next": true
			};
			var nextHandler = this.clickHandler.bind(this, { message: "next" });
			if (!canGoNext(this.props)) {
				nextClasses["slick-disabled"] = true;
				nextHandler = null;
			}
			var nextArrowProps = {
				key: "1",
				"data-role": "none",
				className: (0, import_classnames$154.default)(nextClasses),
				style: { display: "block" },
				onClick: nextHandler
			};
			var customProps = {
				currentSlide: this.props.currentSlide,
				slideCount: this.props.slideCount
			};
			var nextArrow;
			if (this.props.nextArrow) nextArrow = /* @__PURE__ */ import_react.cloneElement(this.props.nextArrow, _objectSpread2(_objectSpread2({}, nextArrowProps), customProps));
			else nextArrow = /* @__PURE__ */ import_react.createElement("button", _extends({
				key: "1",
				type: "button"
			}, nextArrowProps), " ", "Next");
			return nextArrow;
		}
	}]);
}(import_react.PureComponent);

//#endregion
//#region node_modules/@ant-design/react-slick/es/inner-slider.js
var import_classnames$153 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$36 = ["animating"];
function _callSuper$1(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var InnerSlider = /* @__PURE__ */ function(_React$Component) {
	function InnerSlider$1(props) {
		var _this;
		_classCallCheck(this, InnerSlider$1);
		_this = _callSuper$1(this, InnerSlider$1, [props]);
		_defineProperty(_this, "listRefHandler", function(ref) {
			return _this.list = ref;
		});
		_defineProperty(_this, "trackRefHandler", function(ref) {
			return _this.track = ref;
		});
		_defineProperty(_this, "adaptHeight", function() {
			if (_this.props.adaptiveHeight && _this.list) {
				var elem = _this.list.querySelector("[data-index=\"".concat(_this.state.currentSlide, "\"]"));
				_this.list.style.height = getHeight(elem) + "px";
			}
		});
		_defineProperty(_this, "componentDidMount", function() {
			_this.props.onInit && _this.props.onInit();
			if (_this.props.lazyLoad) {
				var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, _this.props), _this.state));
				if (slidesToLoad.length > 0) {
					_this.setState(function(prevState) {
						return { lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad) };
					});
					if (_this.props.onLazyLoad) _this.props.onLazyLoad(slidesToLoad);
				}
			}
			var spec = _objectSpread2({
				listRef: _this.list,
				trackRef: _this.track
			}, _this.props);
			_this.updateState(spec, true, function() {
				_this.adaptHeight();
				_this.props.autoplay && _this.autoPlay("playing");
			});
			if (_this.props.lazyLoad === "progressive") _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);
			_this.ro = new ResizeObserver_es_default(function() {
				if (_this.state.animating) {
					_this.onWindowResized(false);
					_this.callbackTimers.push(setTimeout(function() {
						return _this.onWindowResized();
					}, _this.props.speed));
				} else _this.onWindowResized();
			});
			_this.ro.observe(_this.list);
			document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
				slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;
				slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;
			});
			if (window.addEventListener) window.addEventListener("resize", _this.onWindowResized);
			else window.attachEvent("onresize", _this.onWindowResized);
		});
		_defineProperty(_this, "componentWillUnmount", function() {
			if (_this.animationEndCallback) clearTimeout(_this.animationEndCallback);
			if (_this.lazyLoadTimer) clearInterval(_this.lazyLoadTimer);
			if (_this.callbackTimers.length) {
				_this.callbackTimers.forEach(function(timer) {
					return clearTimeout(timer);
				});
				_this.callbackTimers = [];
			}
			if (window.addEventListener) window.removeEventListener("resize", _this.onWindowResized);
			else window.detachEvent("onresize", _this.onWindowResized);
			if (_this.autoplayTimer) clearInterval(_this.autoplayTimer);
			_this.ro.disconnect();
		});
		_defineProperty(_this, "componentDidUpdate", function(prevProps) {
			_this.checkImagesLoad();
			_this.props.onReInit && _this.props.onReInit();
			if (_this.props.lazyLoad) {
				var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, _this.props), _this.state));
				if (slidesToLoad.length > 0) {
					_this.setState(function(prevState) {
						return { lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad) };
					});
					if (_this.props.onLazyLoad) _this.props.onLazyLoad(slidesToLoad);
				}
			}
			_this.adaptHeight();
			var spec = _objectSpread2(_objectSpread2({
				listRef: _this.list,
				trackRef: _this.track
			}, _this.props), _this.state);
			var setTrackStyle = _this.didPropsChange(prevProps);
			setTrackStyle && _this.updateState(spec, setTrackStyle, function() {
				if (_this.state.currentSlide >= import_react.Children.count(_this.props.children)) _this.changeSlide({
					message: "index",
					index: import_react.Children.count(_this.props.children) - _this.props.slidesToShow,
					currentSlide: _this.state.currentSlide
				});
				if (prevProps.autoplay !== _this.props.autoplay || prevProps.autoplaySpeed !== _this.props.autoplaySpeed) if (!prevProps.autoplay && _this.props.autoplay) _this.autoPlay("playing");
				else if (_this.props.autoplay) _this.autoPlay("update");
				else _this.pause("paused");
			});
		});
		_defineProperty(_this, "onWindowResized", function(setTrackStyle) {
			if (_this.debouncedResize) _this.debouncedResize.cancel();
			_this.debouncedResize = debounce(50, function() {
				return _this.resizeWindow(setTrackStyle);
			});
			_this.debouncedResize();
		});
		_defineProperty(_this, "resizeWindow", function() {
			var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
			if (!Boolean(_this.track && _this.track.node)) return;
			var spec = _objectSpread2(_objectSpread2({
				listRef: _this.list,
				trackRef: _this.track
			}, _this.props), _this.state);
			_this.updateState(spec, setTrackStyle, function() {
				if (_this.props.autoplay) _this.autoPlay("update");
				else _this.pause("paused");
			});
			_this.setState({ animating: false });
			clearTimeout(_this.animationEndCallback);
			delete _this.animationEndCallback;
		});
		_defineProperty(_this, "updateState", function(spec, setTrackStyle, callback) {
			var updatedState = initializedState(spec);
			spec = _objectSpread2(_objectSpread2(_objectSpread2({}, spec), updatedState), {}, { slideIndex: updatedState.currentSlide });
			var targetLeft = getTrackLeft(spec);
			spec = _objectSpread2(_objectSpread2({}, spec), {}, { left: targetLeft });
			var trackStyle = getTrackCSS(spec);
			if (setTrackStyle || import_react.Children.count(_this.props.children) !== import_react.Children.count(spec.children)) updatedState["trackStyle"] = trackStyle;
			_this.setState(updatedState, callback);
		});
		_defineProperty(_this, "ssrInit", function() {
			if (_this.props.variableWidth) {
				var _trackWidth = 0, _trackLeft = 0;
				var childrenWidths = [];
				var preClones = getPreClones(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, { slideCount: _this.props.children.length }));
				var postClones = getPostClones(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, { slideCount: _this.props.children.length }));
				_this.props.children.forEach(function(child) {
					childrenWidths.push(child.props.style.width);
					_trackWidth += child.props.style.width;
				});
				for (var i = 0; i < preClones; i++) {
					_trackLeft += childrenWidths[childrenWidths.length - 1 - i];
					_trackWidth += childrenWidths[childrenWidths.length - 1 - i];
				}
				for (var _i = 0; _i < postClones; _i++) _trackWidth += childrenWidths[_i];
				for (var _i2 = 0; _i2 < _this.state.currentSlide; _i2++) _trackLeft += childrenWidths[_i2];
				var _trackStyle = {
					width: _trackWidth + "px",
					left: -_trackLeft + "px"
				};
				if (_this.props.centerMode) {
					var currentWidth = "".concat(childrenWidths[_this.state.currentSlide], "px");
					_trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
				}
				return { trackStyle: _trackStyle };
			}
			var childrenCount = import_react.Children.count(_this.props.children);
			var spec = _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, { slideCount: childrenCount });
			var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
			var trackWidth = 100 / _this.props.slidesToShow * slideCount;
			var slideWidth = 100 / slideCount;
			var trackLeft = -slideWidth * (getPreClones(spec) + _this.state.currentSlide) * trackWidth / 100;
			if (_this.props.centerMode) trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
			var trackStyle = {
				width: trackWidth + "%",
				left: trackLeft + "%"
			};
			return {
				slideWidth: slideWidth + "%",
				trackStyle
			};
		});
		_defineProperty(_this, "checkImagesLoad", function() {
			var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(".slick-slide img") || [];
			var imagesCount = images.length, loadedCount = 0;
			Array.prototype.forEach.call(images, function(image) {
				var handler = function handler$1() {
					return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();
				};
				if (!image.onclick) image.onclick = function() {
					return image.parentNode.focus();
				};
				else {
					var prevClickHandler = image.onclick;
					image.onclick = function(e$2) {
						prevClickHandler(e$2);
						image.parentNode.focus();
					};
				}
				if (!image.onload) if (_this.props.lazyLoad) image.onload = function() {
					_this.adaptHeight();
					_this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));
				};
				else {
					image.onload = handler;
					image.onerror = function() {
						handler();
						_this.props.onLazyLoadError && _this.props.onLazyLoadError();
					};
				}
			});
		});
		_defineProperty(_this, "progressiveLazyLoad", function() {
			var slidesToLoad = [];
			var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
			for (var index$2 = _this.state.currentSlide; index$2 < _this.state.slideCount + getPostClones(spec); index$2++) if (_this.state.lazyLoadedList.indexOf(index$2) < 0) {
				slidesToLoad.push(index$2);
				break;
			}
			for (var _index = _this.state.currentSlide - 1; _index >= -getPreClones(spec); _index--) if (_this.state.lazyLoadedList.indexOf(_index) < 0) {
				slidesToLoad.push(_index);
				break;
			}
			if (slidesToLoad.length > 0) {
				_this.setState(function(state) {
					return { lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad) };
				});
				if (_this.props.onLazyLoad) _this.props.onLazyLoad(slidesToLoad);
			} else if (_this.lazyLoadTimer) {
				clearInterval(_this.lazyLoadTimer);
				delete _this.lazyLoadTimer;
			}
		});
		_defineProperty(_this, "slideHandler", function(index$2) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;
			var currentSlide = _this.state.currentSlide;
			var _slideHandler = slideHandler(_objectSpread2(_objectSpread2(_objectSpread2({ index: index$2 }, _this.props), _this.state), {}, {
				trackRef: _this.track,
				useCSS: _this.props.useCSS && !dontAnimate
			})), state = _slideHandler.state, nextState = _slideHandler.nextState;
			if (!state) return;
			beforeChange && beforeChange(currentSlide, state.currentSlide);
			var slidesToLoad = state.lazyLoadedList.filter(function(value) {
				return _this.state.lazyLoadedList.indexOf(value) < 0;
			});
			onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
			if (!_this.props.waitForAnimate && _this.animationEndCallback) {
				clearTimeout(_this.animationEndCallback);
				afterChange && afterChange(currentSlide);
				delete _this.animationEndCallback;
			}
			_this.setState(state, function() {
				if (asNavFor && _this.asNavForIndex !== index$2) {
					_this.asNavForIndex = index$2;
					asNavFor.innerSlider.slideHandler(index$2);
				}
				if (!nextState) return;
				_this.animationEndCallback = setTimeout(function() {
					var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, _excluded$36);
					_this.setState(firstBatch, function() {
						_this.callbackTimers.push(setTimeout(function() {
							return _this.setState({ animating });
						}, 10));
						afterChange && afterChange(state.currentSlide);
						delete _this.animationEndCallback;
					});
				}, speed);
			});
		});
		_defineProperty(_this, "changeSlide", function(options) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
			var targetSlide = changeSlide(spec, options);
			if (targetSlide !== 0 && !targetSlide) return;
			if (dontAnimate === true) _this.slideHandler(targetSlide, dontAnimate);
			else _this.slideHandler(targetSlide);
			_this.props.autoplay && _this.autoPlay("update");
			if (_this.props.focusOnSelect) {
				var nodes = _this.list.querySelectorAll(".slick-current");
				nodes[0] && nodes[0].focus();
			}
		});
		_defineProperty(_this, "clickHandler", function(e$2) {
			if (_this.clickable === false) {
				e$2.stopPropagation();
				e$2.preventDefault();
			}
			_this.clickable = true;
		});
		_defineProperty(_this, "keyHandler", function(e$2) {
			var dir = keyHandler(e$2, _this.props.accessibility, _this.props.rtl);
			dir !== "" && _this.changeSlide({ message: dir });
		});
		_defineProperty(_this, "selectHandler", function(options) {
			_this.changeSlide(options);
		});
		_defineProperty(_this, "disableBodyScroll", function() {
			var preventDefault = function preventDefault$1(e$2) {
				e$2 = e$2 || window.event;
				if (e$2.preventDefault) e$2.preventDefault();
				e$2.returnValue = false;
			};
			window.ontouchmove = preventDefault;
		});
		_defineProperty(_this, "enableBodyScroll", function() {
			window.ontouchmove = null;
		});
		_defineProperty(_this, "swipeStart", function(e$2) {
			if (_this.props.verticalSwiping) _this.disableBodyScroll();
			var state = swipeStart(e$2, _this.props.swipe, _this.props.draggable);
			state !== "" && _this.setState(state);
		});
		_defineProperty(_this, "swipeMove", function(e$2) {
			var state = swipeMove(e$2, _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
				trackRef: _this.track,
				listRef: _this.list,
				slideIndex: _this.state.currentSlide
			}));
			if (!state) return;
			if (state["swiping"]) _this.clickable = false;
			_this.setState(state);
		});
		_defineProperty(_this, "swipeEnd", function(e$2) {
			var state = swipeEnd(e$2, _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
				trackRef: _this.track,
				listRef: _this.list,
				slideIndex: _this.state.currentSlide
			}));
			if (!state) return;
			var triggerSlideHandler = state["triggerSlideHandler"];
			delete state["triggerSlideHandler"];
			_this.setState(state);
			if (triggerSlideHandler === void 0) return;
			_this.slideHandler(triggerSlideHandler);
			if (_this.props.verticalSwiping) _this.enableBodyScroll();
		});
		_defineProperty(_this, "touchEnd", function(e$2) {
			_this.swipeEnd(e$2);
			_this.clickable = true;
		});
		_defineProperty(_this, "slickPrev", function() {
			_this.callbackTimers.push(setTimeout(function() {
				return _this.changeSlide({ message: "previous" });
			}, 0));
		});
		_defineProperty(_this, "slickNext", function() {
			_this.callbackTimers.push(setTimeout(function() {
				return _this.changeSlide({ message: "next" });
			}, 0));
		});
		_defineProperty(_this, "slickGoTo", function(slide) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			slide = Number(slide);
			if (isNaN(slide)) return "";
			_this.callbackTimers.push(setTimeout(function() {
				return _this.changeSlide({
					message: "index",
					index: slide,
					currentSlide: _this.state.currentSlide
				}, dontAnimate);
			}, 0));
		});
		_defineProperty(_this, "play", function() {
			var nextIndex;
			if (_this.props.rtl) nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;
			else if (canGoNext(_objectSpread2(_objectSpread2({}, _this.props), _this.state))) nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;
			else return false;
			_this.slideHandler(nextIndex);
		});
		_defineProperty(_this, "autoPlay", function(playType) {
			if (_this.autoplayTimer) clearInterval(_this.autoplayTimer);
			var autoplaying = _this.state.autoplaying;
			if (playType === "update") {
				if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") return;
			} else if (playType === "leave") {
				if (autoplaying === "paused" || autoplaying === "focused") return;
			} else if (playType === "blur") {
				if (autoplaying === "paused" || autoplaying === "hovered") return;
			}
			_this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);
			_this.setState({ autoplaying: "playing" });
		});
		_defineProperty(_this, "pause", function(pauseType) {
			if (_this.autoplayTimer) {
				clearInterval(_this.autoplayTimer);
				_this.autoplayTimer = null;
			}
			var autoplaying = _this.state.autoplaying;
			if (pauseType === "paused") _this.setState({ autoplaying: "paused" });
			else if (pauseType === "focused") {
				if (autoplaying === "hovered" || autoplaying === "playing") _this.setState({ autoplaying: "focused" });
			} else if (autoplaying === "playing") _this.setState({ autoplaying: "hovered" });
		});
		_defineProperty(_this, "onDotsOver", function() {
			return _this.props.autoplay && _this.pause("hovered");
		});
		_defineProperty(_this, "onDotsLeave", function() {
			return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
		});
		_defineProperty(_this, "onTrackOver", function() {
			return _this.props.autoplay && _this.pause("hovered");
		});
		_defineProperty(_this, "onTrackLeave", function() {
			return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
		});
		_defineProperty(_this, "onSlideFocus", function() {
			return _this.props.autoplay && _this.pause("focused");
		});
		_defineProperty(_this, "onSlideBlur", function() {
			return _this.props.autoplay && _this.state.autoplaying === "focused" && _this.autoPlay("blur");
		});
		_defineProperty(_this, "render", function() {
			var className = (0, import_classnames$153.default)("slick-slider", _this.props.className, {
				"slick-vertical": _this.props.vertical,
				"slick-initialized": true
			});
			var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
			var trackProps = extractObject(spec, [
				"fade",
				"cssEase",
				"speed",
				"infinite",
				"centerMode",
				"focusOnSelect",
				"currentSlide",
				"lazyLoad",
				"lazyLoadedList",
				"rtl",
				"slideWidth",
				"slideHeight",
				"listHeight",
				"vertical",
				"slidesToShow",
				"slidesToScroll",
				"slideCount",
				"trackStyle",
				"variableWidth",
				"unslick",
				"centerPadding",
				"targetSlide",
				"useCSS"
			]);
			var pauseOnHover = _this.props.pauseOnHover;
			trackProps = _objectSpread2(_objectSpread2({}, trackProps), {}, {
				onMouseEnter: pauseOnHover ? _this.onTrackOver : null,
				onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,
				onMouseOver: pauseOnHover ? _this.onTrackOver : null,
				focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null
			});
			var dots;
			if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {
				var dotProps = extractObject(spec, [
					"dotsClass",
					"slideCount",
					"slidesToShow",
					"currentSlide",
					"slidesToScroll",
					"clickHandler",
					"children",
					"customPaging",
					"infinite",
					"appendDots"
				]);
				var pauseOnDotsHover = _this.props.pauseOnDotsHover;
				dotProps = _objectSpread2(_objectSpread2({}, dotProps), {}, {
					clickHandler: _this.changeSlide,
					onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,
					onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,
					onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null
				});
				dots = /* @__PURE__ */ import_react.createElement(Dots, dotProps);
			}
			var prevArrow, nextArrow;
			var arrowProps = extractObject(spec, [
				"infinite",
				"centerMode",
				"currentSlide",
				"slideCount",
				"slidesToShow",
				"prevArrow",
				"nextArrow"
			]);
			arrowProps.clickHandler = _this.changeSlide;
			if (_this.props.arrows) {
				prevArrow = /* @__PURE__ */ import_react.createElement(PrevArrow, arrowProps);
				nextArrow = /* @__PURE__ */ import_react.createElement(NextArrow, arrowProps);
			}
			var verticalHeightStyle = null;
			if (_this.props.vertical) verticalHeightStyle = { height: _this.state.listHeight };
			var centerPaddingStyle = null;
			if (_this.props.vertical === false) {
				if (_this.props.centerMode === true) centerPaddingStyle = { padding: "0px " + _this.props.centerPadding };
			} else if (_this.props.centerMode === true) centerPaddingStyle = { padding: _this.props.centerPadding + " 0px" };
			var listStyle = _objectSpread2(_objectSpread2({}, verticalHeightStyle), centerPaddingStyle);
			var touchMove = _this.props.touchMove;
			var listProps = {
				className: "slick-list",
				style: listStyle,
				onClick: _this.clickHandler,
				onMouseDown: touchMove ? _this.swipeStart : null,
				onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
				onMouseUp: touchMove ? _this.swipeEnd : null,
				onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,
				onTouchStart: touchMove ? _this.swipeStart : null,
				onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
				onTouchEnd: touchMove ? _this.touchEnd : null,
				onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,
				onKeyDown: _this.props.accessibility ? _this.keyHandler : null
			};
			var innerSliderProps = {
				className,
				dir: "ltr",
				style: _this.props.style
			};
			if (_this.props.unslick) {
				listProps = { className: "slick-list" };
				innerSliderProps = {
					className,
					style: _this.props.style
				};
			}
			return /* @__PURE__ */ import_react.createElement("div", innerSliderProps, !_this.props.unslick ? prevArrow : "", /* @__PURE__ */ import_react.createElement("div", _extends({ ref: _this.listRefHandler }, listProps), /* @__PURE__ */ import_react.createElement(Track$1, _extends({ ref: _this.trackRefHandler }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : "", !_this.props.unslick ? dots : "");
		});
		_this.list = null;
		_this.track = null;
		_this.state = _objectSpread2(_objectSpread2({}, initial_state_default), {}, {
			currentSlide: _this.props.initialSlide,
			targetSlide: _this.props.initialSlide ? _this.props.initialSlide : 0,
			slideCount: import_react.Children.count(_this.props.children)
		});
		_this.callbackTimers = [];
		_this.clickable = true;
		_this.debouncedResize = null;
		var ssrState = _this.ssrInit();
		_this.state = _objectSpread2(_objectSpread2({}, _this.state), ssrState);
		return _this;
	}
	_inherits(InnerSlider$1, _React$Component);
	return _createClass(InnerSlider$1, [{
		key: "didPropsChange",
		value: function didPropsChange(prevProps) {
			var setTrackStyle = false;
			for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {
				var key = _Object$keys[_i3];
				if (!prevProps.hasOwnProperty(key)) {
					setTrackStyle = true;
					break;
				}
				if (_typeof(prevProps[key]) === "object" || typeof prevProps[key] === "function" || isNaN(prevProps[key])) continue;
				if (prevProps[key] !== this.props[key]) {
					setTrackStyle = true;
					break;
				}
			}
			return setTrackStyle || import_react.Children.count(this.props.children) !== import_react.Children.count(prevProps.children);
		}
	}]);
}(import_react.Component);

//#endregion
//#region node_modules/string-convert/camel2hyphen.js
var require_camel2hyphen = /* @__PURE__ */ __commonJS({ "node_modules/string-convert/camel2hyphen.js": ((exports, module) => {
	var camel2hyphen$1 = function(str) {
		return str.replace(/[A-Z]/g, function(match$1) {
			return "-" + match$1.toLowerCase();
		}).toLowerCase();
	};
	module.exports = camel2hyphen$1;
}) });

//#endregion
//#region node_modules/json2mq/index.js
var require_json2mq = /* @__PURE__ */ __commonJS({ "node_modules/json2mq/index.js": ((exports, module) => {
	var camel2hyphen = require_camel2hyphen();
	var isDimension = function(feature) {
		return /[height|width]$/.test(feature);
	};
	var obj2mq = function(obj) {
		var mq = "";
		var features = Object.keys(obj);
		features.forEach(function(feature, index$2) {
			var value = obj[feature];
			feature = camel2hyphen(feature);
			if (isDimension(feature) && typeof value === "number") value = value + "px";
			if (value === true) mq += feature;
			else if (value === false) mq += "not " + feature;
			else mq += "(" + feature + ": " + value + ")";
			if (index$2 < features.length - 1) mq += " and ";
		});
		return mq;
	};
	var json2mq$1 = function(query) {
		var mq = "";
		if (typeof query === "string") return query;
		if (query instanceof Array) {
			query.forEach(function(q, index$2) {
				mq += obj2mq(q);
				if (index$2 < query.length - 1) mq += ", ";
			});
			return mq;
		}
		return obj2mq(query);
	};
	module.exports = json2mq$1;
}) });

//#endregion
//#region node_modules/@ant-design/react-slick/es/slider.js
var import_json2mq = /* @__PURE__ */ __toESM(require_json2mq());
function _callSuper(t$1, o$2, e$2) {
	return o$2 = _getPrototypeOf(o$2), _possibleConstructorReturn(t$1, _isNativeReflectConstruct() ? Reflect.construct(o$2, e$2 || [], _getPrototypeOf(t$1).constructor) : o$2.apply(t$1, e$2));
}
var Slider$2 = /* @__PURE__ */ function(_React$Component) {
	function Slider$4(props) {
		var _this;
		_classCallCheck(this, Slider$4);
		_this = _callSuper(this, Slider$4, [props]);
		_defineProperty(_this, "innerSliderRefHandler", function(ref) {
			return _this.innerSlider = ref;
		});
		_defineProperty(_this, "slickPrev", function() {
			return _this.innerSlider.slickPrev();
		});
		_defineProperty(_this, "slickNext", function() {
			return _this.innerSlider.slickNext();
		});
		_defineProperty(_this, "slickGoTo", function(slide) {
			var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			return _this.innerSlider.slickGoTo(slide, dontAnimate);
		});
		_defineProperty(_this, "slickPause", function() {
			return _this.innerSlider.pause("paused");
		});
		_defineProperty(_this, "slickPlay", function() {
			return _this.innerSlider.autoPlay("play");
		});
		_this.state = { breakpoint: null };
		_this._responsiveMediaHandlers = [];
		return _this;
	}
	_inherits(Slider$4, _React$Component);
	return _createClass(Slider$4, [
		{
			key: "media",
			value: function media(query, handler) {
				var mql = window.matchMedia(query);
				var listener = function listener$1(_ref) {
					if (_ref.matches) handler();
				};
				mql.addListener(listener);
				listener(mql);
				this._responsiveMediaHandlers.push({
					mql,
					query,
					listener
				});
			}
		},
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				var _this2 = this;
				if (this.props.responsive) {
					var breakpoints = this.props.responsive.map(function(breakpt) {
						return breakpt.breakpoint;
					});
					breakpoints.sort(function(x, y) {
						return x - y;
					});
					breakpoints.forEach(function(breakpoint, index$2) {
						var bQuery;
						if (index$2 === 0) bQuery = (0, import_json2mq.default)({
							minWidth: 0,
							maxWidth: breakpoint
						});
						else bQuery = (0, import_json2mq.default)({
							minWidth: breakpoints[index$2 - 1] + 1,
							maxWidth: breakpoint
						});
						canUseDOM() && _this2.media(bQuery, function() {
							_this2.setState({ breakpoint });
						});
					});
					var query = (0, import_json2mq.default)({ minWidth: breakpoints.slice(-1)[0] });
					canUseDOM() && this.media(query, function() {
						_this2.setState({ breakpoint: null });
					});
				}
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				this._responsiveMediaHandlers.forEach(function(obj) {
					obj.mql.removeListener(obj.listener);
				});
			}
		},
		{
			key: "render",
			value: function render$1() {
				var _this3 = this;
				var settings;
				var newProps;
				if (this.state.breakpoint) {
					newProps = this.props.responsive.filter(function(resp) {
						return resp.breakpoint === _this3.state.breakpoint;
					});
					settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2(_objectSpread2(_objectSpread2({}, default_props_default), this.props), newProps[0].settings);
				} else settings = _objectSpread2(_objectSpread2({}, default_props_default), this.props);
				if (settings.centerMode) {
					if (settings.slidesToScroll > 1 && true) console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
					settings.slidesToScroll = 1;
				}
				if (settings.fade) {
					if (settings.slidesToShow > 1 && true) console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
					if (settings.slidesToScroll > 1 && true) console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
					settings.slidesToShow = 1;
					settings.slidesToScroll = 1;
				}
				var children = import_react.Children.toArray(this.props.children);
				children = children.filter(function(child) {
					if (typeof child === "string") return !!child.trim();
					return !!child;
				});
				if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
					console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
					settings.variableWidth = false;
				}
				var newChildren = [];
				var currentWidth = null;
				for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
					var newSlide = [];
					for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
						var row = [];
						for (var k = j; k < j + settings.slidesPerRow; k += 1) {
							if (settings.variableWidth && children[k].props.style) currentWidth = children[k].props.style.width;
							if (k >= children.length) break;
							row.push(/* @__PURE__ */ import_react.cloneElement(children[k], {
								key: 100 * i + 10 * j + k,
								tabIndex: -1,
								style: {
									width: "".concat(100 / settings.slidesPerRow, "%"),
									display: "inline-block"
								}
							}));
						}
						newSlide.push(/* @__PURE__ */ import_react.createElement("div", { key: 10 * i + j }, row));
					}
					if (settings.variableWidth) newChildren.push(/* @__PURE__ */ import_react.createElement("div", {
						key: i,
						style: { width: currentWidth }
					}, newSlide));
					else newChildren.push(/* @__PURE__ */ import_react.createElement("div", { key: i }, newSlide));
				}
				if (settings === "unslick") {
					var className = "regular slider " + (this.props.className || "");
					return /* @__PURE__ */ import_react.createElement("div", { className }, children);
				} else if (newChildren.length <= settings.slidesToShow && !settings.infinite) settings.unslick = true;
				return /* @__PURE__ */ import_react.createElement(InnerSlider, _extends({
					style: this.props.style,
					ref: this.innerSliderRefHandler
				}, filterSettings(settings)), newChildren);
			}
		}
	]);
}(import_react.Component);

//#endregion
//#region node_modules/@ant-design/react-slick/es/index.js
var es_default$28 = Slider$2;

//#endregion
//#region node_modules/antd/es/carousel/style/index.js
const DotDuration = "--dot-duration";
var genCarouselStyle = (token$1) => {
	const { componentCls, antCls } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		".slick-slider": {
			position: "relative",
			display: "block",
			boxSizing: "border-box",
			touchAction: "pan-y",
			WebkitTouchCallout: "none",
			WebkitTapHighlightColor: "transparent",
			".slick-track, .slick-list": {
				transform: "translate3d(0, 0, 0)",
				touchAction: "pan-y"
			}
		},
		".slick-list": {
			position: "relative",
			display: "block",
			margin: 0,
			padding: 0,
			overflow: "hidden",
			"&:focus": { outline: "none" },
			"&.dragging": { cursor: "pointer" },
			".slick-slide": {
				pointerEvents: "none",
				[`input${antCls}-radio-input, input${antCls}-checkbox-input`]: { visibility: "hidden" },
				"&.slick-active": {
					pointerEvents: "auto",
					[`input${antCls}-radio-input, input${antCls}-checkbox-input`]: { visibility: "visible" }
				},
				"> div > div": { verticalAlign: "bottom" }
			}
		},
		".slick-track": {
			position: "relative",
			top: 0,
			insetInlineStart: 0,
			display: "block",
			"&::before, &::after": {
				display: "table",
				content: "\"\""
			},
			"&::after": { clear: "both" }
		},
		".slick-slide": {
			display: "none",
			float: "left",
			height: "100%",
			minHeight: 1,
			img: { display: "block" },
			"&.dragging img": { pointerEvents: "none" }
		},
		".slick-initialized .slick-slide": { display: "block" },
		".slick-vertical .slick-slide": {
			display: "block",
			height: "auto"
		}
	}) };
};
var genArrowsStyle = (token$1) => {
	const { componentCls, motionDurationSlow, arrowSize, arrowOffset } = token$1;
	const arrowLength = token$1.calc(arrowSize).div(Math.SQRT2).equal();
	return { [componentCls]: {
		".slick-prev, .slick-next": {
			position: "absolute",
			top: "50%",
			width: arrowSize,
			height: arrowSize,
			transform: "translateY(-50%)",
			color: "#fff",
			opacity: .4,
			background: "transparent",
			padding: 0,
			lineHeight: 0,
			border: 0,
			outline: "none",
			cursor: "pointer",
			zIndex: 1,
			transition: `opacity ${motionDurationSlow}`,
			"&:hover, &:focus": { opacity: 1 },
			"&.slick-disabled": {
				pointerEvents: "none",
				opacity: 0
			},
			"&::after": {
				boxSizing: "border-box",
				position: "absolute",
				top: token$1.calc(arrowSize).sub(arrowLength).div(2).equal(),
				insetInlineStart: token$1.calc(arrowSize).sub(arrowLength).div(2).equal(),
				display: "inline-block",
				width: arrowLength,
				height: arrowLength,
				border: `0 solid currentcolor`,
				borderInlineStartWidth: 2,
				borderBlockStartWidth: 2,
				borderRadius: 1,
				content: "\"\""
			}
		},
		".slick-prev": {
			insetInlineStart: arrowOffset,
			"&::after": { transform: "rotate(-45deg)" }
		},
		".slick-next": {
			insetInlineEnd: arrowOffset,
			"&::after": { transform: "rotate(135deg)" }
		}
	} };
};
var genDotsStyle = (token$1) => {
	const { componentCls, dotOffset, dotWidth, dotHeight, dotGap, colorBgContainer, motionDurationSlow } = token$1;
	return { [componentCls]: { ".slick-dots": {
		position: "absolute",
		insetInlineEnd: 0,
		bottom: 0,
		insetInlineStart: 0,
		zIndex: 15,
		display: "flex !important",
		justifyContent: "center",
		paddingInlineStart: 0,
		margin: 0,
		listStyle: "none",
		"&-bottom": { bottom: dotOffset },
		"&-top": {
			top: dotOffset,
			bottom: "auto"
		},
		li: {
			position: "relative",
			display: "inline-block",
			flex: "0 1 auto",
			boxSizing: "content-box",
			width: dotWidth,
			height: dotHeight,
			marginInline: dotGap,
			padding: 0,
			textAlign: "center",
			textIndent: -999,
			verticalAlign: "top",
			transition: `all ${motionDurationSlow}`,
			borderRadius: dotHeight,
			overflow: "hidden",
			"&::after": {
				display: "block",
				position: "absolute",
				top: 0,
				insetInlineStart: 0,
				width: "100%",
				height: dotHeight,
				content: "\"\"",
				background: "transparent",
				borderRadius: dotHeight,
				opacity: 1,
				outline: "none",
				cursor: "pointer",
				overflow: "hidden",
				transform: "translate3d(-100%, 0, 0)"
			},
			button: {
				position: "relative",
				display: "block",
				width: "100%",
				height: dotHeight,
				padding: 0,
				color: "transparent",
				fontSize: 0,
				background: colorBgContainer,
				border: 0,
				borderRadius: dotHeight,
				outline: "none",
				cursor: "pointer",
				opacity: .2,
				transition: `all ${motionDurationSlow}`,
				overflow: "hidden",
				"&:hover": { opacity: .75 },
				"&::after": {
					position: "absolute",
					inset: token$1.calc(dotGap).mul(-1).equal(),
					content: "\"\""
				}
			},
			"&.slick-active": {
				width: token$1.dotActiveWidth,
				position: "relative",
				"&:hover": { opacity: 1 },
				"&::after": {
					background: colorBgContainer,
					transform: "translate3d(0, 0, 0)",
					transition: `transform var(${DotDuration}) ease-out`
				}
			}
		}
	} } };
};
var genCarouselVerticalStyle = (token$1) => {
	const { componentCls, dotOffset, arrowOffset, marginXXS } = token$1;
	const reverseSizeOfDot = {
		width: token$1.dotHeight,
		height: token$1.dotWidth
	};
	return { [`${componentCls}-vertical`]: {
		".slick-prev, .slick-next": {
			insetInlineStart: "50%",
			marginBlockStart: "unset",
			transform: "translateX(-50%)"
		},
		".slick-prev": {
			insetBlockStart: arrowOffset,
			insetInlineStart: "50%",
			"&::after": { transform: "rotate(45deg)" }
		},
		".slick-next": {
			insetBlockStart: "auto",
			insetBlockEnd: arrowOffset,
			"&::after": { transform: "rotate(-135deg)" }
		},
		".slick-dots": {
			top: "50%",
			bottom: "auto",
			flexDirection: "column",
			width: token$1.dotHeight,
			height: "auto",
			margin: 0,
			transform: "translateY(-50%)",
			"&-left": {
				insetInlineEnd: "auto",
				insetInlineStart: dotOffset
			},
			"&-right": {
				insetInlineEnd: dotOffset,
				insetInlineStart: "auto"
			},
			li: Object.assign(Object.assign({}, reverseSizeOfDot), {
				margin: `${unit(marginXXS)} 0`,
				verticalAlign: "baseline",
				button: reverseSizeOfDot,
				"&::after": Object.assign(Object.assign({}, reverseSizeOfDot), { height: 0 }),
				"&.slick-active": Object.assign(Object.assign({}, reverseSizeOfDot), {
					button: reverseSizeOfDot,
					"&::after": Object.assign(Object.assign({}, reverseSizeOfDot), { transition: `height var(${DotDuration}) ease-out` })
				})
			})
		}
	} };
};
var genCarouselRtlStyle = (token$1) => {
	const { componentCls } = token$1;
	return [{ [`${componentCls}-rtl`]: { direction: "rtl" } }, { [`${componentCls}-vertical`]: { ".slick-dots": { [`${componentCls}-rtl&`]: { flexDirection: "column" } } } }];
};
const prepareComponentToken$32 = (token$1) => {
	const dotActiveWidth = 24;
	return {
		arrowSize: 16,
		arrowOffset: token$1.marginXS,
		dotWidth: 16,
		dotHeight: 3,
		dotGap: token$1.marginXXS,
		dotOffset: 12,
		dotWidthActive: dotActiveWidth,
		dotActiveWidth
	};
};
var style_default$40 = genStyleHooks("Carousel", (token$1) => [
	genCarouselStyle(token$1),
	genArrowsStyle(token$1),
	genDotsStyle(token$1),
	genCarouselVerticalStyle(token$1),
	genCarouselRtlStyle(token$1)
], prepareComponentToken$32, { deprecatedTokens: [["dotWidthActive", "dotActiveWidth"]] });

//#endregion
//#region node_modules/antd/es/carousel/index.js
var import_classnames$152 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$75 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var dotsClass = "slick-dots";
var ArrowButton = (_a) => {
	var { currentSlide, slideCount } = _a, rest = __rest$75(_a, ["currentSlide", "slideCount"]);
	return /* @__PURE__ */ import_react.createElement("button", Object.assign({ type: "button" }, rest));
};
var Carousel = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { dots = true, arrows = false, prevArrow, nextArrow, draggable = false, waitForAnimate = false, dotPosition = "bottom", vertical = dotPosition === "left" || dotPosition === "right", rootClassName, className: customClassName, style: style$1, id, autoplay = false, autoplaySpeed = 3e3, rtl } = props, otherProps = __rest$75(props, [
		"dots",
		"arrows",
		"prevArrow",
		"nextArrow",
		"draggable",
		"waitForAnimate",
		"dotPosition",
		"vertical",
		"rootClassName",
		"className",
		"style",
		"id",
		"autoplay",
		"autoplaySpeed",
		"rtl"
	]);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("carousel");
	const slickRef = import_react.useRef(null);
	const goTo = (slide, dontAnimate = false) => {
		slickRef.current.slickGoTo(slide, dontAnimate);
	};
	import_react.useImperativeHandle(ref, () => ({
		goTo,
		autoPlay: slickRef.current.innerSlider.autoPlay,
		innerSlider: slickRef.current.innerSlider,
		prev: slickRef.current.slickPrev,
		next: slickRef.current.slickNext
	}), [slickRef.current]);
	const { children, initialSlide = 0 } = props;
	const count = import_react.Children.count(children);
	const isRTL = (rtl !== null && rtl !== void 0 ? rtl : direction === "rtl") && !vertical;
	import_react.useEffect(() => {
		if (count > 0) {
			const newIndex = isRTL ? count - initialSlide - 1 : initialSlide;
			goTo(newIndex, false);
		}
	}, [
		count,
		initialSlide,
		isRTL
	]);
	const newProps = Object.assign({
		vertical,
		className: (0, import_classnames$152.default)(customClassName, contextClassName),
		style: Object.assign(Object.assign({}, contextStyle), style$1),
		autoplay: !!autoplay
	}, otherProps);
	if (newProps.effect === "fade") newProps.fade = true;
	const prefixCls = getPrefixCls("carousel", newProps.prefixCls);
	const enableDots = !!dots;
	const dsClass = (0, import_classnames$152.default)(dotsClass, `${dotsClass}-${dotPosition}`, typeof dots === "boolean" ? false : dots === null || dots === void 0 ? void 0 : dots.className);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$40(prefixCls);
	const className = (0, import_classnames$152.default)(prefixCls, {
		[`${prefixCls}-rtl`]: isRTL,
		[`${prefixCls}-vertical`]: newProps.vertical
	}, hashId, cssVarCls, rootClassName);
	const dotDurationStyle = autoplay && (typeof autoplay === "object" ? autoplay.dotDuration : false) ? { [DotDuration]: `${autoplaySpeed}ms` } : {};
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
		className,
		id,
		style: dotDurationStyle
	}, /* @__PURE__ */ import_react.createElement(es_default$28, Object.assign({ ref: slickRef }, newProps, {
		dots: enableDots,
		dotsClass: dsClass,
		arrows,
		prevArrow: prevArrow !== null && prevArrow !== void 0 ? prevArrow : /* @__PURE__ */ import_react.createElement(ArrowButton, { "aria-label": isRTL ? "next" : "prev" }),
		nextArrow: nextArrow !== null && nextArrow !== void 0 ? nextArrow : /* @__PURE__ */ import_react.createElement(ArrowButton, { "aria-label": isRTL ? "prev" : "next" }),
		draggable,
		verticalSwiping: vertical,
		autoplaySpeed,
		waitForAnimate,
		rtl: isRTL
	}))));
});
Carousel.displayName = "Carousel";
var carousel_default = Carousel;

//#endregion
//#region node_modules/rc-cascader/es/context.js
var CascaderContext = /* @__PURE__ */ import_react.createContext({});
var context_default$4 = CascaderContext;

//#endregion
//#region node_modules/rc-cascader/es/hooks/useSearchOptions.js
var SEARCH_MARK = "__rc_cascader_search_mark__";
var defaultFilter = function defaultFilter$1(search, options, _ref) {
	var _ref$label = _ref.label, label = _ref$label === void 0 ? "" : _ref$label;
	return options.some(function(opt) {
		return String(opt[label]).toLowerCase().includes(search.toLowerCase());
	});
};
var defaultRender$1 = function defaultRender$2(inputValue, path$1, prefixCls, fieldNames) {
	return path$1.map(function(opt) {
		return opt[fieldNames.label];
	}).join(" / ");
};
var useSearchOptions = function useSearchOptions$1(search, options, fieldNames, prefixCls, config, enableHalfPath) {
	var _config$filter = config.filter, filter$2 = _config$filter === void 0 ? defaultFilter : _config$filter, _config$render = config.render, render$1 = _config$render === void 0 ? defaultRender$1 : _config$render, _config$limit = config.limit, limit = _config$limit === void 0 ? 50 : _config$limit, sort = config.sort;
	return import_react.useMemo(function() {
		var filteredOptions = [];
		if (!search) return [];
		function dig(list, pathOptions) {
			var parentDisabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
			list.forEach(function(option) {
				if (!sort && limit !== false && limit > 0 && filteredOptions.length >= limit) return;
				var connectedPathOptions = [].concat(_toConsumableArray(pathOptions), [option]);
				var children = option[fieldNames.children];
				var mergedDisabled = parentDisabled || option.disabled;
				if (!children || children.length === 0 || enableHalfPath) {
					if (filter$2(search, connectedPathOptions, { label: fieldNames.label })) {
						var _objectSpread2$1;
						filteredOptions.push(_objectSpread2(_objectSpread2({}, option), {}, (_objectSpread2$1 = { disabled: mergedDisabled }, _defineProperty(_objectSpread2$1, fieldNames.label, render$1(search, connectedPathOptions, prefixCls, fieldNames)), _defineProperty(_objectSpread2$1, SEARCH_MARK, connectedPathOptions), _defineProperty(_objectSpread2$1, fieldNames.children, void 0), _objectSpread2$1)));
					}
				}
				if (children) dig(option[fieldNames.children], connectedPathOptions, mergedDisabled);
			});
		}
		dig(options, []);
		if (sort) filteredOptions.sort(function(a, b) {
			return sort(a[SEARCH_MARK], b[SEARCH_MARK], search, fieldNames);
		});
		return limit !== false && limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
	}, [
		search,
		options,
		fieldNames,
		prefixCls,
		render$1,
		enableHalfPath,
		filter$2,
		sort,
		limit
	]);
};
var useSearchOptions_default = useSearchOptions;

//#endregion
//#region node_modules/rc-cascader/es/utils/commonUtil.js
var VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
var SHOW_PARENT$2 = "SHOW_PARENT";
var SHOW_CHILD$2 = "SHOW_CHILD";
/**
* Will convert value to string, and join with `VALUE_SPLIT`
*/
function toPathKey(value) {
	return value.join(VALUE_SPLIT);
}
/**
* Batch convert value to string, and join with `VALUE_SPLIT`
*/
function toPathKeys(value) {
	return value.map(toPathKey);
}
function toPathValueStr(pathKey$1) {
	return pathKey$1.split(VALUE_SPLIT);
}
function fillFieldNames$2(fieldNames) {
	var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, children = _ref.children;
	var val = value || "value";
	return {
		label: label || "label",
		value: val,
		key: val,
		children: children || "children"
	};
}
function isLeaf(option, fieldNames) {
	var _option$isLeaf, _option;
	return (_option$isLeaf = option.isLeaf) !== null && _option$isLeaf !== void 0 ? _option$isLeaf : !((_option = option[fieldNames.children]) !== null && _option !== void 0 && _option.length);
}
function scrollIntoParentView(element) {
	var parent = element.parentElement;
	if (!parent) return;
	var elementToParent = element.offsetTop - parent.offsetTop;
	if (elementToParent - parent.scrollTop < 0) parent.scrollTo({ top: elementToParent });
	else if (elementToParent + element.offsetHeight - parent.scrollTop > parent.offsetHeight) parent.scrollTo({ top: elementToParent + element.offsetHeight - parent.offsetHeight });
}
function getFullPathKeys(options, fieldNames) {
	return options.map(function(item) {
		var _item$SEARCH_MARK;
		return (_item$SEARCH_MARK = item[SEARCH_MARK]) === null || _item$SEARCH_MARK === void 0 ? void 0 : _item$SEARCH_MARK.map(function(opt) {
			return opt[fieldNames.value];
		});
	});
}
function isMultipleValue(value) {
	return Array.isArray(value) && Array.isArray(value[0]);
}
function toRawValues(value) {
	if (!value) return [];
	if (isMultipleValue(value)) return value;
	return (value.length === 0 ? [] : [value]).map(function(val) {
		return Array.isArray(val) ? val : [val];
	});
}

//#endregion
//#region node_modules/rc-cascader/es/utils/treeUtil.js
function formatStrategyValues$1(pathKeys, getKeyPathEntities, showCheckedStrategy) {
	var valueSet = new Set(pathKeys);
	var keyPathEntities = getKeyPathEntities();
	return pathKeys.filter(function(key) {
		var entity = keyPathEntities[key];
		var parent = entity ? entity.parent : null;
		var children = entity ? entity.children : null;
		if (entity && entity.node.disabled) return true;
		return showCheckedStrategy === SHOW_CHILD$2 ? !(children && children.some(function(child) {
			return child.key && valueSet.has(child.key);
		})) : !(parent && !parent.node.disabled && valueSet.has(parent.key));
	});
}
function toPathOptions(valueCells, options, fieldNames) {
	var stringMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	var currentList = options;
	var valueOptions = [];
	var _loop = function _loop$1() {
		var _currentList, _currentList2, _foundOption$fieldNam;
		var valueCell = valueCells[i];
		var foundIndex = (_currentList = currentList) === null || _currentList === void 0 ? void 0 : _currentList.findIndex(function(option) {
			var val = option[fieldNames.value];
			return stringMode ? String(val) === String(valueCell) : val === valueCell;
		});
		var foundOption = foundIndex !== -1 ? (_currentList2 = currentList) === null || _currentList2 === void 0 ? void 0 : _currentList2[foundIndex] : null;
		valueOptions.push({
			value: (_foundOption$fieldNam = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.value]) !== null && _foundOption$fieldNam !== void 0 ? _foundOption$fieldNam : valueCell,
			index: foundIndex,
			option: foundOption
		});
		currentList = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.children];
	};
	for (var i = 0; i < valueCells.length; i += 1) _loop();
	return valueOptions;
}

//#endregion
//#region node_modules/rc-cascader/es/hooks/useDisplayValues.js
var useDisplayValues_default = (function(rawValues, options, fieldNames, multiple, displayRender) {
	return import_react.useMemo(function() {
		var mergedDisplayRender = displayRender || function(labels) {
			var mergedLabels = multiple ? labels.slice(-1) : labels;
			var SPLIT$2 = " / ";
			if (mergedLabels.every(function(label) {
				return ["string", "number"].includes(_typeof(label));
			})) return mergedLabels.join(SPLIT$2);
			return mergedLabels.reduce(function(list, label, index$2) {
				var keyedLabel = /* @__PURE__ */ import_react.isValidElement(label) ? /* @__PURE__ */ import_react.cloneElement(label, { key: index$2 }) : label;
				if (index$2 === 0) return [keyedLabel];
				return [].concat(_toConsumableArray(list), [SPLIT$2, keyedLabel]);
			}, []);
		};
		return rawValues.map(function(valueCells) {
			var _valueOptions;
			var valueOptions = toPathOptions(valueCells, options, fieldNames);
			var label = mergedDisplayRender(valueOptions.map(function(_ref) {
				var _option$fieldNames$la;
				var option = _ref.option, value$1 = _ref.value;
				return (_option$fieldNames$la = option === null || option === void 0 ? void 0 : option[fieldNames.label]) !== null && _option$fieldNames$la !== void 0 ? _option$fieldNames$la : value$1;
			}), valueOptions.map(function(_ref2) {
				return _ref2.option;
			}));
			var value = toPathKey(valueCells);
			return {
				label,
				value,
				key: value,
				valueCells,
				disabled: (_valueOptions = valueOptions[valueOptions.length - 1]) === null || _valueOptions === void 0 || (_valueOptions = _valueOptions.option) === null || _valueOptions === void 0 ? void 0 : _valueOptions.disabled
			};
		});
	}, [
		rawValues,
		options,
		fieldNames,
		displayRender,
		multiple
	]);
});

//#endregion
//#region node_modules/rc-cascader/es/hooks/useMissingValues.js
function useMissingValues(options, fieldNames) {
	return import_react.useCallback(function(rawValues) {
		var missingValues = [];
		var existsValues = [];
		rawValues.forEach(function(valueCell) {
			if (toPathOptions(valueCell, options, fieldNames).every(function(opt) {
				return opt.option;
			})) existsValues.push(valueCell);
			else missingValues.push(valueCell);
		});
		return [existsValues, missingValues];
	}, [options, fieldNames]);
}

//#endregion
//#region node_modules/rc-tree/es/utils/keyUtil.js
function getEntity(keyEntities, key) {
	return keyEntities[key];
}

//#endregion
//#region node_modules/rc-tree/es/utils/treeUtil.js
var _excluded$35 = ["children"];
function getPosition$1(level, index$2) {
	return "".concat(level, "-").concat(index$2);
}
function isTreeNode(node$1) {
	return node$1 && node$1.type && node$1.type.isTreeNode;
}
function getKey(key, pos) {
	if (key !== null && key !== void 0) return key;
	return pos;
}
function fillFieldNames$1(fieldNames) {
	var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key = _ref.key, children = _ref.children;
	var mergedTitle = title || "title";
	return {
		title: mergedTitle,
		_title: _title || [mergedTitle],
		key: key || "key",
		children: children || "children"
	};
}
/**
* Warning if TreeNode do not provides key
*/
function warningWithoutKey(treeData, fieldNames) {
	var keys$1 = /* @__PURE__ */ new Map();
	function dig(list) {
		var path$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
		(list || []).forEach(function(treeNode) {
			var key = treeNode[fieldNames.key];
			var children = treeNode[fieldNames.children];
			warning_default(key !== null && key !== void 0, "Tree node must have a certain key: [".concat(path$1).concat(key, "]"));
			var recordKey = String(key);
			warning_default(!keys$1.has(recordKey) || key === null || key === void 0, "Same 'key' exist in the Tree: ".concat(recordKey));
			keys$1.set(recordKey, true);
			dig(children, "".concat(path$1).concat(recordKey, " > "));
		});
	}
	dig(treeData);
}
/**
* Convert `children` of Tree into `treeData` structure.
*/
function convertTreeToData(rootNodes) {
	function dig(node$1) {
		return toArray(node$1).map(function(treeNode) {
			if (!isTreeNode(treeNode)) {
				warning_default(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
				return null;
			}
			var key = treeNode.key;
			var _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = _objectWithoutProperties(_treeNode$props, _excluded$35);
			var dataNode = _objectSpread2({ key }, rest);
			var parsedChildren = dig(children);
			if (parsedChildren.length) dataNode.children = parsedChildren;
			return dataNode;
		}).filter(function(dataNode) {
			return dataNode;
		});
	}
	return dig(rootNodes);
}
/**
* Flat nest tree data into flatten list. This is used for virtual list render.
* @param treeNodeList Origin data node list
* @param expandedKeys
* need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).
*/
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
	var _fillFieldNames = fillFieldNames$1(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
	var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
	var flattenList = [];
	function dig(list) {
		var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
		return list.map(function(treeNode, index$2) {
			var pos = getPosition$1(parent ? parent.pos : "0", index$2);
			var mergedKey = getKey(treeNode[fieldKey], pos);
			var mergedTitle;
			for (var i = 0; i < fieldTitles.length; i += 1) {
				var fieldTitle = fieldTitles[i];
				if (treeNode[fieldTitle] !== void 0) {
					mergedTitle = treeNode[fieldTitle];
					break;
				}
			}
			var flattenNode = Object.assign(omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren])), {
				title: mergedTitle,
				key: mergedKey,
				parent,
				pos,
				children: null,
				data: treeNode,
				isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index$2 === 0]),
				isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index$2 === list.length - 1])
			});
			flattenList.push(flattenNode);
			if (expandedKeys === true || expandedKeySet.has(mergedKey)) flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
			else flattenNode.children = [];
			return flattenNode;
		});
	}
	dig(treeNodeList);
	return flattenList;
}
/**
* Traverse all the data by `treeData`.
* Please not use it out of the `rc-tree` since we may refactor this code.
*/
function traverseDataNodes(dataNodes, callback, config) {
	var mergedConfig = {};
	if (_typeof(config) === "object") mergedConfig = config;
	else mergedConfig = { externalGetKey: config };
	mergedConfig = mergedConfig || {};
	var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
	var _fillFieldNames2 = fillFieldNames$1(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
	var mergeChildrenPropName = childrenPropName || fieldChildren;
	var syntheticGetKey;
	if (externalGetKey) {
		if (typeof externalGetKey === "string") syntheticGetKey = function syntheticGetKey$1(node$1) {
			return node$1[externalGetKey];
		};
		else if (typeof externalGetKey === "function") syntheticGetKey = function syntheticGetKey$1(node$1) {
			return externalGetKey(node$1);
		};
	} else syntheticGetKey = function syntheticGetKey$1(node$1, pos) {
		return getKey(node$1[fieldKey], pos);
	};
	function processNode(node$1, index$2, parent, pathNodes) {
		var children = node$1 ? node$1[mergeChildrenPropName] : dataNodes;
		var pos = node$1 ? getPosition$1(parent.pos, index$2) : "0";
		var connectNodes = node$1 ? [].concat(_toConsumableArray(pathNodes), [node$1]) : [];
		if (node$1) {
			var key = syntheticGetKey(node$1, pos);
			var _data = {
				node: node$1,
				index: index$2,
				pos,
				key,
				parentPos: parent.node ? parent.pos : null,
				level: parent.level + 1,
				nodes: connectNodes
			};
			callback(_data);
		}
		if (children) children.forEach(function(subNode, subIndex) {
			processNode(subNode, subIndex, {
				node: node$1,
				pos,
				level: parent ? parent.level + 1 : -1
			}, connectNodes);
		});
	}
	processNode(null);
}
/**
* Convert `treeData` into entity records.
*/
function convertDataToEntities(dataNodes) {
	var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
	var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
	var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
	var posEntities = {};
	var keyEntities = {};
	var wrapper = {
		posEntities,
		keyEntities
	};
	if (initWrapper) wrapper = initWrapper(wrapper) || wrapper;
	traverseDataNodes(dataNodes, function(item) {
		var node$1 = item.node, index$2 = item.index, pos = item.pos, key = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
		var entity = {
			node: node$1,
			nodes,
			index: index$2,
			key,
			pos,
			level
		};
		var mergedKey = getKey(key, pos);
		posEntities[pos] = entity;
		keyEntities[mergedKey] = entity;
		entity.parent = posEntities[parentPos];
		if (entity.parent) {
			entity.parent.children = entity.parent.children || [];
			entity.parent.children.push(entity);
		}
		if (processEntity) processEntity(entity, wrapper);
	}, {
		externalGetKey: mergedExternalGetKey,
		childrenPropName,
		fieldNames
	});
	if (onProcessFinished) onProcessFinished(wrapper);
	return wrapper;
}
/**
* Get TreeNode props with Tree props.
*/
function getTreeNodeProps(key, _ref3) {
	var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
	var entity = getEntity(keyEntities, key);
	return {
		eventKey: key,
		expanded: expandedKeys.indexOf(key) !== -1,
		selected: selectedKeys.indexOf(key) !== -1,
		loaded: loadedKeys.indexOf(key) !== -1,
		loading: loadingKeys.indexOf(key) !== -1,
		checked: checkedKeys.indexOf(key) !== -1,
		halfChecked: halfCheckedKeys.indexOf(key) !== -1,
		pos: String(entity ? entity.pos : ""),
		dragOver: dragOverNodeKey === key && dropPosition === 0,
		dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
		dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
	};
}
function convertNodePropsToEventData(props) {
	var data = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey;
	var eventData = _objectSpread2(_objectSpread2({}, data), {}, {
		expanded,
		selected,
		checked,
		loaded,
		loading,
		halfChecked,
		dragOver,
		dragOverGapTop,
		dragOverGapBottom,
		pos,
		active,
		key: eventKey
	});
	if (!("props" in eventData)) Object.defineProperty(eventData, "props", { get: function get$1() {
		warning_default(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
		return props;
	} });
	return eventData;
}

//#endregion
//#region node_modules/rc-cascader/es/hooks/useEntities.js
/** Lazy parse options data into conduct-able info to avoid perf issue in single mode */
var useEntities_default = (function(options, fieldNames) {
	var cacheRef = import_react.useRef({
		options: [],
		info: {
			keyEntities: {},
			pathKeyEntities: {}
		}
	});
	return import_react.useCallback(function() {
		if (cacheRef.current.options !== options) {
			cacheRef.current.options = options;
			cacheRef.current.info = convertDataToEntities(options, {
				fieldNames,
				initWrapper: function initWrapper(wrapper) {
					return _objectSpread2(_objectSpread2({}, wrapper), {}, { pathKeyEntities: {} });
				},
				processEntity: function processEntity(entity, wrapper) {
					var pathKey$1 = entity.nodes.map(function(node$1) {
						return node$1[fieldNames.value];
					}).join(VALUE_SPLIT);
					wrapper.pathKeyEntities[pathKey$1] = entity;
					entity.key = pathKey$1;
				}
			});
		}
		return cacheRef.current.info.pathKeyEntities;
	}, [fieldNames, options]);
});

//#endregion
//#region node_modules/rc-cascader/es/hooks/useOptions.js
function useOptions(mergedFieldNames, options) {
	var mergedOptions = import_react.useMemo(function() {
		return options || [];
	}, [options]);
	var getPathKeyEntities = useEntities_default(mergedOptions, mergedFieldNames);
	/** Convert path key back to value format */
	var getValueByKeyPath = import_react.useCallback(function(pathKeys) {
		var keyPathEntities = getPathKeyEntities();
		return pathKeys.map(function(pathKey$1) {
			return keyPathEntities[pathKey$1].nodes.map(function(node$1) {
				return node$1[mergedFieldNames.value];
			});
		});
	}, [getPathKeyEntities, mergedFieldNames]);
	return [
		mergedOptions,
		getPathKeyEntities,
		getValueByKeyPath
	];
}

//#endregion
//#region node_modules/rc-cascader/es/hooks/useSearchConfig.js
function useSearchConfig(showSearch) {
	return import_react.useMemo(function() {
		if (!showSearch) return [false, {}];
		var searchConfig = {
			matchInputWidth: true,
			limit: 50
		};
		if (showSearch && _typeof(showSearch) === "object") searchConfig = _objectSpread2(_objectSpread2({}, searchConfig), showSearch);
		if (searchConfig.limit <= 0) {
			searchConfig.limit = false;
			warning_default(false, "'limit' of showSearch should be positive number or false.");
		}
		return [true, searchConfig];
	}, [showSearch]);
}

//#endregion
//#region node_modules/rc-tree/es/utils/conductUtil.js
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
	var filteredKeys = /* @__PURE__ */ new Set();
	halfCheckedKeys.forEach(function(key) {
		if (!checkedKeys.has(key)) filteredKeys.add(key);
	});
	return filteredKeys;
}
function isCheckDisabled$1(node$1) {
	var _ref = node$1 || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
	return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys$1, levelEntities, maxLevel, syntheticGetCheckDisabled) {
	var checkedKeys = new Set(keys$1);
	var halfCheckedKeys = /* @__PURE__ */ new Set();
	for (var level = 0; level <= maxLevel; level += 1) (levelEntities.get(level) || /* @__PURE__ */ new Set()).forEach(function(entity) {
		var key = entity.key, node$1 = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
		if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node$1)) children.filter(function(childEntity) {
			return !syntheticGetCheckDisabled(childEntity.node);
		}).forEach(function(childEntity) {
			checkedKeys.add(childEntity.key);
		});
	});
	var visitedKeys = /* @__PURE__ */ new Set();
	for (var _level = maxLevel; _level >= 0; _level -= 1) (levelEntities.get(_level) || /* @__PURE__ */ new Set()).forEach(function(entity) {
		var parent = entity.parent, node$1 = entity.node;
		if (syntheticGetCheckDisabled(node$1) || !entity.parent || visitedKeys.has(entity.parent.key)) return;
		if (syntheticGetCheckDisabled(entity.parent.node)) {
			visitedKeys.add(parent.key);
			return;
		}
		var allChecked = true;
		var partialChecked = false;
		(parent.children || []).filter(function(childEntity) {
			return !syntheticGetCheckDisabled(childEntity.node);
		}).forEach(function(_ref2) {
			var key = _ref2.key;
			var checked = checkedKeys.has(key);
			if (allChecked && !checked) allChecked = false;
			if (!partialChecked && (checked || halfCheckedKeys.has(key))) partialChecked = true;
		});
		if (allChecked) checkedKeys.add(parent.key);
		if (partialChecked) halfCheckedKeys.add(parent.key);
		visitedKeys.add(parent.key);
	});
	return {
		checkedKeys: Array.from(checkedKeys),
		halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
	};
}
function cleanConductCheck(keys$1, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
	var checkedKeys = new Set(keys$1);
	var halfCheckedKeys = new Set(halfKeys);
	for (var level = 0; level <= maxLevel; level += 1) (levelEntities.get(level) || /* @__PURE__ */ new Set()).forEach(function(entity) {
		var key = entity.key, node$1 = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
		if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node$1)) children.filter(function(childEntity) {
			return !syntheticGetCheckDisabled(childEntity.node);
		}).forEach(function(childEntity) {
			checkedKeys.delete(childEntity.key);
		});
	});
	halfCheckedKeys = /* @__PURE__ */ new Set();
	var visitedKeys = /* @__PURE__ */ new Set();
	for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) (levelEntities.get(_level2) || /* @__PURE__ */ new Set()).forEach(function(entity) {
		var parent = entity.parent, node$1 = entity.node;
		if (syntheticGetCheckDisabled(node$1) || !entity.parent || visitedKeys.has(entity.parent.key)) return;
		if (syntheticGetCheckDisabled(entity.parent.node)) {
			visitedKeys.add(parent.key);
			return;
		}
		var allChecked = true;
		var partialChecked = false;
		(parent.children || []).filter(function(childEntity) {
			return !syntheticGetCheckDisabled(childEntity.node);
		}).forEach(function(_ref3) {
			var key = _ref3.key;
			var checked = checkedKeys.has(key);
			if (allChecked && !checked) allChecked = false;
			if (!partialChecked && (checked || halfCheckedKeys.has(key))) partialChecked = true;
		});
		if (!allChecked) checkedKeys.delete(parent.key);
		if (partialChecked) halfCheckedKeys.add(parent.key);
		visitedKeys.add(parent.key);
	});
	return {
		checkedKeys: Array.from(checkedKeys),
		halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
	};
}
/**
* Conduct with keys.
* @param keyList current key list
* @param keyEntities key - dataEntity map
* @param mode `fill` to fill missing key, `clean` to remove useless key
*/
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
	var warningMissKeys = [];
	var syntheticGetCheckDisabled;
	if (getCheckDisabled) syntheticGetCheckDisabled = getCheckDisabled;
	else syntheticGetCheckDisabled = isCheckDisabled$1;
	var keys$1 = new Set(keyList.filter(function(key) {
		var hasEntity = !!getEntity(keyEntities, key);
		if (!hasEntity) warningMissKeys.push(key);
		return hasEntity;
	}));
	var levelEntities = /* @__PURE__ */ new Map();
	var maxLevel = 0;
	Object.keys(keyEntities).forEach(function(key) {
		var entity = keyEntities[key];
		var level = entity.level;
		var levelSet = levelEntities.get(level);
		if (!levelSet) {
			levelSet = /* @__PURE__ */ new Set();
			levelEntities.set(level, levelSet);
		}
		levelSet.add(entity);
		maxLevel = Math.max(maxLevel, level);
	});
	warning_default(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key) {
		return "'".concat(key, "'");
	}).join(", ")));
	var result;
	if (checked === true) result = fillConductCheck(keys$1, levelEntities, maxLevel, syntheticGetCheckDisabled);
	else result = cleanConductCheck(keys$1, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
	return result;
}

//#endregion
//#region node_modules/rc-cascader/es/hooks/useSelect.js
function useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy) {
	return function(valuePath) {
		if (!multiple) triggerChange(valuePath);
		else {
			var pathKey$1 = toPathKey(valuePath);
			var checkedPathKeys = toPathKeys(checkedValues);
			var halfCheckedPathKeys = toPathKeys(halfCheckedValues);
			var existInChecked = checkedPathKeys.includes(pathKey$1);
			var existInMissing = missingCheckedValues.some(function(valueCells) {
				return toPathKey(valueCells) === pathKey$1;
			});
			var nextCheckedValues = checkedValues;
			var nextMissingValues = missingCheckedValues;
			if (existInMissing && !existInChecked) nextMissingValues = missingCheckedValues.filter(function(valueCells) {
				return toPathKey(valueCells) !== pathKey$1;
			});
			else {
				var nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter(function(key) {
					return key !== pathKey$1;
				}) : [].concat(_toConsumableArray(checkedPathKeys), [pathKey$1]);
				var pathKeyEntities = getPathKeyEntities();
				var checkedKeys;
				if (existInChecked) checkedKeys = conductCheck(nextRawCheckedKeys, {
					checked: false,
					halfCheckedKeys: halfCheckedPathKeys
				}, pathKeyEntities).checkedKeys;
				else checkedKeys = conductCheck(nextRawCheckedKeys, true, pathKeyEntities).checkedKeys;
				var deDuplicatedKeys = formatStrategyValues$1(checkedKeys, getPathKeyEntities, showCheckedStrategy);
				nextCheckedValues = getValueByKeyPath(deDuplicatedKeys);
			}
			triggerChange([].concat(_toConsumableArray(nextMissingValues), _toConsumableArray(nextCheckedValues)));
		}
	};
}

//#endregion
//#region node_modules/rc-cascader/es/hooks/useValues.js
function useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues) {
	return import_react.useMemo(function() {
		var _getMissingValues = getMissingValues(rawValues), _getMissingValues2 = _slicedToArray(_getMissingValues, 2), existValues = _getMissingValues2[0], missingValues = _getMissingValues2[1];
		if (!multiple || !rawValues.length) return [
			existValues,
			[],
			missingValues
		];
		var keyPathValues = toPathKeys(existValues);
		var keyPathEntities = getPathKeyEntities();
		var _conductCheck = conductCheck(keyPathValues, true, keyPathEntities), checkedKeys = _conductCheck.checkedKeys, halfCheckedKeys = _conductCheck.halfCheckedKeys;
		return [
			getValueByKeyPath(checkedKeys),
			getValueByKeyPath(halfCheckedKeys),
			missingValues
		];
	}, [
		multiple,
		rawValues,
		getPathKeyEntities,
		getValueByKeyPath,
		getMissingValues
	]);
}

//#endregion
//#region node_modules/rc-cascader/es/OptionList/CacheContent.js
var CacheContent = /* @__PURE__ */ import_react.memo(function(_ref) {
	return _ref.children;
}, function(_, next$1) {
	return !next$1.open;
});
CacheContent.displayName = "CacheContent";
var CacheContent_default = CacheContent;

//#endregion
//#region node_modules/rc-cascader/es/OptionList/Checkbox.js
var import_classnames$151 = /* @__PURE__ */ __toESM(require_classnames());
function Checkbox$2(_ref) {
	var _classNames;
	var prefixCls = _ref.prefixCls, checked = _ref.checked, halfChecked = _ref.halfChecked, disabled = _ref.disabled, onClick = _ref.onClick, disableCheckbox = _ref.disableCheckbox;
	var _React$useContext = import_react.useContext(context_default$4), checkable = _React$useContext.checkable;
	var customCheckbox = typeof checkable !== "boolean" ? checkable : null;
	return /* @__PURE__ */ import_react.createElement("span", {
		className: (0, import_classnames$151.default)("".concat(prefixCls), (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-checked"), checked), _defineProperty(_classNames, "".concat(prefixCls, "-indeterminate"), !checked && halfChecked), _defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled || disableCheckbox), _classNames)),
		onClick
	}, customCheckbox);
}

//#endregion
//#region node_modules/rc-cascader/es/OptionList/Column.js
var import_classnames$150 = /* @__PURE__ */ __toESM(require_classnames());
var FIX_LABEL = "__cascader_fix_label__";
function Column$2(_ref) {
	var prefixCls = _ref.prefixCls, multiple = _ref.multiple, options = _ref.options, activeValue = _ref.activeValue, prevValuePath = _ref.prevValuePath, onToggleOpen = _ref.onToggleOpen, onSelect = _ref.onSelect, onActive = _ref.onActive, checkedSet = _ref.checkedSet, halfCheckedSet = _ref.halfCheckedSet, loadingKeys = _ref.loadingKeys, isSelectable = _ref.isSelectable, propsDisabled = _ref.disabled;
	var menuPrefixCls = "".concat(prefixCls, "-menu");
	var menuItemPrefixCls = "".concat(prefixCls, "-menu-item");
	var _React$useContext = import_react.useContext(context_default$4), fieldNames = _React$useContext.fieldNames, changeOnSelect = _React$useContext.changeOnSelect, expandTrigger = _React$useContext.expandTrigger, expandIcon = _React$useContext.expandIcon, loadingIcon = _React$useContext.loadingIcon, dropdownMenuColumnStyle = _React$useContext.dropdownMenuColumnStyle, optionRender = _React$useContext.optionRender;
	var hoverOpen = expandTrigger === "hover";
	var isOptionDisabled = function isOptionDisabled$1(disabled) {
		return propsDisabled || disabled;
	};
	var optionInfoList = import_react.useMemo(function() {
		return options.map(function(option) {
			var _option$FIX_LABEL;
			var disabled = option.disabled, disableCheckbox = option.disableCheckbox;
			var searchOptions = option[SEARCH_MARK];
			var label = (_option$FIX_LABEL = option[FIX_LABEL]) !== null && _option$FIX_LABEL !== void 0 ? _option$FIX_LABEL : option[fieldNames.label];
			var value = option[fieldNames.value];
			var isMergedLeaf = isLeaf(option, fieldNames);
			var fullPath = searchOptions ? searchOptions.map(function(opt) {
				return opt[fieldNames.value];
			}) : [].concat(_toConsumableArray(prevValuePath), [value]);
			var fullPathKey = toPathKey(fullPath);
			var isLoading = loadingKeys.includes(fullPathKey);
			var checked = checkedSet.has(fullPathKey);
			var halfChecked = halfCheckedSet.has(fullPathKey);
			return {
				disabled,
				label,
				value,
				isLeaf: isMergedLeaf,
				isLoading,
				checked,
				halfChecked,
				option,
				disableCheckbox,
				fullPath,
				fullPathKey
			};
		});
	}, [
		options,
		checkedSet,
		fieldNames,
		halfCheckedSet,
		loadingKeys,
		prevValuePath
	]);
	return /* @__PURE__ */ import_react.createElement("ul", {
		className: menuPrefixCls,
		role: "menu"
	}, optionInfoList.map(function(_ref2) {
		var _classNames;
		var disabled = _ref2.disabled, label = _ref2.label, value = _ref2.value, isMergedLeaf = _ref2.isLeaf, isLoading = _ref2.isLoading, checked = _ref2.checked, halfChecked = _ref2.halfChecked, option = _ref2.option, fullPath = _ref2.fullPath, fullPathKey = _ref2.fullPathKey, disableCheckbox = _ref2.disableCheckbox;
		var triggerOpenPath = function triggerOpenPath$1() {
			if (isOptionDisabled(disabled)) return;
			var nextValueCells = _toConsumableArray(fullPath);
			if (hoverOpen && isMergedLeaf) nextValueCells.pop();
			onActive(nextValueCells);
		};
		var triggerSelect = function triggerSelect$1() {
			if (isSelectable(option) && !isOptionDisabled(disabled)) onSelect(fullPath, isMergedLeaf);
		};
		var title;
		if (typeof option.title === "string") title = option.title;
		else if (typeof label === "string") title = label;
		return /* @__PURE__ */ import_react.createElement("li", {
			key: fullPathKey,
			className: (0, import_classnames$150.default)(menuItemPrefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(menuItemPrefixCls, "-expand"), !isMergedLeaf), _defineProperty(_classNames, "".concat(menuItemPrefixCls, "-active"), activeValue === value || activeValue === fullPathKey), _defineProperty(_classNames, "".concat(menuItemPrefixCls, "-disabled"), isOptionDisabled(disabled)), _defineProperty(_classNames, "".concat(menuItemPrefixCls, "-loading"), isLoading), _classNames)),
			style: dropdownMenuColumnStyle,
			role: "menuitemcheckbox",
			title,
			"aria-checked": checked,
			"data-path-key": fullPathKey,
			onClick: function onClick() {
				triggerOpenPath();
				if (disableCheckbox) return;
				if (!multiple || isMergedLeaf) triggerSelect();
			},
			onDoubleClick: function onDoubleClick() {
				if (changeOnSelect) onToggleOpen(false);
			},
			onMouseEnter: function onMouseEnter() {
				if (hoverOpen) triggerOpenPath();
			},
			onMouseDown: function onMouseDown(e$2) {
				e$2.preventDefault();
			}
		}, multiple && /* @__PURE__ */ import_react.createElement(Checkbox$2, {
			prefixCls: "".concat(prefixCls, "-checkbox"),
			checked,
			halfChecked,
			disabled: isOptionDisabled(disabled) || disableCheckbox,
			disableCheckbox,
			onClick: function onClick(e$2) {
				if (disableCheckbox) return;
				e$2.stopPropagation();
				triggerSelect();
			}
		}), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(menuItemPrefixCls, "-content") }, optionRender ? optionRender(option) : label), !isLoading && expandIcon && !isMergedLeaf && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(menuItemPrefixCls, "-expand-icon") }, expandIcon), isLoading && loadingIcon && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(menuItemPrefixCls, "-loading-icon") }, loadingIcon));
	}));
}

//#endregion
//#region node_modules/rc-cascader/es/OptionList/useActive.js
/**
* Control the active open options path.
*/
var useActive = function useActive$2(multiple, open$2) {
	var firstValueCells = import_react.useContext(context_default$4).values[0];
	var _React$useState = import_react.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), activeValueCells = _React$useState2[0], setActiveValueCells = _React$useState2[1];
	import_react.useEffect(function() {
		if (!multiple) setActiveValueCells(firstValueCells || []);
	}, [open$2, firstValueCells]);
	return [activeValueCells, setActiveValueCells];
};
var useActive_default = useActive;

//#endregion
//#region node_modules/rc-cascader/es/OptionList/useKeyboard.js
var useKeyboard_default = (function(ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) {
	var direction = contextProps.direction, searchValue = contextProps.searchValue, toggleOpen = contextProps.toggleOpen, open$2 = contextProps.open;
	var rtl = direction === "rtl";
	var _React$useMemo = import_react.useMemo(function() {
		var activeIndex = -1;
		var currentOptions = options;
		var mergedActiveIndexes = [];
		var mergedActiveValueCells = [];
		var len = activeValueCells.length;
		var pathKeys = getFullPathKeys(options, fieldNames);
		var _loop = function _loop$1(i$1) {
			var nextActiveIndex = currentOptions.findIndex(function(option, index$2) {
				return (pathKeys[index$2] ? toPathKey(pathKeys[index$2]) : option[fieldNames.value]) === activeValueCells[i$1];
			});
			if (nextActiveIndex === -1) return 1;
			activeIndex = nextActiveIndex;
			mergedActiveIndexes.push(activeIndex);
			mergedActiveValueCells.push(activeValueCells[i$1]);
			currentOptions = currentOptions[activeIndex][fieldNames.children];
		};
		for (var i = 0; i < len && currentOptions; i += 1) if (_loop(i)) break;
		var activeOptions = options;
		for (var _i = 0; _i < mergedActiveIndexes.length - 1; _i += 1) activeOptions = activeOptions[mergedActiveIndexes[_i]][fieldNames.children];
		return [
			mergedActiveValueCells,
			activeIndex,
			activeOptions,
			pathKeys
		];
	}, [
		activeValueCells,
		fieldNames,
		options
	]), _React$useMemo2 = _slicedToArray(_React$useMemo, 4), validActiveValueCells = _React$useMemo2[0], lastActiveIndex = _React$useMemo2[1], lastActiveOptions = _React$useMemo2[2], fullPathKeys = _React$useMemo2[3];
	var internalSetActiveValueCells = function internalSetActiveValueCells$1(next$1) {
		setActiveValueCells(next$1);
	};
	var offsetActiveOption = function offsetActiveOption$1(offset$2) {
		var len = lastActiveOptions.length;
		var currentIndex = lastActiveIndex;
		if (currentIndex === -1 && offset$2 < 0) currentIndex = len;
		for (var i = 0; i < len; i += 1) {
			currentIndex = (currentIndex + offset$2 + len) % len;
			var _option = lastActiveOptions[currentIndex];
			if (_option && !_option.disabled) {
				var nextActiveCells = validActiveValueCells.slice(0, -1).concat(fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : _option[fieldNames.value]);
				internalSetActiveValueCells(nextActiveCells);
				return;
			}
		}
	};
	var prevColumn = function prevColumn$1() {
		if (validActiveValueCells.length > 1) {
			var nextActiveCells = validActiveValueCells.slice(0, -1);
			internalSetActiveValueCells(nextActiveCells);
		} else toggleOpen(false);
	};
	var nextColumn = function nextColumn$1() {
		var _lastActiveOptions$la;
		var nextOption = (((_lastActiveOptions$la = lastActiveOptions[lastActiveIndex]) === null || _lastActiveOptions$la === void 0 ? void 0 : _lastActiveOptions$la[fieldNames.children]) || []).find(function(option) {
			return !option.disabled;
		});
		if (nextOption) {
			var nextActiveCells = [].concat(_toConsumableArray(validActiveValueCells), [nextOption[fieldNames.value]]);
			internalSetActiveValueCells(nextActiveCells);
		}
	};
	import_react.useImperativeHandle(ref, function() {
		return {
			onKeyDown: function onKeyDown$1(event) {
				var which = event.which;
				switch (which) {
					case KeyCode_default.UP:
					case KeyCode_default.DOWN:
						var offset$2 = 0;
						if (which === KeyCode_default.UP) offset$2 = -1;
						else if (which === KeyCode_default.DOWN) offset$2 = 1;
						if (offset$2 !== 0) offsetActiveOption(offset$2);
						break;
					case KeyCode_default.LEFT:
						if (searchValue) break;
						if (rtl) nextColumn();
						else prevColumn();
						break;
					case KeyCode_default.RIGHT:
						if (searchValue) break;
						if (rtl) prevColumn();
						else nextColumn();
						break;
					case KeyCode_default.BACKSPACE:
						if (!searchValue) prevColumn();
						break;
					case KeyCode_default.ENTER:
						if (validActiveValueCells.length) {
							var _option2 = lastActiveOptions[lastActiveIndex];
							var originOptions = (_option2 === null || _option2 === void 0 ? void 0 : _option2[SEARCH_MARK]) || [];
							if (originOptions.length) onKeyBoardSelect(originOptions.map(function(opt) {
								return opt[fieldNames.value];
							}), originOptions[originOptions.length - 1]);
							else onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);
						}
						break;
					case KeyCode_default.ESC:
						toggleOpen(false);
						if (open$2) event.stopPropagation();
				}
			},
			onKeyUp: function onKeyUp() {}
		};
	});
});

//#endregion
//#region node_modules/rc-cascader/es/OptionList/List.js
var import_classnames$149 = /* @__PURE__ */ __toESM(require_classnames());
var RawOptionList = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _optionColumns$, _ref3, _classNames;
	var prefixCls = props.prefixCls, multiple = props.multiple, searchValue = props.searchValue, toggleOpen = props.toggleOpen, notFoundContent = props.notFoundContent, direction = props.direction, open$2 = props.open, disabled = props.disabled;
	var containerRef = import_react.useRef(null);
	var rtl = direction === "rtl";
	var _React$useContext = import_react.useContext(context_default$4), options = _React$useContext.options, values = _React$useContext.values, halfValues = _React$useContext.halfValues, fieldNames = _React$useContext.fieldNames, changeOnSelect = _React$useContext.changeOnSelect, onSelect = _React$useContext.onSelect, searchOptions = _React$useContext.searchOptions, dropdownPrefixCls = _React$useContext.dropdownPrefixCls, loadData = _React$useContext.loadData, expandTrigger = _React$useContext.expandTrigger;
	var mergedPrefixCls = dropdownPrefixCls || prefixCls;
	var _React$useState = import_react.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), loadingKeys = _React$useState2[0], setLoadingKeys = _React$useState2[1];
	var internalLoadData = function internalLoadData$1(valueCells) {
		if (!loadData || searchValue) return;
		var rawOptions = toPathOptions(valueCells, options, fieldNames).map(function(_ref) {
			return _ref.option;
		});
		var lastOption = rawOptions[rawOptions.length - 1];
		if (lastOption && !isLeaf(lastOption, fieldNames)) {
			var pathKey$1 = toPathKey(valueCells);
			setLoadingKeys(function(keys$1) {
				return [].concat(_toConsumableArray(keys$1), [pathKey$1]);
			});
			loadData(rawOptions);
		}
	};
	import_react.useEffect(function() {
		if (loadingKeys.length) loadingKeys.forEach(function(loadingKey) {
			var valueStrCells = toPathValueStr(loadingKey);
			var optionList = toPathOptions(valueStrCells, options, fieldNames, true).map(function(_ref2) {
				return _ref2.option;
			});
			var lastOption = optionList[optionList.length - 1];
			if (!lastOption || lastOption[fieldNames.children] || isLeaf(lastOption, fieldNames)) setLoadingKeys(function(keys$1) {
				return keys$1.filter(function(key) {
					return key !== loadingKey;
				});
			});
		});
	}, [
		options,
		loadingKeys,
		fieldNames
	]);
	var checkedSet = import_react.useMemo(function() {
		return new Set(toPathKeys(values));
	}, [values]);
	var halfCheckedSet = import_react.useMemo(function() {
		return new Set(toPathKeys(halfValues));
	}, [halfValues]);
	var _useActive = useActive_default(multiple, open$2), _useActive2 = _slicedToArray(_useActive, 2), activeValueCells = _useActive2[0], setActiveValueCells = _useActive2[1];
	var onPathOpen = function onPathOpen$1(nextValueCells) {
		setActiveValueCells(nextValueCells);
		internalLoadData(nextValueCells);
	};
	var isSelectable = function isSelectable$1(option) {
		if (disabled) return false;
		var optionDisabled = option.disabled;
		var isMergedLeaf = isLeaf(option, fieldNames);
		return !optionDisabled && (isMergedLeaf || changeOnSelect || multiple);
	};
	var onPathSelect = function onPathSelect$1(valuePath, leaf) {
		var fromKeyboard = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
		onSelect(valuePath);
		if (!multiple && (leaf || changeOnSelect && (expandTrigger === "hover" || fromKeyboard))) toggleOpen(false);
	};
	var mergedOptions = import_react.useMemo(function() {
		if (searchValue) return searchOptions;
		return options;
	}, [
		searchValue,
		searchOptions,
		options
	]);
	var optionColumns = import_react.useMemo(function() {
		var optionList = [{ options: mergedOptions }];
		var currentList = mergedOptions;
		var fullPathKeys = getFullPathKeys(currentList, fieldNames);
		var _loop = function _loop$1() {
			var activeValueCell = activeValueCells[i];
			var currentOption = currentList.find(function(option, index$2) {
				return (fullPathKeys[index$2] ? toPathKey(fullPathKeys[index$2]) : option[fieldNames.value]) === activeValueCell;
			});
			var subOptions = currentOption === null || currentOption === void 0 ? void 0 : currentOption[fieldNames.children];
			if (!(subOptions !== null && subOptions !== void 0 && subOptions.length)) return 1;
			currentList = subOptions;
			optionList.push({ options: subOptions });
		};
		for (var i = 0; i < activeValueCells.length; i += 1) if (_loop()) break;
		return optionList;
	}, [
		mergedOptions,
		activeValueCells,
		fieldNames
	]);
	useKeyboard_default(ref, mergedOptions, fieldNames, activeValueCells, onPathOpen, function onKeyboardSelect(selectValueCells, option) {
		if (isSelectable(option)) onPathSelect(selectValueCells, isLeaf(option, fieldNames), true);
	}, {
		direction,
		searchValue,
		toggleOpen,
		open: open$2
	});
	import_react.useEffect(function() {
		if (searchValue) return;
		for (var i = 0; i < activeValueCells.length; i += 1) {
			var _containerRef$current;
			var cellPath = activeValueCells.slice(0, i + 1);
			var cellKeyPath = toPathKey(cellPath);
			var ele = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelector("li[data-path-key=\"".concat(cellKeyPath.replace(/\\{0,2}"/g, "\\\""), "\"]"));
			if (ele) scrollIntoParentView(ele);
		}
	}, [activeValueCells, searchValue]);
	var isEmpty$1 = !((_optionColumns$ = optionColumns[0]) !== null && _optionColumns$ !== void 0 && (_optionColumns$ = _optionColumns$.options) !== null && _optionColumns$ !== void 0 && _optionColumns$.length);
	var emptyList = [(_ref3 = {}, _defineProperty(_ref3, fieldNames.value, "__EMPTY__"), _defineProperty(_ref3, FIX_LABEL, notFoundContent), _defineProperty(_ref3, "disabled", true), _ref3)];
	var columnProps = _objectSpread2(_objectSpread2({}, props), {}, {
		multiple: !isEmpty$1 && multiple,
		onSelect: onPathSelect,
		onActive: onPathOpen,
		onToggleOpen: toggleOpen,
		checkedSet,
		halfCheckedSet,
		loadingKeys,
		isSelectable
	});
	var columnNodes = (isEmpty$1 ? [{ options: emptyList }] : optionColumns).map(function(col, index$2) {
		var prevValuePath = activeValueCells.slice(0, index$2);
		var activeValue = activeValueCells[index$2];
		return /* @__PURE__ */ import_react.createElement(Column$2, _extends({ key: index$2 }, columnProps, {
			prefixCls: mergedPrefixCls,
			options: col.options,
			prevValuePath,
			activeValue
		}));
	});
	return /* @__PURE__ */ import_react.createElement(CacheContent_default, { open: open$2 }, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$149.default)("".concat(mergedPrefixCls, "-menus"), (_classNames = {}, _defineProperty(_classNames, "".concat(mergedPrefixCls, "-menu-empty"), isEmpty$1), _defineProperty(_classNames, "".concat(mergedPrefixCls, "-rtl"), rtl), _classNames)),
		ref: containerRef
	}, columnNodes));
});
RawOptionList.displayName = "RawOptionList";
var List_default$1 = RawOptionList;

//#endregion
//#region node_modules/rc-cascader/es/OptionList/index.js
var RefOptionList$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var baseProps = useBaseProps();
	return /* @__PURE__ */ import_react.createElement(List_default$1, _extends({}, props, baseProps, { ref }));
});
var OptionList_default$1 = RefOptionList$1;

//#endregion
//#region node_modules/rc-cascader/es/Panel.js
var import_classnames$148 = /* @__PURE__ */ __toESM(require_classnames());
function noop$2() {}
function Panel$2(props) {
	var _classNames;
	var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-cascader" : _ref$prefixCls, style$1 = _ref.style, className = _ref.className, options = _ref.options, checkable = _ref.checkable, defaultValue = _ref.defaultValue, value = _ref.value, fieldNames = _ref.fieldNames, changeOnSelect = _ref.changeOnSelect, onChange = _ref.onChange, showCheckedStrategy = _ref.showCheckedStrategy, loadData = _ref.loadData, expandTrigger = _ref.expandTrigger, _ref$expandIcon = _ref.expandIcon, expandIcon = _ref$expandIcon === void 0 ? ">" : _ref$expandIcon, loadingIcon = _ref.loadingIcon, direction = _ref.direction, _ref$notFoundContent = _ref.notFoundContent, notFoundContent = _ref$notFoundContent === void 0 ? "Not Found" : _ref$notFoundContent, disabled = _ref.disabled;
	var multiple = !!checkable;
	var _useMergedState = useMergedState(defaultValue, {
		value,
		postState: toRawValues
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValues = _useMergedState2[0], setRawValues = _useMergedState2[1];
	var mergedFieldNames = import_react.useMemo(function() {
		return fillFieldNames$2(fieldNames);
	}, [JSON.stringify(fieldNames)]);
	var _useOptions = useOptions(mergedFieldNames, options), _useOptions2 = _slicedToArray(_useOptions, 3), mergedOptions = _useOptions2[0], getPathKeyEntities = _useOptions2[1], getValueByKeyPath = _useOptions2[2];
	var getMissingValues = useMissingValues(mergedOptions, mergedFieldNames);
	var _useValues = useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues), _useValues2 = _slicedToArray(_useValues, 3), checkedValues = _useValues2[0], halfCheckedValues = _useValues2[1], missingCheckedValues = _useValues2[2];
	var triggerChange = useEvent(function(nextValues) {
		setRawValues(nextValues);
		if (onChange) {
			var nextRawValues = toRawValues(nextValues);
			var valueOptions = nextRawValues.map(function(valueCells) {
				return toPathOptions(valueCells, mergedOptions, mergedFieldNames).map(function(valueOpt) {
					return valueOpt.option;
				});
			});
			var triggerValues = multiple ? nextRawValues : nextRawValues[0];
			var triggerOptions = multiple ? valueOptions : valueOptions[0];
			onChange(triggerValues, triggerOptions);
		}
	});
	var handleSelection = useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy);
	var onInternalSelect = useEvent(function(valuePath) {
		handleSelection(valuePath);
	});
	var cascaderContext = import_react.useMemo(function() {
		return {
			options: mergedOptions,
			fieldNames: mergedFieldNames,
			values: checkedValues,
			halfValues: halfCheckedValues,
			changeOnSelect,
			onSelect: onInternalSelect,
			checkable,
			searchOptions: [],
			dropdownPrefixCls: void 0,
			loadData,
			expandTrigger,
			expandIcon,
			loadingIcon,
			dropdownMenuColumnStyle: void 0
		};
	}, [
		mergedOptions,
		mergedFieldNames,
		checkedValues,
		halfCheckedValues,
		changeOnSelect,
		onInternalSelect,
		checkable,
		loadData,
		expandTrigger,
		expandIcon,
		loadingIcon
	]);
	var panelPrefixCls = "".concat(prefixCls, "-panel");
	var isEmpty$1 = !mergedOptions.length;
	return /* @__PURE__ */ import_react.createElement(context_default$4.Provider, { value: cascaderContext }, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$148.default)(panelPrefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(panelPrefixCls, "-rtl"), direction === "rtl"), _defineProperty(_classNames, "".concat(panelPrefixCls, "-empty"), isEmpty$1), _classNames), className),
		style: style$1
	}, isEmpty$1 ? notFoundContent : /* @__PURE__ */ import_react.createElement(List_default$1, {
		prefixCls,
		searchValue: "",
		multiple,
		toggleOpen: noop$2,
		open: true,
		direction,
		disabled
	})));
}

//#endregion
//#region node_modules/rc-cascader/es/utils/warningPropsUtil.js
function warningProps$1(props) {
	var onPopupVisibleChange = props.onPopupVisibleChange, popupVisible = props.popupVisible, popupClassName = props.popupClassName, popupPlacement = props.popupPlacement, onDropdownVisibleChange = props.onDropdownVisibleChange;
	warning_default(!onPopupVisibleChange, "`onPopupVisibleChange` is deprecated. Please use `onOpenChange` instead.");
	warning_default(!onDropdownVisibleChange, "`onDropdownVisibleChange` is deprecated. Please use `onOpenChange` instead.");
	warning_default(popupVisible === void 0, "`popupVisible` is deprecated. Please use `open` instead.");
	warning_default(popupClassName === void 0, "`popupClassName` is deprecated. Please use `dropdownClassName` instead.");
	warning_default(popupPlacement === void 0, "`popupPlacement` is deprecated. Please use `placement` instead.");
}
function warningNullOptions(options, fieldNames) {
	if (options) (function recursiveOptions(optionsList) {
		for (var i = 0; i < optionsList.length; i++) {
			var option = optionsList[i];
			if (option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.value] === null) {
				warning_default(false, "`value` in Cascader options should not be `null`.");
				return true;
			}
			if (Array.isArray(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.children]) && recursiveOptions(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.children])) return true;
		}
	})(options);
}
var warningPropsUtil_default$1 = warningProps$1;

//#endregion
//#region node_modules/rc-cascader/es/Cascader.js
var _excluded$34 = [
	"id",
	"prefixCls",
	"fieldNames",
	"defaultValue",
	"value",
	"changeOnSelect",
	"onChange",
	"displayRender",
	"checkable",
	"autoClearSearchValue",
	"searchValue",
	"onSearch",
	"showSearch",
	"expandTrigger",
	"options",
	"dropdownPrefixCls",
	"loadData",
	"popupVisible",
	"open",
	"popupClassName",
	"dropdownClassName",
	"dropdownMenuColumnStyle",
	"dropdownStyle",
	"popupPlacement",
	"placement",
	"onDropdownVisibleChange",
	"onPopupVisibleChange",
	"onOpenChange",
	"expandIcon",
	"loadingIcon",
	"children",
	"dropdownMatchSelectWidth",
	"showCheckedStrategy",
	"optionRender"
];
var Cascader$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var id = props.id, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-cascader" : _props$prefixCls, fieldNames = props.fieldNames, defaultValue = props.defaultValue, value = props.value, changeOnSelect = props.changeOnSelect, onChange = props.onChange, displayRender = props.displayRender, checkable = props.checkable, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, searchValue = props.searchValue, onSearch = props.onSearch, showSearch = props.showSearch, expandTrigger = props.expandTrigger, options = props.options, dropdownPrefixCls = props.dropdownPrefixCls, loadData = props.loadData, popupVisible = props.popupVisible, open$2 = props.open, popupClassName = props.popupClassName, dropdownClassName = props.dropdownClassName, dropdownMenuColumnStyle = props.dropdownMenuColumnStyle, customDropdownStyle = props.dropdownStyle, popupPlacement = props.popupPlacement, placement = props.placement, onDropdownVisibleChange = props.onDropdownVisibleChange, onPopupVisibleChange = props.onPopupVisibleChange, onOpenChange = props.onOpenChange, _props$expandIcon = props.expandIcon, expandIcon = _props$expandIcon === void 0 ? ">" : _props$expandIcon, loadingIcon = props.loadingIcon, children = props.children, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? false : _props$dropdownMatchS, _props$showCheckedStr = props.showCheckedStrategy, showCheckedStrategy = _props$showCheckedStr === void 0 ? SHOW_PARENT$2 : _props$showCheckedStr, optionRender = props.optionRender, restProps = _objectWithoutProperties(props, _excluded$34);
	var mergedId = useId(id);
	var multiple = !!checkable;
	var _useMergedState = useMergedState(defaultValue, {
		value,
		postState: toRawValues
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValues = _useMergedState2[0], setRawValues = _useMergedState2[1];
	var mergedFieldNames = import_react.useMemo(function() {
		return fillFieldNames$2(fieldNames);
	}, [JSON.stringify(fieldNames)]);
	var _useOptions = useOptions(mergedFieldNames, options), _useOptions2 = _slicedToArray(_useOptions, 3), mergedOptions = _useOptions2[0], getPathKeyEntities = _useOptions2[1], getValueByKeyPath = _useOptions2[2];
	var _useMergedState3 = useMergedState("", {
		value: searchValue,
		postState: function postState(search) {
			return search || "";
		}
	}), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedSearchValue = _useMergedState4[0], setSearchValue = _useMergedState4[1];
	var onInternalSearch = function onInternalSearch$1(searchText, info) {
		setSearchValue(searchText);
		if (info.source !== "blur" && onSearch) onSearch(searchText);
	};
	var _useSearchConfig = useSearchConfig(showSearch), _useSearchConfig2 = _slicedToArray(_useSearchConfig, 2), mergedShowSearch = _useSearchConfig2[0], searchConfig = _useSearchConfig2[1];
	var searchOptions = useSearchOptions_default(mergedSearchValue, mergedOptions, mergedFieldNames, dropdownPrefixCls || prefixCls, searchConfig, changeOnSelect || multiple);
	var getMissingValues = useMissingValues(mergedOptions, mergedFieldNames);
	var _useValues = useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues), _useValues2 = _slicedToArray(_useValues, 3), checkedValues = _useValues2[0], halfCheckedValues = _useValues2[1], missingCheckedValues = _useValues2[2];
	var deDuplicatedValues = import_react.useMemo(function() {
		var checkedKeys = toPathKeys(checkedValues);
		var deduplicateKeys = formatStrategyValues$1(checkedKeys, getPathKeyEntities, showCheckedStrategy);
		return [].concat(_toConsumableArray(missingCheckedValues), _toConsumableArray(getValueByKeyPath(deduplicateKeys)));
	}, [
		checkedValues,
		getPathKeyEntities,
		getValueByKeyPath,
		missingCheckedValues,
		showCheckedStrategy
	]);
	var displayValues = useDisplayValues_default(deDuplicatedValues, mergedOptions, mergedFieldNames, multiple, displayRender);
	var triggerChange = useEvent(function(nextValues) {
		setRawValues(nextValues);
		if (onChange) {
			var nextRawValues = toRawValues(nextValues);
			var valueOptions = nextRawValues.map(function(valueCells) {
				return toPathOptions(valueCells, mergedOptions, mergedFieldNames).map(function(valueOpt) {
					return valueOpt.option;
				});
			});
			var triggerValues = multiple ? nextRawValues : nextRawValues[0];
			var triggerOptions = multiple ? valueOptions : valueOptions[0];
			onChange(triggerValues, triggerOptions);
		}
	});
	var handleSelection = useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy);
	var onInternalSelect = useEvent(function(valuePath) {
		if (!multiple || autoClearSearchValue) setSearchValue("");
		handleSelection(valuePath);
	});
	var onDisplayValuesChange = function onDisplayValuesChange$1(_, info) {
		if (info.type === "clear") {
			triggerChange([]);
			return;
		}
		var _ref = info.values[0], valueCells = _ref.valueCells;
		onInternalSelect(valueCells);
	};
	var mergedOpen = open$2 !== void 0 ? open$2 : popupVisible;
	var mergedDropdownClassName = dropdownClassName || popupClassName;
	var mergedPlacement = placement || popupPlacement;
	var onInternalDropdownVisibleChange = function onInternalDropdownVisibleChange$1(nextVisible) {
		onOpenChange === null || onOpenChange === void 0 || onOpenChange(nextVisible);
		onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 || onDropdownVisibleChange(nextVisible);
		onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextVisible);
	};
	warningPropsUtil_default$1(props);
	warningNullOptions(mergedOptions, mergedFieldNames);
	var cascaderContext = import_react.useMemo(function() {
		return {
			options: mergedOptions,
			fieldNames: mergedFieldNames,
			values: checkedValues,
			halfValues: halfCheckedValues,
			changeOnSelect,
			onSelect: onInternalSelect,
			checkable,
			searchOptions,
			dropdownPrefixCls,
			loadData,
			expandTrigger,
			expandIcon,
			loadingIcon,
			dropdownMenuColumnStyle,
			optionRender
		};
	}, [
		mergedOptions,
		mergedFieldNames,
		checkedValues,
		halfCheckedValues,
		changeOnSelect,
		onInternalSelect,
		checkable,
		searchOptions,
		dropdownPrefixCls,
		loadData,
		expandTrigger,
		expandIcon,
		loadingIcon,
		dropdownMenuColumnStyle,
		optionRender
	]);
	var emptyOptions = !(mergedSearchValue ? searchOptions : mergedOptions).length;
	var dropdownStyle = mergedSearchValue && searchConfig.matchInputWidth || emptyOptions ? {} : { minWidth: "auto" };
	return /* @__PURE__ */ import_react.createElement(context_default$4.Provider, { value: cascaderContext }, /* @__PURE__ */ import_react.createElement(BaseSelect_default, _extends({}, restProps, {
		ref,
		id: mergedId,
		prefixCls,
		autoClearSearchValue,
		dropdownMatchSelectWidth,
		dropdownStyle: _objectSpread2(_objectSpread2({}, dropdownStyle), customDropdownStyle),
		displayValues,
		onDisplayValuesChange,
		mode: multiple ? "multiple" : void 0,
		searchValue: mergedSearchValue,
		onSearch: onInternalSearch,
		showSearch: mergedShowSearch,
		OptionList: OptionList_default$1,
		emptyOptions,
		open: mergedOpen,
		dropdownClassName: mergedDropdownClassName,
		placement: mergedPlacement,
		onDropdownVisibleChange: onInternalDropdownVisibleChange,
		getRawInputElement: function getRawInputElement() {
			return children;
		}
	})));
});
Cascader$1.displayName = "Cascader";
Cascader$1.SHOW_PARENT = SHOW_PARENT$2;
Cascader$1.SHOW_CHILD = SHOW_CHILD$2;
Cascader$1.Panel = Panel$2;
var Cascader_default = Cascader$1;

//#endregion
//#region node_modules/rc-cascader/es/index.js
var es_default$27 = Cascader_default;

//#endregion
//#region node_modules/antd/es/cascader/hooks/useBase.js
function useBase(customizePrefixCls, direction) {
	const { getPrefixCls, direction: rootDirection, renderEmpty } = import_react.useContext(ConfigContext);
	const mergedDirection = direction || rootDirection;
	const prefixCls = getPrefixCls("select", customizePrefixCls);
	const cascaderPrefixCls = getPrefixCls("cascader", customizePrefixCls);
	return [
		prefixCls,
		cascaderPrefixCls,
		mergedDirection,
		renderEmpty
	];
}
var useBase_default = useBase;

//#endregion
//#region node_modules/antd/es/cascader/hooks/useCheckable.js
function useCheckable(cascaderPrefixCls, multiple) {
	return import_react.useMemo(() => multiple ? /* @__PURE__ */ import_react.createElement("span", { className: `${cascaderPrefixCls}-checkbox-inner` }) : false, [multiple]);
}

//#endregion
//#region node_modules/antd/es/cascader/hooks/useColumnIcons.js
var useColumnIcons = (prefixCls, rtl, expandIcon) => {
	let mergedExpandIcon = expandIcon;
	if (!expandIcon) mergedExpandIcon = rtl ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null);
	const loadingIcon = /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-menu-item-loading-icon` }, /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { spin: true }));
	return import_react.useMemo(() => [mergedExpandIcon, loadingIcon], [mergedExpandIcon]);
};
var useColumnIcons_default = useColumnIcons;

//#endregion
//#region node_modules/antd/es/checkbox/style/index.js
const genCheckboxStyle = (token$1) => {
	const { checkboxCls } = token$1;
	const wrapperCls = `${checkboxCls}-wrapper`;
	return [
		{
			[`${checkboxCls}-group`]: Object.assign(Object.assign({}, resetComponent(token$1)), {
				display: "inline-flex",
				flexWrap: "wrap",
				columnGap: token$1.marginXS,
				[`> ${token$1.antCls}-row`]: { flex: 1 }
			}),
			[wrapperCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
				display: "inline-flex",
				alignItems: "baseline",
				cursor: "pointer",
				"&:after": {
					display: "inline-block",
					width: 0,
					overflow: "hidden",
					content: "'\\a0'"
				},
				[`& + ${wrapperCls}`]: { marginInlineStart: 0 },
				[`&${wrapperCls}-in-form-item`]: { "input[type=\"checkbox\"]": {
					width: 14,
					height: 14
				} }
			}),
			[checkboxCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
				position: "relative",
				whiteSpace: "nowrap",
				lineHeight: 1,
				cursor: "pointer",
				borderRadius: token$1.borderRadiusSM,
				alignSelf: "center",
				[`${checkboxCls}-input`]: {
					position: "absolute",
					inset: 0,
					zIndex: 1,
					cursor: "pointer",
					opacity: 0,
					margin: 0,
					[`&:focus-visible + ${checkboxCls}-inner`]: genFocusOutline(token$1)
				},
				[`${checkboxCls}-inner`]: {
					boxSizing: "border-box",
					display: "block",
					width: token$1.checkboxSize,
					height: token$1.checkboxSize,
					direction: "ltr",
					backgroundColor: token$1.colorBgContainer,
					border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
					borderRadius: token$1.borderRadiusSM,
					borderCollapse: "separate",
					transition: `all ${token$1.motionDurationSlow}`,
					"&:after": {
						boxSizing: "border-box",
						position: "absolute",
						top: "50%",
						insetInlineStart: "25%",
						display: "table",
						width: token$1.calc(token$1.checkboxSize).div(14).mul(5).equal(),
						height: token$1.calc(token$1.checkboxSize).div(14).mul(8).equal(),
						border: `${unit(token$1.lineWidthBold)} solid ${token$1.colorWhite}`,
						borderTop: 0,
						borderInlineStart: 0,
						transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
						opacity: 0,
						content: "\"\"",
						transition: `all ${token$1.motionDurationFast} ${token$1.motionEaseInBack}, opacity ${token$1.motionDurationFast}`
					}
				},
				"& + span": {
					paddingInlineStart: token$1.paddingXS,
					paddingInlineEnd: token$1.paddingXS
				}
			})
		},
		{
			[`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: { [`&:hover ${checkboxCls}-inner`]: { borderColor: token$1.colorPrimary } },
			[`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
				[`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
					backgroundColor: token$1.colorPrimaryHover,
					borderColor: "transparent"
				},
				[`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: { borderColor: token$1.colorPrimaryHover }
			}
		},
		{
			[`${checkboxCls}-checked`]: { [`${checkboxCls}-inner`]: {
				backgroundColor: token$1.colorPrimary,
				borderColor: token$1.colorPrimary,
				"&:after": {
					opacity: 1,
					transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
					transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseOutBack} ${token$1.motionDurationFast}`
				}
			} },
			[`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: { [`&:hover ${checkboxCls}-inner`]: {
				backgroundColor: token$1.colorPrimaryHover,
				borderColor: "transparent"
			} }
		},
		{ [checkboxCls]: { "&-indeterminate": { "&": {
			[`${checkboxCls}-inner`]: {
				backgroundColor: `${token$1.colorBgContainer}`,
				borderColor: `${token$1.colorBorder}`,
				"&:after": {
					top: "50%",
					insetInlineStart: "50%",
					width: token$1.calc(token$1.fontSizeLG).div(2).equal(),
					height: token$1.calc(token$1.fontSizeLG).div(2).equal(),
					backgroundColor: token$1.colorPrimary,
					border: 0,
					transform: "translate(-50%, -50%) scale(1)",
					opacity: 1,
					content: "\"\""
				}
			},
			[`&:hover ${checkboxCls}-inner`]: {
				backgroundColor: `${token$1.colorBgContainer}`,
				borderColor: `${token$1.colorPrimary}`
			}
		} } } },
		{
			[`${wrapperCls}-disabled`]: { cursor: "not-allowed" },
			[`${checkboxCls}-disabled`]: {
				[`&, ${checkboxCls}-input`]: {
					cursor: "not-allowed",
					pointerEvents: "none"
				},
				[`${checkboxCls}-inner`]: {
					background: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder,
					"&:after": { borderColor: token$1.colorTextDisabled }
				},
				"&:after": { display: "none" },
				"& + span": { color: token$1.colorTextDisabled },
				[`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: { background: token$1.colorTextDisabled }
			}
		}
	];
};
function getStyle(prefixCls, token$1) {
	const checkboxToken = merge(token$1, {
		checkboxCls: `.${prefixCls}`,
		checkboxSize: token$1.controlInteractiveSize
	});
	return genCheckboxStyle(checkboxToken);
}
var style_default$38 = genStyleHooks("Checkbox", (token$1, { prefixCls }) => [getStyle(prefixCls, token$1)]);

//#endregion
//#region node_modules/antd/es/cascader/style/columns.js
var getColumnsStyle = (token$1) => {
	const { prefixCls, componentCls } = token$1;
	const cascaderMenuItemCls = `${componentCls}-menu-item`;
	const iconCls = `
  &${cascaderMenuItemCls}-expand ${cascaderMenuItemCls}-expand-icon,
  ${cascaderMenuItemCls}-loading-icon
`;
	return [getStyle(`${prefixCls}-checkbox`, token$1), { [componentCls]: {
		"&-checkbox": {
			top: 0,
			marginInlineEnd: token$1.paddingXS,
			pointerEvents: "unset"
		},
		"&-menus": {
			display: "flex",
			flexWrap: "nowrap",
			alignItems: "flex-start",
			[`&${componentCls}-menu-empty`]: { [`${componentCls}-menu`]: {
				width: "100%",
				height: "auto",
				[cascaderMenuItemCls]: { color: token$1.colorTextDisabled }
			} }
		},
		"&-menu": {
			flexGrow: 1,
			flexShrink: 0,
			minWidth: token$1.controlItemWidth,
			height: token$1.dropdownHeight,
			margin: 0,
			padding: token$1.menuPadding,
			overflow: "auto",
			verticalAlign: "top",
			listStyle: "none",
			"-ms-overflow-style": "-ms-autohiding-scrollbar",
			"&:not(:last-child)": { borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
			"&-item": Object.assign(Object.assign({}, textEllipsis), {
				display: "flex",
				flexWrap: "nowrap",
				alignItems: "center",
				padding: token$1.optionPadding,
				lineHeight: token$1.lineHeight,
				cursor: "pointer",
				transition: `all ${token$1.motionDurationMid}`,
				borderRadius: token$1.borderRadiusSM,
				"&:hover": { background: token$1.controlItemBgHover },
				"&-disabled": {
					color: token$1.colorTextDisabled,
					cursor: "not-allowed",
					"&:hover": { background: "transparent" },
					[iconCls]: { color: token$1.colorTextDisabled }
				},
				[`&-active:not(${cascaderMenuItemCls}-disabled)`]: { "&, &:hover": {
					color: token$1.optionSelectedColor,
					fontWeight: token$1.optionSelectedFontWeight,
					backgroundColor: token$1.optionSelectedBg
				} },
				"&-content": { flex: "auto" },
				[iconCls]: {
					marginInlineStart: token$1.paddingXXS,
					color: token$1.colorIcon,
					fontSize: token$1.fontSizeIcon
				},
				"&-keyword": { color: token$1.colorHighlight }
			})
		}
	} }];
};
var columns_default = getColumnsStyle;

//#endregion
//#region node_modules/antd/es/cascader/style/index.js
var genBaseStyle$10 = (token$1) => {
	const { componentCls, antCls } = token$1;
	return [
		{ [componentCls]: { width: token$1.controlWidth } },
		{ [`${componentCls}-dropdown`]: [{ [`&${antCls}-select-dropdown`]: { padding: 0 } }, columns_default(token$1)] },
		{ [`${componentCls}-dropdown-rtl`]: { direction: "rtl" } },
		genCompactItemStyle(token$1)
	];
};
const prepareComponentToken$31 = (token$1) => {
	const itemPaddingVertical = Math.round((token$1.controlHeight - token$1.fontSize * token$1.lineHeight) / 2);
	return {
		controlWidth: 184,
		controlItemWidth: 111,
		dropdownHeight: 180,
		optionSelectedBg: token$1.controlItemBgActive,
		optionSelectedFontWeight: token$1.fontWeightStrong,
		optionPadding: `${itemPaddingVertical}px ${token$1.paddingSM}px`,
		menuPadding: token$1.paddingXXS,
		optionSelectedColor: token$1.colorText
	};
};
var style_default$39 = genStyleHooks("Cascader", genBaseStyle$10, prepareComponentToken$31, { unitless: { optionSelectedFontWeight: true } });

//#endregion
//#region node_modules/antd/es/cascader/style/panel.js
var genPanelStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-panel`]: [columns_default(token$1), {
		display: "inline-flex",
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
		borderRadius: token$1.borderRadiusLG,
		overflowX: "auto",
		maxWidth: "100%",
		[`${componentCls}-menus`]: { alignItems: "stretch" },
		[`${componentCls}-menu`]: { height: "auto" },
		"&-empty": { padding: token$1.paddingXXS }
	}] };
};
var panel_default = genComponentStyleHook(["Cascader", "Panel"], genPanelStyle, prepareComponentToken$31);

//#endregion
//#region node_modules/antd/es/cascader/Panel.js
var import_classnames$147 = /* @__PURE__ */ __toESM(require_classnames());
function CascaderPanel(props) {
	const { prefixCls: customizePrefixCls, className, multiple, rootClassName, notFoundContent, direction, expandIcon, disabled: customDisabled } = props;
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase_default(customizePrefixCls, direction);
	const rootCls = useCSSVarCls_default(cascaderPrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$39(cascaderPrefixCls, rootCls);
	panel_default(cascaderPrefixCls);
	const [mergedExpandIcon, loadingIcon] = useColumnIcons_default(prefixCls, mergedDirection === "rtl", expandIcon);
	const mergedNotFoundContent = notFoundContent || (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Cascader")) || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Cascader" });
	const checkable = useCheckable(cascaderPrefixCls, multiple);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(Panel$2, Object.assign({}, props, {
		checkable,
		prefixCls: cascaderPrefixCls,
		className: (0, import_classnames$147.default)(className, hashId, rootClassName, cssVarCls, rootCls),
		notFoundContent: mergedNotFoundContent,
		direction: mergedDirection,
		expandIcon: mergedExpandIcon,
		loadingIcon,
		disabled: mergedDisabled
	})));
}
var Panel_default$3 = CascaderPanel;

//#endregion
//#region node_modules/antd/es/cascader/index.js
var import_classnames$146 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$74 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var { SHOW_CHILD: SHOW_CHILD$1, SHOW_PARENT: SHOW_PARENT$1 } = es_default$27;
function highlightKeyword(str, lowerKeyword, prefixCls) {
	const cells = str.toLowerCase().split(lowerKeyword).reduce((list, cur, index$2) => index$2 === 0 ? [cur] : [].concat(_toConsumableArray(list), [lowerKeyword, cur]), []);
	const fillCells = [];
	let start = 0;
	cells.forEach((cell, index$2) => {
		const end = start + cell.length;
		let originWorld = str.slice(start, end);
		start = end;
		if (index$2 % 2 === 1) originWorld = /* @__PURE__ */ import_react.createElement("span", {
			className: `${prefixCls}-menu-item-keyword`,
			key: `separator-${index$2}`
		}, originWorld);
		fillCells.push(originWorld);
	});
	return fillCells;
}
var defaultSearchRender = (inputValue, path$1, prefixCls, fieldNames) => {
	const optionList = [];
	const lower$1 = inputValue.toLowerCase();
	path$1.forEach((node$1, index$2) => {
		if (index$2 !== 0) optionList.push(" / ");
		let label = node$1[fieldNames.label];
		const type$2 = typeof label;
		if (type$2 === "string" || type$2 === "number") label = highlightKeyword(String(label), lower$1, prefixCls);
		optionList.push(label);
	});
	return optionList;
};
var Cascader = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a, _b, _c, _d;
	const { prefixCls: customizePrefixCls, size: customizeSize, disabled: customDisabled, className, rootClassName, multiple, bordered = true, transitionName, choiceTransitionName = "", popupClassName, dropdownClassName, expandIcon, placement, showSearch, allowClear = true, notFoundContent, direction, getPopupContainer, status: customStatus, showArrow, builtinPlacements, style: style$1, variant: customVariant, dropdownRender, onDropdownVisibleChange, dropdownMenuColumnStyle, popupRender, dropdownStyle, popupMenuColumnStyle, onOpenChange, styles, classNames: classNames$252 } = props, rest = __rest$74(props, [
		"prefixCls",
		"size",
		"disabled",
		"className",
		"rootClassName",
		"multiple",
		"bordered",
		"transitionName",
		"choiceTransitionName",
		"popupClassName",
		"dropdownClassName",
		"expandIcon",
		"placement",
		"showSearch",
		"allowClear",
		"notFoundContent",
		"direction",
		"getPopupContainer",
		"status",
		"showArrow",
		"builtinPlacements",
		"style",
		"variant",
		"dropdownRender",
		"onDropdownVisibleChange",
		"dropdownMenuColumnStyle",
		"popupRender",
		"dropdownStyle",
		"popupMenuColumnStyle",
		"onOpenChange",
		"styles",
		"classNames"
	]);
	const restProps = omit(rest, ["suffixIcon"]);
	const { getPrefixCls, getPopupContainer: getContextPopupContainer, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("cascader");
	const { popupOverflow } = import_react.useContext(ConfigContext);
	const { status: contextStatus, hasFeedback, isFormItemInput, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	{
		const warning$4 = devUseWarning("Cascader");
		Object.entries({
			dropdownClassName: "classNames.popup.root",
			dropdownStyle: "styles.popup.root",
			dropdownRender: "popupRender",
			dropdownMenuColumnStyle: "popupMenuColumnStyle",
			onDropdownVisibleChange: "onOpenChange",
			bordered: "variant"
		}).forEach(([oldProp, newProp]) => {
			warning$4.deprecated(!(oldProp in props), oldProp, newProp);
		});
		warning$4(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.");
	}
	const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase_default(customizePrefixCls, direction);
	const isRtl = mergedDirection === "rtl";
	const rootPrefixCls = getPrefixCls();
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapSelectCSSVar, hashId, cssVarCls] = style_default$3(prefixCls, rootCls);
	const cascaderRootCls = useCSSVarCls_default(cascaderPrefixCls);
	const [wrapCascaderCSSVar] = style_default$39(cascaderPrefixCls, cascaderRootCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const [variant, enableVariantCls] = useVariants_default("cascader", customVariant, bordered);
	const mergedNotFoundContent = notFoundContent || (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Cascader")) || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Cascader" });
	const mergedPopupClassName = (0, import_classnames$146.default)(((_a = classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.popup) === null || _a === void 0 ? void 0 : _a.root) || ((_b = contextClassNames.popup) === null || _b === void 0 ? void 0 : _b.root) || popupClassName || dropdownClassName, `${cascaderPrefixCls}-dropdown`, { [`${cascaderPrefixCls}-dropdown-rtl`]: mergedDirection === "rtl" }, rootClassName, rootCls, contextClassNames.root, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.root, cascaderRootCls, hashId, cssVarCls);
	const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
	const mergedPopupMenuColumnStyle = popupMenuColumnStyle || dropdownMenuColumnStyle;
	const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
	const mergedPopupStyle = ((_c = styles === null || styles === void 0 ? void 0 : styles.popup) === null || _c === void 0 ? void 0 : _c.root) || ((_d = contextStyles.popup) === null || _d === void 0 ? void 0 : _d.root) || dropdownStyle;
	const mergedShowSearch = import_react.useMemo(() => {
		if (!showSearch) return showSearch;
		let searchConfig = { render: defaultSearchRender };
		if (typeof showSearch === "object") searchConfig = Object.assign(Object.assign({}, searchConfig), showSearch);
		return searchConfig;
	}, [showSearch]);
	const mergedSize = useSize_default((ctx) => {
		var _a$1;
		return (_a$1 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a$1 !== void 0 ? _a$1 : ctx;
	});
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const [mergedExpandIcon, loadingIcon] = useColumnIcons_default(prefixCls, isRtl, expandIcon);
	const checkable = useCheckable(cascaderPrefixCls, multiple);
	const showSuffixIcon = useShowArrow(props.suffixIcon, showArrow);
	const { suffixIcon, removeIcon, clearIcon } = useIcons(Object.assign(Object.assign({}, props), {
		hasFeedback,
		feedbackIcon,
		showSuffixIcon,
		multiple,
		prefixCls,
		componentName: "Cascader"
	}));
	const memoPlacement = import_react.useMemo(() => {
		if (placement !== void 0) return placement;
		return isRtl ? "bottomRight" : "bottomLeft";
	}, [placement, isRtl]);
	const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
	const [zIndex] = useZIndex("SelectLike", mergedPopupStyle === null || mergedPopupStyle === void 0 ? void 0 : mergedPopupStyle.zIndex);
	const renderNode = /* @__PURE__ */ import_react.createElement(es_default$27, Object.assign({
		prefixCls,
		className: (0, import_classnames$146.default)(!customizePrefixCls && cascaderPrefixCls, {
			[`${prefixCls}-lg`]: mergedSize === "large",
			[`${prefixCls}-sm`]: mergedSize === "small",
			[`${prefixCls}-rtl`]: isRtl,
			[`${prefixCls}-${variant}`]: enableVariantCls,
			[`${prefixCls}-in-form-item`]: isFormItemInput
		}, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, rootClassName, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.root, contextClassNames.root, rootCls, cascaderRootCls, hashId, cssVarCls),
		disabled: mergedDisabled,
		style: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), styles === null || styles === void 0 ? void 0 : styles.root), contextStyle), style$1)
	}, restProps, {
		builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
		direction: mergedDirection,
		placement: memoPlacement,
		notFoundContent: mergedNotFoundContent,
		allowClear: mergedAllowClear,
		showSearch: mergedShowSearch,
		expandIcon: mergedExpandIcon,
		suffixIcon,
		removeIcon,
		loadingIcon,
		checkable,
		dropdownClassName: mergedPopupClassName,
		dropdownPrefixCls: customizePrefixCls || cascaderPrefixCls,
		dropdownStyle: Object.assign(Object.assign({}, mergedPopupStyle), { zIndex }),
		dropdownRender: mergedPopupRender,
		dropdownMenuColumnStyle: mergedPopupMenuColumnStyle,
		onOpenChange: mergedOnOpenChange,
		choiceTransitionName: getTransitionName(rootPrefixCls, "", choiceTransitionName),
		transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		ref
	}));
	return wrapCascaderCSSVar(wrapSelectCSSVar(renderNode));
});
Cascader.displayName = "Cascader";
/* istanbul ignore next */
var PurePanel$7 = PurePanel_default(Cascader, "dropdownAlign", (props) => omit(props, ["visible"]));
Cascader.SHOW_PARENT = SHOW_PARENT$1;
Cascader.SHOW_CHILD = SHOW_CHILD$1;
Cascader.Panel = Panel_default$3;
Cascader._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$7;
var cascader_default = Cascader;

//#endregion
//#region node_modules/antd/es/checkbox/GroupContext.js
var GroupContext = /* @__PURE__ */ import_react.createContext(null);
var GroupContext_default = GroupContext;

//#endregion
//#region node_modules/antd/es/checkbox/Checkbox.js
var import_classnames$145 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$73 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var InternalCheckbox = (props, ref) => {
	var _a;
	const { prefixCls: customizePrefixCls, className, rootClassName, children, indeterminate = false, style: style$1, onMouseEnter, onMouseLeave, skipGroup = false, disabled } = props, restProps = __rest$73(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"children",
		"indeterminate",
		"style",
		"onMouseEnter",
		"onMouseLeave",
		"skipGroup",
		"disabled"
	]);
	const { getPrefixCls, direction, checkbox } = import_react.useContext(ConfigContext);
	const checkboxGroup = import_react.useContext(GroupContext_default);
	const { isFormItemInput } = import_react.useContext(FormItemInputContext);
	const contextDisabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = (_a = (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || disabled) !== null && _a !== void 0 ? _a : contextDisabled;
	const prevValue = import_react.useRef(restProps.value);
	const checkboxRef = import_react.useRef(null);
	const mergedRef = composeRef(ref, checkboxRef);
	devUseWarning("Checkbox")("checked" in restProps || !!checkboxGroup || !("value" in restProps), "usage", "`value` is not a valid prop, do you mean `checked`?");
	import_react.useEffect(() => {
		checkboxGroup === null || checkboxGroup === void 0 || checkboxGroup.registerValue(restProps.value);
	}, []);
	import_react.useEffect(() => {
		if (skipGroup) return;
		if (restProps.value !== prevValue.current) {
			checkboxGroup === null || checkboxGroup === void 0 || checkboxGroup.cancelValue(prevValue.current);
			checkboxGroup === null || checkboxGroup === void 0 || checkboxGroup.registerValue(restProps.value);
			prevValue.current = restProps.value;
		}
		return () => checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
	}, [restProps.value]);
	import_react.useEffect(() => {
		var _a$1;
		if ((_a$1 = checkboxRef.current) === null || _a$1 === void 0 ? void 0 : _a$1.input) checkboxRef.current.input.indeterminate = indeterminate;
	}, [indeterminate]);
	const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$38(prefixCls, rootCls);
	const checkboxProps = Object.assign({}, restProps);
	if (checkboxGroup && !skipGroup) {
		checkboxProps.onChange = (...args) => {
			if (restProps.onChange) restProps.onChange.apply(restProps, args);
			if (checkboxGroup.toggleOption) checkboxGroup.toggleOption({
				label: children,
				value: restProps.value
			});
		};
		checkboxProps.name = checkboxGroup.name;
		checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
	}
	const classString = (0, import_classnames$145.default)(`${prefixCls}-wrapper`, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
		[`${prefixCls}-wrapper-disabled`]: mergedDisabled,
		[`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
	}, checkbox === null || checkbox === void 0 ? void 0 : checkbox.className, className, rootClassName, cssVarCls, rootCls, hashId);
	const checkboxClass = (0, import_classnames$145.default)({ [`${prefixCls}-indeterminate`]: indeterminate }, TARGET_CLS, hashId);
	const [onLabelClick, onInputClick] = useBubbleLock(checkboxProps.onClick);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(wave_default, {
		component: "Checkbox",
		disabled: mergedDisabled
	}, /* @__PURE__ */ import_react.createElement("label", {
		className: classString,
		style: Object.assign(Object.assign({}, checkbox === null || checkbox === void 0 ? void 0 : checkbox.style), style$1),
		onMouseEnter,
		onMouseLeave,
		onClick: onLabelClick
	}, /* @__PURE__ */ import_react.createElement(es_default$26, Object.assign({}, checkboxProps, {
		onClick: onInputClick,
		prefixCls,
		className: checkboxClass,
		disabled: mergedDisabled,
		ref: mergedRef
	})), children !== void 0 && children !== null && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-label` }, children))));
};
var Checkbox$1 = /* @__PURE__ */ import_react.forwardRef(InternalCheckbox);
Checkbox$1.displayName = "Checkbox";
var Checkbox_default = Checkbox$1;

//#endregion
//#region node_modules/antd/es/checkbox/Group.js
var import_classnames$144 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$72 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var CheckboxGroup = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { defaultValue, children, options = [], prefixCls: customizePrefixCls, className, rootClassName, style: style$1, onChange } = props, restProps = __rest$72(props, [
		"defaultValue",
		"children",
		"options",
		"prefixCls",
		"className",
		"rootClassName",
		"style",
		"onChange"
	]);
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const [value, setValue] = import_react.useState(restProps.value || defaultValue || []);
	const [registeredValues, setRegisteredValues] = import_react.useState([]);
	import_react.useEffect(() => {
		if ("value" in restProps) setValue(restProps.value || []);
	}, [restProps.value]);
	const memoizedOptions = import_react.useMemo(() => options.map((option) => {
		if (typeof option === "string" || typeof option === "number") return {
			label: option,
			value: option
		};
		return option;
	}), [options]);
	const cancelValue = (val) => {
		setRegisteredValues((prevValues) => prevValues.filter((v) => v !== val));
	};
	const registerValue = (val) => {
		setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
	};
	const toggleOption = (option) => {
		const optionIndex = value.indexOf(option.value);
		const newValue = _toConsumableArray(value);
		if (optionIndex === -1) newValue.push(option.value);
		else newValue.splice(optionIndex, 1);
		if (!("value" in restProps)) setValue(newValue);
		onChange === null || onChange === void 0 || onChange(newValue.filter((val) => registeredValues.includes(val)).sort((a, b) => {
			const indexA = memoizedOptions.findIndex((opt) => opt.value === a);
			const indexB = memoizedOptions.findIndex((opt) => opt.value === b);
			return indexA - indexB;
		}));
	};
	const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
	const groupPrefixCls = `${prefixCls}-group`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$38(prefixCls, rootCls);
	const domProps = omit(restProps, ["value", "disabled"]);
	const childrenNode = options.length ? memoizedOptions.map((option) => /* @__PURE__ */ import_react.createElement(Checkbox_default, {
		prefixCls,
		key: option.value.toString(),
		disabled: "disabled" in option ? option.disabled : restProps.disabled,
		value: option.value,
		checked: value.includes(option.value),
		onChange: option.onChange,
		className: (0, import_classnames$144.default)(`${groupPrefixCls}-item`, option.className),
		style: option.style,
		title: option.title,
		id: option.id,
		required: option.required
	}, option.label)) : children;
	const memoizedContext = import_react.useMemo(() => ({
		toggleOption,
		value,
		disabled: restProps.disabled,
		name: restProps.name,
		registerValue,
		cancelValue
	}), [
		toggleOption,
		value,
		restProps.disabled,
		restProps.name,
		registerValue,
		cancelValue
	]);
	const classString = (0, import_classnames$144.default)(groupPrefixCls, { [`${groupPrefixCls}-rtl`]: direction === "rtl" }, className, rootClassName, cssVarCls, rootCls, hashId);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({
		className: classString,
		style: style$1
	}, domProps, { ref }), /* @__PURE__ */ import_react.createElement(GroupContext_default.Provider, { value: memoizedContext }, childrenNode)));
});
var Group_default$1 = CheckboxGroup;

//#endregion
//#region node_modules/antd/es/checkbox/index.js
var Checkbox = Checkbox_default;
Checkbox.Group = Group_default$1;
Checkbox.__ANT_CHECKBOX = true;
Checkbox.displayName = "Checkbox";
var checkbox_default = Checkbox;

//#endregion
//#region node_modules/antd/es/grid/RowContext.js
var RowContext = /* @__PURE__ */ (0, import_react.createContext)({});
var RowContext_default = RowContext;

//#endregion
//#region node_modules/antd/es/grid/col.js
var import_classnames$143 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$71 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function parseFlex(flex) {
	if (typeof flex === "number") return `${flex} ${flex} auto`;
	if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) return `0 0 ${flex}`;
	return flex;
}
var sizes = [
	"xs",
	"sm",
	"md",
	"lg",
	"xl",
	"xxl"
];
var Col = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { gutter, wrap } = import_react.useContext(RowContext_default);
	const { prefixCls: customizePrefixCls, span, order, offset: offset$2, push, pull, className, children, flex, style: style$1 } = props, others = __rest$71(props, [
		"prefixCls",
		"span",
		"order",
		"offset",
		"push",
		"pull",
		"className",
		"children",
		"flex",
		"style"
	]);
	const prefixCls = getPrefixCls("col", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = useColStyle(prefixCls);
	const sizeStyle = {};
	let sizeClassObj = {};
	sizes.forEach((size) => {
		let sizeProps = {};
		const propSize = props[size];
		if (typeof propSize === "number") sizeProps.span = propSize;
		else if (typeof propSize === "object") sizeProps = propSize || {};
		delete others[size];
		sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
			[`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
			[`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
			[`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
			[`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
			[`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
			[`${prefixCls}-rtl`]: direction === "rtl"
		});
		if (sizeProps.flex) {
			sizeClassObj[`${prefixCls}-${size}-flex`] = true;
			sizeStyle[`--${prefixCls}-${size}-flex`] = parseFlex(sizeProps.flex);
		}
	});
	const classes = (0, import_classnames$143.default)(prefixCls, {
		[`${prefixCls}-${span}`]: span !== void 0,
		[`${prefixCls}-order-${order}`]: order,
		[`${prefixCls}-offset-${offset$2}`]: offset$2,
		[`${prefixCls}-push-${push}`]: push,
		[`${prefixCls}-pull-${pull}`]: pull
	}, className, sizeClassObj, hashId, cssVarCls);
	const mergedStyle = {};
	if (gutter && gutter[0] > 0) {
		const horizontalGutter = gutter[0] / 2;
		mergedStyle.paddingLeft = horizontalGutter;
		mergedStyle.paddingRight = horizontalGutter;
	}
	if (flex) {
		mergedStyle.flex = parseFlex(flex);
		if (wrap === false && !mergedStyle.minWidth) mergedStyle.minWidth = 0;
	}
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({}, others, {
		style: Object.assign(Object.assign(Object.assign({}, mergedStyle), style$1), sizeStyle),
		className: classes,
		ref
	}), children));
});
Col.displayName = "Col";
var col_default$1 = Col;

//#endregion
//#region node_modules/antd/es/grid/hooks/useGutter.js
function useGutter(gutter, screens) {
	const results = [void 0, void 0];
	const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
	const mergedScreens = screens || {
		xs: true,
		sm: true,
		md: true,
		lg: true,
		xl: true,
		xxl: true
	};
	normalizedGutter.forEach((g, index$2) => {
		if (typeof g === "object" && g !== null) for (let i = 0; i < responsiveArray.length; i++) {
			const breakpoint = responsiveArray[i];
			if (mergedScreens[breakpoint] && g[breakpoint] !== void 0) {
				results[index$2] = g[breakpoint];
				break;
			}
		}
		else results[index$2] = g;
	});
	return results;
}

//#endregion
//#region node_modules/antd/es/grid/row.js
var import_classnames$142 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$70 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function useMergedPropByScreen(oriProp, screen) {
	const [prop, setProp] = import_react.useState(typeof oriProp === "string" ? oriProp : "");
	const calcMergedAlignOrJustify = () => {
		if (typeof oriProp === "string") setProp(oriProp);
		if (typeof oriProp !== "object") return;
		for (let i = 0; i < responsiveArray.length; i++) {
			const breakpoint = responsiveArray[i];
			if (!screen || !screen[breakpoint]) continue;
			const curVal = oriProp[breakpoint];
			if (curVal !== void 0) {
				setProp(curVal);
				return;
			}
		}
	};
	import_react.useEffect(() => {
		calcMergedAlignOrJustify();
	}, [JSON.stringify(oriProp), screen]);
	return prop;
}
var Row$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, justify, align, className, style: style$1, children, gutter = 0, wrap } = props, others = __rest$70(props, [
		"prefixCls",
		"justify",
		"align",
		"className",
		"style",
		"children",
		"gutter",
		"wrap"
	]);
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const screens = useBreakpoint_default(true, null);
	const mergedAlign = useMergedPropByScreen(align, screens);
	const mergedJustify = useMergedPropByScreen(justify, screens);
	const prefixCls = getPrefixCls("row", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = useRowStyle(prefixCls);
	const gutters = useGutter(gutter, screens);
	const classes = (0, import_classnames$142.default)(prefixCls, {
		[`${prefixCls}-no-wrap`]: wrap === false,
		[`${prefixCls}-${mergedJustify}`]: mergedJustify,
		[`${prefixCls}-${mergedAlign}`]: mergedAlign,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, hashId, cssVarCls);
	const rowStyle = {};
	const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
	if (horizontalGutter) {
		rowStyle.marginLeft = horizontalGutter;
		rowStyle.marginRight = horizontalGutter;
	}
	const [gutterH, gutterV] = gutters;
	rowStyle.rowGap = gutterV;
	const rowContext = import_react.useMemo(() => ({
		gutter: [gutterH, gutterV],
		wrap
	}), [
		gutterH,
		gutterV,
		wrap
	]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(RowContext_default.Provider, { value: rowContext }, /* @__PURE__ */ import_react.createElement("div", Object.assign({}, others, {
		className: classes,
		style: Object.assign(Object.assign({}, rowStyle), style$1),
		ref
	}), children)));
});
Row$1.displayName = "Row";
var row_default$1 = Row$1;

//#endregion
//#region node_modules/antd/es/grid/index.js
function useBreakpoint() {
	return useBreakpoint_default();
}
var grid_default = { useBreakpoint };

//#endregion
//#region node_modules/antd/es/col/index.js
var col_default = col_default$1;

//#endregion
//#region node_modules/antd/es/divider/style/index.js
var genSizeDividerStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: { "&-horizontal": { [`&${componentCls}`]: {
		"&-sm": { marginBlock: token$1.marginXS },
		"&-md": { marginBlock: token$1.margin }
	} } } };
};
var genSharedDividerStyle = (token$1) => {
	const { componentCls, sizePaddingEdgeHorizontal, colorSplit, lineWidth, textPaddingInline, orientationMargin, verticalMarginInline } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		borderBlockStart: `${unit(lineWidth)} solid ${colorSplit}`,
		"&-vertical": {
			position: "relative",
			top: "-0.06em",
			display: "inline-block",
			height: "0.9em",
			marginInline: verticalMarginInline,
			marginBlock: 0,
			verticalAlign: "middle",
			borderTop: 0,
			borderInlineStart: `${unit(lineWidth)} solid ${colorSplit}`
		},
		"&-horizontal": {
			display: "flex",
			clear: "both",
			width: "100%",
			minWidth: "100%",
			margin: `${unit(token$1.marginLG)} 0`
		},
		[`&-horizontal${componentCls}-with-text`]: {
			display: "flex",
			alignItems: "center",
			margin: `${unit(token$1.dividerHorizontalWithTextGutterMargin)} 0`,
			color: token$1.colorTextHeading,
			fontWeight: 500,
			fontSize: token$1.fontSizeLG,
			whiteSpace: "nowrap",
			textAlign: "center",
			borderBlockStart: `0 ${colorSplit}`,
			"&::before, &::after": {
				position: "relative",
				width: "50%",
				borderBlockStart: `${unit(lineWidth)} solid transparent`,
				borderBlockStartColor: "inherit",
				borderBlockEnd: 0,
				transform: "translateY(50%)",
				content: "''"
			}
		},
		[`&-horizontal${componentCls}-with-text-start`]: {
			"&::before": { width: `calc(${orientationMargin} * 100%)` },
			"&::after": { width: `calc(100% - ${orientationMargin} * 100%)` }
		},
		[`&-horizontal${componentCls}-with-text-end`]: {
			"&::before": { width: `calc(100% - ${orientationMargin} * 100%)` },
			"&::after": { width: `calc(${orientationMargin} * 100%)` }
		},
		[`${componentCls}-inner-text`]: {
			display: "inline-block",
			paddingBlock: 0,
			paddingInline: textPaddingInline
		},
		"&-dashed": {
			background: "none",
			borderColor: colorSplit,
			borderStyle: "dashed",
			borderWidth: `${unit(lineWidth)} 0 0`
		},
		[`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: { "&::before, &::after": { borderStyle: "dashed none none" } },
		[`&-vertical${componentCls}-dashed`]: {
			borderInlineStartWidth: lineWidth,
			borderInlineEnd: 0,
			borderBlockStart: 0,
			borderBlockEnd: 0
		},
		"&-dotted": {
			background: "none",
			borderColor: colorSplit,
			borderStyle: "dotted",
			borderWidth: `${unit(lineWidth)} 0 0`
		},
		[`&-horizontal${componentCls}-with-text${componentCls}-dotted`]: { "&::before, &::after": { borderStyle: "dotted none none" } },
		[`&-vertical${componentCls}-dotted`]: {
			borderInlineStartWidth: lineWidth,
			borderInlineEnd: 0,
			borderBlockStart: 0,
			borderBlockEnd: 0
		},
		[`&-plain${componentCls}-with-text`]: {
			color: token$1.colorText,
			fontWeight: "normal",
			fontSize: token$1.fontSize
		},
		[`&-horizontal${componentCls}-with-text-start${componentCls}-no-default-orientation-margin-start`]: {
			"&::before": { width: 0 },
			"&::after": { width: "100%" },
			[`${componentCls}-inner-text`]: { paddingInlineStart: sizePaddingEdgeHorizontal }
		},
		[`&-horizontal${componentCls}-with-text-end${componentCls}-no-default-orientation-margin-end`]: {
			"&::before": { width: "100%" },
			"&::after": { width: 0 },
			[`${componentCls}-inner-text`]: { paddingInlineEnd: sizePaddingEdgeHorizontal }
		}
	}) };
};
const prepareComponentToken$30 = (token$1) => ({
	textPaddingInline: "1em",
	orientationMargin: .05,
	verticalMarginInline: token$1.marginXS
});
var style_default$37 = genStyleHooks("Divider", (token$1) => {
	const dividerToken = merge(token$1, {
		dividerHorizontalWithTextGutterMargin: token$1.margin,
		sizePaddingEdgeHorizontal: 0
	});
	return [genSharedDividerStyle(dividerToken), genSizeDividerStyle(dividerToken)];
}, prepareComponentToken$30, { unitless: { orientationMargin: true } });

//#endregion
//#region node_modules/antd/es/divider/index.js
var import_classnames$141 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$69 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var sizeClassNameMap = {
	small: "sm",
	middle: "md"
};
var Divider = (props) => {
	const { getPrefixCls, direction, className: dividerClassName, style: dividerStyle } = useComponentConfig("divider");
	const { prefixCls: customizePrefixCls, type: type$2 = "horizontal", orientation = "center", orientationMargin, className, rootClassName, children, dashed, variant = "solid", plain, style: style$1, size: customSize } = props, restProps = __rest$69(props, [
		"prefixCls",
		"type",
		"orientation",
		"orientationMargin",
		"className",
		"rootClassName",
		"children",
		"dashed",
		"variant",
		"plain",
		"style",
		"size"
	]);
	const prefixCls = getPrefixCls("divider", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$37(prefixCls);
	const sizeFullName = useSize_default(customSize);
	const sizeCls = sizeClassNameMap[sizeFullName];
	const hasChildren = !!children;
	const mergedOrientation = import_react.useMemo(() => {
		if (orientation === "left") return direction === "rtl" ? "end" : "start";
		if (orientation === "right") return direction === "rtl" ? "start" : "end";
		return orientation;
	}, [direction, orientation]);
	const hasMarginStart = mergedOrientation === "start" && orientationMargin != null;
	const hasMarginEnd = mergedOrientation === "end" && orientationMargin != null;
	const classString = (0, import_classnames$141.default)(prefixCls, dividerClassName, hashId, cssVarCls, `${prefixCls}-${type$2}`, {
		[`${prefixCls}-with-text`]: hasChildren,
		[`${prefixCls}-with-text-${mergedOrientation}`]: hasChildren,
		[`${prefixCls}-dashed`]: !!dashed,
		[`${prefixCls}-${variant}`]: variant !== "solid",
		[`${prefixCls}-plain`]: !!plain,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-no-default-orientation-margin-start`]: hasMarginStart,
		[`${prefixCls}-no-default-orientation-margin-end`]: hasMarginEnd,
		[`${prefixCls}-${sizeCls}`]: !!sizeCls
	}, className, rootClassName);
	const memoizedOrientationMargin = import_react.useMemo(() => {
		if (typeof orientationMargin === "number") return orientationMargin;
		if (/^\d+$/.test(orientationMargin)) return Number(orientationMargin);
		return orientationMargin;
	}, [orientationMargin]);
	const innerStyle = {
		marginInlineStart: hasMarginStart ? memoizedOrientationMargin : void 0,
		marginInlineEnd: hasMarginEnd ? memoizedOrientationMargin : void 0
	};
	devUseWarning("Divider")(!children || type$2 !== "vertical", "usage", "`children` not working in `vertical` mode.");
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({
		className: classString,
		style: Object.assign(Object.assign({}, dividerStyle), style$1)
	}, restProps, { role: "separator" }), children && type$2 !== "vertical" && /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-inner-text`,
		style: innerStyle
	}, children)));
};
Divider.displayName = "Divider";
var divider_default = Divider;

//#endregion
//#region node_modules/rc-segmented/es/MotionThumb.js
var import_classnames$140 = /* @__PURE__ */ __toESM(require_classnames());
var calcThumbStyle = function calcThumbStyle$1(targetElement, vertical) {
	if (!targetElement) return null;
	var style$1 = {
		left: targetElement.offsetLeft,
		right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
		width: targetElement.clientWidth,
		top: targetElement.offsetTop,
		bottom: targetElement.parentElement.clientHeight - targetElement.clientHeight - targetElement.offsetTop,
		height: targetElement.clientHeight
	};
	if (vertical) return {
		left: 0,
		right: 0,
		width: 0,
		top: style$1.top,
		bottom: style$1.bottom,
		height: style$1.height
	};
	return {
		left: style$1.left,
		right: style$1.right,
		width: style$1.width,
		top: 0,
		bottom: 0,
		height: 0
	};
};
var toPX = function toPX$1(value) {
	return value !== void 0 ? "".concat(value, "px") : void 0;
};
function MotionThumb(props) {
	var prefixCls = props.prefixCls, containerRef = props.containerRef, value = props.value, getValueIndex = props.getValueIndex, motionName = props.motionName, onMotionStart = props.onMotionStart, onMotionEnd = props.onMotionEnd, direction = props.direction, _props$vertical = props.vertical, vertical = _props$vertical === void 0 ? false : _props$vertical;
	var thumbRef = import_react.useRef(null);
	var _React$useState = import_react.useState(value), _React$useState2 = _slicedToArray(_React$useState, 2), prevValue = _React$useState2[0], setPrevValue = _React$useState2[1];
	var findValueElement = function findValueElement$1(val) {
		var _containerRef$current;
		var index$2 = getValueIndex(val);
		var ele = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelectorAll(".".concat(prefixCls, "-item"))[index$2];
		return (ele === null || ele === void 0 ? void 0 : ele.offsetParent) && ele;
	};
	var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), prevStyle = _React$useState4[0], setPrevStyle = _React$useState4[1];
	var _React$useState5 = import_react.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), nextStyle = _React$useState6[0], setNextStyle = _React$useState6[1];
	useLayoutEffect_default(function() {
		if (prevValue !== value) {
			var prev$1 = findValueElement(prevValue);
			var next$1 = findValueElement(value);
			var calcPrevStyle = calcThumbStyle(prev$1, vertical);
			var calcNextStyle = calcThumbStyle(next$1, vertical);
			setPrevValue(value);
			setPrevStyle(calcPrevStyle);
			setNextStyle(calcNextStyle);
			if (prev$1 && next$1) onMotionStart();
			else onMotionEnd();
		}
	}, [value]);
	var thumbStart = import_react.useMemo(function() {
		if (vertical) {
			var _prevStyle$top;
			return toPX((_prevStyle$top = prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.top) !== null && _prevStyle$top !== void 0 ? _prevStyle$top : 0);
		}
		if (direction === "rtl") return toPX(-(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.right));
		return toPX(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.left);
	}, [
		vertical,
		direction,
		prevStyle
	]);
	var thumbActive = import_react.useMemo(function() {
		if (vertical) {
			var _nextStyle$top;
			return toPX((_nextStyle$top = nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.top) !== null && _nextStyle$top !== void 0 ? _nextStyle$top : 0);
		}
		if (direction === "rtl") return toPX(-(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.right));
		return toPX(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.left);
	}, [
		vertical,
		direction,
		nextStyle
	]);
	var onAppearStart = function onAppearStart$1() {
		if (vertical) return {
			transform: "translateY(var(--thumb-start-top))",
			height: "var(--thumb-start-height)"
		};
		return {
			transform: "translateX(var(--thumb-start-left))",
			width: "var(--thumb-start-width)"
		};
	};
	var onAppearActive = function onAppearActive$1() {
		if (vertical) return {
			transform: "translateY(var(--thumb-active-top))",
			height: "var(--thumb-active-height)"
		};
		return {
			transform: "translateX(var(--thumb-active-left))",
			width: "var(--thumb-active-width)"
		};
	};
	var onVisibleChanged = function onVisibleChanged$1() {
		setPrevStyle(null);
		setNextStyle(null);
		onMotionEnd();
	};
	if (!prevStyle || !nextStyle) return null;
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible: true,
		motionName,
		motionAppear: true,
		onAppearStart,
		onAppearActive,
		onVisibleChanged
	}, function(_ref, ref) {
		var motionClassName = _ref.className, motionStyle = _ref.style;
		var mergedStyle = _objectSpread2(_objectSpread2({}, motionStyle), {}, {
			"--thumb-start-left": thumbStart,
			"--thumb-start-width": toPX(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.width),
			"--thumb-active-left": thumbActive,
			"--thumb-active-width": toPX(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.width),
			"--thumb-start-top": thumbStart,
			"--thumb-start-height": toPX(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.height),
			"--thumb-active-top": thumbActive,
			"--thumb-active-height": toPX(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.height)
		});
		var motionProps = {
			ref: composeRef(thumbRef, ref),
			style: mergedStyle,
			className: (0, import_classnames$140.default)("".concat(prefixCls, "-thumb"), motionClassName)
		};
		return /* @__PURE__ */ import_react.createElement("div", motionProps);
	});
}

//#endregion
//#region node_modules/rc-segmented/es/index.js
var import_classnames$139 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$33 = [
	"prefixCls",
	"direction",
	"vertical",
	"options",
	"disabled",
	"defaultValue",
	"value",
	"name",
	"onChange",
	"className",
	"motionName"
];
function getValidTitle(option) {
	if (typeof option.title !== "undefined") return option.title;
	if (_typeof(option.label) !== "object") {
		var _option$label;
		return (_option$label = option.label) === null || _option$label === void 0 ? void 0 : _option$label.toString();
	}
}
function normalizeOptions(options) {
	return options.map(function(option) {
		if (_typeof(option) === "object" && option !== null) {
			var validTitle = getValidTitle(option);
			return _objectSpread2(_objectSpread2({}, option), {}, { title: validTitle });
		}
		return {
			label: option === null || option === void 0 ? void 0 : option.toString(),
			title: option === null || option === void 0 ? void 0 : option.toString(),
			value: option
		};
	});
}
var InternalSegmentedOption = function InternalSegmentedOption$1(_ref) {
	var prefixCls = _ref.prefixCls, className = _ref.className, disabled = _ref.disabled, checked = _ref.checked, label = _ref.label, title = _ref.title, value = _ref.value, name = _ref.name, onChange = _ref.onChange, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onKeyDown$1 = _ref.onKeyDown, onKeyUp = _ref.onKeyUp, onMouseDown = _ref.onMouseDown;
	return /* @__PURE__ */ import_react.createElement("label", {
		className: (0, import_classnames$139.default)(className, _defineProperty({}, "".concat(prefixCls, "-item-disabled"), disabled)),
		onMouseDown
	}, /* @__PURE__ */ import_react.createElement("input", {
		name,
		className: "".concat(prefixCls, "-item-input"),
		type: "radio",
		disabled,
		checked,
		onChange: function handleChange(event) {
			if (disabled) return;
			onChange(event, value);
		},
		onFocus,
		onBlur,
		onKeyDown: onKeyDown$1,
		onKeyUp
	}), /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-item-label"),
		title,
		"aria-selected": checked
	}, label));
};
var Segmented$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _segmentedOptions$, _classNames2;
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-segmented" : _props$prefixCls, direction = props.direction, vertical = props.vertical, _props$options = props.options, options = _props$options === void 0 ? [] : _props$options, disabled = props.disabled, defaultValue = props.defaultValue, value = props.value, name = props.name, onChange = props.onChange, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, _props$motionName = props.motionName, motionName = _props$motionName === void 0 ? "thumb-motion" : _props$motionName, restProps = _objectWithoutProperties(props, _excluded$33);
	var containerRef = import_react.useRef(null);
	var mergedRef = import_react.useMemo(function() {
		return composeRef(containerRef, ref);
	}, [containerRef, ref]);
	var segmentedOptions = import_react.useMemo(function() {
		return normalizeOptions(options);
	}, [options]);
	var _useMergedState = useMergedState((_segmentedOptions$ = segmentedOptions[0]) === null || _segmentedOptions$ === void 0 ? void 0 : _segmentedOptions$.value, {
		value,
		defaultValue
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValue = _useMergedState2[0], setRawValue = _useMergedState2[1];
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), thumbShow = _React$useState2[0], setThumbShow = _React$useState2[1];
	var handleChange = function handleChange$1(event, val) {
		setRawValue(val);
		onChange === null || onChange === void 0 || onChange(val);
	};
	var divProps = omit(restProps, ["children"]);
	var _React$useState3 = import_react.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), isKeyboard = _React$useState4[0], setIsKeyboard = _React$useState4[1];
	var _React$useState5 = import_react.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), isFocused = _React$useState6[0], setIsFocused = _React$useState6[1];
	var handleFocus = function handleFocus$1() {
		setIsFocused(true);
	};
	var handleBlur = function handleBlur$1() {
		setIsFocused(false);
	};
	var handleMouseDown = function handleMouseDown$1() {
		setIsKeyboard(false);
	};
	var handleKeyUp = function handleKeyUp$1(event) {
		if (event.key === "Tab") setIsKeyboard(true);
	};
	var onOffset = function onOffset$1(offset$2) {
		var currentIndex = segmentedOptions.findIndex(function(option) {
			return option.value === rawValue;
		});
		var total = segmentedOptions.length;
		var nextIndex = (currentIndex + offset$2 + total) % total;
		var nextOption = segmentedOptions[nextIndex];
		if (nextOption) {
			setRawValue(nextOption.value);
			onChange === null || onChange === void 0 || onChange(nextOption.value);
		}
	};
	var handleKeyDown = function handleKeyDown$1(event) {
		switch (event.key) {
			case "ArrowLeft":
			case "ArrowUp":
				onOffset(-1);
				break;
			case "ArrowRight":
			case "ArrowDown":
				onOffset(1);
				break;
		}
	};
	return /* @__PURE__ */ import_react.createElement("div", _extends({
		role: "radiogroup",
		"aria-label": "segmented control",
		tabIndex: disabled ? void 0 : 0
	}, divProps, {
		className: (0, import_classnames$139.default)(prefixCls, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty(_classNames2, "".concat(prefixCls, "-vertical"), vertical), _classNames2), className),
		ref: mergedRef
	}), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-group") }, /* @__PURE__ */ import_react.createElement(MotionThumb, {
		vertical,
		prefixCls,
		value: rawValue,
		containerRef,
		motionName: "".concat(prefixCls, "-").concat(motionName),
		direction,
		getValueIndex: function getValueIndex(val) {
			return segmentedOptions.findIndex(function(n$1) {
				return n$1.value === val;
			});
		},
		onMotionStart: function onMotionStart() {
			setThumbShow(true);
		},
		onMotionEnd: function onMotionEnd() {
			setThumbShow(false);
		}
	}), segmentedOptions.map(function(segmentedOption) {
		var _classNames3;
		return /* @__PURE__ */ import_react.createElement(InternalSegmentedOption, _extends({}, segmentedOption, {
			name,
			key: segmentedOption.value,
			prefixCls,
			className: (0, import_classnames$139.default)(segmentedOption.className, "".concat(prefixCls, "-item"), (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefixCls, "-item-selected"), segmentedOption.value === rawValue && !thumbShow), _defineProperty(_classNames3, "".concat(prefixCls, "-item-focused"), isFocused && isKeyboard && segmentedOption.value === rawValue), _classNames3)),
			checked: segmentedOption.value === rawValue,
			onChange: handleChange,
			onFocus: handleFocus,
			onBlur: handleBlur,
			onKeyDown: handleKeyDown,
			onKeyUp: handleKeyUp,
			onMouseDown: handleMouseDown,
			disabled: !!disabled || !!segmentedOption.disabled
		}));
	})));
});
Segmented$1.displayName = "Segmented";
var TypedSegmented = Segmented$1;
var es_default$25 = TypedSegmented;

//#endregion
//#region node_modules/antd/es/segmented/style/index.js
function getItemDisabledStyle(cls$12, token$1) {
	return { [`${cls$12}, ${cls$12}:hover, ${cls$12}:focus`]: {
		color: token$1.colorTextDisabled,
		cursor: "not-allowed"
	} };
}
function getItemSelectedStyle(token$1) {
	return {
		backgroundColor: token$1.itemSelectedBg,
		boxShadow: token$1.boxShadowTertiary
	};
}
var segmentedTextEllipsisCss = Object.assign({ overflow: "hidden" }, textEllipsis);
var genSegmentedStyle = (token$1) => {
	const { componentCls } = token$1;
	const labelHeight = token$1.calc(token$1.controlHeight).sub(token$1.calc(token$1.trackPadding).mul(2)).equal();
	const labelHeightLG = token$1.calc(token$1.controlHeightLG).sub(token$1.calc(token$1.trackPadding).mul(2)).equal();
	const labelHeightSM = token$1.calc(token$1.controlHeightSM).sub(token$1.calc(token$1.trackPadding).mul(2)).equal();
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
		display: "inline-block",
		padding: token$1.trackPadding,
		color: token$1.itemColor,
		background: token$1.trackBg,
		borderRadius: token$1.borderRadius,
		transition: `all ${token$1.motionDurationMid} ${token$1.motionEaseInOut}`
	}), genFocusStyle(token$1)), {
		[`${componentCls}-group`]: {
			position: "relative",
			display: "flex",
			alignItems: "stretch",
			justifyItems: "flex-start",
			flexDirection: "row",
			width: "100%"
		},
		[`&${componentCls}-rtl`]: { direction: "rtl" },
		[`&${componentCls}-vertical`]: {
			[`${componentCls}-group`]: { flexDirection: "column" },
			[`${componentCls}-thumb`]: {
				width: "100%",
				height: 0,
				padding: `0 ${unit(token$1.paddingXXS)}`
			}
		},
		[`&${componentCls}-block`]: { display: "flex" },
		[`&${componentCls}-block ${componentCls}-item`]: {
			flex: 1,
			minWidth: 0
		},
		[`${componentCls}-item`]: {
			position: "relative",
			textAlign: "center",
			cursor: "pointer",
			transition: `color ${token$1.motionDurationMid} ${token$1.motionEaseInOut}`,
			borderRadius: token$1.borderRadiusSM,
			transform: "translateZ(0)",
			"&-selected": Object.assign(Object.assign({}, getItemSelectedStyle(token$1)), { color: token$1.itemSelectedColor }),
			"&-focused": genFocusOutline(token$1),
			"&::after": {
				content: "\"\"",
				position: "absolute",
				zIndex: -1,
				width: "100%",
				height: "100%",
				top: 0,
				insetInlineStart: 0,
				borderRadius: "inherit",
				opacity: 0,
				transition: `opacity ${token$1.motionDurationMid}`,
				pointerEvents: "none"
			},
			[`&:hover:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
				color: token$1.itemHoverColor,
				"&::after": {
					opacity: 1,
					backgroundColor: token$1.itemHoverBg
				}
			},
			[`&:active:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
				color: token$1.itemHoverColor,
				"&::after": {
					opacity: 1,
					backgroundColor: token$1.itemActiveBg
				}
			},
			"&-label": Object.assign({
				minHeight: labelHeight,
				lineHeight: unit(labelHeight),
				padding: `0 ${unit(token$1.segmentedPaddingHorizontal)}`
			}, segmentedTextEllipsisCss),
			"&-icon + *": { marginInlineStart: token$1.calc(token$1.marginSM).div(2).equal() },
			"&-input": {
				position: "absolute",
				insetBlockStart: 0,
				insetInlineStart: 0,
				width: 0,
				height: 0,
				opacity: 0,
				pointerEvents: "none"
			}
		},
		[`${componentCls}-thumb`]: Object.assign(Object.assign({}, getItemSelectedStyle(token$1)), {
			position: "absolute",
			insetBlockStart: 0,
			insetInlineStart: 0,
			width: 0,
			height: "100%",
			padding: `${unit(token$1.paddingXXS)} 0`,
			borderRadius: token$1.borderRadiusSM,
			transition: `transform ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}, height ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`,
			[`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: { backgroundColor: "transparent" }
		}),
		[`&${componentCls}-lg`]: {
			borderRadius: token$1.borderRadiusLG,
			[`${componentCls}-item-label`]: {
				minHeight: labelHeightLG,
				lineHeight: unit(labelHeightLG),
				padding: `0 ${unit(token$1.segmentedPaddingHorizontal)}`,
				fontSize: token$1.fontSizeLG
			},
			[`${componentCls}-item, ${componentCls}-thumb`]: { borderRadius: token$1.borderRadius }
		},
		[`&${componentCls}-sm`]: {
			borderRadius: token$1.borderRadiusSM,
			[`${componentCls}-item-label`]: {
				minHeight: labelHeightSM,
				lineHeight: unit(labelHeightSM),
				padding: `0 ${unit(token$1.segmentedPaddingHorizontalSM)}`
			},
			[`${componentCls}-item, ${componentCls}-thumb`]: { borderRadius: token$1.borderRadiusXS }
		}
	}), getItemDisabledStyle(`&-disabled ${componentCls}-item`, token$1)), getItemDisabledStyle(`${componentCls}-item-disabled`, token$1)), {
		[`${componentCls}-thumb-motion-appear-active`]: {
			transition: `transform ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}, width ${token$1.motionDurationSlow} ${token$1.motionEaseInOut}`,
			willChange: "transform, width"
		},
		[`&${componentCls}-shape-round`]: {
			borderRadius: 9999,
			[`${componentCls}-item, ${componentCls}-thumb`]: { borderRadius: 9999 }
		}
	}) };
};
const prepareComponentToken$29 = (token$1) => {
	const { colorTextLabel, colorText, colorFillSecondary, colorBgElevated, colorFill, lineWidthBold, colorBgLayout } = token$1;
	return {
		trackPadding: lineWidthBold,
		trackBg: colorBgLayout,
		itemColor: colorTextLabel,
		itemHoverColor: colorText,
		itemHoverBg: colorFillSecondary,
		itemSelectedBg: colorBgElevated,
		itemActiveBg: colorFill,
		itemSelectedColor: colorText
	};
};
var style_default$36 = genStyleHooks("Segmented", (token$1) => {
	const { lineWidth, calc } = token$1;
	const segmentedToken = merge(token$1, {
		segmentedPaddingHorizontal: calc(token$1.controlPaddingHorizontal).sub(lineWidth).equal(),
		segmentedPaddingHorizontalSM: calc(token$1.controlPaddingHorizontalSM).sub(lineWidth).equal()
	});
	return genSegmentedStyle(segmentedToken);
}, prepareComponentToken$29);

//#endregion
//#region node_modules/antd/es/segmented/index.js
var import_classnames$138 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$68 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function isSegmentedLabeledOptionWithIcon(option) {
	return typeof option === "object" && !!(option === null || option === void 0 ? void 0 : option.icon);
}
var Segmented = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const defaultName = useId_default();
	const { prefixCls: customizePrefixCls, className, rootClassName, block, options = [], size: customSize = "middle", style: style$1, vertical, shape = "default", name = defaultName } = props, restProps = __rest$68(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"block",
		"options",
		"size",
		"style",
		"vertical",
		"shape",
		"name"
	]);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("segmented");
	const prefixCls = getPrefixCls("segmented", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$36(prefixCls);
	const mergedSize = useSize_default(customSize);
	const extendedOptions = import_react.useMemo(() => options.map((option) => {
		if (isSegmentedLabeledOptionWithIcon(option)) {
			const { icon, label } = option, restOption = __rest$68(option, ["icon", "label"]);
			return Object.assign(Object.assign({}, restOption), { label: /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-item-icon` }, icon), label && /* @__PURE__ */ import_react.createElement("span", null, label)) });
		}
		return option;
	}), [options, prefixCls]);
	const cls$12 = (0, import_classnames$138.default)(className, rootClassName, contextClassName, {
		[`${prefixCls}-block`]: block,
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-lg`]: mergedSize === "large",
		[`${prefixCls}-vertical`]: vertical,
		[`${prefixCls}-shape-${shape}`]: shape === "round"
	}, hashId, cssVarCls);
	const mergedStyle = Object.assign(Object.assign({}, contextStyle), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$25, Object.assign({}, restProps, {
		name,
		className: cls$12,
		style: mergedStyle,
		options: extendedOptions,
		ref,
		prefixCls,
		direction,
		vertical
	})));
});
Segmented.displayName = "Segmented";
var segmented_default = Segmented;

//#endregion
//#region node_modules/antd/es/color-picker/context.js
const PanelPickerContext = /* @__PURE__ */ import_react.createContext({});
const PanelPresetsContext = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorClear.js
var ColorClear = ({ prefixCls, value, onChange }) => {
	const handleClick = () => {
		if (onChange && value && !value.cleared) {
			const hsba = value.toHsb();
			hsba.a = 0;
			const genColor = generateColor(hsba);
			genColor.cleared = true;
			onChange(genColor);
		}
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-clear`,
		onClick: handleClick
	});
};
var ColorClear_default = ColorClear;

//#endregion
//#region node_modules/antd/es/color-picker/interface.js
const FORMAT_HEX = "hex";
const FORMAT_RGB = "rgb";
const FORMAT_HSB = "hsb";

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/UpOutlined.js
var UpOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" }
		}]
	},
	"name": "up",
	"theme": "outlined"
};
var UpOutlined_default$1 = UpOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/UpOutlined.js
/**![up](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg5MC41IDc1NS4zTDUzNy45IDI2OS4yYy0xMi44LTE3LjYtMzktMTcuNi01MS43IDBMMTMzLjUgNzU1LjNBOCA4IDAgMDAxNDAgNzY4aDc1YzUuMSAwIDkuOS0yLjUgMTIuOS02LjZMNTEyIDM2OS44bDI4NC4xIDM5MS42YzMgNC4xIDcuOCA2LjYgMTIuOSA2LjZoNzVjNi41IDAgMTAuMy03LjQgNi41LTEyLjd6IiAvPjwvc3ZnPg==) */
var RefIcon$35 = /* @__PURE__ */ import_react.forwardRef(function UpOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: UpOutlined_default$1
	}));
});
RefIcon$35.displayName = "UpOutlined";
var UpOutlined_default = RefIcon$35;

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/supportUtil.js
function supportBigInt() {
	return typeof BigInt === "function";
}

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/numberUtil.js
function isEmpty(value) {
	return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}
/**
* Format string number to readable number
*/
function trimNumber(numStr) {
	var str = numStr.trim();
	var negative = str.startsWith("-");
	if (negative) str = str.slice(1);
	str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
	if (str.startsWith(".")) str = "0".concat(str);
	var trimStr = str || "0";
	var splitNumber = trimStr.split(".");
	var integerStr = splitNumber[0] || "0";
	var decimalStr = splitNumber[1] || "0";
	if (integerStr === "0" && decimalStr === "0") negative = false;
	var negativeStr = negative ? "-" : "";
	return {
		negative,
		negativeStr,
		trimStr,
		integerStr,
		decimalStr,
		fullStr: "".concat(negativeStr).concat(trimStr)
	};
}
function isE(number$1) {
	var str = String(number$1);
	return !Number.isNaN(Number(str)) && str.includes("e");
}
/**
* [Legacy] Convert 1e-9 to 0.000000001.
* This may lose some precision if user really want 1e-9.
*/
function getNumberPrecision(number$1) {
	var numStr = String(number$1);
	if (isE(number$1)) {
		var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
		var decimalMatch = numStr.match(/\.(\d+)/);
		if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) precision += decimalMatch[1].length;
		return precision;
	}
	return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
/**
* Convert number (includes scientific notation) to -xxx.yyy format
*/
function num2str(number$1) {
	var numStr = String(number$1);
	if (isE(number$1)) {
		if (number$1 > Number.MAX_SAFE_INTEGER) return String(supportBigInt() ? BigInt(number$1).toString() : Number.MAX_SAFE_INTEGER);
		if (number$1 < Number.MIN_SAFE_INTEGER) return String(supportBigInt() ? BigInt(number$1).toString() : Number.MIN_SAFE_INTEGER);
		numStr = number$1.toFixed(getNumberPrecision(numStr));
	}
	return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
	if (typeof num === "number") return !Number.isNaN(num);
	if (!num) return false;
	return /^\s*-?\d+(\.\d+)?\s*$/.test(num) || /^\s*-?\d+\.\s*$/.test(num) || /^\s*-?\.\d+\s*$/.test(num);
}

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/BigIntDecimal.js
var BigIntDecimal = /* @__PURE__ */ function() {
	/** BigInt will convert `0009` to `9`. We need record the len of decimal */
	function BigIntDecimal$1(value) {
		_classCallCheck(this, BigIntDecimal$1);
		_defineProperty(this, "origin", "");
		_defineProperty(this, "negative", void 0);
		_defineProperty(this, "integer", void 0);
		_defineProperty(this, "decimal", void 0);
		_defineProperty(this, "decimalLen", void 0);
		_defineProperty(this, "empty", void 0);
		_defineProperty(this, "nan", void 0);
		if (isEmpty(value)) {
			this.empty = true;
			return;
		}
		this.origin = String(value);
		if (value === "-" || Number.isNaN(value)) {
			this.nan = true;
			return;
		}
		var mergedValue = value;
		if (isE(mergedValue)) mergedValue = Number(mergedValue);
		mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
		if (validateNumber(mergedValue)) {
			var trimRet = trimNumber(mergedValue);
			this.negative = trimRet.negative;
			var numbers = trimRet.trimStr.split(".");
			this.integer = BigInt(numbers[0]);
			var decimalStr = numbers[1] || "0";
			this.decimal = BigInt(decimalStr);
			this.decimalLen = decimalStr.length;
		} else this.nan = true;
	}
	_createClass(BigIntDecimal$1, [
		{
			key: "getMark",
			value: function getMark$1() {
				return this.negative ? "-" : "";
			}
		},
		{
			key: "getIntegerStr",
			value: function getIntegerStr() {
				return this.integer.toString();
			}
		},
		{
			key: "getDecimalStr",
			value: function getDecimalStr() {
				return this.decimal.toString().padStart(this.decimalLen, "0");
			}
		},
		{
			key: "alignDecimal",
			value: function alignDecimal(decimalLength) {
				var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
				return BigInt(str);
			}
		},
		{
			key: "negate",
			value: function negate() {
				var clone = new BigIntDecimal$1(this.toString());
				clone.negative = !clone.negative;
				return clone;
			}
		},
		{
			key: "cal",
			value: function cal(offset$2, calculator, calDecimalLen) {
				var maxDecimalLength = Math.max(this.getDecimalStr().length, offset$2.getDecimalStr().length);
				var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
				var offsetAlignedDecimal = offset$2.alignDecimal(maxDecimalLength);
				var valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString();
				var nextDecimalLength = calDecimalLen(maxDecimalLength);
				var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
				var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
				return new BigIntDecimal$1("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
			}
		},
		{
			key: "add",
			value: function add(value) {
				if (this.isInvalidate()) return new BigIntDecimal$1(value);
				var offset$2 = new BigIntDecimal$1(value);
				if (offset$2.isInvalidate()) return this;
				return this.cal(offset$2, function(num1, num2) {
					return num1 + num2;
				}, function(len) {
					return len;
				});
			}
		},
		{
			key: "multi",
			value: function multi(value) {
				var target = new BigIntDecimal$1(value);
				if (this.isInvalidate() || target.isInvalidate()) return new BigIntDecimal$1(NaN);
				return this.cal(target, function(num1, num2) {
					return num1 * num2;
				}, function(len) {
					return len * 2;
				});
			}
		},
		{
			key: "isEmpty",
			value: function isEmpty$1() {
				return this.empty;
			}
		},
		{
			key: "isNaN",
			value: function isNaN$1() {
				return this.nan;
			}
		},
		{
			key: "isInvalidate",
			value: function isInvalidate() {
				return this.isEmpty() || this.isNaN();
			}
		},
		{
			key: "equals",
			value: function equals(target) {
				return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
			}
		},
		{
			key: "lessEquals",
			value: function lessEquals(target) {
				return this.add(target.negate().toString()).toNumber() <= 0;
			}
		},
		{
			key: "toNumber",
			value: function toNumber() {
				if (this.isNaN()) return NaN;
				return Number(this.toString());
			}
		},
		{
			key: "toString",
			value: function toString() {
				if (!(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true)) return this.origin;
				if (this.isInvalidate()) return "";
				return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
			}
		}
	]);
	return BigIntDecimal$1;
}();

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/NumberDecimal.js
/**
* We can remove this when IE not support anymore
*/
var NumberDecimal = /* @__PURE__ */ function() {
	function NumberDecimal$1(value) {
		_classCallCheck(this, NumberDecimal$1);
		_defineProperty(this, "origin", "");
		_defineProperty(this, "number", void 0);
		_defineProperty(this, "empty", void 0);
		if (isEmpty(value)) {
			this.empty = true;
			return;
		}
		this.origin = String(value);
		this.number = Number(value);
	}
	_createClass(NumberDecimal$1, [
		{
			key: "negate",
			value: function negate() {
				return new NumberDecimal$1(-this.toNumber());
			}
		},
		{
			key: "add",
			value: function add(value) {
				if (this.isInvalidate()) return new NumberDecimal$1(value);
				var target = Number(value);
				if (Number.isNaN(target)) return this;
				var number$1 = this.number + target;
				if (number$1 > Number.MAX_SAFE_INTEGER) return new NumberDecimal$1(Number.MAX_SAFE_INTEGER);
				if (number$1 < Number.MIN_SAFE_INTEGER) return new NumberDecimal$1(Number.MIN_SAFE_INTEGER);
				var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
				return new NumberDecimal$1(number$1.toFixed(maxPrecision));
			}
		},
		{
			key: "multi",
			value: function multi(value) {
				var target = Number(value);
				if (this.isInvalidate() || Number.isNaN(target)) return new NumberDecimal$1(NaN);
				var number$1 = this.number * target;
				if (number$1 > Number.MAX_SAFE_INTEGER) return new NumberDecimal$1(Number.MAX_SAFE_INTEGER);
				if (number$1 < Number.MIN_SAFE_INTEGER) return new NumberDecimal$1(Number.MIN_SAFE_INTEGER);
				var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
				return new NumberDecimal$1(number$1.toFixed(maxPrecision));
			}
		},
		{
			key: "isEmpty",
			value: function isEmpty$1() {
				return this.empty;
			}
		},
		{
			key: "isNaN",
			value: function isNaN$1() {
				return Number.isNaN(this.number);
			}
		},
		{
			key: "isInvalidate",
			value: function isInvalidate() {
				return this.isEmpty() || this.isNaN();
			}
		},
		{
			key: "equals",
			value: function equals(target) {
				return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
			}
		},
		{
			key: "lessEquals",
			value: function lessEquals(target) {
				return this.add(target.negate().toString()).toNumber() <= 0;
			}
		},
		{
			key: "toNumber",
			value: function toNumber() {
				return this.number;
			}
		},
		{
			key: "toString",
			value: function toString() {
				if (!(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true)) return this.origin;
				if (this.isInvalidate()) return "";
				return num2str(this.number);
			}
		}
	]);
	return NumberDecimal$1;
}();

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/MiniDecimal.js
function getMiniDecimal(value) {
	if (supportBigInt()) return new BigIntDecimal(value);
	return new NumberDecimal(value);
}
/**
* Align the logic of toFixed to around like 1.5 => 2.
* If set `cutOnly`, will just remove the over decimal part.
*/
function toFixed(numStr, separatorStr, precision) {
	var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	if (numStr === "") return "";
	var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr;
	var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
	var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
	if (precision >= 0) {
		var advancedNum = Number(decimalStr[precision]);
		if (advancedNum >= 5 && !cutOnly) {
			var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
			return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
		}
		if (precision === 0) return numberWithoutDecimal;
		return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
	}
	if (precisionDecimalStr === ".0") return numberWithoutDecimal;
	return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}

//#endregion
//#region node_modules/@rc-component/mini-decimal/es/index.js
var es_default$24 = getMiniDecimal;

//#endregion
//#region node_modules/rc-input/es/utils/commonUtils.js
function hasAddon(props) {
	return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix$1(props) {
	return !!(props.prefix || props.suffix || props.allowClear);
}
function cloneEvent(event, target, value) {
	var currentTarget = target.cloneNode(true);
	var newEvent = Object.create(event, {
		target: { value: currentTarget },
		currentTarget: { value: currentTarget }
	});
	currentTarget.value = value;
	if (typeof target.selectionStart === "number" && typeof target.selectionEnd === "number") {
		currentTarget.selectionStart = target.selectionStart;
		currentTarget.selectionEnd = target.selectionEnd;
	}
	currentTarget.setSelectionRange = function() {
		target.setSelectionRange.apply(target, arguments);
	};
	return newEvent;
}
function resolveOnChange(target, e$2, onChange, targetValue) {
	if (!onChange) return;
	var event = e$2;
	if (e$2.type === "click") {
		event = cloneEvent(e$2, target, "");
		onChange(event);
		return;
	}
	if (target.type !== "file" && targetValue !== void 0) {
		event = cloneEvent(e$2, target, targetValue);
		onChange(event);
		return;
	}
	onChange(event);
}
function triggerFocus(element, option) {
	if (!element) return;
	element.focus(option);
	var _ref = option || {}, cursor = _ref.cursor;
	if (cursor) {
		var len = element.value.length;
		switch (cursor) {
			case "start":
				element.setSelectionRange(0, 0);
				break;
			case "end":
				element.setSelectionRange(len, len);
				break;
			default: element.setSelectionRange(0, len);
		}
	}
}

//#endregion
//#region node_modules/rc-input/es/BaseInput.js
var import_classnames$137 = /* @__PURE__ */ __toESM(require_classnames());
var BaseInput = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _props, _props2, _props3;
	var inputEl = props.inputElement, children = props.children, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style$1 = props.style, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus$1 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, classes = props.classes, classNames$252 = props.classNames, dataAttrs = props.dataAttrs, styles = props.styles, components$1 = props.components, onClear = props.onClear;
	var inputElement = children !== null && children !== void 0 ? children : inputEl;
	var AffixWrapperComponent = (components$1 === null || components$1 === void 0 ? void 0 : components$1.affixWrapper) || "span";
	var GroupWrapperComponent = (components$1 === null || components$1 === void 0 ? void 0 : components$1.groupWrapper) || "span";
	var WrapperComponent = (components$1 === null || components$1 === void 0 ? void 0 : components$1.wrapper) || "span";
	var GroupAddonComponent = (components$1 === null || components$1 === void 0 ? void 0 : components$1.groupAddon) || "span";
	var containerRef = (0, import_react.useRef)(null);
	var onInputClick = function onInputClick$1(e$2) {
		var _containerRef$current;
		if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e$2.target)) triggerFocus$1 === null || triggerFocus$1 === void 0 || triggerFocus$1();
	};
	var hasAffix = hasPrefixSuffix$1(props);
	var element = /* @__PURE__ */ (0, import_react.cloneElement)(inputElement, {
		value,
		className: (0, import_classnames$137.default)((_props = inputElement.props) === null || _props === void 0 ? void 0 : _props.className, !hasAffix && (classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.variant)) || null
	});
	var groupRef = (0, import_react.useRef)(null);
	import_react.useImperativeHandle(ref, function() {
		return { nativeElement: groupRef.current || containerRef.current };
	});
	if (hasAffix) {
		var clearIcon = null;
		if (allowClear) {
			var needClear = !disabled && !readOnly && value;
			var clearIconCls = "".concat(prefixCls, "-clear-icon");
			var iconNode = _typeof(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "";
			clearIcon = /* @__PURE__ */ import_react.createElement("button", {
				type: "button",
				tabIndex: -1,
				onClick: function onClick(event) {
					handleReset === null || handleReset === void 0 || handleReset(event);
					onClear === null || onClear === void 0 || onClear();
				},
				onMouseDown: function onMouseDown(e$2) {
					return e$2.preventDefault();
				},
				className: (0, import_classnames$137.default)(clearIconCls, _defineProperty(_defineProperty({}, "".concat(clearIconCls, "-hidden"), !needClear), "".concat(clearIconCls, "-has-suffix"), !!suffix))
			}, iconNode);
		}
		var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
		var affixWrapperCls = (0, import_classnames$137.default)(affixWrapperPrefixCls, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-focused"), focused), "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), classes === null || classes === void 0 ? void 0 : classes.affixWrapper, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.affixWrapper, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.variant);
		var suffixNode = (suffix || allowClear) && /* @__PURE__ */ import_react.createElement("span", {
			className: (0, import_classnames$137.default)("".concat(prefixCls, "-suffix"), classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.suffix),
			style: styles === null || styles === void 0 ? void 0 : styles.suffix
		}, clearIcon, suffix);
		element = /* @__PURE__ */ import_react.createElement(AffixWrapperComponent, _extends({
			className: affixWrapperCls,
			style: styles === null || styles === void 0 ? void 0 : styles.affixWrapper,
			onClick: onInputClick
		}, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, { ref: containerRef }), prefix && /* @__PURE__ */ import_react.createElement("span", {
			className: (0, import_classnames$137.default)("".concat(prefixCls, "-prefix"), classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.prefix),
			style: styles === null || styles === void 0 ? void 0 : styles.prefix
		}, prefix), element, suffixNode);
	}
	if (hasAddon(props)) {
		var wrapperCls = "".concat(prefixCls, "-group");
		var addonCls = "".concat(wrapperCls, "-addon");
		var groupWrapperCls = "".concat(wrapperCls, "-wrapper");
		var mergedWrapperClassName = (0, import_classnames$137.default)("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.wrapper);
		var mergedGroupClassName = (0, import_classnames$137.default)(groupWrapperCls, _defineProperty({}, "".concat(groupWrapperCls, "-disabled"), disabled), classes === null || classes === void 0 ? void 0 : classes.group, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.groupWrapper);
		element = /* @__PURE__ */ import_react.createElement(GroupWrapperComponent, {
			className: mergedGroupClassName,
			ref: groupRef
		}, /* @__PURE__ */ import_react.createElement(WrapperComponent, { className: mergedWrapperClassName }, addonBefore && /* @__PURE__ */ import_react.createElement(GroupAddonComponent, { className: addonCls }, addonBefore), element, addonAfter && /* @__PURE__ */ import_react.createElement(GroupAddonComponent, { className: addonCls }, addonAfter)));
	}
	return /* @__PURE__ */ import_react.cloneElement(element, {
		className: (0, import_classnames$137.default)((_props2 = element.props) === null || _props2 === void 0 ? void 0 : _props2.className, className) || null,
		style: _objectSpread2(_objectSpread2({}, (_props3 = element.props) === null || _props3 === void 0 ? void 0 : _props3.style), style$1),
		hidden
	});
});
var BaseInput_default = BaseInput;

//#endregion
//#region node_modules/rc-input/es/hooks/useCount.js
var _excluded$32 = ["show"];
function useCount(count, showCount) {
	return import_react.useMemo(function() {
		var mergedConfig = {};
		if (showCount) mergedConfig.show = _typeof(showCount) === "object" && showCount.formatter ? showCount.formatter : !!showCount;
		mergedConfig = _objectSpread2(_objectSpread2({}, mergedConfig), count);
		var _ref = mergedConfig, show = _ref.show, rest = _objectWithoutProperties(_ref, _excluded$32);
		return _objectSpread2(_objectSpread2({}, rest), {}, {
			show: !!show,
			showFormatter: typeof show === "function" ? show : void 0,
			strategy: rest.strategy || function(value) {
				return value.length;
			}
		});
	}, [count, showCount]);
}

//#endregion
//#region node_modules/rc-input/es/Input.js
var import_classnames$136 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$31 = [
	"autoComplete",
	"onChange",
	"onFocus",
	"onBlur",
	"onPressEnter",
	"onKeyDown",
	"onKeyUp",
	"prefixCls",
	"disabled",
	"htmlSize",
	"className",
	"maxLength",
	"suffix",
	"showCount",
	"count",
	"type",
	"classes",
	"classNames",
	"styles",
	"onCompositionStart",
	"onCompositionEnd"
];
var Input$2 = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown$1 = props.onKeyDown, onKeyUp = props.onKeyUp, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, count = props.count, _props$type = props.type, type$2 = _props$type === void 0 ? "text" : _props$type, classes = props.classes, classNames$252 = props.classNames, styles = props.styles, _onCompositionStart = props.onCompositionStart, onCompositionEnd = props.onCompositionEnd, rest = _objectWithoutProperties(props, _excluded$31);
	var _useState = (0, import_react.useState)(false), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
	var compositionRef = (0, import_react.useRef)(false);
	var keyLockRef = (0, import_react.useRef)(false);
	var inputRef = (0, import_react.useRef)(null);
	var holderRef = (0, import_react.useRef)(null);
	var focus = function focus$1(option) {
		if (inputRef.current) triggerFocus(inputRef.current, option);
	};
	var _useMergedState = useMergedState(props.defaultValue, { value: props.value }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
	var formatValue$1 = value === void 0 || value === null ? "" : String(value);
	var _useState3 = (0, import_react.useState)(null), _useState4 = _slicedToArray(_useState3, 2), selection = _useState4[0], setSelection = _useState4[1];
	var countConfig = useCount(count, showCount);
	var mergedMax = countConfig.max || maxLength;
	var valueLength = countConfig.strategy(formatValue$1);
	var isOutOfRange = !!mergedMax && valueLength > mergedMax;
	(0, import_react.useImperativeHandle)(ref, function() {
		var _holderRef$current;
		return {
			focus,
			blur: function blur() {
				var _inputRef$current;
				(_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();
			},
			setSelectionRange: function setSelectionRange(start, end, direction) {
				var _inputRef$current2;
				(_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.setSelectionRange(start, end, direction);
			},
			select: function select() {
				var _inputRef$current3;
				(_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.select();
			},
			input: inputRef.current,
			nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || inputRef.current
		};
	});
	(0, import_react.useEffect)(function() {
		if (keyLockRef.current) keyLockRef.current = false;
		setFocused(function(prev$1) {
			return prev$1 && disabled ? false : prev$1;
		});
	}, [disabled]);
	var triggerChange = function triggerChange$1(e$2, currentValue, info) {
		var cutValue = currentValue;
		if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
			cutValue = countConfig.exceedFormatter(currentValue, { max: countConfig.max });
			if (currentValue !== cutValue) {
				var _inputRef$current4, _inputRef$current5;
				setSelection([((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.selectionStart) || 0, ((_inputRef$current5 = inputRef.current) === null || _inputRef$current5 === void 0 ? void 0 : _inputRef$current5.selectionEnd) || 0]);
			}
		} else if (info.source === "compositionEnd") return;
		setValue(cutValue);
		if (inputRef.current) resolveOnChange(inputRef.current, e$2, onChange, cutValue);
	};
	(0, import_react.useEffect)(function() {
		if (selection) {
			var _inputRef$current6;
			(_inputRef$current6 = inputRef.current) === null || _inputRef$current6 === void 0 || _inputRef$current6.setSelectionRange.apply(_inputRef$current6, _toConsumableArray(selection));
		}
	}, [selection]);
	var onInternalChange = function onInternalChange$1(e$2) {
		triggerChange(e$2, e$2.target.value, { source: "change" });
	};
	var onInternalCompositionEnd = function onInternalCompositionEnd$1(e$2) {
		compositionRef.current = false;
		triggerChange(e$2, e$2.currentTarget.value, { source: "compositionEnd" });
		onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e$2);
	};
	var handleKeyDown = function handleKeyDown$1(e$2) {
		if (onPressEnter && e$2.key === "Enter" && !keyLockRef.current) {
			keyLockRef.current = true;
			onPressEnter(e$2);
		}
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(e$2);
	};
	var handleKeyUp = function handleKeyUp$1(e$2) {
		if (e$2.key === "Enter") keyLockRef.current = false;
		onKeyUp === null || onKeyUp === void 0 || onKeyUp(e$2);
	};
	var handleFocus = function handleFocus$1(e$2) {
		setFocused(true);
		onFocus === null || onFocus === void 0 || onFocus(e$2);
	};
	var handleBlur = function handleBlur$1(e$2) {
		if (keyLockRef.current) keyLockRef.current = false;
		setFocused(false);
		onBlur === null || onBlur === void 0 || onBlur(e$2);
	};
	var handleReset = function handleReset$1(e$2) {
		setValue("");
		focus();
		if (inputRef.current) resolveOnChange(inputRef.current, e$2, onChange);
	};
	var outOfRangeCls = isOutOfRange && "".concat(prefixCls, "-out-of-range");
	return /* @__PURE__ */ import_react.createElement(BaseInput_default, _extends({}, rest, {
		prefixCls,
		className: (0, import_classnames$136.default)(className, outOfRangeCls),
		handleReset,
		value: formatValue$1,
		focused,
		triggerFocus: focus,
		suffix: function getSuffix() {
			var hasMaxLength = Number(mergedMax) > 0;
			if (suffix || countConfig.show) {
				var dataCount = countConfig.showFormatter ? countConfig.showFormatter({
					value: formatValue$1,
					count: valueLength,
					maxLength: mergedMax
				}) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
				return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, countConfig.show && /* @__PURE__ */ import_react.createElement("span", {
					className: (0, import_classnames$136.default)("".concat(prefixCls, "-show-count-suffix"), _defineProperty({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.count),
					style: _objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.count)
				}, dataCount), suffix);
			}
			return null;
		}(),
		disabled,
		classes,
		classNames: classNames$252,
		styles,
		ref: holderRef
	}), function getInputElement() {
		var otherProps = omit(props, [
			"prefixCls",
			"onPressEnter",
			"addonBefore",
			"addonAfter",
			"prefix",
			"suffix",
			"allowClear",
			"defaultValue",
			"showCount",
			"count",
			"classes",
			"htmlSize",
			"styles",
			"classNames",
			"onClear"
		]);
		return /* @__PURE__ */ import_react.createElement("input", _extends({ autoComplete }, otherProps, {
			onChange: onInternalChange,
			onFocus: handleFocus,
			onBlur: handleBlur,
			onKeyDown: handleKeyDown,
			onKeyUp: handleKeyUp,
			className: (0, import_classnames$136.default)(prefixCls, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.input),
			style: styles === null || styles === void 0 ? void 0 : styles.input,
			ref: inputRef,
			size: htmlSize,
			type: type$2,
			onCompositionStart: function onCompositionStart(e$2) {
				compositionRef.current = true;
				_onCompositionStart === null || _onCompositionStart === void 0 || _onCompositionStart(e$2);
			},
			onCompositionEnd: onInternalCompositionEnd
		}));
	}());
});
var Input_default$1 = Input$2;

//#endregion
//#region node_modules/rc-input/es/index.js
var es_default$22 = Input_default$1;

//#endregion
//#region node_modules/rc-util/es/proxyObject.js
/**
* Proxy object if environment supported
*/
function proxyObject(obj, extendProps) {
	if (typeof Proxy !== "undefined" && obj) return new Proxy(obj, { get: function get$1(target, prop) {
		if (extendProps[prop]) return extendProps[prop];
		var originProp = target[prop];
		return typeof originProp === "function" ? originProp.bind(target) : originProp;
	} });
	return obj;
}

//#endregion
//#region node_modules/rc-input-number/es/hooks/useCursor.js
/**
* Keep input cursor in the correct position if possible.
* Is this necessary since we have `formatter` which may mass the content?
*/
function useCursor(input, focused) {
	var selectionRef = (0, import_react.useRef)(null);
	function recordCursor() {
		try {
			var start = input.selectionStart, end = input.selectionEnd, value = input.value;
			var beforeTxt = value.substring(0, start);
			var afterTxt = value.substring(end);
			selectionRef.current = {
				start,
				end,
				value,
				beforeTxt,
				afterTxt
			};
		} catch (e$2) {}
	}
	/**
	* Restore logic:
	*  1. back string same
	*  2. start string same
	*/
	function restoreCursor() {
		if (input && selectionRef.current && focused) try {
			var value = input.value;
			var _selectionRef$current = selectionRef.current, beforeTxt = _selectionRef$current.beforeTxt, afterTxt = _selectionRef$current.afterTxt, start = _selectionRef$current.start;
			var startPos = value.length;
			if (value.startsWith(beforeTxt)) startPos = beforeTxt.length;
			else if (value.endsWith(afterTxt)) startPos = value.length - selectionRef.current.afterTxt.length;
			else {
				var beforeLastChar = beforeTxt[start - 1];
				var newIndex = value.indexOf(beforeLastChar, start - 1);
				if (newIndex !== -1) startPos = newIndex + 1;
			}
			input.setSelectionRange(startPos, startPos);
		} catch (e$2) {
			warning_default(false, "Something warning of cursor restore. Please fire issue about this: ".concat(e$2.message));
		}
	}
	return [recordCursor, restoreCursor];
}

//#endregion
//#region node_modules/rc-util/es/hooks/useMobile.js
/**
* Hook to detect if the user is on a mobile device
* Notice that this hook will only detect the device type in effect, so it will always be false in server side
*/
var useMobile = function useMobile$1() {
	var _useState = (0, import_react.useState)(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
	useLayoutEffect_default(function() {
		setMobile(isMobile_default());
	}, []);
	return mobile;
};
var useMobile_default = useMobile;

//#endregion
//#region node_modules/rc-input-number/es/StepHandler.js
var import_classnames$135 = /* @__PURE__ */ __toESM(require_classnames());
/**
* When click and hold on a button - the speed of auto changing the value.
*/
var STEP_INTERVAL = 200;
/**
* When click and hold on a button - the delay before auto changing the value.
*/
var STEP_DELAY = 600;
function StepHandler(_ref) {
	var prefixCls = _ref.prefixCls, upNode = _ref.upNode, downNode = _ref.downNode, upDisabled = _ref.upDisabled, downDisabled = _ref.downDisabled, onStep = _ref.onStep;
	var stepTimeoutRef = import_react.useRef();
	var frameIds = import_react.useRef([]);
	var onStepRef = import_react.useRef();
	onStepRef.current = onStep;
	var onStopStep = function onStopStep$1() {
		clearTimeout(stepTimeoutRef.current);
	};
	var onStepMouseDown = function onStepMouseDown$1(e$2, up) {
		e$2.preventDefault();
		onStopStep();
		onStepRef.current(up);
		function loopStep() {
			onStepRef.current(up);
			stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
		}
		stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
	};
	import_react.useEffect(function() {
		return function() {
			onStopStep();
			frameIds.current.forEach(function(id) {
				return raf_default.cancel(id);
			});
		};
	}, []);
	if (useMobile_default()) return null;
	var handlerClassName = "".concat(prefixCls, "-handler");
	var upClassName = (0, import_classnames$135.default)(handlerClassName, "".concat(handlerClassName, "-up"), _defineProperty({}, "".concat(handlerClassName, "-up-disabled"), upDisabled));
	var downClassName = (0, import_classnames$135.default)(handlerClassName, "".concat(handlerClassName, "-down"), _defineProperty({}, "".concat(handlerClassName, "-down-disabled"), downDisabled));
	var safeOnStopStep = function safeOnStopStep$1() {
		return frameIds.current.push(raf_default(onStopStep));
	};
	var sharedHandlerProps = {
		unselectable: "on",
		role: "button",
		onMouseUp: safeOnStopStep,
		onMouseLeave: safeOnStopStep
	};
	return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(handlerClassName, "-wrap") }, /* @__PURE__ */ import_react.createElement("span", _extends({}, sharedHandlerProps, {
		onMouseDown: function onMouseDown(e$2) {
			onStepMouseDown(e$2, true);
		},
		"aria-label": "Increase Value",
		"aria-disabled": upDisabled,
		className: upClassName
	}), upNode || /* @__PURE__ */ import_react.createElement("span", {
		unselectable: "on",
		className: "".concat(prefixCls, "-handler-up-inner")
	})), /* @__PURE__ */ import_react.createElement("span", _extends({}, sharedHandlerProps, {
		onMouseDown: function onMouseDown(e$2) {
			onStepMouseDown(e$2, false);
		},
		"aria-label": "Decrease Value",
		"aria-disabled": downDisabled,
		className: downClassName
	}), downNode || /* @__PURE__ */ import_react.createElement("span", {
		unselectable: "on",
		className: "".concat(prefixCls, "-handler-down-inner")
	})));
}

//#endregion
//#region node_modules/rc-input-number/es/utils/numberUtil.js
function getDecupleSteps(step) {
	var stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
	if (!stepStr.includes(".")) return step + "0";
	return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
}

//#endregion
//#region node_modules/rc-input-number/es/hooks/useFrame.js
/**
* Always trigger latest once when call multiple time
*/
var useFrame_default = (function() {
	var idRef = (0, import_react.useRef)(0);
	var cleanUp = function cleanUp$1() {
		raf_default.cancel(idRef.current);
	};
	(0, import_react.useEffect)(function() {
		return cleanUp;
	}, []);
	return function(callback) {
		cleanUp();
		idRef.current = raf_default(function() {
			callback();
		});
	};
});

//#endregion
//#region node_modules/rc-input-number/es/InputNumber.js
var import_classnames$134 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$30 = [
	"prefixCls",
	"className",
	"style",
	"min",
	"max",
	"step",
	"defaultValue",
	"value",
	"disabled",
	"readOnly",
	"upHandler",
	"downHandler",
	"keyboard",
	"changeOnWheel",
	"controls",
	"classNames",
	"stringMode",
	"parser",
	"formatter",
	"precision",
	"decimalSeparator",
	"onChange",
	"onInput",
	"onPressEnter",
	"onStep",
	"changeOnBlur",
	"domRef"
], _excluded2$5 = [
	"disabled",
	"style",
	"prefixCls",
	"value",
	"prefix",
	"suffix",
	"addonBefore",
	"addonAfter",
	"className",
	"classNames"
];
/**
* We support `stringMode` which need handle correct type when user call in onChange
* format max or min value
* 1. if isInvalid return null
* 2. if precision is undefined, return decimal
* 3. format with precision
*    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3
*    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4
*    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4
*    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3
*/
var getDecimalValue = function getDecimalValue$1(stringMode, decimalValue) {
	if (stringMode || decimalValue.isEmpty()) return decimalValue.toString();
	return decimalValue.toNumber();
};
var getDecimalIfValidate = function getDecimalIfValidate$1(value) {
	var decimal = es_default$24(value);
	return decimal.isInvalidate() ? null : decimal;
};
var InternalInputNumber = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, className = props.className, style$1 = props.style, min = props.min, max = props.max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, defaultValue = props.defaultValue, value = props.value, disabled = props.disabled, readOnly = props.readOnly, upHandler = props.upHandler, downHandler = props.downHandler, keyboard = props.keyboard, _props$changeOnWheel = props.changeOnWheel, changeOnWheel = _props$changeOnWheel === void 0 ? false : _props$changeOnWheel, _props$controls = props.controls, controls = _props$controls === void 0 ? true : _props$controls;
	props.classNames;
	var stringMode = props.stringMode, parser = props.parser, formatter = props.formatter, precision = props.precision, decimalSeparator = props.decimalSeparator, onChange = props.onChange, onInput = props.onInput, onPressEnter = props.onPressEnter, onStep = props.onStep, _props$changeOnBlur = props.changeOnBlur, changeOnBlur = _props$changeOnBlur === void 0 ? true : _props$changeOnBlur, domRef = props.domRef, inputProps = _objectWithoutProperties(props, _excluded$30);
	var inputClassName = "".concat(prefixCls, "-input");
	var inputRef = import_react.useRef(null);
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focus = _React$useState2[0], setFocus = _React$useState2[1];
	var userTypingRef = import_react.useRef(false);
	var compositionRef = import_react.useRef(false);
	var shiftKeyRef = import_react.useRef(false);
	var _React$useState3 = import_react.useState(function() {
		return es_default$24(value !== null && value !== void 0 ? value : defaultValue);
	}), _React$useState4 = _slicedToArray(_React$useState3, 2), decimalValue = _React$useState4[0], setDecimalValue = _React$useState4[1];
	function setUncontrolledDecimalValue(newDecimal) {
		if (value === void 0) setDecimalValue(newDecimal);
	}
	/**
	* `precision` is used for formatter & onChange.
	* It will auto generate by `value` & `step`.
	* But it will not block user typing.
	*
	* Note: Auto generate `precision` is used for legacy logic.
	* We should remove this since we already support high precision with BigInt.
	*
	* @param number  Provide which number should calculate precision
	* @param userTyping  Change by user typing
	*/
	var getPrecision = import_react.useCallback(function(numStr, userTyping) {
		if (userTyping) return;
		if (precision >= 0) return precision;
		return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
	}, [precision, step]);
	var mergedParser = import_react.useCallback(function(num) {
		var numStr = String(num);
		if (parser) return parser(numStr);
		var parsedStr = numStr;
		if (decimalSeparator) parsedStr = parsedStr.replace(decimalSeparator, ".");
		return parsedStr.replace(/[^\w.-]+/g, "");
	}, [parser, decimalSeparator]);
	var inputValueRef = import_react.useRef("");
	var mergedFormatter = import_react.useCallback(function(number$1, userTyping) {
		if (formatter) return formatter(number$1, {
			userTyping,
			input: String(inputValueRef.current)
		});
		var str = typeof number$1 === "number" ? num2str(number$1) : number$1;
		if (!userTyping) {
			var mergedPrecision = getPrecision(str, userTyping);
			if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) str = toFixed(str, decimalSeparator || ".", mergedPrecision);
		}
		return str;
	}, [
		formatter,
		getPrecision,
		decimalSeparator
	]);
	/**
	* Input text value control
	*
	* User can not update input content directly. It updates with follow rules by priority:
	*  1. controlled `value` changed
	*    * [SPECIAL] Typing like `1.` should not immediately convert to `1`
	*  2. User typing with format (not precision)
	*  3. Blur or Enter trigger revalidate
	*/
	var _React$useState5 = import_react.useState(function() {
		var initValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : value;
		if (decimalValue.isInvalidate() && ["string", "number"].includes(_typeof(initValue))) return Number.isNaN(initValue) ? "" : initValue;
		return mergedFormatter(decimalValue.toString(), false);
	}), _React$useState6 = _slicedToArray(_React$useState5, 2), inputValue = _React$useState6[0], setInternalInputValue = _React$useState6[1];
	inputValueRef.current = inputValue;
	function setInputValue(newValue, userTyping) {
		setInternalInputValue(mergedFormatter(newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping));
	}
	var maxDecimal = import_react.useMemo(function() {
		return getDecimalIfValidate(max);
	}, [max, precision]);
	var minDecimal = import_react.useMemo(function() {
		return getDecimalIfValidate(min);
	}, [min, precision]);
	var upDisabled = import_react.useMemo(function() {
		if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) return false;
		return maxDecimal.lessEquals(decimalValue);
	}, [maxDecimal, decimalValue]);
	var downDisabled = import_react.useMemo(function() {
		if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) return false;
		return decimalValue.lessEquals(minDecimal);
	}, [minDecimal, decimalValue]);
	var _useCursor = useCursor(inputRef.current, focus), _useCursor2 = _slicedToArray(_useCursor, 2), recordCursor = _useCursor2[0], restoreCursor = _useCursor2[1];
	/**
	* Find target value closet within range.
	* e.g. [11, 28]:
	*    3  => 11
	*    23 => 23
	*    99 => 28
	*/
	var getRangeValue = function getRangeValue$1(target) {
		if (maxDecimal && !target.lessEquals(maxDecimal)) return maxDecimal;
		if (minDecimal && !minDecimal.lessEquals(target)) return minDecimal;
		return null;
	};
	/**
	* Check value is in [min, max] range
	*/
	var isInRange$1 = function isInRange$2(target) {
		return !getRangeValue(target);
	};
	/**
	* Trigger `onChange` if value validated and not equals of origin.
	* Return the value that re-align in range.
	*/
	var triggerValueUpdate = function triggerValueUpdate$1(newValue, userTyping) {
		var updateValue = newValue;
		var isRangeValidate = isInRange$1(updateValue) || updateValue.isEmpty();
		if (!updateValue.isEmpty() && !userTyping) {
			updateValue = getRangeValue(updateValue) || updateValue;
			isRangeValidate = true;
		}
		if (!readOnly && !disabled && isRangeValidate) {
			var numStr = updateValue.toString();
			var mergedPrecision = getPrecision(numStr, userTyping);
			if (mergedPrecision >= 0) {
				updateValue = es_default$24(toFixed(numStr, ".", mergedPrecision));
				if (!isInRange$1(updateValue)) updateValue = es_default$24(toFixed(numStr, ".", mergedPrecision, true));
			}
			if (!updateValue.equals(decimalValue)) {
				setUncontrolledDecimalValue(updateValue);
				onChange === null || onChange === void 0 || onChange(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
				if (value === void 0) setInputValue(updateValue, userTyping);
			}
			return updateValue;
		}
		return decimalValue;
	};
	var onNextPromise = useFrame_default();
	var collectInputValue = function collectInputValue$1(inputStr) {
		recordCursor();
		inputValueRef.current = inputStr;
		setInternalInputValue(inputStr);
		if (!compositionRef.current) {
			var finalValue = mergedParser(inputStr);
			var finalDecimal = es_default$24(finalValue);
			if (!finalDecimal.isNaN()) triggerValueUpdate(finalDecimal, true);
		}
		onInput === null || onInput === void 0 || onInput(inputStr);
		onNextPromise(function() {
			var nextInputStr = inputStr;
			if (!parser) nextInputStr = inputStr.replace(//g, ".");
			if (nextInputStr !== inputStr) collectInputValue$1(nextInputStr);
		});
	};
	var onCompositionStart = function onCompositionStart$1() {
		compositionRef.current = true;
	};
	var onCompositionEnd = function onCompositionEnd$1() {
		compositionRef.current = false;
		collectInputValue(inputRef.current.value);
	};
	var onInternalInput = function onInternalInput$1(e$2) {
		collectInputValue(e$2.target.value);
	};
	var onInternalStep = function onInternalStep$1(up) {
		var _inputRef$current;
		if (up && upDisabled || !up && downDisabled) return;
		userTypingRef.current = false;
		var stepDecimal = es_default$24(shiftKeyRef.current ? getDecupleSteps(step) : step);
		if (!up) stepDecimal = stepDecimal.negate();
		var target = (decimalValue || es_default$24(0)).add(stepDecimal.toString());
		var updatedValue = triggerValueUpdate(target, false);
		onStep === null || onStep === void 0 || onStep(getDecimalValue(stringMode, updatedValue), {
			offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
			type: up ? "up" : "down"
		});
		(_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
	};
	/**
	* Flush current input content to trigger value change & re-formatter input if needed.
	* This will always flush input value for update.
	* If it's invalidate, will fallback to last validate value.
	*/
	var flushInputValue = function flushInputValue$1(userTyping) {
		var parsedValue = es_default$24(mergedParser(inputValue));
		var formatValue$1;
		if (!parsedValue.isNaN()) formatValue$1 = triggerValueUpdate(parsedValue, userTyping);
		else formatValue$1 = triggerValueUpdate(decimalValue, userTyping);
		if (value !== void 0) setInputValue(decimalValue, false);
		else if (!formatValue$1.isNaN()) setInputValue(formatValue$1, false);
	};
	var onBeforeInput = function onBeforeInput$1() {
		userTypingRef.current = true;
	};
	var onKeyDown$1 = function onKeyDown$2(event) {
		var key = event.key, shiftKey = event.shiftKey;
		userTypingRef.current = true;
		shiftKeyRef.current = shiftKey;
		if (key === "Enter") {
			if (!compositionRef.current) userTypingRef.current = false;
			flushInputValue(false);
			onPressEnter === null || onPressEnter === void 0 || onPressEnter(event);
		}
		if (keyboard === false) return;
		if (!compositionRef.current && [
			"Up",
			"ArrowUp",
			"Down",
			"ArrowDown"
		].includes(key)) {
			onInternalStep(key === "Up" || key === "ArrowUp");
			event.preventDefault();
		}
	};
	var onKeyUp = function onKeyUp$1() {
		userTypingRef.current = false;
		shiftKeyRef.current = false;
	};
	import_react.useEffect(function() {
		if (changeOnWheel && focus) {
			var onWheel = function onWheel$1(event) {
				onInternalStep(event.deltaY < 0);
				event.preventDefault();
			};
			var input = inputRef.current;
			if (input) {
				input.addEventListener("wheel", onWheel, { passive: false });
				return function() {
					return input.removeEventListener("wheel", onWheel);
				};
			}
		}
	});
	var onBlur = function onBlur$1() {
		if (changeOnBlur) flushInputValue(false);
		setFocus(false);
		userTypingRef.current = false;
	};
	useLayoutUpdateEffect(function() {
		if (!decimalValue.isInvalidate()) setInputValue(decimalValue, false);
	}, [precision, formatter]);
	useLayoutUpdateEffect(function() {
		var newValue = es_default$24(value);
		setDecimalValue(newValue);
		var currentParsedValue = es_default$24(mergedParser(inputValue));
		if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) setInputValue(newValue, userTypingRef.current);
	}, [value]);
	useLayoutUpdateEffect(function() {
		if (formatter) restoreCursor();
	}, [inputValue]);
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: domRef,
		className: (0, import_classnames$134.default)(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-focused"), focus), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-readonly"), readOnly), "".concat(prefixCls, "-not-a-number"), decimalValue.isNaN()), "".concat(prefixCls, "-out-of-range"), !decimalValue.isInvalidate() && !isInRange$1(decimalValue))),
		style: style$1,
		onFocus: function onFocus() {
			setFocus(true);
		},
		onBlur,
		onKeyDown: onKeyDown$1,
		onKeyUp,
		onCompositionStart,
		onCompositionEnd,
		onBeforeInput
	}, controls && /* @__PURE__ */ import_react.createElement(StepHandler, {
		prefixCls,
		upNode: upHandler,
		downNode: downHandler,
		upDisabled,
		downDisabled,
		onStep: onInternalStep
	}), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(inputClassName, "-wrap") }, /* @__PURE__ */ import_react.createElement("input", _extends({
		autoComplete: "off",
		role: "spinbutton",
		"aria-valuemin": min,
		"aria-valuemax": max,
		"aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
		step
	}, inputProps, {
		ref: composeRef(inputRef, ref),
		className: inputClassName,
		value: inputValue,
		onChange: onInternalInput,
		disabled,
		readOnly
	}))));
});
var InputNumber$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var disabled = props.disabled, style$1 = props.style, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input-number" : _props$prefixCls, value = props.value, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, classNames$252 = props.classNames, rest = _objectWithoutProperties(props, _excluded2$5);
	var holderRef = import_react.useRef(null);
	var inputNumberDomRef = import_react.useRef(null);
	var inputFocusRef = import_react.useRef(null);
	var focus = function focus$1(option) {
		if (inputFocusRef.current) triggerFocus(inputFocusRef.current, option);
	};
	import_react.useImperativeHandle(ref, function() {
		return proxyObject(inputFocusRef.current, {
			focus,
			nativeElement: holderRef.current.nativeElement || inputNumberDomRef.current
		});
	});
	return /* @__PURE__ */ import_react.createElement(BaseInput_default, {
		className,
		triggerFocus: focus,
		prefixCls,
		value,
		disabled,
		style: style$1,
		prefix,
		suffix,
		addonAfter,
		addonBefore,
		classNames: classNames$252,
		components: {
			affixWrapper: "div",
			groupWrapper: "div",
			wrapper: "div",
			groupAddon: "div"
		},
		ref: holderRef
	}, /* @__PURE__ */ import_react.createElement(InternalInputNumber, _extends({
		prefixCls,
		disabled,
		ref: inputFocusRef,
		domRef: inputNumberDomRef,
		className: classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.input
	}, rest)));
});
InputNumber$1.displayName = "InputNumber";
var InputNumber_default = InputNumber$1;

//#endregion
//#region node_modules/rc-input-number/es/index.js
var es_default$23 = InputNumber_default;

//#endregion
//#region node_modules/antd/es/input-number/style/token.js
const prepareComponentToken$28 = (token$1) => {
	var _a;
	const handleVisible = (_a = token$1.handleVisible) !== null && _a !== void 0 ? _a : "auto";
	const handleWidth = token$1.controlHeightSM - token$1.lineWidth * 2;
	return Object.assign(Object.assign({}, initComponentToken$1(token$1)), {
		controlWidth: 90,
		handleWidth,
		handleFontSize: token$1.fontSize / 2,
		handleVisible,
		handleActiveBg: token$1.colorFillAlter,
		handleBg: token$1.colorBgContainer,
		filledHandleBg: new FastColor(token$1.colorFillSecondary).onBackground(token$1.colorBgContainer).toHexString(),
		handleHoverColor: token$1.colorPrimary,
		handleBorderColor: token$1.colorBorder,
		handleOpacity: handleVisible === true ? 1 : 0,
		handleVisibleWidth: handleVisible === true ? handleWidth : 0
	});
};

//#endregion
//#region node_modules/antd/es/input-number/style/index.js
const genRadiusStyle$1 = ({ componentCls, borderRadiusSM, borderRadiusLG }, size) => {
	const borderRadius = size === "lg" ? borderRadiusLG : borderRadiusSM;
	return { [`&-${size}`]: {
		[`${componentCls}-handler-wrap`]: {
			borderStartEndRadius: borderRadius,
			borderEndEndRadius: borderRadius
		},
		[`${componentCls}-handler-up`]: { borderStartEndRadius: borderRadius },
		[`${componentCls}-handler-down`]: { borderEndEndRadius: borderRadius }
	} };
};
var genInputNumberStyles = (token$1) => {
	const { componentCls, lineWidth, lineType, borderRadius, inputFontSizeSM, inputFontSizeLG, controlHeightLG, controlHeightSM, colorError, paddingInlineSM, paddingBlockSM, paddingBlockLG, paddingInlineLG, colorIcon, motionDurationMid, handleHoverColor, handleOpacity, paddingInline, paddingBlock, handleBg, handleActiveBg, colorTextDisabled, borderRadiusSM, borderRadiusLG, controlWidth, handleBorderColor, filledHandleBg, lineHeightLG, calc } = token$1;
	return [{ [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), genBasicInputStyle(token$1)), {
		display: "inline-block",
		width: controlWidth,
		margin: 0,
		padding: 0,
		borderRadius
	}), genOutlinedStyle(token$1, { [`${componentCls}-handler-wrap`]: {
		background: handleBg,
		[`${componentCls}-handler-down`]: { borderBlockStart: `${unit(lineWidth)} ${lineType} ${handleBorderColor}` }
	} })), genFilledStyle(token$1, {
		[`${componentCls}-handler-wrap`]: {
			background: filledHandleBg,
			[`${componentCls}-handler-down`]: { borderBlockStart: `${unit(lineWidth)} ${lineType} ${handleBorderColor}` }
		},
		"&:focus-within": { [`${componentCls}-handler-wrap`]: { background: handleBg } }
	})), genUnderlinedStyle(token$1, { [`${componentCls}-handler-wrap`]: {
		background: handleBg,
		[`${componentCls}-handler-down`]: { borderBlockStart: `${unit(lineWidth)} ${lineType} ${handleBorderColor}` }
	} })), genBorderlessStyle(token$1)), {
		"&-rtl": {
			direction: "rtl",
			[`${componentCls}-input`]: { direction: "rtl" }
		},
		"&-lg": {
			padding: 0,
			fontSize: inputFontSizeLG,
			lineHeight: lineHeightLG,
			borderRadius: borderRadiusLG,
			[`input${componentCls}-input`]: {
				height: calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal(),
				padding: `${unit(paddingBlockLG)} ${unit(paddingInlineLG)}`
			}
		},
		"&-sm": {
			padding: 0,
			fontSize: inputFontSizeSM,
			borderRadius: borderRadiusSM,
			[`input${componentCls}-input`]: {
				height: calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal(),
				padding: `${unit(paddingBlockSM)} ${unit(paddingInlineSM)}`
			}
		},
		"&-out-of-range": { [`${componentCls}-input-wrap`]: { input: { color: colorError } } },
		"&-group": Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), genInputGroupStyle(token$1)), { "&-wrapper": Object.assign(Object.assign(Object.assign({
			display: "inline-block",
			textAlign: "start",
			verticalAlign: "top",
			[`${componentCls}-affix-wrapper`]: { width: "100%" },
			"&-lg": { [`${componentCls}-group-addon`]: {
				borderRadius: borderRadiusLG,
				fontSize: token$1.fontSizeLG
			} },
			"&-sm": { [`${componentCls}-group-addon`]: { borderRadius: borderRadiusSM } }
		}, genOutlinedGroupStyle(token$1)), genFilledGroupStyle(token$1)), {
			[`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: { borderRadius: 0 } },
			[`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: {
				borderStartEndRadius: 0,
				borderEndEndRadius: 0
			} },
			[`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: { [`${componentCls}, ${componentCls}-group-addon`]: {
				borderStartStartRadius: 0,
				borderEndStartRadius: 0
			} }
		}) }),
		[`&-disabled ${componentCls}-input`]: { cursor: "not-allowed" },
		[componentCls]: { "&-input": Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
			width: "100%",
			padding: `${unit(paddingBlock)} ${unit(paddingInline)}`,
			textAlign: "start",
			backgroundColor: "transparent",
			border: 0,
			borderRadius,
			outline: 0,
			transition: `all ${motionDurationMid} linear`,
			appearance: "textfield",
			fontSize: "inherit"
		}), genPlaceholderStyle(token$1.colorTextPlaceholder)), { "&[type=\"number\"]::-webkit-inner-spin-button, &[type=\"number\"]::-webkit-outer-spin-button": {
			margin: 0,
			appearance: "none"
		} }) },
		[`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
			width: token$1.handleWidth,
			opacity: 1
		}
	}) }, { [componentCls]: Object.assign(Object.assign(Object.assign({
		[`${componentCls}-handler-wrap`]: {
			position: "absolute",
			insetBlockStart: 0,
			insetInlineEnd: 0,
			width: token$1.handleVisibleWidth,
			opacity: handleOpacity,
			height: "100%",
			borderStartStartRadius: 0,
			borderStartEndRadius: borderRadius,
			borderEndEndRadius: borderRadius,
			borderEndStartRadius: 0,
			display: "flex",
			flexDirection: "column",
			alignItems: "stretch",
			transition: `all ${motionDurationMid}`,
			overflow: "hidden",
			[`${componentCls}-handler`]: {
				display: "flex",
				alignItems: "center",
				justifyContent: "center",
				flex: "auto",
				height: "40%",
				[`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
					marginInlineEnd: 0,
					fontSize: token$1.handleFontSize
				}
			}
		},
		[`${componentCls}-handler`]: {
			height: "50%",
			overflow: "hidden",
			color: colorIcon,
			fontWeight: "bold",
			lineHeight: 0,
			textAlign: "center",
			cursor: "pointer",
			borderInlineStart: `${unit(lineWidth)} ${lineType} ${handleBorderColor}`,
			transition: `all ${motionDurationMid} linear`,
			"&:active": { background: handleActiveBg },
			"&:hover": {
				height: `60%`,
				[`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: { color: handleHoverColor }
			},
			"&-up-inner, &-down-inner": Object.assign(Object.assign({}, resetIcon()), {
				color: colorIcon,
				transition: `all ${motionDurationMid} linear`,
				userSelect: "none"
			})
		},
		[`${componentCls}-handler-up`]: { borderStartEndRadius: borderRadius },
		[`${componentCls}-handler-down`]: { borderEndEndRadius: borderRadius }
	}, genRadiusStyle$1(token$1, "lg")), genRadiusStyle$1(token$1, "sm")), {
		"&-disabled, &-readonly": {
			[`${componentCls}-handler-wrap`]: { display: "none" },
			[`${componentCls}-input`]: { color: "inherit" }
		},
		[`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: { cursor: "not-allowed" },
		[`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: { color: colorTextDisabled }
	}) }];
};
var genAffixWrapperStyles = (token$1) => {
	const { componentCls, paddingBlock, paddingInline, inputAffixPadding, controlWidth, borderRadiusLG, borderRadiusSM, paddingInlineLG, paddingInlineSM, paddingBlockLG, paddingBlockSM, motionDurationMid } = token$1;
	return {
		[`${componentCls}-affix-wrapper`]: Object.assign(Object.assign({ [`input${componentCls}-input`]: { padding: `${unit(paddingBlock)} 0` } }, genBasicInputStyle(token$1)), {
			position: "relative",
			display: "inline-flex",
			alignItems: "center",
			width: controlWidth,
			padding: 0,
			paddingInlineStart: paddingInline,
			"&-lg": {
				borderRadius: borderRadiusLG,
				paddingInlineStart: paddingInlineLG,
				[`input${componentCls}-input`]: { padding: `${unit(paddingBlockLG)} 0` }
			},
			"&-sm": {
				borderRadius: borderRadiusSM,
				paddingInlineStart: paddingInlineSM,
				[`input${componentCls}-input`]: { padding: `${unit(paddingBlockSM)} 0` }
			},
			[`&:not(${componentCls}-disabled):hover`]: { zIndex: 1 },
			"&-focused, &:focus": { zIndex: 1 },
			[`&-disabled > ${componentCls}-disabled`]: { background: "transparent" },
			[`> div${componentCls}`]: {
				width: "100%",
				border: "none",
				outline: "none",
				[`&${componentCls}-focused`]: { boxShadow: "none !important" }
			},
			"&::before": {
				display: "inline-block",
				width: 0,
				visibility: "hidden",
				content: "\"\\a0\""
			},
			[`${componentCls}-handler-wrap`]: { zIndex: 2 },
			[componentCls]: {
				position: "static",
				color: "inherit",
				"&-prefix, &-suffix": {
					display: "flex",
					flex: "none",
					alignItems: "center",
					pointerEvents: "none"
				},
				"&-prefix": { marginInlineEnd: inputAffixPadding },
				"&-suffix": {
					insetBlockStart: 0,
					insetInlineEnd: 0,
					height: "100%",
					marginInlineEnd: paddingInline,
					marginInlineStart: inputAffixPadding,
					transition: `margin ${motionDurationMid}`
				}
			},
			[`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
				width: token$1.handleWidth,
				opacity: 1
			},
			[`&:not(${componentCls}-affix-wrapper-without-controls):hover ${componentCls}-suffix`]: { marginInlineEnd: token$1.calc(token$1.handleWidth).add(paddingInline).equal() }
		}),
		[`${componentCls}-underlined`]: { borderRadius: 0 }
	};
};
var style_default$35 = genStyleHooks("InputNumber", (token$1) => {
	const inputNumberToken = merge(token$1, initInputToken(token$1));
	return [
		genInputNumberStyles(inputNumberToken),
		genAffixWrapperStyles(inputNumberToken),
		genCompactItemStyle(inputNumberToken)
	];
}, prepareComponentToken$28, {
	unitless: { handleOpacity: true },
	resetFont: false
});

//#endregion
//#region node_modules/antd/es/input-number/index.js
var import_classnames$133 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$67 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var InputNumber = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	{
		const typeWarning = devUseWarning("InputNumber");
		typeWarning.deprecated(!("bordered" in props), "bordered", "variant");
		typeWarning(!(props.type === "number" && props.changeOnWheel), "usage", "When `type=number` is used together with `changeOnWheel`, changeOnWheel may not work properly. Please delete `type=number` if it is not necessary.");
	}
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const inputRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => inputRef.current);
	const { className, rootClassName, size: customizeSize, disabled: customDisabled, prefixCls: customizePrefixCls, addonBefore, addonAfter, prefix, suffix, bordered, readOnly, status: customStatus, controls, variant: customVariant } = props, others = __rest$67(props, [
		"className",
		"rootClassName",
		"size",
		"disabled",
		"prefixCls",
		"addonBefore",
		"addonAfter",
		"prefix",
		"suffix",
		"bordered",
		"readOnly",
		"status",
		"controls",
		"variant"
	]);
	const prefixCls = getPrefixCls("input-number", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$35(prefixCls, rootCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	let upIcon = /* @__PURE__ */ import_react.createElement(UpOutlined_default, { className: `${prefixCls}-handler-up-inner` });
	let downIcon = /* @__PURE__ */ import_react.createElement(DownOutlined_default, { className: `${prefixCls}-handler-down-inner` });
	const controlsTemp = typeof controls === "boolean" ? controls : void 0;
	if (typeof controls === "object") {
		upIcon = typeof controls.upIcon === "undefined" ? upIcon : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-handler-up-inner` }, controls.upIcon);
		downIcon = typeof controls.downIcon === "undefined" ? downIcon : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-handler-down-inner` }, controls.downIcon);
	}
	const { hasFeedback, status: contextStatus, isFormItemInput, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const mergedSize = useSize_default((ctx) => {
		var _a;
		return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
	});
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const [variant, enableVariantCls] = useVariants_default("inputNumber", customVariant, bordered);
	const suffixNode = hasFeedback && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, feedbackIcon);
	const inputNumberClass = (0, import_classnames$133.default)({
		[`${prefixCls}-lg`]: mergedSize === "large",
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-in-form-item`]: isFormItemInput
	}, hashId);
	const wrapperClassName = `${prefixCls}-group`;
	const element = /* @__PURE__ */ import_react.createElement(es_default$23, Object.assign({
		ref: inputRef,
		disabled: mergedDisabled,
		className: (0, import_classnames$133.default)(cssVarCls, rootCls, className, rootClassName, compactItemClassnames),
		upHandler: upIcon,
		downHandler: downIcon,
		prefixCls,
		readOnly,
		controls: controlsTemp,
		prefix,
		suffix: suffixNode || suffix,
		addonBefore: addonBefore && /* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
			form: true,
			space: true
		}, addonBefore),
		addonAfter: addonAfter && /* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
			form: true,
			space: true
		}, addonAfter),
		classNames: {
			input: inputNumberClass,
			variant: (0, import_classnames$133.default)({ [`${prefixCls}-${variant}`]: enableVariantCls }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback)),
			affixWrapper: (0, import_classnames$133.default)({
				[`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
				[`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
				[`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
				[`${prefixCls}-affix-wrapper-without-controls`]: controls === false || mergedDisabled || readOnly
			}, hashId),
			wrapper: (0, import_classnames$133.default)({ [`${wrapperClassName}-rtl`]: direction === "rtl" }, hashId),
			groupWrapper: (0, import_classnames$133.default)({
				[`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
				[`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
				[`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
				[`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
			}, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
		}
	}, others));
	return wrapCSSVar(element);
});
var TypedInputNumber = InputNumber;
/** @private Internal Component. Do not use in your production. */
var PureInputNumber = (props) => /* @__PURE__ */ import_react.createElement(config_provider_default, { theme: { components: { InputNumber: { handleVisible: true } } } }, /* @__PURE__ */ import_react.createElement(InputNumber, Object.assign({}, props)));
TypedInputNumber.displayName = "InputNumber";
TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
var input_number_default = TypedInputNumber;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorSteppers.js
var import_classnames$132 = /* @__PURE__ */ __toESM(require_classnames());
var ColorSteppers = ({ prefixCls, min = 0, max = 100, value, onChange, className, formatter }) => {
	const colorSteppersPrefixCls = `${prefixCls}-steppers`;
	const [internalValue, setInternalValue] = (0, import_react.useState)(0);
	const stepValue = !Number.isNaN(value) ? value : internalValue;
	return /* @__PURE__ */ import_react.createElement(input_number_default, {
		className: (0, import_classnames$132.default)(colorSteppersPrefixCls, className),
		min,
		max,
		value: stepValue,
		formatter,
		size: "small",
		onChange: (step) => {
			setInternalValue(step || 0);
			onChange === null || onChange === void 0 || onChange(step);
		}
	});
};
var ColorSteppers_default = ColorSteppers;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorAlphaInput.js
var ColorAlphaInput = ({ prefixCls, value, onChange }) => {
	const colorAlphaInputPrefixCls = `${prefixCls}-alpha-input`;
	const [internalValue, setInternalValue] = (0, import_react.useState)(() => generateColor(value || "#000"));
	const alphaValue = value || internalValue;
	const handleAlphaChange = (step) => {
		const hsba = alphaValue.toHsb();
		hsba.a = (step || 0) / 100;
		const genColor = generateColor(hsba);
		setInternalValue(genColor);
		onChange === null || onChange === void 0 || onChange(genColor);
	};
	return /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		value: getColorAlpha(alphaValue),
		prefixCls,
		formatter: (step) => `${step}%`,
		className: colorAlphaInputPrefixCls,
		onChange: handleAlphaChange
	});
};
var ColorAlphaInput_default = ColorAlphaInput;

//#endregion
//#region node_modules/antd/es/_util/getAllowClear.js
var getAllowClear = (allowClear) => {
	let mergedAllowClear;
	if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) mergedAllowClear = allowClear;
	else if (allowClear) mergedAllowClear = { clearIcon: /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null) };
	return mergedAllowClear;
};
var getAllowClear_default = getAllowClear;

//#endregion
//#region node_modules/antd/es/input/hooks/useRemovePasswordTimeout.js
function useRemovePasswordTimeout(inputRef, triggerOnMount) {
	const removePasswordTimeoutRef = (0, import_react.useRef)([]);
	const removePasswordTimeout = () => {
		removePasswordTimeoutRef.current.push(setTimeout(() => {
			var _a, _b, _c, _d;
			if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) (_d = inputRef.current) === null || _d === void 0 || _d.input.removeAttribute("value");
		}));
	};
	(0, import_react.useEffect)(() => {
		if (triggerOnMount) removePasswordTimeout();
		return () => removePasswordTimeoutRef.current.forEach((timer) => {
			if (timer) clearTimeout(timer);
		});
	}, []);
	return removePasswordTimeout;
}

//#endregion
//#region node_modules/antd/es/input/utils.js
function hasPrefixSuffix(props) {
	return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
}

//#endregion
//#region node_modules/antd/es/input/Input.js
var import_classnames$131 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$66 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Input$1 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls: customizePrefixCls, bordered = true, status: customStatus, size: customSize, disabled: customDisabled, onBlur, onFocus, suffix, allowClear, addonAfter, addonBefore, className, style: style$1, styles, rootClassName, onChange, classNames: classNames$252, variant: customVariant } = props, rest = __rest$66(props, [
		"prefixCls",
		"bordered",
		"status",
		"size",
		"disabled",
		"onBlur",
		"onFocus",
		"suffix",
		"allowClear",
		"addonAfter",
		"addonBefore",
		"className",
		"style",
		"styles",
		"rootClassName",
		"onChange",
		"classNames",
		"variant"
	]);
	{
		const { deprecated } = devUseWarning("Input");
		deprecated(!("bordered" in props), "bordered", "variant");
	}
	const { getPrefixCls, direction, allowClear: contextAllowClear, autoComplete: contextAutoComplete, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("input");
	const prefixCls = getPrefixCls("input", customizePrefixCls);
	const inputRef = (0, import_react.useRef)(null);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapSharedCSSVar, hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
	const [wrapCSSVar] = style_default$24(prefixCls, rootCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const mergedSize = useSize_default((ctx) => {
		var _a;
		return (_a = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
	});
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const { status: contextStatus, hasFeedback, feedbackIcon } = (0, import_react.useContext)(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
	const prevHasPrefixSuffix = (0, import_react.useRef)(inputHasPrefixSuffix);
	{
		const warning$4 = devUseWarning("Input");
		(0, import_react.useEffect)(() => {
			var _a;
			if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current) warning$4(document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input), "usage", `When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ`);
			prevHasPrefixSuffix.current = inputHasPrefixSuffix;
		}, [inputHasPrefixSuffix]);
	}
	const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
	const handleBlur = (e$2) => {
		removePasswordTimeout();
		onBlur === null || onBlur === void 0 || onBlur(e$2);
	};
	const handleFocus = (e$2) => {
		removePasswordTimeout();
		onFocus === null || onFocus === void 0 || onFocus(e$2);
	};
	const handleChange = (e$2) => {
		removePasswordTimeout();
		onChange === null || onChange === void 0 || onChange(e$2);
	};
	const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, suffix, hasFeedback && feedbackIcon);
	const mergedAllowClear = getAllowClear_default(allowClear !== null && allowClear !== void 0 ? allowClear : contextAllowClear);
	const [variant, enableVariantCls] = useVariants_default("input", customVariant, bordered);
	return wrapSharedCSSVar(wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$22, Object.assign({
		ref: composeRef(ref, inputRef),
		prefixCls,
		autoComplete: contextAutoComplete
	}, rest, {
		disabled: mergedDisabled,
		onBlur: handleBlur,
		onFocus: handleFocus,
		style: Object.assign(Object.assign({}, contextStyle), style$1),
		styles: Object.assign(Object.assign({}, contextStyles), styles),
		suffix: suffixNode,
		allowClear: mergedAllowClear,
		className: (0, import_classnames$131.default)(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, contextClassName),
		onChange: handleChange,
		addonBefore: addonBefore && /* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
			form: true,
			space: true
		}, addonBefore),
		addonAfter: addonAfter && /* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
			form: true,
			space: true
		}, addonAfter),
		classNames: Object.assign(Object.assign(Object.assign({}, classNames$252), contextClassNames), {
			input: (0, import_classnames$131.default)({
				[`${prefixCls}-sm`]: mergedSize === "small",
				[`${prefixCls}-lg`]: mergedSize === "large",
				[`${prefixCls}-rtl`]: direction === "rtl"
			}, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.input, contextClassNames.input, hashId),
			variant: (0, import_classnames$131.default)({ [`${prefixCls}-${variant}`]: enableVariantCls }, getStatusClassNames(prefixCls, mergedStatus)),
			affixWrapper: (0, import_classnames$131.default)({
				[`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
				[`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
				[`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
			}, hashId),
			wrapper: (0, import_classnames$131.default)({ [`${prefixCls}-group-rtl`]: direction === "rtl" }, hashId),
			groupWrapper: (0, import_classnames$131.default)({
				[`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
				[`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
				[`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
				[`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
			}, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
		})
	}))));
});
Input$1.displayName = "Input";
var Input_default = Input$1;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorHexInput.js
var hexReg = /(^#[\da-f]{6}$)|(^#[\da-f]{8}$)/i;
var isHexString = (hex) => hexReg.test(`#${hex}`);
var ColorHexInput = ({ prefixCls, value, onChange }) => {
	const colorHexInputPrefixCls = `${prefixCls}-hex-input`;
	const [hexValue, setHexValue] = (0, import_react.useState)(() => value ? toHexFormat(value.toHexString()) : void 0);
	(0, import_react.useEffect)(() => {
		if (value) setHexValue(toHexFormat(value.toHexString()));
	}, [value]);
	const handleHexChange = (e$2) => {
		const originValue = e$2.target.value;
		setHexValue(toHexFormat(originValue));
		if (isHexString(toHexFormat(originValue, true))) onChange === null || onChange === void 0 || onChange(generateColor(originValue));
	};
	return /* @__PURE__ */ import_react.createElement(Input_default, {
		className: colorHexInputPrefixCls,
		value: hexValue,
		prefix: "#",
		onChange: handleHexChange,
		size: "small"
	});
};
var ColorHexInput_default = ColorHexInput;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorHsbInput.js
var ColorHsbInput = ({ prefixCls, value, onChange }) => {
	const colorHsbInputPrefixCls = `${prefixCls}-hsb-input`;
	const [internalValue, setInternalValue] = (0, import_react.useState)(() => generateColor(value || "#000"));
	const hsbValue = value || internalValue;
	const handleHsbChange = (step, type$2) => {
		const hsb = hsbValue.toHsb();
		hsb[type$2] = type$2 === "h" ? step : (step || 0) / 100;
		const genColor = generateColor(hsb);
		setInternalValue(genColor);
		onChange === null || onChange === void 0 || onChange(genColor);
	};
	return /* @__PURE__ */ import_react.createElement("div", { className: colorHsbInputPrefixCls }, /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 360,
		min: 0,
		value: Number(hsbValue.toHsb().h),
		prefixCls,
		className: colorHsbInputPrefixCls,
		formatter: (step) => getRoundNumber(step || 0).toString(),
		onChange: (step) => handleHsbChange(Number(step), "h")
	}), /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 100,
		min: 0,
		value: Number(hsbValue.toHsb().s) * 100,
		prefixCls,
		className: colorHsbInputPrefixCls,
		formatter: (step) => `${getRoundNumber(step || 0)}%`,
		onChange: (step) => handleHsbChange(Number(step), "s")
	}), /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 100,
		min: 0,
		value: Number(hsbValue.toHsb().b) * 100,
		prefixCls,
		className: colorHsbInputPrefixCls,
		formatter: (step) => `${getRoundNumber(step || 0)}%`,
		onChange: (step) => handleHsbChange(Number(step), "b")
	}));
};
var ColorHsbInput_default = ColorHsbInput;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorRgbInput.js
var ColorRgbInput = ({ prefixCls, value, onChange }) => {
	const colorRgbInputPrefixCls = `${prefixCls}-rgb-input`;
	const [internalValue, setInternalValue] = (0, import_react.useState)(() => generateColor(value || "#000"));
	const rgbValue = value || internalValue;
	const handleRgbChange = (step, type$2) => {
		const rgb = rgbValue.toRgb();
		rgb[type$2] = step || 0;
		const genColor = generateColor(rgb);
		setInternalValue(genColor);
		onChange === null || onChange === void 0 || onChange(genColor);
	};
	return /* @__PURE__ */ import_react.createElement("div", { className: colorRgbInputPrefixCls }, /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 255,
		min: 0,
		value: Number(rgbValue.toRgb().r),
		prefixCls,
		className: colorRgbInputPrefixCls,
		onChange: (step) => handleRgbChange(Number(step), "r")
	}), /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 255,
		min: 0,
		value: Number(rgbValue.toRgb().g),
		prefixCls,
		className: colorRgbInputPrefixCls,
		onChange: (step) => handleRgbChange(Number(step), "g")
	}), /* @__PURE__ */ import_react.createElement(ColorSteppers_default, {
		max: 255,
		min: 0,
		value: Number(rgbValue.toRgb().b),
		prefixCls,
		className: colorRgbInputPrefixCls,
		onChange: (step) => handleRgbChange(Number(step), "b")
	}));
};
var ColorRgbInput_default = ColorRgbInput;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorInput.js
var selectOptions = [
	FORMAT_HEX,
	FORMAT_HSB,
	FORMAT_RGB
].map((format$2) => ({
	value: format$2,
	label: format$2.toUpperCase()
}));
var ColorInput = (props) => {
	const { prefixCls, format: format$2, value, disabledAlpha, onFormatChange, onChange, disabledFormat } = props;
	const [colorFormat, setColorFormat] = useMergedState(FORMAT_HEX, {
		value: format$2,
		onChange: onFormatChange
	});
	const colorInputPrefixCls = `${prefixCls}-input`;
	const handleFormatChange = (newFormat) => {
		setColorFormat(newFormat);
	};
	const steppersNode = (0, import_react.useMemo)(() => {
		const inputProps = {
			value,
			prefixCls,
			onChange
		};
		switch (colorFormat) {
			case FORMAT_HSB: return /* @__PURE__ */ import_react.createElement(ColorHsbInput_default, Object.assign({}, inputProps));
			case FORMAT_RGB: return /* @__PURE__ */ import_react.createElement(ColorRgbInput_default, Object.assign({}, inputProps));
			default: return /* @__PURE__ */ import_react.createElement(ColorHexInput_default, Object.assign({}, inputProps));
		}
	}, [
		colorFormat,
		prefixCls,
		value,
		onChange
	]);
	return /* @__PURE__ */ import_react.createElement("div", { className: `${colorInputPrefixCls}-container` }, !disabledFormat && /* @__PURE__ */ import_react.createElement(select_default, {
		value: colorFormat,
		variant: "borderless",
		getPopupContainer: (current) => current,
		popupMatchSelectWidth: 68,
		placement: "bottomRight",
		onChange: handleFormatChange,
		className: `${prefixCls}-format-select`,
		size: "small",
		options: selectOptions
	}), /* @__PURE__ */ import_react.createElement("div", { className: colorInputPrefixCls }, steppersNode), !disabledAlpha && /* @__PURE__ */ import_react.createElement(ColorAlphaInput_default, {
		prefixCls,
		value,
		onChange
	}));
};
var ColorInput_default = ColorInput;

//#endregion
//#region node_modules/rc-slider/es/util.js
function getOffset$3(value, min, max) {
	return (value - min) / (max - min);
}
function getDirectionStyle(direction, value, min, max) {
	var offset$2 = getOffset$3(value, min, max);
	var positionStyle = {};
	switch (direction) {
		case "rtl":
			positionStyle.right = "".concat(offset$2 * 100, "%");
			positionStyle.transform = "translateX(50%)";
			break;
		case "btt":
			positionStyle.bottom = "".concat(offset$2 * 100, "%");
			positionStyle.transform = "translateY(50%)";
			break;
		case "ttb":
			positionStyle.top = "".concat(offset$2 * 100, "%");
			positionStyle.transform = "translateY(-50%)";
			break;
		default:
			positionStyle.left = "".concat(offset$2 * 100, "%");
			positionStyle.transform = "translateX(-50%)";
			break;
	}
	return positionStyle;
}
/** Return index value if is list or return value directly */
function getIndex(value, index$2) {
	return Array.isArray(value) ? value[index$2] : value;
}

//#endregion
//#region node_modules/rc-slider/es/context.js
var SliderContext = /* @__PURE__ */ import_react.createContext({
	min: 0,
	max: 0,
	direction: "ltr",
	step: 1,
	includedStart: 0,
	includedEnd: 0,
	tabIndex: 0,
	keyboard: true,
	styles: {},
	classNames: {}
});
var context_default$3 = SliderContext;
/** @private NOT PROMISE AVAILABLE. DO NOT USE IN PRODUCTION. */
var UnstableContext$1 = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/rc-slider/es/Handles/Handle.js
var import_classnames$130 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$29 = [
	"prefixCls",
	"value",
	"valueIndex",
	"onStartMove",
	"onDelete",
	"style",
	"render",
	"dragging",
	"draggingDelete",
	"onOffsetChange",
	"onChangeComplete",
	"onFocus",
	"onMouseEnter"
];
var Handle = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, value = props.value, valueIndex = props.valueIndex, onStartMove = props.onStartMove, onDelete = props.onDelete, style$1 = props.style, render$1 = props.render, dragging = props.dragging, draggingDelete = props.draggingDelete, onOffsetChange = props.onOffsetChange, onChangeComplete = props.onChangeComplete, onFocus = props.onFocus, onMouseEnter = props.onMouseEnter, restProps = _objectWithoutProperties(props, _excluded$29);
	var _React$useContext = import_react.useContext(context_default$3), min = _React$useContext.min, max = _React$useContext.max, direction = _React$useContext.direction, disabled = _React$useContext.disabled, keyboard = _React$useContext.keyboard, range$1 = _React$useContext.range, tabIndex = _React$useContext.tabIndex, ariaLabelForHandle = _React$useContext.ariaLabelForHandle, ariaLabelledByForHandle = _React$useContext.ariaLabelledByForHandle, ariaRequired = _React$useContext.ariaRequired, ariaValueTextFormatterForHandle = _React$useContext.ariaValueTextFormatterForHandle, styles = _React$useContext.styles, classNames$252 = _React$useContext.classNames;
	var handlePrefixCls = "".concat(prefixCls, "-handle");
	var onInternalStartMove = function onInternalStartMove$1(e$2) {
		if (!disabled) onStartMove(e$2, valueIndex);
	};
	var onInternalFocus = function onInternalFocus$1(e$2) {
		onFocus === null || onFocus === void 0 || onFocus(e$2, valueIndex);
	};
	var onInternalMouseEnter = function onInternalMouseEnter$1(e$2) {
		onMouseEnter(e$2, valueIndex);
	};
	var onKeyDown$1 = function onKeyDown$2(e$2) {
		if (!disabled && keyboard) {
			var offset$2 = null;
			switch (e$2.which || e$2.keyCode) {
				case KeyCode_default.LEFT:
					offset$2 = direction === "ltr" || direction === "btt" ? -1 : 1;
					break;
				case KeyCode_default.RIGHT:
					offset$2 = direction === "ltr" || direction === "btt" ? 1 : -1;
					break;
				case KeyCode_default.UP:
					offset$2 = direction !== "ttb" ? 1 : -1;
					break;
				case KeyCode_default.DOWN:
					offset$2 = direction !== "ttb" ? -1 : 1;
					break;
				case KeyCode_default.HOME:
					offset$2 = "min";
					break;
				case KeyCode_default.END:
					offset$2 = "max";
					break;
				case KeyCode_default.PAGE_UP:
					offset$2 = 2;
					break;
				case KeyCode_default.PAGE_DOWN:
					offset$2 = -2;
					break;
				case KeyCode_default.BACKSPACE:
				case KeyCode_default.DELETE:
					onDelete === null || onDelete === void 0 || onDelete(valueIndex);
					break;
			}
			if (offset$2 !== null) {
				e$2.preventDefault();
				onOffsetChange(offset$2, valueIndex);
			}
		}
	};
	var handleKeyUp = function handleKeyUp$1(e$2) {
		switch (e$2.which || e$2.keyCode) {
			case KeyCode_default.LEFT:
			case KeyCode_default.RIGHT:
			case KeyCode_default.UP:
			case KeyCode_default.DOWN:
			case KeyCode_default.HOME:
			case KeyCode_default.END:
			case KeyCode_default.PAGE_UP:
			case KeyCode_default.PAGE_DOWN:
				onChangeComplete === null || onChangeComplete === void 0 || onChangeComplete();
				break;
		}
	};
	var positionStyle = getDirectionStyle(direction, value, min, max);
	var divProps = {};
	if (valueIndex !== null) {
		var _getIndex;
		divProps = {
			tabIndex: disabled ? null : getIndex(tabIndex, valueIndex),
			role: "slider",
			"aria-valuemin": min,
			"aria-valuemax": max,
			"aria-valuenow": value,
			"aria-disabled": disabled,
			"aria-label": getIndex(ariaLabelForHandle, valueIndex),
			"aria-labelledby": getIndex(ariaLabelledByForHandle, valueIndex),
			"aria-required": getIndex(ariaRequired, valueIndex),
			"aria-valuetext": (_getIndex = getIndex(ariaValueTextFormatterForHandle, valueIndex)) === null || _getIndex === void 0 ? void 0 : _getIndex(value),
			"aria-orientation": direction === "ltr" || direction === "rtl" ? "horizontal" : "vertical",
			onMouseDown: onInternalStartMove,
			onTouchStart: onInternalStartMove,
			onFocus: onInternalFocus,
			onMouseEnter: onInternalMouseEnter,
			onKeyDown: onKeyDown$1,
			onKeyUp: handleKeyUp
		};
	}
	var handleNode = /* @__PURE__ */ import_react.createElement("div", _extends({
		ref,
		className: (0, import_classnames$130.default)(handlePrefixCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(handlePrefixCls, "-").concat(valueIndex + 1), valueIndex !== null && range$1), "".concat(handlePrefixCls, "-dragging"), dragging), "".concat(handlePrefixCls, "-dragging-delete"), draggingDelete), classNames$252.handle),
		style: _objectSpread2(_objectSpread2(_objectSpread2({}, positionStyle), style$1), styles.handle)
	}, divProps, restProps));
	if (render$1) handleNode = render$1(handleNode, {
		index: valueIndex,
		prefixCls,
		value,
		dragging,
		draggingDelete
	});
	return handleNode;
});
Handle.displayName = "Handle";
var Handle_default = Handle;

//#endregion
//#region node_modules/rc-slider/es/Handles/index.js
var import_react_dom$3 = /* @__PURE__ */ __toESM(require_react_dom());
var _excluded$28 = [
	"prefixCls",
	"style",
	"onStartMove",
	"onOffsetChange",
	"values",
	"handleRender",
	"activeHandleRender",
	"draggingIndex",
	"draggingDelete",
	"onFocus"
];
var Handles = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, style$1 = props.style, onStartMove = props.onStartMove, onOffsetChange = props.onOffsetChange, values = props.values, handleRender = props.handleRender, activeHandleRender = props.activeHandleRender, draggingIndex = props.draggingIndex, draggingDelete = props.draggingDelete, onFocus = props.onFocus, restProps = _objectWithoutProperties(props, _excluded$28);
	var handlesRef = import_react.useRef({});
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), activeVisible = _React$useState2[0], setActiveVisible = _React$useState2[1];
	var _React$useState3 = import_react.useState(-1), _React$useState4 = _slicedToArray(_React$useState3, 2), activeIndex = _React$useState4[0], setActiveIndex = _React$useState4[1];
	var onActive = function onActive$1(index$2) {
		setActiveIndex(index$2);
		setActiveVisible(true);
	};
	var onHandleFocus = function onHandleFocus$1(e$2, index$2) {
		onActive(index$2);
		onFocus === null || onFocus === void 0 || onFocus(e$2);
	};
	var onHandleMouseEnter = function onHandleMouseEnter$1(e$2, index$2) {
		onActive(index$2);
	};
	import_react.useImperativeHandle(ref, function() {
		return {
			focus: function focus(index$2) {
				var _handlesRef$current$i;
				(_handlesRef$current$i = handlesRef.current[index$2]) === null || _handlesRef$current$i === void 0 || _handlesRef$current$i.focus();
			},
			hideHelp: function hideHelp() {
				(0, import_react_dom$3.flushSync)(function() {
					setActiveVisible(false);
				});
			}
		};
	});
	var handleProps = _objectSpread2({
		prefixCls,
		onStartMove,
		onOffsetChange,
		render: handleRender,
		onFocus: onHandleFocus,
		onMouseEnter: onHandleMouseEnter
	}, restProps);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, values.map(function(value, index$2) {
		var dragging = draggingIndex === index$2;
		return /* @__PURE__ */ import_react.createElement(Handle_default, _extends({
			ref: function ref$1(node$1) {
				if (!node$1) delete handlesRef.current[index$2];
				else handlesRef.current[index$2] = node$1;
			},
			dragging,
			draggingDelete: dragging && draggingDelete,
			style: getIndex(style$1, index$2),
			key: index$2,
			value,
			valueIndex: index$2
		}, handleProps));
	}), activeHandleRender && activeVisible && /* @__PURE__ */ import_react.createElement(Handle_default, _extends({ key: "a11y" }, handleProps, {
		value: values[activeIndex],
		valueIndex: null,
		dragging: draggingIndex !== -1,
		draggingDelete,
		render: activeHandleRender,
		style: { pointerEvents: "none" },
		tabIndex: null,
		"aria-hidden": true
	})));
});
Handles.displayName = "Handles";
var Handles_default = Handles;

//#endregion
//#region node_modules/rc-slider/es/Marks/Mark.js
var import_classnames$129 = /* @__PURE__ */ __toESM(require_classnames());
var Mark = function Mark$1(props) {
	var prefixCls = props.prefixCls, style$1 = props.style, children = props.children, value = props.value, _onClick = props.onClick;
	var _React$useContext = import_react.useContext(context_default$3), min = _React$useContext.min, max = _React$useContext.max, direction = _React$useContext.direction, includedStart = _React$useContext.includedStart, includedEnd = _React$useContext.includedEnd, included = _React$useContext.included;
	var textCls = "".concat(prefixCls, "-text");
	var positionStyle = getDirectionStyle(direction, value, min, max);
	return /* @__PURE__ */ import_react.createElement("span", {
		className: (0, import_classnames$129.default)(textCls, _defineProperty({}, "".concat(textCls, "-active"), included && includedStart <= value && value <= includedEnd)),
		style: _objectSpread2(_objectSpread2({}, positionStyle), style$1),
		onMouseDown: function onMouseDown(e$2) {
			e$2.stopPropagation();
		},
		onClick: function onClick() {
			_onClick(value);
		}
	}, children);
};
var Mark_default = Mark;

//#endregion
//#region node_modules/rc-slider/es/Marks/index.js
var Marks = function Marks$1(props) {
	var prefixCls = props.prefixCls, marks = props.marks, onClick = props.onClick;
	var markPrefixCls = "".concat(prefixCls, "-mark");
	if (!marks.length) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className: markPrefixCls }, marks.map(function(_ref) {
		var value = _ref.value, style$1 = _ref.style, label = _ref.label;
		return /* @__PURE__ */ import_react.createElement(Mark_default, {
			key: value,
			prefixCls: markPrefixCls,
			style: style$1,
			value,
			onClick
		}, label);
	}));
};
var Marks_default = Marks;

//#endregion
//#region node_modules/rc-slider/es/Steps/Dot.js
var import_classnames$128 = /* @__PURE__ */ __toESM(require_classnames());
var Dot = function Dot$1(props) {
	var prefixCls = props.prefixCls, value = props.value, style$1 = props.style, activeStyle = props.activeStyle;
	var _React$useContext = import_react.useContext(context_default$3), min = _React$useContext.min, max = _React$useContext.max, direction = _React$useContext.direction, included = _React$useContext.included, includedStart = _React$useContext.includedStart, includedEnd = _React$useContext.includedEnd;
	var dotClassName = "".concat(prefixCls, "-dot");
	var active = included && includedStart <= value && value <= includedEnd;
	var mergedStyle = _objectSpread2(_objectSpread2({}, getDirectionStyle(direction, value, min, max)), typeof style$1 === "function" ? style$1(value) : style$1);
	if (active) mergedStyle = _objectSpread2(_objectSpread2({}, mergedStyle), typeof activeStyle === "function" ? activeStyle(value) : activeStyle);
	return /* @__PURE__ */ import_react.createElement("span", {
		className: (0, import_classnames$128.default)(dotClassName, _defineProperty({}, "".concat(dotClassName, "-active"), active)),
		style: mergedStyle
	});
};
var Dot_default = Dot;

//#endregion
//#region node_modules/rc-slider/es/Steps/index.js
var Steps$3 = function Steps$4(props) {
	var prefixCls = props.prefixCls, marks = props.marks, dots = props.dots, style$1 = props.style, activeStyle = props.activeStyle;
	var _React$useContext = import_react.useContext(context_default$3), min = _React$useContext.min, max = _React$useContext.max, step = _React$useContext.step;
	var stepDots = import_react.useMemo(function() {
		var dotSet = /* @__PURE__ */ new Set();
		marks.forEach(function(mark) {
			dotSet.add(mark.value);
		});
		if (dots && step !== null) {
			var current = min;
			while (current <= max) {
				dotSet.add(current);
				current += step;
			}
		}
		return Array.from(dotSet);
	}, [
		min,
		max,
		step,
		dots,
		marks
	]);
	return /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-step") }, stepDots.map(function(dotValue) {
		return /* @__PURE__ */ import_react.createElement(Dot_default, {
			prefixCls,
			key: dotValue,
			value: dotValue,
			style: style$1,
			activeStyle
		});
	}));
};
var Steps_default$2 = Steps$3;

//#endregion
//#region node_modules/rc-slider/es/Tracks/Track.js
var import_classnames$127 = /* @__PURE__ */ __toESM(require_classnames());
var Track = function Track$2(props) {
	var prefixCls = props.prefixCls, style$1 = props.style, start = props.start, end = props.end, index$2 = props.index, onStartMove = props.onStartMove, replaceCls = props.replaceCls;
	var _React$useContext = import_react.useContext(context_default$3), direction = _React$useContext.direction, min = _React$useContext.min, max = _React$useContext.max, disabled = _React$useContext.disabled, range$1 = _React$useContext.range, classNames$252 = _React$useContext.classNames;
	var trackPrefixCls = "".concat(prefixCls, "-track");
	var offsetStart = getOffset$3(start, min, max);
	var offsetEnd = getOffset$3(end, min, max);
	var onInternalStartMove = function onInternalStartMove$1(e$2) {
		if (!disabled && onStartMove) onStartMove(e$2, -1);
	};
	var positionStyle = {};
	switch (direction) {
		case "rtl":
			positionStyle.right = "".concat(offsetStart * 100, "%");
			positionStyle.width = "".concat(offsetEnd * 100 - offsetStart * 100, "%");
			break;
		case "btt":
			positionStyle.bottom = "".concat(offsetStart * 100, "%");
			positionStyle.height = "".concat(offsetEnd * 100 - offsetStart * 100, "%");
			break;
		case "ttb":
			positionStyle.top = "".concat(offsetStart * 100, "%");
			positionStyle.height = "".concat(offsetEnd * 100 - offsetStart * 100, "%");
			break;
		default:
			positionStyle.left = "".concat(offsetStart * 100, "%");
			positionStyle.width = "".concat(offsetEnd * 100 - offsetStart * 100, "%");
	}
	var className = replaceCls || (0, import_classnames$127.default)(trackPrefixCls, _defineProperty(_defineProperty({}, "".concat(trackPrefixCls, "-").concat(index$2 + 1), index$2 !== null && range$1), "".concat(prefixCls, "-track-draggable"), onStartMove), classNames$252.track);
	return /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: _objectSpread2(_objectSpread2({}, positionStyle), style$1),
		onMouseDown: onInternalStartMove,
		onTouchStart: onInternalStartMove
	});
};
var Track_default = Track;

//#endregion
//#region node_modules/rc-slider/es/Tracks/index.js
var import_classnames$126 = /* @__PURE__ */ __toESM(require_classnames());
var Tracks = function Tracks$1(props) {
	var prefixCls = props.prefixCls, style$1 = props.style, values = props.values, startPoint = props.startPoint, onStartMove = props.onStartMove;
	var _React$useContext = import_react.useContext(context_default$3), included = _React$useContext.included, range$1 = _React$useContext.range, min = _React$useContext.min, styles = _React$useContext.styles, classNames$252 = _React$useContext.classNames;
	var trackList = import_react.useMemo(function() {
		if (!range$1) {
			if (values.length === 0) return [];
			var startValue = startPoint !== null && startPoint !== void 0 ? startPoint : min;
			var endValue = values[0];
			return [{
				start: Math.min(startValue, endValue),
				end: Math.max(startValue, endValue)
			}];
		}
		var list = [];
		for (var i = 0; i < values.length - 1; i += 1) list.push({
			start: values[i],
			end: values[i + 1]
		});
		return list;
	}, [
		values,
		range$1,
		startPoint,
		min
	]);
	if (!included) return null;
	var tracksNode = trackList !== null && trackList !== void 0 && trackList.length && (classNames$252.tracks || styles.tracks) ? /* @__PURE__ */ import_react.createElement(Track_default, {
		index: null,
		prefixCls,
		start: trackList[0].start,
		end: trackList[trackList.length - 1].end,
		replaceCls: (0, import_classnames$126.default)(classNames$252.tracks, "".concat(prefixCls, "-tracks")),
		style: styles.tracks
	}) : null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, tracksNode, trackList.map(function(_ref, index$2) {
		var start = _ref.start, end = _ref.end;
		return /* @__PURE__ */ import_react.createElement(Track_default, {
			index: index$2,
			prefixCls,
			style: _objectSpread2(_objectSpread2({}, getIndex(style$1, index$2)), styles.track),
			start,
			end,
			key: index$2,
			onStartMove
		});
	}));
};
var Tracks_default = Tracks;

//#endregion
//#region node_modules/rc-slider/es/hooks/useDrag.js
/** Drag to delete offset. It's a user experience number for dragging out */
var REMOVE_DIST = 130;
function getPosition(e$2) {
	var obj = "targetTouches" in e$2 ? e$2.targetTouches[0] : e$2;
	return {
		pageX: obj.pageX,
		pageY: obj.pageY
	};
}
function useDrag(containerRef, direction, rawValues, min, max, formatValue$1, triggerChange, finishChange, offsetValues, editable, minCount) {
	var _React$useState = import_react.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), draggingValue = _React$useState2[0], setDraggingValue = _React$useState2[1];
	var _React$useState3 = import_react.useState(-1), _React$useState4 = _slicedToArray(_React$useState3, 2), draggingIndex = _React$useState4[0], setDraggingIndex = _React$useState4[1];
	var _React$useState5 = import_react.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), draggingDelete = _React$useState6[0], setDraggingDelete = _React$useState6[1];
	var _React$useState7 = import_react.useState(rawValues), _React$useState8 = _slicedToArray(_React$useState7, 2), cacheValues = _React$useState8[0], setCacheValues = _React$useState8[1];
	var _React$useState9 = import_react.useState(rawValues), _React$useState10 = _slicedToArray(_React$useState9, 2), originValues = _React$useState10[0], setOriginValues = _React$useState10[1];
	var mouseMoveEventRef = import_react.useRef(null);
	var mouseUpEventRef = import_react.useRef(null);
	var touchEventTargetRef = import_react.useRef(null);
	var _React$useContext = import_react.useContext(UnstableContext$1), onDragStart = _React$useContext.onDragStart, onDragChange = _React$useContext.onDragChange;
	useLayoutEffect_default(function() {
		if (draggingIndex === -1) setCacheValues(rawValues);
	}, [rawValues, draggingIndex]);
	import_react.useEffect(function() {
		return function() {
			document.removeEventListener("mousemove", mouseMoveEventRef.current);
			document.removeEventListener("mouseup", mouseUpEventRef.current);
			if (touchEventTargetRef.current) {
				touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
				touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
			}
		};
	}, []);
	var flushValues = function flushValues$1(nextValues, nextValue, deleteMark) {
		if (nextValue !== void 0) setDraggingValue(nextValue);
		setCacheValues(nextValues);
		var changeValues = nextValues;
		if (deleteMark) changeValues = nextValues.filter(function(_, i) {
			return i !== draggingIndex;
		});
		triggerChange(changeValues);
		if (onDragChange) onDragChange({
			rawValues: nextValues,
			deleteIndex: deleteMark ? draggingIndex : -1,
			draggingIndex,
			draggingValue: nextValue
		});
	};
	var updateCacheValue = useEvent(function(valueIndex, offsetPercent, deleteMark) {
		if (valueIndex === -1) {
			var startValue = originValues[0];
			var endValue = originValues[originValues.length - 1];
			var maxStartOffset = min - startValue;
			var maxEndOffset = max - endValue;
			var offset$2 = offsetPercent * (max - min);
			offset$2 = Math.max(offset$2, maxStartOffset);
			offset$2 = Math.min(offset$2, maxEndOffset);
			offset$2 = formatValue$1(startValue + offset$2) - startValue;
			var cloneCacheValues = originValues.map(function(val) {
				return val + offset$2;
			});
			flushValues(cloneCacheValues);
		} else {
			var offsetDist = (max - min) * offsetPercent;
			var cloneValues = _toConsumableArray(cacheValues);
			cloneValues[valueIndex] = originValues[valueIndex];
			var next$1 = offsetValues(cloneValues, offsetDist, valueIndex, "dist");
			flushValues(next$1.values, next$1.value, deleteMark);
		}
	});
	var onStartMove = function onStartMove$1(e$2, valueIndex, startValues) {
		e$2.stopPropagation();
		var initialValues = startValues || rawValues;
		var originValue = initialValues[valueIndex];
		setDraggingIndex(valueIndex);
		setDraggingValue(originValue);
		setOriginValues(initialValues);
		setCacheValues(initialValues);
		setDraggingDelete(false);
		var _getPosition = getPosition(e$2), startX = _getPosition.pageX, startY = _getPosition.pageY;
		var deleteMark = false;
		if (onDragStart) onDragStart({
			rawValues: initialValues,
			draggingIndex: valueIndex,
			draggingValue: originValue
		});
		var onMouseMove = function onMouseMove$1(event) {
			event.preventDefault();
			var _getPosition2 = getPosition(event), moveX = _getPosition2.pageX, moveY = _getPosition2.pageY;
			var offsetX = moveX - startX;
			var offsetY = moveY - startY;
			var _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height;
			var offSetPercent;
			var removeDist;
			switch (direction) {
				case "btt":
					offSetPercent = -offsetY / height;
					removeDist = offsetX;
					break;
				case "ttb":
					offSetPercent = offsetY / height;
					removeDist = offsetX;
					break;
				case "rtl":
					offSetPercent = -offsetX / width;
					removeDist = offsetY;
					break;
				default:
					offSetPercent = offsetX / width;
					removeDist = offsetY;
			}
			deleteMark = editable ? Math.abs(removeDist) > REMOVE_DIST && minCount < cacheValues.length : false;
			setDraggingDelete(deleteMark);
			updateCacheValue(valueIndex, offSetPercent, deleteMark);
		};
		var onMouseUp = function onMouseUp$1(event) {
			event.preventDefault();
			document.removeEventListener("mouseup", onMouseUp$1);
			document.removeEventListener("mousemove", onMouseMove);
			if (touchEventTargetRef.current) {
				touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
				touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
			}
			mouseMoveEventRef.current = null;
			mouseUpEventRef.current = null;
			touchEventTargetRef.current = null;
			finishChange(deleteMark);
			setDraggingIndex(-1);
			setDraggingDelete(false);
		};
		document.addEventListener("mouseup", onMouseUp);
		document.addEventListener("mousemove", onMouseMove);
		e$2.currentTarget.addEventListener("touchend", onMouseUp);
		e$2.currentTarget.addEventListener("touchmove", onMouseMove);
		mouseMoveEventRef.current = onMouseMove;
		mouseUpEventRef.current = onMouseUp;
		touchEventTargetRef.current = e$2.currentTarget;
	};
	var returnValues = import_react.useMemo(function() {
		var sourceValues = _toConsumableArray(rawValues).sort(function(a, b) {
			return a - b;
		});
		var targetValues = _toConsumableArray(cacheValues).sort(function(a, b) {
			return a - b;
		});
		var counts = {};
		targetValues.forEach(function(val) {
			counts[val] = (counts[val] || 0) + 1;
		});
		sourceValues.forEach(function(val) {
			counts[val] = (counts[val] || 0) - 1;
		});
		var maxDiffCount = editable ? 1 : 0;
		return Object.values(counts).reduce(function(prev$1, next$1) {
			return prev$1 + Math.abs(next$1);
		}, 0) <= maxDiffCount ? cacheValues : rawValues;
	}, [
		rawValues,
		cacheValues,
		editable
	]);
	return [
		draggingIndex,
		draggingValue,
		draggingDelete,
		returnValues,
		onStartMove
	];
}
var useDrag_default = useDrag;

//#endregion
//#region node_modules/rc-slider/es/hooks/useOffset.js
/** Format the value in the range of [min, max] */
/** Format value align with step */
/** Format value align with step & marks */
function useOffset(min, max, step, markList, allowCross, pushable) {
	var formatRangeValue = import_react.useCallback(function(val) {
		return Math.max(min, Math.min(max, val));
	}, [min, max]);
	var formatStepValue = import_react.useCallback(function(val) {
		if (step !== null) {
			var stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;
			var getDecimal = function getDecimal$1(num) {
				return (String(num).split(".")[1] || "").length;
			};
			var maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));
			var fixedValue = Number(stepValue.toFixed(maxDecimal));
			return min <= fixedValue && fixedValue <= max ? fixedValue : null;
		}
		return null;
	}, [
		step,
		min,
		max,
		formatRangeValue
	]);
	var formatValue$1 = import_react.useCallback(function(val) {
		var formatNextValue = formatRangeValue(val);
		var alignValues = markList.map(function(mark) {
			return mark.value;
		});
		if (step !== null) alignValues.push(formatStepValue(val));
		alignValues.push(min, max);
		var closeValue = alignValues[0];
		var closeDist = max - min;
		alignValues.forEach(function(alignValue) {
			var dist = Math.abs(formatNextValue - alignValue);
			if (dist <= closeDist) {
				closeValue = alignValue;
				closeDist = dist;
			}
		});
		return closeValue;
	}, [
		min,
		max,
		markList,
		step,
		formatRangeValue,
		formatStepValue
	]);
	var offsetValue = function offsetValue$1(values, offset$2, valueIndex) {
		var mode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit";
		if (typeof offset$2 === "number") {
			var nextValue;
			var originValue = values[valueIndex];
			var targetDistValue = originValue + offset$2;
			var potentialValues = [];
			markList.forEach(function(mark) {
				potentialValues.push(mark.value);
			});
			potentialValues.push(min, max);
			potentialValues.push(formatStepValue(originValue));
			var sign = offset$2 > 0 ? 1 : -1;
			if (mode === "unit") potentialValues.push(formatStepValue(originValue + sign * step));
			else potentialValues.push(formatStepValue(targetDistValue));
			potentialValues = potentialValues.filter(function(val) {
				return val !== null;
			}).filter(function(val) {
				return offset$2 < 0 ? val <= originValue : val >= originValue;
			});
			if (mode === "unit") potentialValues = potentialValues.filter(function(val) {
				return val !== originValue;
			});
			var compareValue = mode === "unit" ? originValue : targetDistValue;
			nextValue = potentialValues[0];
			var valueDist = Math.abs(nextValue - compareValue);
			potentialValues.forEach(function(potentialValue) {
				var dist = Math.abs(potentialValue - compareValue);
				if (dist < valueDist) {
					nextValue = potentialValue;
					valueDist = dist;
				}
			});
			if (nextValue === void 0) return offset$2 < 0 ? min : max;
			if (mode === "dist") return nextValue;
			if (Math.abs(offset$2) > 1) {
				var cloneValues = _toConsumableArray(values);
				cloneValues[valueIndex] = nextValue;
				return offsetValue$1(cloneValues, offset$2 - sign, valueIndex, mode);
			}
			return nextValue;
		} else if (offset$2 === "min") return min;
		else if (offset$2 === "max") return max;
	};
	/** Same as `offsetValue` but return `changed` mark to tell value changed */
	var offsetChangedValue = function offsetChangedValue$1(values, offset$2, valueIndex) {
		var mode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit";
		var originValue = values[valueIndex];
		var nextValue = offsetValue(values, offset$2, valueIndex, mode);
		return {
			value: nextValue,
			changed: nextValue !== originValue
		};
	};
	var needPush = function needPush$1(dist) {
		return pushable === null && dist === 0 || typeof pushable === "number" && dist < pushable;
	};
	return [formatValue$1, function offsetValues(values, offset$2, valueIndex) {
		var mode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit";
		var nextValues = values.map(formatValue$1);
		var originValue = nextValues[valueIndex];
		nextValues[valueIndex] = offsetValue(nextValues, offset$2, valueIndex, mode);
		if (allowCross === false) {
			var pushNum = pushable || 0;
			if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);
			if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);
		} else if (typeof pushable === "number" || pushable === null) {
			for (var i = valueIndex + 1; i < nextValues.length; i += 1) {
				var changed = true;
				while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
					var _offsetChangedValue = offsetChangedValue(nextValues, 1, i);
					nextValues[i] = _offsetChangedValue.value;
					changed = _offsetChangedValue.changed;
				}
			}
			for (var _i = valueIndex; _i > 0; _i -= 1) {
				var _changed = true;
				while (needPush(nextValues[_i] - nextValues[_i - 1]) && _changed) {
					var _offsetChangedValue2 = offsetChangedValue(nextValues, -1, _i - 1);
					nextValues[_i - 1] = _offsetChangedValue2.value;
					_changed = _offsetChangedValue2.changed;
				}
			}
			for (var _i2 = nextValues.length - 1; _i2 > 0; _i2 -= 1) {
				var _changed2 = true;
				while (needPush(nextValues[_i2] - nextValues[_i2 - 1]) && _changed2) {
					var _offsetChangedValue3 = offsetChangedValue(nextValues, -1, _i2 - 1);
					nextValues[_i2 - 1] = _offsetChangedValue3.value;
					_changed2 = _offsetChangedValue3.changed;
				}
			}
			for (var _i3 = 0; _i3 < nextValues.length - 1; _i3 += 1) {
				var _changed3 = true;
				while (needPush(nextValues[_i3 + 1] - nextValues[_i3]) && _changed3) {
					var _offsetChangedValue4 = offsetChangedValue(nextValues, 1, _i3 + 1);
					nextValues[_i3 + 1] = _offsetChangedValue4.value;
					_changed3 = _offsetChangedValue4.changed;
				}
			}
		}
		return {
			value: nextValues[valueIndex],
			values: nextValues
		};
	}];
}

//#endregion
//#region node_modules/rc-slider/es/hooks/useRange.js
function useRange(range$1) {
	return (0, import_react.useMemo)(function() {
		if (range$1 === true || !range$1) return [
			!!range$1,
			false,
			false,
			0
		];
		var editable = range$1.editable, draggableTrack = range$1.draggableTrack, minCount = range$1.minCount, maxCount = range$1.maxCount;
		warning(!editable || !draggableTrack, "`editable` can not work with `draggableTrack`.");
		return [
			true,
			editable,
			!editable && draggableTrack,
			minCount || 0,
			maxCount
		];
	}, [range$1]);
}

//#endregion
//#region node_modules/rc-slider/es/Slider.js
var import_classnames$125 = /* @__PURE__ */ __toESM(require_classnames());
/**
* New:
* - click mark to update range value
* - handleRender
* - Fix handle with count not correct
* - Fix pushable not work in some case
* - No more FindDOMNode
* - Move all position related style into inline style
* - Key: up is plus, down is minus
* - fix Key with step = null not align with marks
* - Change range should not trigger onChange
* - keyboard support pushable
*/
var Slider$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-slider" : _props$prefixCls, className = props.className, style$1 = props.style, classNames$252 = props.classNames, styles = props.styles, id = props.id, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, autoFocus = props.autoFocus, onFocus = props.onFocus, onBlur = props.onBlur, _props$min = props.min, min = _props$min === void 0 ? 0 : _props$min, _props$max = props.max, max = _props$max === void 0 ? 100 : _props$max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, value = props.value, defaultValue = props.defaultValue, range$1 = props.range, count = props.count, onChange = props.onChange, onBeforeChange = props.onBeforeChange, onAfterChange = props.onAfterChange, onChangeComplete = props.onChangeComplete, _props$allowCross = props.allowCross, allowCross = _props$allowCross === void 0 ? true : _props$allowCross, _props$pushable = props.pushable, pushable = _props$pushable === void 0 ? false : _props$pushable, reverse = props.reverse, vertical = props.vertical, _props$included = props.included, included = _props$included === void 0 ? true : _props$included, startPoint = props.startPoint, trackStyle = props.trackStyle, handleStyle = props.handleStyle, railStyle = props.railStyle, dotStyle = props.dotStyle, activeDotStyle = props.activeDotStyle, marks = props.marks, dots = props.dots, handleRender = props.handleRender, activeHandleRender = props.activeHandleRender, track = props.track, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, ariaLabelForHandle = props.ariaLabelForHandle, ariaLabelledByForHandle = props.ariaLabelledByForHandle, ariaRequired = props.ariaRequired, ariaValueTextFormatterForHandle = props.ariaValueTextFormatterForHandle;
	var handlesRef = import_react.useRef(null);
	var containerRef = import_react.useRef(null);
	var direction = import_react.useMemo(function() {
		if (vertical) return reverse ? "ttb" : "btt";
		return reverse ? "rtl" : "ltr";
	}, [reverse, vertical]);
	var _useRange = useRange(range$1), _useRange2 = _slicedToArray(_useRange, 5), rangeEnabled = _useRange2[0], rangeEditable = _useRange2[1], rangeDraggableTrack = _useRange2[2], minCount = _useRange2[3], maxCount = _useRange2[4];
	var mergedMin = import_react.useMemo(function() {
		return isFinite(min) ? min : 0;
	}, [min]);
	var mergedMax = import_react.useMemo(function() {
		return isFinite(max) ? max : 100;
	}, [max]);
	var mergedStep = import_react.useMemo(function() {
		return step !== null && step <= 0 ? 1 : step;
	}, [step]);
	var mergedPush = import_react.useMemo(function() {
		if (typeof pushable === "boolean") return pushable ? mergedStep : false;
		return pushable >= 0 ? pushable : false;
	}, [pushable, mergedStep]);
	var markList = import_react.useMemo(function() {
		return Object.keys(marks || {}).map(function(key) {
			var mark = marks[key];
			var markObj = { value: Number(key) };
			if (mark && _typeof(mark) === "object" && !/* @__PURE__ */ import_react.isValidElement(mark) && ("label" in mark || "style" in mark)) {
				markObj.style = mark.style;
				markObj.label = mark.label;
			} else markObj.label = mark;
			return markObj;
		}).filter(function(_ref) {
			var label = _ref.label;
			return label || typeof label === "number";
		}).sort(function(a, b) {
			return a.value - b.value;
		});
	}, [marks]);
	var _useOffset = useOffset(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush), _useOffset2 = _slicedToArray(_useOffset, 2), formatValue$1 = _useOffset2[0], offsetValues = _useOffset2[1];
	var _useMergedState = useMergedState(defaultValue, { value }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setValue = _useMergedState2[1];
	var rawValues = import_react.useMemo(function() {
		var valueList = mergedValue === null || mergedValue === void 0 ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];
		var _valueList = _slicedToArray(valueList, 1), _valueList$ = _valueList[0];
		var returnValues = mergedValue === null ? [] : [_valueList$ === void 0 ? mergedMin : _valueList$];
		if (rangeEnabled) {
			returnValues = _toConsumableArray(valueList);
			if (count || mergedValue === void 0) {
				var pointCount = count >= 0 ? count + 1 : 2;
				returnValues = returnValues.slice(0, pointCount);
				while (returnValues.length < pointCount) {
					var _returnValues;
					returnValues.push((_returnValues = returnValues[returnValues.length - 1]) !== null && _returnValues !== void 0 ? _returnValues : mergedMin);
				}
			}
			returnValues.sort(function(a, b) {
				return a - b;
			});
		}
		returnValues.forEach(function(val, index$2) {
			returnValues[index$2] = formatValue$1(val);
		});
		return returnValues;
	}, [
		mergedValue,
		rangeEnabled,
		mergedMin,
		count,
		formatValue$1
	]);
	var getTriggerValue = function getTriggerValue$1(triggerValues) {
		return rangeEnabled ? triggerValues : triggerValues[0];
	};
	var triggerChange = useEvent(function(nextValues) {
		var cloneNextValues = _toConsumableArray(nextValues).sort(function(a, b) {
			return a - b;
		});
		if (onChange && !isEqual_default(cloneNextValues, rawValues, true)) onChange(getTriggerValue(cloneNextValues));
		setValue(cloneNextValues);
	});
	var finishChange = useEvent(function(draggingDelete$1) {
		if (draggingDelete$1) handlesRef.current.hideHelp();
		var finishValue = getTriggerValue(rawValues);
		onAfterChange === null || onAfterChange === void 0 || onAfterChange(finishValue);
		warning_default(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
		onChangeComplete === null || onChangeComplete === void 0 || onChangeComplete(finishValue);
	});
	var onDelete = function onDelete$1(index$2) {
		if (disabled || !rangeEditable || rawValues.length <= minCount) return;
		var cloneNextValues = _toConsumableArray(rawValues);
		cloneNextValues.splice(index$2, 1);
		onBeforeChange === null || onBeforeChange === void 0 || onBeforeChange(getTriggerValue(cloneNextValues));
		triggerChange(cloneNextValues);
		var nextFocusIndex = Math.max(0, index$2 - 1);
		handlesRef.current.hideHelp();
		handlesRef.current.focus(nextFocusIndex);
	};
	var _useDrag = useDrag_default(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue$1, triggerChange, finishChange, offsetValues, rangeEditable, minCount), _useDrag2 = _slicedToArray(_useDrag, 5), draggingIndex = _useDrag2[0], draggingValue = _useDrag2[1], draggingDelete = _useDrag2[2], cacheValues = _useDrag2[3], onStartDrag = _useDrag2[4];
	/**
	* When `rangeEditable` will insert a new value in the values array.
	* Else it will replace the value in the values array.
	*/
	var changeToCloseValue = function changeToCloseValue$1(newValue, e$2) {
		if (!disabled) {
			var cloneNextValues = _toConsumableArray(rawValues);
			var valueIndex = 0;
			var valueBeforeIndex = 0;
			var valueDist = mergedMax - mergedMin;
			rawValues.forEach(function(val, index$2) {
				var dist = Math.abs(newValue - val);
				if (dist <= valueDist) {
					valueDist = dist;
					valueIndex = index$2;
				}
				if (val < newValue) valueBeforeIndex = index$2;
			});
			var focusIndex = valueIndex;
			if (rangeEditable && valueDist !== 0 && (!maxCount || rawValues.length < maxCount)) {
				cloneNextValues.splice(valueBeforeIndex + 1, 0, newValue);
				focusIndex = valueBeforeIndex + 1;
			} else cloneNextValues[valueIndex] = newValue;
			if (rangeEnabled && !rawValues.length && count === void 0) cloneNextValues.push(newValue);
			var nextValue = getTriggerValue(cloneNextValues);
			onBeforeChange === null || onBeforeChange === void 0 || onBeforeChange(nextValue);
			triggerChange(cloneNextValues);
			if (e$2) {
				var _document$activeEleme, _document$activeEleme2;
				(_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 || (_document$activeEleme2 = _document$activeEleme.blur) === null || _document$activeEleme2 === void 0 || _document$activeEleme2.call(_document$activeEleme);
				handlesRef.current.focus(focusIndex);
				onStartDrag(e$2, focusIndex, cloneNextValues);
			} else {
				onAfterChange === null || onAfterChange === void 0 || onAfterChange(nextValue);
				warning_default(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
				onChangeComplete === null || onChangeComplete === void 0 || onChangeComplete(nextValue);
			}
		}
	};
	var onSliderMouseDown = function onSliderMouseDown$1(e$2) {
		e$2.preventDefault();
		var _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height, left = _containerRef$current.left, top = _containerRef$current.top, bottom = _containerRef$current.bottom, right = _containerRef$current.right;
		var clientX = e$2.clientX, clientY = e$2.clientY;
		var percent;
		switch (direction) {
			case "btt":
				percent = (bottom - clientY) / height;
				break;
			case "ttb":
				percent = (clientY - top) / height;
				break;
			case "rtl":
				percent = (right - clientX) / width;
				break;
			default: percent = (clientX - left) / width;
		}
		var nextValue = mergedMin + percent * (mergedMax - mergedMin);
		changeToCloseValue(formatValue$1(nextValue), e$2);
	};
	var _React$useState = import_react.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), keyboardValue = _React$useState2[0], setKeyboardValue = _React$useState2[1];
	var onHandleOffsetChange = function onHandleOffsetChange$1(offset$2, valueIndex) {
		if (!disabled) {
			var next$1 = offsetValues(rawValues, offset$2, valueIndex);
			onBeforeChange === null || onBeforeChange === void 0 || onBeforeChange(getTriggerValue(rawValues));
			triggerChange(next$1.values);
			setKeyboardValue(next$1.value);
		}
	};
	import_react.useEffect(function() {
		if (keyboardValue !== null) {
			var valueIndex = rawValues.indexOf(keyboardValue);
			if (valueIndex >= 0) handlesRef.current.focus(valueIndex);
		}
		setKeyboardValue(null);
	}, [keyboardValue]);
	var mergedDraggableTrack = import_react.useMemo(function() {
		if (rangeDraggableTrack && mergedStep === null) {
			warning_default(false, "`draggableTrack` is not supported when `step` is `null`.");
			return false;
		}
		return rangeDraggableTrack;
	}, [rangeDraggableTrack, mergedStep]);
	var onStartMove = useEvent(function(e$2, valueIndex) {
		onStartDrag(e$2, valueIndex);
		onBeforeChange === null || onBeforeChange === void 0 || onBeforeChange(getTriggerValue(rawValues));
	});
	var dragging = draggingIndex !== -1;
	import_react.useEffect(function() {
		if (!dragging) {
			var valueIndex = rawValues.lastIndexOf(draggingValue);
			handlesRef.current.focus(valueIndex);
		}
	}, [dragging]);
	var sortedCacheValues = import_react.useMemo(function() {
		return _toConsumableArray(cacheValues).sort(function(a, b) {
			return a - b;
		});
	}, [cacheValues]);
	var _React$useMemo = import_react.useMemo(function() {
		if (!rangeEnabled) return [mergedMin, sortedCacheValues[0]];
		return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];
	}, [
		sortedCacheValues,
		rangeEnabled,
		mergedMin
	]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), includedStart = _React$useMemo2[0], includedEnd = _React$useMemo2[1];
	import_react.useImperativeHandle(ref, function() {
		return {
			focus: function focus() {
				handlesRef.current.focus(0);
			},
			blur: function blur() {
				var _containerRef$current2;
				var _document = document, activeElement = _document.activeElement;
				if ((_containerRef$current2 = containerRef.current) !== null && _containerRef$current2 !== void 0 && _containerRef$current2.contains(activeElement)) activeElement === null || activeElement === void 0 || activeElement.blur();
			}
		};
	});
	import_react.useEffect(function() {
		if (autoFocus) handlesRef.current.focus(0);
	}, []);
	var context = import_react.useMemo(function() {
		return {
			min: mergedMin,
			max: mergedMax,
			direction,
			disabled,
			keyboard,
			step: mergedStep,
			included,
			includedStart,
			includedEnd,
			range: rangeEnabled,
			tabIndex,
			ariaLabelForHandle,
			ariaLabelledByForHandle,
			ariaRequired,
			ariaValueTextFormatterForHandle,
			styles: styles || {},
			classNames: classNames$252 || {}
		};
	}, [
		mergedMin,
		mergedMax,
		direction,
		disabled,
		keyboard,
		mergedStep,
		included,
		includedStart,
		includedEnd,
		rangeEnabled,
		tabIndex,
		ariaLabelForHandle,
		ariaLabelledByForHandle,
		ariaRequired,
		ariaValueTextFormatterForHandle,
		styles,
		classNames$252
	]);
	return /* @__PURE__ */ import_react.createElement(context_default$3.Provider, { value: context }, /* @__PURE__ */ import_react.createElement("div", {
		ref: containerRef,
		className: (0, import_classnames$125.default)(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-vertical"), vertical), "".concat(prefixCls, "-horizontal"), !vertical), "".concat(prefixCls, "-with-marks"), markList.length)),
		style: style$1,
		onMouseDown: onSliderMouseDown,
		id
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$125.default)("".concat(prefixCls, "-rail"), classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.rail),
		style: _objectSpread2(_objectSpread2({}, railStyle), styles === null || styles === void 0 ? void 0 : styles.rail)
	}), track !== false && /* @__PURE__ */ import_react.createElement(Tracks_default, {
		prefixCls,
		style: trackStyle,
		values: rawValues,
		startPoint,
		onStartMove: mergedDraggableTrack ? onStartMove : void 0
	}), /* @__PURE__ */ import_react.createElement(Steps_default$2, {
		prefixCls,
		marks: markList,
		dots,
		style: dotStyle,
		activeStyle: activeDotStyle
	}), /* @__PURE__ */ import_react.createElement(Handles_default, {
		ref: handlesRef,
		prefixCls,
		style: handleStyle,
		values: cacheValues,
		draggingIndex,
		draggingDelete,
		onStartMove,
		onOffsetChange: onHandleOffsetChange,
		onFocus,
		onBlur,
		handleRender,
		activeHandleRender,
		onChangeComplete: finishChange,
		onDelete: rangeEditable ? onDelete : void 0
	}), /* @__PURE__ */ import_react.createElement(Marks_default, {
		prefixCls,
		marks: markList,
		onClick: changeToCloseValue
	})));
});
Slider$1.displayName = "Slider";
var Slider_default = Slider$1;

//#endregion
//#region node_modules/rc-slider/es/index.js
var es_default$21 = Slider_default;

//#endregion
//#region node_modules/antd/es/slider/Context.js
/** @private Internal context. Do not use in your production. */
var SliderInternalContext = /* @__PURE__ */ (0, import_react.createContext)({});
var Context_default = SliderInternalContext;

//#endregion
//#region node_modules/antd/es/slider/SliderTooltip.js
var SliderTooltip = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { open: open$2, draggingDelete, value } = props;
	const innerRef = (0, import_react.useRef)(null);
	const mergedOpen = open$2 && !draggingDelete;
	const rafRef = (0, import_react.useRef)(null);
	function cancelKeepAlign() {
		raf_default.cancel(rafRef.current);
		rafRef.current = null;
	}
	function keepAlign() {
		rafRef.current = raf_default(() => {
			var _a;
			(_a = innerRef.current) === null || _a === void 0 || _a.forceAlign();
			rafRef.current = null;
		});
	}
	import_react.useEffect(() => {
		if (mergedOpen) keepAlign();
		else cancelKeepAlign();
		return cancelKeepAlign;
	}, [
		mergedOpen,
		props.title,
		value
	]);
	return /* @__PURE__ */ import_react.createElement(tooltip_default, Object.assign({ ref: composeRef(innerRef, ref) }, props, { open: mergedOpen }));
});
SliderTooltip.displayName = "SliderTooltip";
var SliderTooltip_default = SliderTooltip;

//#endregion
//#region node_modules/antd/es/slider/style/index.js
var genBaseStyle$9 = (token$1) => {
	const { componentCls, antCls, controlSize, dotSize, marginFull, marginPart, colorFillContentHover, handleColorDisabled, calc, handleSize, handleSizeHover, handleActiveColor, handleActiveOutlineColor, handleLineWidth, handleLineWidthHover, motionDurationMid } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "relative",
		height: controlSize,
		margin: `${unit(marginPart)} ${unit(marginFull)}`,
		padding: 0,
		cursor: "pointer",
		touchAction: "none",
		"&-vertical": { margin: `${unit(marginFull)} ${unit(marginPart)}` },
		[`${componentCls}-rail`]: {
			position: "absolute",
			backgroundColor: token$1.railBg,
			borderRadius: token$1.borderRadiusXS,
			transition: `background-color ${motionDurationMid}`
		},
		[`${componentCls}-track,${componentCls}-tracks`]: {
			position: "absolute",
			transition: `background-color ${motionDurationMid}`
		},
		[`${componentCls}-track`]: {
			backgroundColor: token$1.trackBg,
			borderRadius: token$1.borderRadiusXS
		},
		[`${componentCls}-track-draggable`]: {
			boxSizing: "content-box",
			backgroundClip: "content-box",
			border: "solid rgba(0,0,0,0)"
		},
		"&:hover": {
			[`${componentCls}-rail`]: { backgroundColor: token$1.railHoverBg },
			[`${componentCls}-track`]: { backgroundColor: token$1.trackHoverBg },
			[`${componentCls}-dot`]: { borderColor: colorFillContentHover },
			[`${componentCls}-handle::after`]: { boxShadow: `0 0 0 ${unit(handleLineWidth)} ${token$1.colorPrimaryBorderHover}` },
			[`${componentCls}-dot-active`]: { borderColor: token$1.dotActiveBorderColor }
		},
		[`${componentCls}-handle`]: {
			position: "absolute",
			width: handleSize,
			height: handleSize,
			outline: "none",
			userSelect: "none",
			"&-dragging-delete": { opacity: 0 },
			"&::before": {
				content: "\"\"",
				position: "absolute",
				insetInlineStart: calc(handleLineWidth).mul(-1).equal(),
				insetBlockStart: calc(handleLineWidth).mul(-1).equal(),
				width: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
				height: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
				backgroundColor: "transparent"
			},
			"&::after": {
				content: "\"\"",
				position: "absolute",
				insetBlockStart: 0,
				insetInlineStart: 0,
				width: handleSize,
				height: handleSize,
				backgroundColor: token$1.colorBgElevated,
				boxShadow: `0 0 0 ${unit(handleLineWidth)} ${token$1.handleColor}`,
				outline: `0px solid transparent`,
				borderRadius: "50%",
				cursor: "pointer",
				transition: `
            inset-inline-start ${motionDurationMid},
            inset-block-start ${motionDurationMid},
            width ${motionDurationMid},
            height ${motionDurationMid},
            box-shadow ${motionDurationMid},
            outline ${motionDurationMid}
          `
			},
			"&:hover, &:active, &:focus": {
				"&::before": {
					insetInlineStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
					insetBlockStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
					width: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal(),
					height: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal()
				},
				"&::after": {
					boxShadow: `0 0 0 ${unit(handleLineWidthHover)} ${handleActiveColor}`,
					outline: `6px solid ${handleActiveOutlineColor}`,
					width: handleSizeHover,
					height: handleSizeHover,
					insetInlineStart: token$1.calc(handleSize).sub(handleSizeHover).div(2).equal(),
					insetBlockStart: token$1.calc(handleSize).sub(handleSizeHover).div(2).equal()
				}
			}
		},
		[`&-lock ${componentCls}-handle`]: { "&::before, &::after": { transition: "none" } },
		[`${componentCls}-mark`]: {
			position: "absolute",
			fontSize: token$1.fontSize
		},
		[`${componentCls}-mark-text`]: {
			position: "absolute",
			display: "inline-block",
			color: token$1.colorTextDescription,
			textAlign: "center",
			wordBreak: "keep-all",
			cursor: "pointer",
			userSelect: "none",
			"&-active": { color: token$1.colorText }
		},
		[`${componentCls}-step`]: {
			position: "absolute",
			background: "transparent",
			pointerEvents: "none"
		},
		[`${componentCls}-dot`]: {
			position: "absolute",
			width: dotSize,
			height: dotSize,
			backgroundColor: token$1.colorBgElevated,
			border: `${unit(handleLineWidth)} solid ${token$1.dotBorderColor}`,
			borderRadius: "50%",
			cursor: "pointer",
			transition: `border-color ${token$1.motionDurationSlow}`,
			pointerEvents: "auto",
			"&-active": { borderColor: token$1.dotActiveBorderColor }
		},
		[`&${componentCls}-disabled`]: {
			cursor: "not-allowed",
			[`${componentCls}-rail`]: { backgroundColor: `${token$1.railBg} !important` },
			[`${componentCls}-track`]: { backgroundColor: `${token$1.trackBgDisabled} !important` },
			[`
          ${componentCls}-dot
        `]: {
				backgroundColor: token$1.colorBgElevated,
				borderColor: token$1.trackBgDisabled,
				boxShadow: "none",
				cursor: "not-allowed"
			},
			[`${componentCls}-handle::after`]: {
				backgroundColor: token$1.colorBgElevated,
				cursor: "not-allowed",
				width: handleSize,
				height: handleSize,
				boxShadow: `0 0 0 ${unit(handleLineWidth)} ${handleColorDisabled}`,
				insetInlineStart: 0,
				insetBlockStart: 0
			},
			[`
          ${componentCls}-mark-text,
          ${componentCls}-dot
        `]: { cursor: `not-allowed !important` }
		},
		[`&-tooltip ${antCls}-tooltip-inner`]: { minWidth: "unset" }
	}) };
};
var genDirectionStyle = (token$1, horizontal) => {
	const { componentCls, railSize, handleSize, dotSize, marginFull, calc } = token$1;
	const railPadding = horizontal ? "paddingBlock" : "paddingInline";
	const full = horizontal ? "width" : "height";
	const part = horizontal ? "height" : "width";
	const handlePos = horizontal ? "insetBlockStart" : "insetInlineStart";
	const markInset = horizontal ? "top" : "insetInlineStart";
	const handlePosSize = calc(railSize).mul(3).sub(handleSize).div(2).equal();
	const draggableBorderSize = calc(handleSize).sub(railSize).div(2).equal();
	const draggableBorder = horizontal ? {
		borderWidth: `${unit(draggableBorderSize)} 0`,
		transform: `translateY(${unit(calc(draggableBorderSize).mul(-1).equal())})`
	} : {
		borderWidth: `0 ${unit(draggableBorderSize)}`,
		transform: `translateX(${unit(token$1.calc(draggableBorderSize).mul(-1).equal())})`
	};
	return {
		[railPadding]: railSize,
		[part]: calc(railSize).mul(3).equal(),
		[`${componentCls}-rail`]: {
			[full]: "100%",
			[part]: railSize
		},
		[`${componentCls}-track,${componentCls}-tracks`]: { [part]: railSize },
		[`${componentCls}-track-draggable`]: Object.assign({}, draggableBorder),
		[`${componentCls}-handle`]: { [handlePos]: handlePosSize },
		[`${componentCls}-mark`]: {
			insetInlineStart: 0,
			top: 0,
			[markInset]: calc(railSize).mul(3).add(horizontal ? 0 : marginFull).equal(),
			[full]: "100%"
		},
		[`${componentCls}-step`]: {
			insetInlineStart: 0,
			top: 0,
			[markInset]: railSize,
			[full]: "100%",
			[part]: railSize
		},
		[`${componentCls}-dot`]: {
			position: "absolute",
			[handlePos]: calc(railSize).sub(dotSize).div(2).equal()
		}
	};
};
var genHorizontalStyle$2 = (token$1) => {
	const { componentCls, marginPartWithMark } = token$1;
	return { [`${componentCls}-horizontal`]: Object.assign(Object.assign({}, genDirectionStyle(token$1, true)), { [`&${componentCls}-with-marks`]: { marginBottom: marginPartWithMark } }) };
};
var genVerticalStyle$1 = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-vertical`]: Object.assign(Object.assign({}, genDirectionStyle(token$1, false)), { height: "100%" }) };
};
const prepareComponentToken$27 = (token$1) => {
	const increaseHandleWidth = 1;
	const controlSize = token$1.controlHeightLG / 4;
	const controlSizeHover = token$1.controlHeightSM / 2;
	const handleLineWidth = token$1.lineWidth + increaseHandleWidth;
	const handleLineWidthHover = token$1.lineWidth + increaseHandleWidth * 1.5;
	const handleActiveColor = token$1.colorPrimary;
	const handleActiveOutlineColor = new FastColor(handleActiveColor).setA(.2).toRgbString();
	return {
		controlSize,
		railSize: 4,
		handleSize: controlSize,
		handleSizeHover: controlSizeHover,
		dotSize: 8,
		handleLineWidth,
		handleLineWidthHover,
		railBg: token$1.colorFillTertiary,
		railHoverBg: token$1.colorFillSecondary,
		trackBg: token$1.colorPrimaryBorder,
		trackHoverBg: token$1.colorPrimaryBorderHover,
		handleColor: token$1.colorPrimaryBorder,
		handleActiveColor,
		handleActiveOutlineColor,
		handleColorDisabled: new FastColor(token$1.colorTextDisabled).onBackground(token$1.colorBgContainer).toHexString(),
		dotBorderColor: token$1.colorBorderSecondary,
		dotActiveBorderColor: token$1.colorPrimaryBorder,
		trackBgDisabled: token$1.colorBgContainerDisabled
	};
};
var style_default$34 = genStyleHooks("Slider", (token$1) => {
	const sliderToken = merge(token$1, {
		marginPart: token$1.calc(token$1.controlHeight).sub(token$1.controlSize).div(2).equal(),
		marginFull: token$1.calc(token$1.controlSize).div(2).equal(),
		marginPartWithMark: token$1.calc(token$1.controlHeightLG).sub(token$1.controlSize).equal()
	});
	return [
		genBaseStyle$9(sliderToken),
		genHorizontalStyle$2(sliderToken),
		genVerticalStyle$1(sliderToken)
	];
}, prepareComponentToken$27);

//#endregion
//#region node_modules/antd/es/slider/useRafLock.js
function useRafLock() {
	const [state, setState] = import_react.useState(false);
	const rafRef = import_react.useRef(null);
	const cleanup$1 = () => {
		raf_default.cancel(rafRef.current);
	};
	const setDelayState = (nextState) => {
		cleanup$1();
		if (nextState) setState(nextState);
		else rafRef.current = raf_default(() => {
			setState(nextState);
		});
	};
	import_react.useEffect(() => cleanup$1, []);
	return [state, setDelayState];
}

//#endregion
//#region node_modules/antd/es/slider/index.js
var import_classnames$124 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$65 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function getTipFormatter(tipFormatter, legacyTipFormatter) {
	if (tipFormatter || tipFormatter === null) return tipFormatter;
	if (legacyTipFormatter || legacyTipFormatter === null) return legacyTipFormatter;
	return (val) => typeof val === "number" ? val.toString() : "";
}
var Slider = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, range: range$1, className, rootClassName, style: style$1, disabled, tooltipPrefixCls: legacyTooltipPrefixCls, tipFormatter: legacyTipFormatter, tooltipVisible: legacyTooltipVisible, getTooltipPopupContainer: legacyGetTooltipPopupContainer, tooltipPlacement: legacyTooltipPlacement, tooltip = {}, onChangeComplete, classNames: sliderClassNames, styles } = props, restProps = __rest$65(props, [
		"prefixCls",
		"range",
		"className",
		"rootClassName",
		"style",
		"disabled",
		"tooltipPrefixCls",
		"tipFormatter",
		"tooltipVisible",
		"getTooltipPopupContainer",
		"tooltipPlacement",
		"tooltip",
		"onChangeComplete",
		"classNames",
		"styles"
	]);
	const { vertical } = props;
	const { getPrefixCls, direction: contextDirection, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles, getPopupContainer } = useComponentConfig("slider");
	const contextDisabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = disabled !== null && disabled !== void 0 ? disabled : contextDisabled;
	const { handleRender: contextHandleRender, direction: internalContextDirection } = import_react.useContext(Context_default);
	const isRTL = (internalContextDirection || contextDirection) === "rtl";
	const [hoverOpen, setHoverOpen] = useRafLock();
	const [focusOpen, setFocusOpen] = useRafLock();
	const tooltipProps = Object.assign({}, tooltip);
	const { open: tooltipOpen, placement: tooltipPlacement, getPopupContainer: getTooltipPopupContainer, prefixCls: customizeTooltipPrefixCls, formatter: tipFormatter } = tooltipProps;
	const lockOpen = tooltipOpen !== null && tooltipOpen !== void 0 ? tooltipOpen : legacyTooltipVisible;
	const activeOpen = (hoverOpen || focusOpen) && lockOpen !== false;
	const mergedTipFormatter = getTipFormatter(tipFormatter, legacyTipFormatter);
	const [dragging, setDragging] = useRafLock();
	const onInternalChangeComplete = (nextValues) => {
		onChangeComplete === null || onChangeComplete === void 0 || onChangeComplete(nextValues);
		setDragging(false);
	};
	const getTooltipPlacement = (placement, vert) => {
		if (placement) return placement;
		if (!vert) return "top";
		return isRTL ? "left" : "right";
	};
	const prefixCls = getPrefixCls("slider", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$34(prefixCls);
	const rootClassNames = (0, import_classnames$124.default)(className, contextClassName, contextClassNames.root, sliderClassNames === null || sliderClassNames === void 0 ? void 0 : sliderClassNames.root, rootClassName, {
		[`${prefixCls}-rtl`]: isRTL,
		[`${prefixCls}-lock`]: dragging
	}, hashId, cssVarCls);
	if (isRTL && !restProps.vertical) restProps.reverse = !restProps.reverse;
	{
		const warning$4 = devUseWarning("Slider");
		[
			["tooltipPrefixCls", "prefixCls"],
			["getTooltipPopupContainer", "getPopupContainer"],
			["tipFormatter", "formatter"],
			["tooltipPlacement", "placement"],
			["tooltipVisible", "open"]
		].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in props), deprecatedName, `tooltip.${newName}`);
		});
	}
	import_react.useEffect(() => {
		const onMouseUp = () => {
			raf_default(() => {
				setFocusOpen(false);
			}, 1);
		};
		document.addEventListener("mouseup", onMouseUp);
		return () => {
			document.removeEventListener("mouseup", onMouseUp);
		};
	}, []);
	const useActiveTooltipHandle = range$1 && !lockOpen;
	const handleRender = contextHandleRender || ((node$1, info) => {
		const { index: index$2 } = info;
		const nodeProps = node$1.props;
		function proxyEvent(eventName, event, triggerRestPropsEvent) {
			var _a, _b, _c, _d;
			if (triggerRestPropsEvent) (_b = (_a = restProps)[eventName]) === null || _b === void 0 || _b.call(_a, event);
			(_d = (_c = nodeProps)[eventName]) === null || _d === void 0 || _d.call(_c, event);
		}
		const passedProps = Object.assign(Object.assign({}, nodeProps), {
			onMouseEnter: (e$2) => {
				setHoverOpen(true);
				proxyEvent("onMouseEnter", e$2);
			},
			onMouseLeave: (e$2) => {
				setHoverOpen(false);
				proxyEvent("onMouseLeave", e$2);
			},
			onMouseDown: (e$2) => {
				setFocusOpen(true);
				setDragging(true);
				proxyEvent("onMouseDown", e$2);
			},
			onFocus: (e$2) => {
				var _a;
				setFocusOpen(true);
				(_a = restProps.onFocus) === null || _a === void 0 || _a.call(restProps, e$2);
				proxyEvent("onFocus", e$2, true);
			},
			onBlur: (e$2) => {
				var _a;
				setFocusOpen(false);
				(_a = restProps.onBlur) === null || _a === void 0 || _a.call(restProps, e$2);
				proxyEvent("onBlur", e$2, true);
			}
		});
		const cloneNode = /* @__PURE__ */ import_react.cloneElement(node$1, passedProps);
		const open$2 = (!!lockOpen || activeOpen) && mergedTipFormatter !== null;
		if (!useActiveTooltipHandle) return /* @__PURE__ */ import_react.createElement(SliderTooltip_default, Object.assign({}, tooltipProps, {
			prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls !== null && customizeTooltipPrefixCls !== void 0 ? customizeTooltipPrefixCls : legacyTooltipPrefixCls),
			title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
			value: info.value,
			open: open$2,
			placement: getTooltipPlacement(tooltipPlacement !== null && tooltipPlacement !== void 0 ? tooltipPlacement : legacyTooltipPlacement, vertical),
			key: index$2,
			classNames: { root: `${prefixCls}-tooltip` },
			getPopupContainer: getTooltipPopupContainer || legacyGetTooltipPopupContainer || getPopupContainer
		}), cloneNode);
		return cloneNode;
	});
	const activeHandleRender = useActiveTooltipHandle ? (handle, info) => {
		const cloneNode = /* @__PURE__ */ import_react.cloneElement(handle, { style: Object.assign(Object.assign({}, handle.props.style), { visibility: "hidden" }) });
		return /* @__PURE__ */ import_react.createElement(SliderTooltip_default, Object.assign({}, tooltipProps, {
			prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls !== null && customizeTooltipPrefixCls !== void 0 ? customizeTooltipPrefixCls : legacyTooltipPrefixCls),
			title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
			open: mergedTipFormatter !== null && activeOpen,
			placement: getTooltipPlacement(tooltipPlacement !== null && tooltipPlacement !== void 0 ? tooltipPlacement : legacyTooltipPlacement, vertical),
			key: "tooltip",
			classNames: { root: `${prefixCls}-tooltip` },
			getPopupContainer: getTooltipPopupContainer || legacyGetTooltipPopupContainer || getPopupContainer,
			draggingDelete: info.draggingDelete
		}), cloneNode);
	} : void 0;
	const rootStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), contextStyle), styles === null || styles === void 0 ? void 0 : styles.root), style$1);
	const mergedTracks = Object.assign(Object.assign({}, contextStyles.tracks), styles === null || styles === void 0 ? void 0 : styles.tracks);
	const mergedTracksClassNames = (0, import_classnames$124.default)(contextClassNames.tracks, sliderClassNames === null || sliderClassNames === void 0 ? void 0 : sliderClassNames.tracks);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$21, Object.assign({}, restProps, {
		classNames: Object.assign({
			handle: (0, import_classnames$124.default)(contextClassNames.handle, sliderClassNames === null || sliderClassNames === void 0 ? void 0 : sliderClassNames.handle),
			rail: (0, import_classnames$124.default)(contextClassNames.rail, sliderClassNames === null || sliderClassNames === void 0 ? void 0 : sliderClassNames.rail),
			track: (0, import_classnames$124.default)(contextClassNames.track, sliderClassNames === null || sliderClassNames === void 0 ? void 0 : sliderClassNames.track)
		}, mergedTracksClassNames ? { tracks: mergedTracksClassNames } : {}),
		styles: Object.assign({
			handle: Object.assign(Object.assign({}, contextStyles.handle), styles === null || styles === void 0 ? void 0 : styles.handle),
			rail: Object.assign(Object.assign({}, contextStyles.rail), styles === null || styles === void 0 ? void 0 : styles.rail),
			track: Object.assign(Object.assign({}, contextStyles.track), styles === null || styles === void 0 ? void 0 : styles.track)
		}, Object.keys(mergedTracks).length ? { tracks: mergedTracks } : {}),
		step: restProps.step,
		range: range$1,
		className: rootClassNames,
		style: rootStyle,
		disabled: mergedDisabled,
		ref,
		prefixCls,
		handleRender,
		activeHandleRender,
		onChangeComplete: onInternalChangeComplete
	})));
});
Slider.displayName = "Slider";
var slider_default = Slider;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorSlider.js
var import_classnames$123 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$64 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const GradientColorSlider = (props) => {
	const { prefixCls, colors, type: type$2, color, range: range$1 = false, className, activeIndex, onActive, onDragStart, onDragChange, onKeyDelete } = props, restProps = __rest$64(props, [
		"prefixCls",
		"colors",
		"type",
		"color",
		"range",
		"className",
		"activeIndex",
		"onActive",
		"onDragStart",
		"onDragChange",
		"onKeyDelete"
	]);
	const sliderProps = Object.assign(Object.assign({}, restProps), { track: false });
	const linearCss = import_react.useMemo(() => {
		return `linear-gradient(90deg, ${colors.map((c) => `${c.color} ${c.percent}%`).join(", ")})`;
	}, [colors]);
	const pointColor = import_react.useMemo(() => {
		if (!color || !type$2) return null;
		if (type$2 === "alpha") return color.toRgbString();
		return `hsl(${color.toHsb().h}, 100%, 50%)`;
	}, [color, type$2]);
	const onInternalDragStart = useEvent(onDragStart);
	const onInternalDragChange = useEvent(onDragChange);
	const unstableContext = import_react.useMemo(() => ({
		onDragStart: onInternalDragStart,
		onDragChange: onInternalDragChange
	}), []);
	const handleRender = useEvent((ori, info) => {
		const { onFocus, style: style$1, className: handleCls, onKeyDown: onKeyDown$1 } = ori.props;
		const mergedStyle = Object.assign({}, style$1);
		if (type$2 === "gradient") mergedStyle.background = getGradientPercentColor(colors, info.value);
		return /* @__PURE__ */ import_react.cloneElement(ori, {
			onFocus: (e$2) => {
				onActive === null || onActive === void 0 || onActive(info.index);
				onFocus === null || onFocus === void 0 || onFocus(e$2);
			},
			style: mergedStyle,
			className: (0, import_classnames$123.default)(handleCls, { [`${prefixCls}-slider-handle-active`]: activeIndex === info.index }),
			onKeyDown: (e$2) => {
				if ((e$2.key === "Delete" || e$2.key === "Backspace") && onKeyDelete) onKeyDelete(info.index);
				onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(e$2);
			}
		});
	});
	const sliderContext = import_react.useMemo(() => ({
		direction: "ltr",
		handleRender
	}), []);
	return /* @__PURE__ */ import_react.createElement(Context_default.Provider, { value: sliderContext }, /* @__PURE__ */ import_react.createElement(UnstableContext$1.Provider, { value: unstableContext }, /* @__PURE__ */ import_react.createElement(slider_default, Object.assign({}, sliderProps, {
		className: (0, import_classnames$123.default)(className, `${prefixCls}-slider`),
		tooltip: { open: false },
		range: {
			editable: range$1,
			minCount: 2
		},
		styles: {
			rail: { background: linearCss },
			handle: pointColor ? { background: pointColor } : {}
		},
		classNames: {
			rail: `${prefixCls}-slider-rail`,
			handle: `${prefixCls}-slider-handle`
		}
	}))));
};
var SingleColorSlider = (props) => {
	const { value, onChange, onChangeComplete } = props;
	const singleOnChange = (v) => onChange(v[0]);
	const singleOnChangeComplete = (v) => onChangeComplete(v[0]);
	return /* @__PURE__ */ import_react.createElement(GradientColorSlider, Object.assign({}, props, {
		value: [value],
		onChange: singleOnChange,
		onChangeComplete: singleOnChangeComplete
	}));
};
var ColorSlider_default = SingleColorSlider;

//#endregion
//#region node_modules/antd/es/color-picker/components/PanelPicker/GradientColorBar.js
function sortColors(colors) {
	return _toConsumableArray(colors).sort((a, b) => a.percent - b.percent);
}
/**
* GradientColorBar will auto show when the mode is `gradient`.
*/
var GradientColorBar = (props) => {
	const { prefixCls, mode, onChange, onChangeComplete, onActive, activeIndex, onGradientDragging, colors } = props;
	const isGradient = mode === "gradient";
	const colorList = import_react.useMemo(() => colors.map((info) => ({
		percent: info.percent,
		color: info.color.toRgbString()
	})), [colors]);
	const values = import_react.useMemo(() => colorList.map((info) => info.percent), [colorList]);
	const colorsRef = import_react.useRef(colorList);
	const onDragStart = ({ rawValues, draggingIndex, draggingValue }) => {
		if (rawValues.length > colorList.length) {
			const newPointColor = getGradientPercentColor(colorList, draggingValue);
			const nextColors = _toConsumableArray(colorList);
			nextColors.splice(draggingIndex, 0, {
				percent: draggingValue,
				color: newPointColor
			});
			colorsRef.current = nextColors;
		} else colorsRef.current = colorList;
		onGradientDragging(true);
		onChange(new AggregationColor(sortColors(colorsRef.current)), true);
	};
	const onDragChange = ({ deleteIndex, draggingIndex, draggingValue }) => {
		let nextColors = _toConsumableArray(colorsRef.current);
		if (deleteIndex !== -1) nextColors.splice(deleteIndex, 1);
		else {
			nextColors[draggingIndex] = Object.assign(Object.assign({}, nextColors[draggingIndex]), { percent: draggingValue });
			nextColors = sortColors(nextColors);
		}
		onChange(new AggregationColor(nextColors), true);
	};
	const onKeyDelete = (index$2) => {
		const nextColors = _toConsumableArray(colorList);
		nextColors.splice(index$2, 1);
		const nextColor = new AggregationColor(nextColors);
		onChange(nextColor);
		onChangeComplete(nextColor);
	};
	const onInternalChangeComplete = (nextValues) => {
		onChangeComplete(new AggregationColor(colorList));
		if (activeIndex >= nextValues.length) onActive(nextValues.length - 1);
		onGradientDragging(false);
	};
	if (!isGradient) return null;
	return /* @__PURE__ */ import_react.createElement(GradientColorSlider, {
		min: 0,
		max: 100,
		prefixCls,
		className: `${prefixCls}-gradient-slider`,
		colors: colorList,
		color: null,
		value: values,
		range: true,
		onChangeComplete: onInternalChangeComplete,
		disabled: false,
		type: "gradient",
		activeIndex,
		onActive,
		onDragStart,
		onDragChange,
		onKeyDelete
	});
};
var GradientColorBar_default = /* @__PURE__ */ import_react.memo(GradientColorBar);

//#endregion
//#region node_modules/antd/es/color-picker/components/PanelPicker/index.js
var __rest$63 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var components = { slider: ColorSlider_default };
var PanelPicker = () => {
	const panelPickerContext = (0, import_react.useContext)(PanelPickerContext);
	const { mode, onModeChange, modeOptions, prefixCls, allowClear, value, disabledAlpha, onChange, onClear, onChangeComplete, activeIndex, gradientDragging } = panelPickerContext, injectProps = __rest$63(panelPickerContext, [
		"mode",
		"onModeChange",
		"modeOptions",
		"prefixCls",
		"allowClear",
		"value",
		"disabledAlpha",
		"onChange",
		"onClear",
		"onChangeComplete",
		"activeIndex",
		"gradientDragging"
	]);
	const colors = import_react.useMemo(() => {
		if (!value.cleared) return value.getColors();
		return [{
			percent: 0,
			color: new AggregationColor("")
		}, {
			percent: 100,
			color: new AggregationColor("")
		}];
	}, [value]);
	const isSingle = !value.isGradient();
	const [lockedColor, setLockedColor] = import_react.useState(value);
	useLayoutEffect_default(() => {
		var _a;
		if (!isSingle) setLockedColor((_a = colors[activeIndex]) === null || _a === void 0 ? void 0 : _a.color);
	}, [gradientDragging, activeIndex]);
	const activeColor = import_react.useMemo(() => {
		var _a;
		if (isSingle) return value;
		if (gradientDragging) return lockedColor;
		return (_a = colors[activeIndex]) === null || _a === void 0 ? void 0 : _a.color;
	}, [
		value,
		activeIndex,
		isSingle,
		lockedColor,
		gradientDragging
	]);
	const [pickerColor, setPickerColor] = import_react.useState(activeColor);
	const [forceSync, setForceSync] = import_react.useState(0);
	const mergedPickerColor = (pickerColor === null || pickerColor === void 0 ? void 0 : pickerColor.equals(activeColor)) ? activeColor : pickerColor;
	useLayoutEffect_default(() => {
		setPickerColor(activeColor);
	}, [forceSync, activeColor === null || activeColor === void 0 ? void 0 : activeColor.toHexString()]);
	const fillColor = (nextColor, info) => {
		let submitColor = generateColor(nextColor);
		if (value.cleared) {
			const rgb = submitColor.toRgb();
			if (!rgb.r && !rgb.g && !rgb.b && info) {
				const { type: infoType, value: infoValue = 0 } = info;
				submitColor = new AggregationColor({
					h: infoType === "hue" ? infoValue : 0,
					s: 1,
					b: 1,
					a: infoType === "alpha" ? infoValue / 100 : 1
				});
			} else submitColor = genAlphaColor(submitColor);
		}
		if (mode === "single") return submitColor;
		const nextColors = _toConsumableArray(colors);
		nextColors[activeIndex] = Object.assign(Object.assign({}, nextColors[activeIndex]), { color: submitColor });
		return new AggregationColor(nextColors);
	};
	const onPickerChange = (colorValue, fromPicker, info) => {
		const nextColor = fillColor(colorValue, info);
		setPickerColor(nextColor.isGradient() ? nextColor.getColors()[activeIndex].color : nextColor);
		onChange(nextColor, fromPicker);
	};
	const onInternalChangeComplete = (nextColor, info) => {
		onChangeComplete(fillColor(nextColor, info));
		setForceSync((ori) => ori + 1);
	};
	const onInputChange = (colorValue) => {
		onChange(fillColor(colorValue));
	};
	let operationNode = null;
	const showMode = modeOptions.length > 1;
	if (allowClear || showMode) operationNode = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-operation` }, showMode && /* @__PURE__ */ import_react.createElement(segmented_default, {
		size: "small",
		options: modeOptions,
		value: mode,
		onChange: onModeChange
	}), /* @__PURE__ */ import_react.createElement(ColorClear_default, Object.assign({
		prefixCls,
		value,
		onChange: (clearColor) => {
			onChange(clearColor);
			onClear === null || onClear === void 0 || onClear();
		}
	}, injectProps)));
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, operationNode, /* @__PURE__ */ import_react.createElement(GradientColorBar_default, Object.assign({}, panelPickerContext, { colors })), /* @__PURE__ */ import_react.createElement(es_default$20, {
		prefixCls,
		value: mergedPickerColor === null || mergedPickerColor === void 0 ? void 0 : mergedPickerColor.toHsb(),
		disabledAlpha,
		onChange: (colorValue, info) => {
			onPickerChange(colorValue, true, info);
		},
		onChangeComplete: (colorValue, info) => {
			onInternalChangeComplete(colorValue, info);
		},
		components
	}), /* @__PURE__ */ import_react.createElement(ColorInput_default, Object.assign({
		value: activeColor,
		onChange: onInputChange,
		prefixCls,
		disabledAlpha
	}, injectProps)));
};
var PanelPicker_default = PanelPicker;

//#endregion
//#region node_modules/antd/es/color-picker/components/PanelPresets.js
var PanelPresets = () => {
	const { prefixCls, value, presets, onChange } = (0, import_react.useContext)(PanelPresetsContext);
	return Array.isArray(presets) ? /* @__PURE__ */ import_react.createElement(ColorPresets_default, {
		value,
		presets,
		prefixCls,
		onChange
	}) : null;
};
var PanelPresets_default = PanelPresets;

//#endregion
//#region node_modules/antd/es/color-picker/ColorPickerPanel.js
var ColorPickerPanel = (props) => {
	const { prefixCls, presets, panelRender, value, onChange, onClear, allowClear, disabledAlpha, mode, onModeChange, modeOptions, onChangeComplete, activeIndex, onActive, format: format$2, onFormatChange, gradientDragging, onGradientDragging, disabledFormat } = props;
	const colorPickerPanelPrefixCls = `${prefixCls}-inner`;
	const panelContext = import_react.useMemo(() => ({
		prefixCls,
		value,
		onChange,
		onClear,
		allowClear,
		disabledAlpha,
		mode,
		onModeChange,
		modeOptions,
		onChangeComplete,
		activeIndex,
		onActive,
		format: format$2,
		onFormatChange,
		gradientDragging,
		onGradientDragging,
		disabledFormat
	}), [
		prefixCls,
		value,
		onChange,
		onClear,
		allowClear,
		disabledAlpha,
		mode,
		onModeChange,
		modeOptions,
		onChangeComplete,
		activeIndex,
		onActive,
		format$2,
		onFormatChange,
		gradientDragging,
		onGradientDragging,
		disabledFormat
	]);
	const presetContext = import_react.useMemo(() => ({
		prefixCls,
		value,
		presets,
		onChange
	}), [
		prefixCls,
		value,
		presets,
		onChange
	]);
	const innerPanel = /* @__PURE__ */ import_react.createElement("div", { className: `${colorPickerPanelPrefixCls}-content` }, /* @__PURE__ */ import_react.createElement(PanelPicker_default, null), Array.isArray(presets) && /* @__PURE__ */ import_react.createElement(divider_default, null), /* @__PURE__ */ import_react.createElement(PanelPresets_default, null));
	return /* @__PURE__ */ import_react.createElement(PanelPickerContext.Provider, { value: panelContext }, /* @__PURE__ */ import_react.createElement(PanelPresetsContext.Provider, { value: presetContext }, /* @__PURE__ */ import_react.createElement("div", { className: colorPickerPanelPrefixCls }, typeof panelRender === "function" ? panelRender(innerPanel, { components: {
		Picker: PanelPicker_default,
		Presets: PanelPresets_default
	} }) : innerPanel)));
};
ColorPickerPanel.displayName = "ColorPickerPanel";
var ColorPickerPanel_default = ColorPickerPanel;

//#endregion
//#region node_modules/antd/es/color-picker/components/ColorTrigger.js
var import_classnames$122 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$62 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var ColorTrigger = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { color, prefixCls, open: open$2, disabled, format: format$2, className, showText, activeIndex } = props, rest = __rest$62(props, [
		"color",
		"prefixCls",
		"open",
		"disabled",
		"format",
		"className",
		"showText",
		"activeIndex"
	]);
	const colorTriggerPrefixCls = `${prefixCls}-trigger`;
	const colorTextPrefixCls = `${colorTriggerPrefixCls}-text`;
	const colorTextCellPrefixCls = `${colorTextPrefixCls}-cell`;
	const [locale$5] = useLocale_default("ColorPicker");
	const desc = import_react.useMemo(() => {
		if (!showText) return "";
		if (typeof showText === "function") return showText(color);
		if (color.cleared) return locale$5.transparent;
		if (color.isGradient()) return color.getColors().map((c, index$2) => {
			const inactive = activeIndex !== -1 && activeIndex !== index$2;
			return /* @__PURE__ */ import_react.createElement("span", {
				key: index$2,
				className: (0, import_classnames$122.default)(colorTextCellPrefixCls, inactive && `${colorTextCellPrefixCls}-inactive`)
			}, c.color.toRgbString(), " ", c.percent, "%");
		});
		const hexString = color.toHexString().toUpperCase();
		const alpha = getColorAlpha(color);
		switch (format$2) {
			case "rgb": return color.toRgbString();
			case "hsb": return color.toHsbString();
			default: return alpha < 100 ? `${hexString.slice(0, 7)},${alpha}%` : hexString;
		}
	}, [
		color,
		format$2,
		showText,
		activeIndex
	]);
	const containerNode = (0, import_react.useMemo)(() => color.cleared ? /* @__PURE__ */ import_react.createElement(ColorClear_default, { prefixCls }) : /* @__PURE__ */ import_react.createElement(ColorBlock_default, {
		prefixCls,
		color: color.toCssString()
	}), [color, prefixCls]);
	return /* @__PURE__ */ import_react.createElement("div", Object.assign({
		ref,
		className: (0, import_classnames$122.default)(colorTriggerPrefixCls, className, {
			[`${colorTriggerPrefixCls}-active`]: open$2,
			[`${colorTriggerPrefixCls}-disabled`]: disabled
		})
	}, pickAttrs(rest)), containerNode, showText && /* @__PURE__ */ import_react.createElement("div", { className: colorTextPrefixCls }, desc));
});
var ColorTrigger_default = ColorTrigger;

//#endregion
//#region node_modules/antd/es/color-picker/hooks/useModeColor.js
/**
* Combine the `color` and `mode` to make sure sync of state.
*/
function useModeColor(defaultValue, value, mode) {
	const [locale$5] = useLocale_default("ColorPicker");
	const [mergedColor, setMergedColor] = useMergedState(defaultValue, { value });
	const [modeState, setModeState] = import_react.useState("single");
	const [modeOptionList, modeSet] = import_react.useMemo(() => {
		const list = (Array.isArray(mode) ? mode : [mode]).filter((m) => m);
		if (!list.length) list.push("single");
		const modes = new Set(list);
		const optionList = [];
		const pushOption = (modeType, localeTxt) => {
			if (modes.has(modeType)) optionList.push({
				label: localeTxt,
				value: modeType
			});
		};
		pushOption("single", locale$5.singleColor);
		pushOption("gradient", locale$5.gradientColor);
		return [optionList, modes];
	}, [mode]);
	const [cacheColor, setCacheColor] = import_react.useState(null);
	const setColor = useEvent((nextColor) => {
		setCacheColor(nextColor);
		setMergedColor(nextColor);
	});
	const postColor = import_react.useMemo(() => {
		const colorObj = generateColor(mergedColor || "");
		return colorObj.equals(cacheColor) ? cacheColor : colorObj;
	}, [mergedColor, cacheColor]);
	const postMode = import_react.useMemo(() => {
		var _a;
		if (modeSet.has(modeState)) return modeState;
		return (_a = modeOptionList[0]) === null || _a === void 0 ? void 0 : _a.value;
	}, [
		modeSet,
		modeState,
		modeOptionList
	]);
	import_react.useEffect(() => {
		setModeState(postColor.isGradient() ? "gradient" : "single");
	}, [postColor]);
	return [
		postColor,
		setColor,
		postMode,
		setModeState,
		modeOptionList
	];
}

//#endregion
//#region node_modules/antd/es/color-picker/style/color-block.js
/**
* @private Internal usage only
* see: https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient#checkerboard
*/
const getTransBg = (size, colorFill) => ({
	backgroundImage: `conic-gradient(${colorFill} 25%, transparent 25% 50%, ${colorFill} 50% 75%, transparent 75% 100%)`,
	backgroundSize: `${size} ${size}`
});
var genColorBlockStyle = (token$1, size) => {
	const { componentCls, borderRadiusSM, colorPickerInsetShadow, lineWidth, colorFillSecondary } = token$1;
	return { [`${componentCls}-color-block`]: Object.assign(Object.assign({
		position: "relative",
		borderRadius: borderRadiusSM,
		width: size,
		height: size,
		boxShadow: colorPickerInsetShadow,
		flex: "none"
	}, getTransBg("50%", token$1.colorFillSecondary)), { [`${componentCls}-color-block-inner`]: {
		width: "100%",
		height: "100%",
		boxShadow: `inset 0 0 0 ${unit(lineWidth)} ${colorFillSecondary}`,
		borderRadius: "inherit"
	} }) };
};
var color_block_default = genColorBlockStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/input.js
var genInputStyle = (token$1) => {
	const { componentCls, antCls, fontSizeSM, lineHeightSM, colorPickerAlphaInputWidth, marginXXS, paddingXXS, controlHeightSM, marginXS, fontSizeIcon, paddingXS, colorTextPlaceholder, colorPickerInputNumberHandleWidth, lineWidth } = token$1;
	return { [`${componentCls}-input-container`]: {
		display: "flex",
		[`${componentCls}-steppers${antCls}-input-number`]: {
			fontSize: fontSizeSM,
			lineHeight: lineHeightSM,
			[`${antCls}-input-number-input`]: {
				paddingInlineStart: paddingXXS,
				paddingInlineEnd: 0
			},
			[`${antCls}-input-number-handler-wrap`]: { width: colorPickerInputNumberHandleWidth }
		},
		[`${componentCls}-steppers${componentCls}-alpha-input`]: {
			flex: `0 0 ${unit(colorPickerAlphaInputWidth)}`,
			marginInlineStart: marginXXS
		},
		[`${componentCls}-format-select${antCls}-select`]: {
			marginInlineEnd: marginXS,
			width: "auto",
			"&-single": {
				[`${antCls}-select-selector`]: {
					padding: 0,
					border: 0
				},
				[`${antCls}-select-arrow`]: { insetInlineEnd: 0 },
				[`${antCls}-select-selection-item`]: {
					paddingInlineEnd: token$1.calc(fontSizeIcon).add(marginXXS).equal(),
					fontSize: fontSizeSM,
					lineHeight: unit(controlHeightSM)
				},
				[`${antCls}-select-item-option-content`]: {
					fontSize: fontSizeSM,
					lineHeight: lineHeightSM
				},
				[`${antCls}-select-dropdown`]: { [`${antCls}-select-item`]: { minHeight: "auto" } }
			}
		},
		[`${componentCls}-input`]: {
			gap: marginXXS,
			alignItems: "center",
			flex: 1,
			width: 0,
			[`${componentCls}-hsb-input,${componentCls}-rgb-input`]: {
				display: "flex",
				gap: marginXXS,
				alignItems: "center"
			},
			[`${componentCls}-steppers`]: { flex: 1 },
			[`${componentCls}-hex-input${antCls}-input-affix-wrapper`]: {
				flex: 1,
				padding: `0 ${unit(paddingXS)}`,
				[`${antCls}-input`]: {
					fontSize: fontSizeSM,
					textTransform: "uppercase",
					lineHeight: unit(token$1.calc(controlHeightSM).sub(token$1.calc(lineWidth).mul(2)).equal())
				},
				[`${antCls}-input-prefix`]: { color: colorTextPlaceholder }
			}
		}
	} };
};
var input_default$1 = genInputStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/picker.js
var genPickerStyle = (token$1) => {
	const { componentCls, controlHeightLG, borderRadiusSM, colorPickerInsetShadow, marginSM, colorBgElevated, colorFillSecondary, lineWidthBold, colorPickerHandlerSize } = token$1;
	return {
		userSelect: "none",
		[`${componentCls}-select`]: {
			[`${componentCls}-palette`]: {
				minHeight: token$1.calc(controlHeightLG).mul(4).equal(),
				overflow: "hidden",
				borderRadius: borderRadiusSM
			},
			[`${componentCls}-saturation`]: {
				position: "absolute",
				borderRadius: "inherit",
				boxShadow: colorPickerInsetShadow,
				inset: 0
			},
			marginBottom: marginSM
		},
		[`${componentCls}-handler`]: {
			width: colorPickerHandlerSize,
			height: colorPickerHandlerSize,
			border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
			position: "relative",
			borderRadius: "50%",
			cursor: "pointer",
			boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`
		}
	};
};
var picker_default = genPickerStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/presets.js
var genPresetsStyle = (token$1) => {
	const { componentCls, antCls, colorTextQuaternary, paddingXXS, colorPickerPresetColorSize, fontSizeSM, colorText, lineHeightSM, lineWidth, borderRadius, colorFill, colorWhite, marginXXS, paddingXS, fontHeightSM } = token$1;
	return { [`${componentCls}-presets`]: {
		[`${antCls}-collapse-item > ${antCls}-collapse-header`]: {
			padding: 0,
			[`${antCls}-collapse-expand-icon`]: {
				height: fontHeightSM,
				color: colorTextQuaternary,
				paddingInlineEnd: paddingXXS
			}
		},
		[`${antCls}-collapse`]: {
			display: "flex",
			flexDirection: "column",
			gap: marginXXS
		},
		[`${antCls}-collapse-item > ${antCls}-collapse-content > ${antCls}-collapse-content-box`]: { padding: `${unit(paddingXS)} 0` },
		"&-label": {
			fontSize: fontSizeSM,
			color: colorText,
			lineHeight: lineHeightSM
		},
		"&-items": {
			display: "flex",
			flexWrap: "wrap",
			gap: token$1.calc(marginXXS).mul(1.5).equal(),
			[`${componentCls}-presets-color`]: {
				position: "relative",
				cursor: "pointer",
				width: colorPickerPresetColorSize,
				height: colorPickerPresetColorSize,
				"&::before": {
					content: "\"\"",
					pointerEvents: "none",
					width: token$1.calc(colorPickerPresetColorSize).add(token$1.calc(lineWidth).mul(4)).equal(),
					height: token$1.calc(colorPickerPresetColorSize).add(token$1.calc(lineWidth).mul(4)).equal(),
					position: "absolute",
					top: token$1.calc(lineWidth).mul(-2).equal(),
					insetInlineStart: token$1.calc(lineWidth).mul(-2).equal(),
					borderRadius,
					border: `${unit(lineWidth)} solid transparent`,
					transition: `border-color ${token$1.motionDurationMid} ${token$1.motionEaseInBack}`
				},
				"&:hover::before": { borderColor: colorFill },
				"&::after": {
					boxSizing: "border-box",
					position: "absolute",
					top: "50%",
					insetInlineStart: "21.5%",
					display: "table",
					width: token$1.calc(colorPickerPresetColorSize).div(13).mul(5).equal(),
					height: token$1.calc(colorPickerPresetColorSize).div(13).mul(8).equal(),
					border: `${unit(token$1.lineWidthBold)} solid ${token$1.colorWhite}`,
					borderTop: 0,
					borderInlineStart: 0,
					transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
					opacity: 0,
					content: "\"\"",
					transition: `all ${token$1.motionDurationFast} ${token$1.motionEaseInBack}, opacity ${token$1.motionDurationFast}`
				},
				[`&${componentCls}-presets-color-checked`]: {
					"&::after": {
						opacity: 1,
						borderColor: colorWhite,
						transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
						transition: `transform ${token$1.motionDurationMid} ${token$1.motionEaseOutBack} ${token$1.motionDurationFast}`
					},
					[`&${componentCls}-presets-color-bright`]: { "&::after": { borderColor: "rgba(0, 0, 0, 0.45)" } }
				}
			}
		},
		"&-empty": {
			fontSize: fontSizeSM,
			color: colorTextQuaternary
		}
	} };
};
var presets_default = genPresetsStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/slider.js
var genSliderStyle = (token$1) => {
	const { componentCls, colorPickerInsetShadow, colorBgElevated, colorFillSecondary, lineWidthBold, colorPickerHandlerSizeSM, colorPickerSliderHeight, marginSM, marginXS } = token$1;
	const handleInnerSize = token$1.calc(colorPickerHandlerSizeSM).sub(token$1.calc(lineWidthBold).mul(2).equal()).equal();
	const handleHoverSize = token$1.calc(colorPickerHandlerSizeSM).add(token$1.calc(lineWidthBold).mul(2).equal()).equal();
	const activeHandleStyle = { "&:after": {
		transform: "scale(1)",
		boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${token$1.colorPrimaryActive}`
	} };
	return {
		[`${componentCls}-slider`]: [getTransBg(unit(colorPickerSliderHeight), token$1.colorFillSecondary), {
			margin: 0,
			padding: 0,
			height: colorPickerSliderHeight,
			borderRadius: token$1.calc(colorPickerSliderHeight).div(2).equal(),
			"&-rail": {
				height: colorPickerSliderHeight,
				borderRadius: token$1.calc(colorPickerSliderHeight).div(2).equal(),
				boxShadow: colorPickerInsetShadow
			},
			[`& ${componentCls}-slider-handle`]: {
				width: handleInnerSize,
				height: handleInnerSize,
				top: 0,
				borderRadius: "100%",
				"&:before": {
					display: "block",
					position: "absolute",
					background: "transparent",
					left: {
						_skip_check_: true,
						value: "50%"
					},
					top: "50%",
					transform: "translate(-50%, -50%)",
					width: handleHoverSize,
					height: handleHoverSize,
					borderRadius: "100%"
				},
				"&:after": {
					width: colorPickerHandlerSizeSM,
					height: colorPickerHandlerSizeSM,
					border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
					boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`,
					outline: "none",
					insetInlineStart: token$1.calc(lineWidthBold).mul(-1).equal(),
					top: token$1.calc(lineWidthBold).mul(-1).equal(),
					background: "transparent",
					transition: "none"
				},
				"&:focus": activeHandleStyle
			}
		}],
		[`${componentCls}-slider-container`]: {
			display: "flex",
			gap: marginSM,
			marginBottom: marginSM,
			[`${componentCls}-slider-group`]: {
				flex: 1,
				flexDirection: "column",
				justifyContent: "space-between",
				display: "flex",
				"&-disabled-alpha": { justifyContent: "center" }
			}
		},
		[`${componentCls}-gradient-slider`]: {
			marginBottom: marginXS,
			[`& ${componentCls}-slider-handle`]: {
				"&:after": { transform: "scale(0.8)" },
				"&-active, &:focus": activeHandleStyle
			}
		}
	};
};
var slider_default$1 = genSliderStyle;

//#endregion
//#region node_modules/antd/es/color-picker/style/index.js
const genActiveStyle = (token$1, borderColor, outlineColor) => ({
	borderInlineEndWidth: token$1.lineWidth,
	borderColor,
	boxShadow: `0 0 0 ${unit(token$1.controlOutlineWidth)} ${outlineColor}`,
	outline: 0
});
var genRtlStyle$2 = (token$1) => {
	const { componentCls } = token$1;
	return { "&-rtl": {
		[`${componentCls}-presets-color`]: { "&::after": { direction: "ltr" } },
		[`${componentCls}-clear`]: { "&::after": { direction: "ltr" } }
	} };
};
var genClearStyle = (token$1, size, extraStyle) => {
	const { componentCls, borderRadiusSM, lineWidth, colorSplit, colorBorder, red6 } = token$1;
	return { [`${componentCls}-clear`]: Object.assign(Object.assign({
		width: size,
		height: size,
		borderRadius: borderRadiusSM,
		border: `${unit(lineWidth)} solid ${colorSplit}`,
		position: "relative",
		overflow: "hidden",
		cursor: "inherit",
		transition: `all ${token$1.motionDurationFast}`
	}, extraStyle), {
		"&::after": {
			content: "\"\"",
			position: "absolute",
			insetInlineEnd: token$1.calc(lineWidth).mul(-1).equal(),
			top: token$1.calc(lineWidth).mul(-1).equal(),
			display: "block",
			width: 40,
			height: 2,
			transformOrigin: `calc(100% - 1px) 1px`,
			transform: "rotate(-45deg)",
			backgroundColor: red6
		},
		"&:hover": { borderColor: colorBorder }
	}) };
};
var genStatusStyle = (token$1) => {
	const { componentCls, colorError, colorWarning, colorErrorHover, colorWarningHover, colorErrorOutline, colorWarningOutline } = token$1;
	return {
		[`&${componentCls}-status-error`]: {
			borderColor: colorError,
			"&:hover": { borderColor: colorErrorHover },
			[`&${componentCls}-trigger-active`]: Object.assign({}, genActiveStyle(token$1, colorError, colorErrorOutline))
		},
		[`&${componentCls}-status-warning`]: {
			borderColor: colorWarning,
			"&:hover": { borderColor: colorWarningHover },
			[`&${componentCls}-trigger-active`]: Object.assign({}, genActiveStyle(token$1, colorWarning, colorWarningOutline))
		}
	};
};
var genSizeStyle$1 = (token$1) => {
	const { componentCls, controlHeightLG, controlHeightSM, controlHeight, controlHeightXS, borderRadius, borderRadiusSM, borderRadiusXS, borderRadiusLG, fontSizeLG } = token$1;
	return {
		[`&${componentCls}-lg`]: {
			minWidth: controlHeightLG,
			minHeight: controlHeightLG,
			borderRadius: borderRadiusLG,
			[`${componentCls}-color-block, ${componentCls}-clear`]: {
				width: controlHeight,
				height: controlHeight,
				borderRadius
			},
			[`${componentCls}-trigger-text`]: { fontSize: fontSizeLG }
		},
		[`&${componentCls}-sm`]: {
			minWidth: controlHeightSM,
			minHeight: controlHeightSM,
			borderRadius: borderRadiusSM,
			[`${componentCls}-color-block, ${componentCls}-clear`]: {
				width: controlHeightXS,
				height: controlHeightXS,
				borderRadius: borderRadiusXS
			},
			[`${componentCls}-trigger-text`]: { lineHeight: unit(controlHeightXS) }
		}
	};
};
var genColorPickerStyle = (token$1) => {
	const { antCls, componentCls, colorPickerWidth, colorPrimary, motionDurationMid, colorBgElevated, colorTextDisabled, colorText, colorBgContainerDisabled, borderRadius, marginXS, marginSM, controlHeight, controlHeightSM, colorBgTextActive, colorPickerPresetColorSize, colorPickerPreviewSize, lineWidth, colorBorder, paddingXXS, fontSize, colorPrimaryHover, controlOutline } = token$1;
	return [{ [componentCls]: Object.assign({
		[`${componentCls}-inner`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
			"&-content": {
				display: "flex",
				flexDirection: "column",
				width: colorPickerWidth,
				[`& > ${antCls}-divider`]: { margin: `${unit(marginSM)} 0 ${unit(marginXS)}` }
			},
			[`${componentCls}-panel`]: Object.assign({}, picker_default(token$1))
		}, slider_default$1(token$1)), color_block_default(token$1, colorPickerPreviewSize)), input_default$1(token$1)), presets_default(token$1)), genClearStyle(token$1, colorPickerPresetColorSize, { marginInlineStart: "auto" })), { [`${componentCls}-operation`]: {
			display: "flex",
			justifyContent: "space-between",
			marginBottom: marginXS
		} }),
		"&-trigger": Object.assign(Object.assign(Object.assign(Object.assign({
			minWidth: controlHeight,
			minHeight: controlHeight,
			borderRadius,
			border: `${unit(lineWidth)} solid ${colorBorder}`,
			cursor: "pointer",
			display: "inline-flex",
			alignItems: "flex-start",
			justifyContent: "center",
			transition: `all ${motionDurationMid}`,
			background: colorBgElevated,
			padding: token$1.calc(paddingXXS).sub(lineWidth).equal(),
			[`${componentCls}-trigger-text`]: {
				marginInlineStart: marginXS,
				marginInlineEnd: token$1.calc(marginXS).sub(token$1.calc(paddingXXS).sub(lineWidth)).equal(),
				fontSize,
				color: colorText,
				alignSelf: "center",
				"&-cell": {
					"&:not(:last-child):after": { content: "\", \"" },
					"&-inactive": { color: colorTextDisabled }
				}
			},
			"&:hover": { borderColor: colorPrimaryHover },
			[`&${componentCls}-trigger-active`]: Object.assign({}, genActiveStyle(token$1, colorPrimary, controlOutline)),
			"&-disabled": {
				color: colorTextDisabled,
				background: colorBgContainerDisabled,
				cursor: "not-allowed",
				"&:hover": { borderColor: colorBgTextActive },
				[`${componentCls}-trigger-text`]: { color: colorTextDisabled }
			}
		}, genClearStyle(token$1, controlHeightSM)), color_block_default(token$1, controlHeightSM)), genStatusStyle(token$1)), genSizeStyle$1(token$1))
	}, genRtlStyle$2(token$1)) }, genCompactItemStyle(token$1, { focusElCls: `${componentCls}-trigger-active` })];
};
var style_default$33 = genStyleHooks("ColorPicker", (token$1) => {
	const { colorTextQuaternary, marginSM } = token$1;
	const colorPickerSliderHeight = 8;
	const colorPickerToken = merge(token$1, {
		colorPickerWidth: 234,
		colorPickerHandlerSize: 16,
		colorPickerHandlerSizeSM: 12,
		colorPickerAlphaInputWidth: 44,
		colorPickerInputNumberHandleWidth: 16,
		colorPickerPresetColorSize: 24,
		colorPickerInsetShadow: `inset 0 0 1px 0 ${colorTextQuaternary}`,
		colorPickerSliderHeight,
		colorPickerPreviewSize: token$1.calc(colorPickerSliderHeight).mul(2).add(marginSM).equal()
	});
	return genColorPickerStyle(colorPickerToken);
});

//#endregion
//#region node_modules/antd/es/color-picker/ColorPicker.js
var import_classnames$121 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$61 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var ColorPicker = (props) => {
	const { mode, value, defaultValue, format: format$2, defaultFormat, allowClear = false, presets, children, trigger = "click", open: open$2, disabled, placement = "bottomLeft", arrow = true, panelRender, showText, style: style$1, className, size: customizeSize, rootClassName, prefixCls: customizePrefixCls, styles, disabledAlpha = false, onFormatChange, onChange, onClear, onOpenChange, onChangeComplete, getPopupContainer, autoAdjustOverflow: autoAdjustOverflow$2 = true, destroyTooltipOnHide, destroyOnHidden, disabledFormat } = props, rest = __rest$61(props, [
		"mode",
		"value",
		"defaultValue",
		"format",
		"defaultFormat",
		"allowClear",
		"presets",
		"children",
		"trigger",
		"open",
		"disabled",
		"placement",
		"arrow",
		"panelRender",
		"showText",
		"style",
		"className",
		"size",
		"rootClassName",
		"prefixCls",
		"styles",
		"disabledAlpha",
		"onFormatChange",
		"onChange",
		"onClear",
		"onOpenChange",
		"onChangeComplete",
		"getPopupContainer",
		"autoAdjustOverflow",
		"destroyTooltipOnHide",
		"destroyOnHidden",
		"disabledFormat"
	]);
	const { getPrefixCls, direction, colorPicker } = (0, import_react.useContext)(ConfigContext);
	const contextDisabled = (0, import_react.useContext)(DisabledContext_default);
	const mergedDisabled = disabled !== null && disabled !== void 0 ? disabled : contextDisabled;
	const [popupOpen, setPopupOpen] = useMergedState(false, {
		value: open$2,
		postState: (openData) => !mergedDisabled && openData,
		onChange: onOpenChange
	});
	const [formatValue$1, setFormatValue] = useMergedState(format$2, {
		value: format$2,
		defaultValue: defaultFormat,
		onChange: onFormatChange
	});
	const prefixCls = getPrefixCls("color-picker", customizePrefixCls);
	const [mergedColor, setColor, modeState, setModeState, modeOptions] = useModeColor(defaultValue, value, mode);
	const isAlphaColor = (0, import_react.useMemo)(() => getColorAlpha(mergedColor) < 100, [mergedColor]);
	const [cachedGradientColor, setCachedGradientColor] = import_react.useState(null);
	const onInternalChangeComplete = (color) => {
		if (onChangeComplete) {
			let changeColor = generateColor(color);
			if (disabledAlpha && isAlphaColor) changeColor = genAlphaColor(color);
			onChangeComplete(changeColor);
		}
	};
	const onInternalChange = (data, changeFromPickerDrag) => {
		let color = generateColor(data);
		if (disabledAlpha && isAlphaColor) color = genAlphaColor(color);
		setColor(color);
		setCachedGradientColor(null);
		if (onChange) onChange(color, color.toCssString());
		if (!changeFromPickerDrag) onInternalChangeComplete(color);
	};
	const [activeIndex, setActiveIndex] = import_react.useState(0);
	const [gradientDragging, setGradientDragging] = import_react.useState(false);
	const onInternalModeChange = (newMode) => {
		setModeState(newMode);
		if (newMode === "single" && mergedColor.isGradient()) {
			setActiveIndex(0);
			onInternalChange(new AggregationColor(mergedColor.getColors()[0].color));
			setCachedGradientColor(mergedColor);
		} else if (newMode === "gradient" && !mergedColor.isGradient()) {
			const baseColor = isAlphaColor ? genAlphaColor(mergedColor) : mergedColor;
			onInternalChange(new AggregationColor(cachedGradientColor || [{
				percent: 0,
				color: baseColor
			}, {
				percent: 100,
				color: baseColor
			}]));
		}
	};
	const { status: contextStatus } = import_react.useContext(FormItemInputContext);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const mergedSize = useSize_default((ctx) => {
		var _a;
		return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
	});
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$33(prefixCls, rootCls);
	const rtlCls = { [`${prefixCls}-rtl`]: direction };
	const mergedRootCls = (0, import_classnames$121.default)(rootClassName, cssVarCls, rootCls, rtlCls);
	const mergedCls = (0, import_classnames$121.default)(getStatusClassNames(prefixCls, contextStatus), {
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-lg`]: mergedSize === "large"
	}, compactItemClassnames, colorPicker === null || colorPicker === void 0 ? void 0 : colorPicker.className, mergedRootCls, className, hashId);
	const mergedPopupCls = (0, import_classnames$121.default)(prefixCls, mergedRootCls);
	devUseWarning("ColorPicker")(!(disabledAlpha && isAlphaColor), "usage", "`disabledAlpha` will make the alpha to be 100% when use alpha color.");
	const popoverProps = {
		open: popupOpen,
		trigger,
		placement,
		arrow,
		rootClassName,
		getPopupContainer,
		autoAdjustOverflow: autoAdjustOverflow$2,
		destroyOnHidden: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : !!destroyTooltipOnHide
	};
	const mergedStyle = Object.assign(Object.assign({}, colorPicker === null || colorPicker === void 0 ? void 0 : colorPicker.style), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(popover_default, Object.assign({
		style: styles === null || styles === void 0 ? void 0 : styles.popup,
		styles: { body: styles === null || styles === void 0 ? void 0 : styles.popupOverlayInner },
		onOpenChange: (visible) => {
			if (!visible || !mergedDisabled) setPopupOpen(visible);
		},
		content: /* @__PURE__ */ import_react.createElement(ContextIsolator_default, { form: true }, /* @__PURE__ */ import_react.createElement(ColorPickerPanel_default, {
			mode: modeState,
			onModeChange: onInternalModeChange,
			modeOptions,
			prefixCls,
			value: mergedColor,
			allowClear,
			disabled: mergedDisabled,
			disabledAlpha,
			presets,
			panelRender,
			format: formatValue$1,
			onFormatChange: setFormatValue,
			onChange: onInternalChange,
			onChangeComplete: onInternalChangeComplete,
			onClear,
			activeIndex,
			onActive: setActiveIndex,
			gradientDragging,
			onGradientDragging: setGradientDragging,
			disabledFormat
		})),
		classNames: { root: mergedPopupCls }
	}, popoverProps), children || /* @__PURE__ */ import_react.createElement(ColorTrigger_default, Object.assign({
		activeIndex: popupOpen ? activeIndex : -1,
		open: popupOpen,
		className: mergedCls,
		style: mergedStyle,
		prefixCls,
		disabled: mergedDisabled,
		showText,
		format: formatValue$1
	}, rest, { color: mergedColor }))));
};
ColorPicker.displayName = "ColorPicker";
ColorPicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default(ColorPicker, void 0, (props) => Object.assign(Object.assign({}, props), {
	placement: "bottom",
	autoAdjustOverflow: false
}), "color-picker", (prefixCls) => prefixCls);
var ColorPicker_default = ColorPicker;

//#endregion
//#region node_modules/antd/es/color-picker/index.js
var color_picker_default = ColorPicker_default;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CalendarOutlined.js
var CalendarOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" }
		}]
	},
	"name": "calendar",
	"theme": "outlined"
};
var CalendarOutlined_default$1 = CalendarOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CalendarOutlined.js
/**![calendar](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg4MCAxODRINzEydi02NGMwLTQuNC0zLjYtOC04LThoLTU2Yy00LjQgMC04IDMuNi04IDh2NjRIMzg0di02NGMwLTQuNC0zLjYtOC04LThoLTU2Yy00LjQgMC04IDMuNi04IDh2NjRIMTQ0Yy0xNy43IDAtMzIgMTQuMy0zMiAzMnY2NjRjMCAxNy43IDE0LjMgMzIgMzIgMzJoNzM2YzE3LjcgMCAzMi0xNC4zIDMyLTMyVjIxNmMwLTE3LjctMTQuMy0zMi0zMi0zMnptLTQwIDY1NkgxODRWNDYwaDY1NnYzODB6TTE4NCAzOTJWMjU2aDEyOHY0OGMwIDQuNCAzLjYgOCA4IDhoNTZjNC40IDAgOC0zLjYgOC04di00OGgyNTZ2NDhjMCA0LjQgMy42IDggOCA4aDU2YzQuNCAwIDgtMy42IDgtOHYtNDhoMTI4djEzNkgxODR6IiAvPjwvc3ZnPg==) */
var RefIcon$34 = /* @__PURE__ */ import_react.forwardRef(function CalendarOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CalendarOutlined_default$1
	}));
});
RefIcon$34.displayName = "CalendarOutlined";
var CalendarOutlined_default = RefIcon$34;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/ClockCircleOutlined.js
var ClockCircleOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" }
		}]
	},
	"name": "clock-circle",
	"theme": "outlined"
};
var ClockCircleOutlined_default$1 = ClockCircleOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/ClockCircleOutlined.js
/**![clock-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0wIDgyMGMtMjA1LjQgMC0zNzItMTY2LjYtMzcyLTM3MnMxNjYuNi0zNzIgMzcyLTM3MiAzNzIgMTY2LjYgMzcyIDM3Mi0xNjYuNiAzNzItMzcyIDM3MnoiIC8+PHBhdGggZD0iTTY4Ni43IDYzOC42TDU0NC4xIDUzNS41VjI4OGMwLTQuNC0zLjYtOC04LThINDg4Yy00LjQgMC04IDMuNi04IDh2Mjc1LjRjMCAyLjYgMS4yIDUgMy4zIDYuNWwxNjUuNCAxMjAuNmMzLjYgMi42IDguNiAxLjggMTEuMi0xLjdsMjguNi0zOWMyLjYtMy43IDEuOC04LjctMS44LTExLjJ6IiAvPjwvc3ZnPg==) */
var RefIcon$33 = /* @__PURE__ */ import_react.forwardRef(function ClockCircleOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: ClockCircleOutlined_default$1
	}));
});
RefIcon$33.displayName = "ClockCircleOutlined";
var ClockCircleOutlined_default = RefIcon$33;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/SwapRightOutlined.js
var SwapRightOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" }
		}]
	},
	"name": "swap-right",
	"theme": "outlined"
};
var SwapRightOutlined_default$1 = SwapRightOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/SwapRightOutlined.js
/**![swap-right](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg3My4xIDU5Ni4ybC0xNjQtMjA4QTMyIDMyIDAgMDA2ODQgMzc2aC02NC44Yy02LjcgMC0xMC40IDcuNy02LjMgMTNsMTQ0LjMgMTgzSDE1MmMtNC40IDAtOCAzLjYtOCA4djYwYzAgNC40IDMuNiA4IDggOGg2OTUuOWMyNi44IDAgNDEuNy0zMC44IDI1LjItNTEuOHoiIC8+PC9zdmc+) */
var RefIcon$32 = /* @__PURE__ */ import_react.forwardRef(function SwapRightOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: SwapRightOutlined_default$1
	}));
});
RefIcon$32.displayName = "SwapRightOutlined";
var SwapRightOutlined_default = RefIcon$32;

//#endregion
//#region node_modules/antd/es/date-picker/util.js
function getPlaceholder(locale$5, picker, customizePlaceholder) {
	if (customizePlaceholder !== void 0) return customizePlaceholder;
	if (picker === "year" && locale$5.lang.yearPlaceholder) return locale$5.lang.yearPlaceholder;
	if (picker === "quarter" && locale$5.lang.quarterPlaceholder) return locale$5.lang.quarterPlaceholder;
	if (picker === "month" && locale$5.lang.monthPlaceholder) return locale$5.lang.monthPlaceholder;
	if (picker === "week" && locale$5.lang.weekPlaceholder) return locale$5.lang.weekPlaceholder;
	if (picker === "time" && locale$5.timePickerLocale.placeholder) return locale$5.timePickerLocale.placeholder;
	return locale$5.lang.placeholder;
}
function getRangePlaceholder(locale$5, picker, customizePlaceholder) {
	if (customizePlaceholder !== void 0) return customizePlaceholder;
	if (picker === "year" && locale$5.lang.yearPlaceholder) return locale$5.lang.rangeYearPlaceholder;
	if (picker === "quarter" && locale$5.lang.quarterPlaceholder) return locale$5.lang.rangeQuarterPlaceholder;
	if (picker === "month" && locale$5.lang.monthPlaceholder) return locale$5.lang.rangeMonthPlaceholder;
	if (picker === "week" && locale$5.lang.weekPlaceholder) return locale$5.lang.rangeWeekPlaceholder;
	if (picker === "time" && locale$5.timePickerLocale.placeholder) return locale$5.timePickerLocale.rangePlaceholder;
	return locale$5.lang.rangePlaceholder;
}
function useIcons$1(props, prefixCls) {
	const { allowClear = true } = props;
	const { clearIcon, removeIcon } = useIcons(Object.assign(Object.assign({}, props), {
		prefixCls,
		componentName: "DatePicker"
	}));
	return [import_react.useMemo(() => {
		if (allowClear === false) return false;
		const allowClearConfig = allowClear === true ? {} : allowClear;
		return Object.assign({ clearIcon }, allowClearConfig);
	}, [allowClear, clearIcon]), removeIcon];
}

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/constant.js
const [WEEK, WEEKPICKER] = ["week", "WeekPicker"];
const [MONTH, MONTHPICKER] = ["month", "MonthPicker"];
const [YEAR, YEARPICKER] = ["year", "YearPicker"];
const [QUARTER, QUARTERPICKER] = ["quarter", "QuarterPicker"];
const [TIME, TIMEPICKER] = ["time", "TimePicker"];

//#endregion
//#region node_modules/antd/es/date-picker/PickerButton.js
var PickerButton = (props) => /* @__PURE__ */ import_react.createElement(button_default, Object.assign({
	size: "small",
	type: "primary"
}, props));
var PickerButton_default = PickerButton;

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/useComponents.js
function useComponents(components$1) {
	return (0, import_react.useMemo)(() => Object.assign({ button: PickerButton_default }, components$1), [components$1]);
}

//#endregion
//#region node_modules/antd/es/_util/hooks/useMergeSemantic/index.js
var import_classnames$120 = /* @__PURE__ */ __toESM(require_classnames());
function mergeClassNames(schema, ...classNames$252) {
	const mergedSchema = schema || {};
	return classNames$252.reduce((acc, cur) => {
		Object.keys(cur || {}).forEach((key) => {
			const keySchema = mergedSchema[key];
			const curVal = cur[key];
			if (keySchema && typeof keySchema === "object") if (curVal && typeof curVal === "object") acc[key] = mergeClassNames(keySchema, acc[key], curVal);
			else {
				const { _default: defaultField } = keySchema;
				acc[key] = acc[key] || {};
				acc[key][defaultField] = (0, import_classnames$120.default)(acc[key][defaultField], curVal);
			}
			else acc[key] = (0, import_classnames$120.default)(acc[key], curVal);
		});
		return acc;
	}, {});
}
function useSemanticClassNames(schema, ...classNames$252) {
	return import_react.useMemo(() => mergeClassNames.apply(void 0, [schema].concat(classNames$252)), [classNames$252]);
}
function useSemanticStyles(...styles) {
	return import_react.useMemo(() => {
		return styles.reduce((acc, cur = {}) => {
			Object.keys(cur).forEach((key) => {
				acc[key] = Object.assign(Object.assign({}, acc[key]), cur[key]);
			});
			return acc;
		}, {});
	}, [styles]);
}
function fillObjectBySchema(obj, schema) {
	const newObj = Object.assign({}, obj);
	Object.keys(schema).forEach((key) => {
		if (key !== "_default") {
			const nestSchema = schema[key];
			const nextValue = newObj[key] || {};
			newObj[key] = nestSchema ? fillObjectBySchema(nextValue, nestSchema) : nextValue;
		}
	});
	return newObj;
}
/**
* Merge classNames and styles from multiple sources.
* When `schema` is provided, it will **must** provide the nest object structure.
*/
function useMergeSemantic(classNamesList, stylesList, schema) {
	const mergedClassNames = useSemanticClassNames.apply(void 0, [schema].concat(_toConsumableArray(classNamesList)));
	const mergedStyles = useSemanticStyles.apply(void 0, _toConsumableArray(stylesList));
	return import_react.useMemo(() => {
		return [fillObjectBySchema(mergedClassNames, schema), fillObjectBySchema(mergedStyles, schema)];
	}, [mergedClassNames, mergedStyles]);
}

//#endregion
//#region node_modules/antd/es/date-picker/hooks/useMergedPickerSemantic.js
var import_classnames$119 = /* @__PURE__ */ __toESM(require_classnames());
var useMergedPickerSemantic = (pickerType, classNames$252, styles, popupClassName, popupStyle) => {
	const { classNames: contextClassNames, styles: contextStyles } = useComponentConfig(pickerType);
	const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames$252], [contextStyles, styles], { popup: { _default: "root" } });
	return import_react.useMemo(() => {
		var _a, _b;
		const filledClassNames = Object.assign(Object.assign({}, mergedClassNames), { popup: Object.assign(Object.assign({}, mergedClassNames.popup), { root: (0, import_classnames$119.default)((_a = mergedClassNames.popup) === null || _a === void 0 ? void 0 : _a.root, popupClassName) }) });
		const filledStyles = Object.assign(Object.assign({}, mergedStyles), { popup: Object.assign(Object.assign({}, mergedStyles.popup), { root: Object.assign(Object.assign({}, (_b = mergedStyles.popup) === null || _b === void 0 ? void 0 : _b.root), popupStyle) }) });
		return [filledClassNames, filledStyles];
	}, [
		mergedClassNames,
		mergedStyles,
		popupClassName,
		popupStyle
	]);
};
var useMergedPickerSemantic_default = useMergedPickerSemantic;

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/generateRangePicker.js
var import_classnames$118 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$60 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var generateRangePicker = (generateConfig$1) => {
	const RangePicker$2 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
		var _a;
		const { prefixCls: customizePrefixCls, getPopupContainer: customGetPopupContainer, components: components$1, className, style: style$1, placement, size: customizeSize, disabled: customDisabled, bordered = true, placeholder, popupStyle, popupClassName, dropdownClassName, status: customStatus, rootClassName, variant: customVariant, picker, styles, classNames: classNames$252 } = props, restProps = __rest$60(props, [
			"prefixCls",
			"getPopupContainer",
			"components",
			"className",
			"style",
			"placement",
			"size",
			"disabled",
			"bordered",
			"placeholder",
			"popupStyle",
			"popupClassName",
			"dropdownClassName",
			"status",
			"rootClassName",
			"variant",
			"picker",
			"styles",
			"classNames"
		]);
		const pickerType = picker === TIME ? "timePicker" : "datePicker";
		const innerRef = import_react.useRef(null);
		const { getPrefixCls, direction, getPopupContainer, rangePicker } = (0, import_react.useContext)(ConfigContext);
		const prefixCls = getPrefixCls("picker", customizePrefixCls);
		const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
		const rootPrefixCls = getPrefixCls();
		const [variant, enableVariantCls] = useVariants_default("rangePicker", customVariant, bordered);
		const rootCls = useCSSVarCls_default(prefixCls);
		const [wrapCSSVar, hashId, cssVarCls] = style_default$32(prefixCls, rootCls);
		{
			const warning$4 = devUseWarning("DatePicker.RangePicker");
			Object.entries({
				dropdownClassName: "classNames.popup.root",
				popupClassName: "classNames.popup.root",
				popupStyle: "styles.popup.root",
				bordered: "variant",
				onSelect: "onCalendarChange"
			}).forEach(([oldProp, newProp]) => {
				warning$4.deprecated(!(oldProp in props), oldProp, newProp);
			});
		}
		const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default(pickerType, classNames$252, styles, popupClassName || dropdownClassName, popupStyle);
		const [mergedAllowClear] = useIcons$1(props, prefixCls);
		const mergedComponents = useComponents(components$1);
		const mergedSize = useSize_default((ctx) => {
			var _a$1;
			return (_a$1 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a$1 !== void 0 ? _a$1 : ctx;
		});
		const disabled = import_react.useContext(DisabledContext_default);
		const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
		const { hasFeedback, status: contextStatus, feedbackIcon } = (0, import_react.useContext)(FormItemInputContext);
		const suffixNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, picker === TIME ? /* @__PURE__ */ import_react.createElement(ClockCircleOutlined_default, null) : /* @__PURE__ */ import_react.createElement(CalendarOutlined_default, null), hasFeedback && feedbackIcon);
		(0, import_react.useImperativeHandle)(ref, () => innerRef.current);
		const [contextLocale] = useLocale_default("Calendar", en_US_default$2);
		const locale$5 = Object.assign(Object.assign({}, contextLocale), props.locale);
		const [zIndex] = useZIndex("DatePicker", (_a = mergedStyles.popup.root) === null || _a === void 0 ? void 0 : _a.zIndex);
		return wrapCSSVar(/* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, /* @__PURE__ */ import_react.createElement(RangePicker_default, Object.assign({
			separator: /* @__PURE__ */ import_react.createElement("span", {
				"aria-label": "to",
				className: `${prefixCls}-separator`
			}, /* @__PURE__ */ import_react.createElement(SwapRightOutlined_default, null)),
			disabled: mergedDisabled,
			ref: innerRef,
			placement,
			placeholder: getRangePlaceholder(locale$5, picker, placeholder),
			suffixIcon: suffixNode,
			prevIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-prev-icon` }),
			nextIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-next-icon` }),
			superPrevIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-super-prev-icon` }),
			superNextIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-super-next-icon` }),
			transitionName: `${rootPrefixCls}-slide-up`,
			picker
		}, restProps, {
			className: (0, import_classnames$118.default)({
				[`${prefixCls}-${mergedSize}`]: mergedSize,
				[`${prefixCls}-${variant}`]: enableVariantCls
			}, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, className, rangePicker === null || rangePicker === void 0 ? void 0 : rangePicker.className, cssVarCls, rootCls, rootClassName, mergedClassNames.root),
			style: Object.assign(Object.assign(Object.assign({}, rangePicker === null || rangePicker === void 0 ? void 0 : rangePicker.style), style$1), mergedStyles.root),
			locale: locale$5.lang,
			prefixCls,
			getPopupContainer: customGetPopupContainer || getPopupContainer,
			generateConfig: generateConfig$1,
			components: mergedComponents,
			direction,
			classNames: { popup: (0, import_classnames$118.default)(hashId, cssVarCls, rootCls, rootClassName, mergedClassNames.popup.root) },
			styles: { popup: Object.assign(Object.assign({}, mergedStyles.popup.root), { zIndex }) },
			allowClear: mergedAllowClear
		}))));
	});
	RangePicker$2.displayName = "RangePicker";
	return RangePicker$2;
};
var generateRangePicker_default = generateRangePicker;

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/generateSinglePicker.js
var import_classnames$117 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$59 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var generatePicker$1 = (generateConfig$1) => {
	const getPicker = (picker, displayName) => {
		const consumerName = displayName === TIMEPICKER ? "timePicker" : "datePicker";
		const Picker$2 = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
			var _a;
			const { prefixCls: customizePrefixCls, getPopupContainer: customizeGetPopupContainer, components: components$1, style: style$1, className, rootClassName, size: customizeSize, bordered, placement, placeholder, popupStyle, popupClassName, dropdownClassName, disabled: customDisabled, status: customStatus, variant: customVariant, onCalendarChange, styles, classNames: classNames$252 } = props, restProps = __rest$59(props, [
				"prefixCls",
				"getPopupContainer",
				"components",
				"style",
				"className",
				"rootClassName",
				"size",
				"bordered",
				"placement",
				"placeholder",
				"popupStyle",
				"popupClassName",
				"dropdownClassName",
				"disabled",
				"status",
				"variant",
				"onCalendarChange",
				"styles",
				"classNames"
			]);
			const { getPrefixCls, direction, getPopupContainer, [consumerName]: consumerStyle } = (0, import_react.useContext)(ConfigContext);
			const prefixCls = getPrefixCls("picker", customizePrefixCls);
			const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
			const innerRef = import_react.useRef(null);
			const [variant, enableVariantCls] = useVariants_default("datePicker", customVariant, bordered);
			const rootCls = useCSSVarCls_default(prefixCls);
			const [wrapCSSVar, hashId, cssVarCls] = style_default$32(prefixCls, rootCls);
			(0, import_react.useImperativeHandle)(ref, () => innerRef.current);
			const additionalProps = { showToday: true };
			const mergedPicker = picker || props.picker;
			const rootPrefixCls = getPrefixCls();
			const { onSelect, multiple } = restProps;
			const hasLegacyOnSelect = onSelect && picker === "time" && !multiple;
			const onInternalCalendarChange = (date$1, dateStr, info) => {
				onCalendarChange === null || onCalendarChange === void 0 || onCalendarChange(date$1, dateStr, info);
				if (hasLegacyOnSelect) onSelect(date$1);
			};
			{
				const warning$4 = devUseWarning(displayName || "DatePicker");
				warning$4(picker !== "quarter", "deprecated", `DatePicker.${displayName} is legacy usage. Please use DatePicker[picker='${picker}'] directly.`);
				Object.entries({
					dropdownClassName: "classNames.popup.root",
					popupClassName: "classNames.popup.root",
					popupStyle: "styles.popup.root",
					bordered: "variant",
					onSelect: "onCalendarChange"
				}).forEach(([oldProp, newProp]) => {
					warning$4.deprecated(!(oldProp in props), oldProp, newProp);
				});
			}
			const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default(consumerName, classNames$252, styles, popupClassName || dropdownClassName, popupStyle);
			const [mergedAllowClear, removeIcon] = useIcons$1(props, prefixCls);
			const mergedComponents = useComponents(components$1);
			const mergedSize = useSize_default((ctx) => {
				var _a$1;
				return (_a$1 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a$1 !== void 0 ? _a$1 : ctx;
			});
			const disabled = import_react.useContext(DisabledContext_default);
			const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
			const { hasFeedback, status: contextStatus, feedbackIcon } = (0, import_react.useContext)(FormItemInputContext);
			const suffixNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, mergedPicker === "time" ? /* @__PURE__ */ import_react.createElement(ClockCircleOutlined_default, null) : /* @__PURE__ */ import_react.createElement(CalendarOutlined_default, null), hasFeedback && feedbackIcon);
			const [contextLocale] = useLocale_default("DatePicker", en_US_default$2);
			const locale$5 = Object.assign(Object.assign({}, contextLocale), props.locale);
			const [zIndex] = useZIndex("DatePicker", (_a = mergedStyles.popup.root) === null || _a === void 0 ? void 0 : _a.zIndex);
			return wrapCSSVar(/* @__PURE__ */ import_react.createElement(ContextIsolator_default, { space: true }, /* @__PURE__ */ import_react.createElement(es_default$19, Object.assign({
				ref: innerRef,
				placeholder: getPlaceholder(locale$5, mergedPicker, placeholder),
				suffixIcon: suffixNode,
				placement,
				prevIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-prev-icon` }),
				nextIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-next-icon` }),
				superPrevIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-super-prev-icon` }),
				superNextIcon: /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-super-next-icon` }),
				transitionName: `${rootPrefixCls}-slide-up`,
				picker,
				onCalendarChange: onInternalCalendarChange
			}, additionalProps, restProps, {
				locale: locale$5.lang,
				className: (0, import_classnames$117.default)({
					[`${prefixCls}-${mergedSize}`]: mergedSize,
					[`${prefixCls}-${variant}`]: enableVariantCls
				}, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, consumerStyle === null || consumerStyle === void 0 ? void 0 : consumerStyle.className, className, cssVarCls, rootCls, rootClassName, mergedClassNames.root),
				style: Object.assign(Object.assign(Object.assign({}, consumerStyle === null || consumerStyle === void 0 ? void 0 : consumerStyle.style), style$1), mergedStyles.root),
				prefixCls,
				getPopupContainer: customizeGetPopupContainer || getPopupContainer,
				generateConfig: generateConfig$1,
				components: mergedComponents,
				direction,
				disabled: mergedDisabled,
				classNames: { popup: (0, import_classnames$117.default)(hashId, cssVarCls, rootCls, rootClassName, mergedClassNames.popup.root) },
				styles: { popup: Object.assign(Object.assign({}, mergedStyles.popup.root), { zIndex }) },
				allowClear: mergedAllowClear,
				removeIcon
			}))));
		});
		if (displayName) Picker$2.displayName = displayName;
		return Picker$2;
	};
	const DatePicker$1 = getPicker();
	const WeekPicker = getPicker(WEEK, WEEKPICKER);
	const MonthPicker = getPicker(MONTH, MONTHPICKER);
	const YearPicker = getPicker(YEAR, YEARPICKER);
	const QuarterPicker = getPicker(QUARTER, QUARTERPICKER);
	const TimePicker$1 = getPicker(TIME, TIMEPICKER);
	return {
		DatePicker: DatePicker$1,
		WeekPicker,
		MonthPicker,
		YearPicker,
		TimePicker: TimePicker$1,
		QuarterPicker
	};
};
var generateSinglePicker_default = generatePicker$1;

//#endregion
//#region node_modules/antd/es/date-picker/generatePicker/index.js
var generatePicker = (generateConfig$1) => {
	const { DatePicker: DatePicker$1, WeekPicker, MonthPicker, YearPicker, TimePicker: TimePicker$1, QuarterPicker } = generateSinglePicker_default(generateConfig$1);
	const RangePicker$2 = generateRangePicker_default(generateConfig$1);
	const MergedDatePicker = DatePicker$1;
	MergedDatePicker.WeekPicker = WeekPicker;
	MergedDatePicker.MonthPicker = MonthPicker;
	MergedDatePicker.YearPicker = YearPicker;
	MergedDatePicker.RangePicker = RangePicker$2;
	MergedDatePicker.TimePicker = TimePicker$1;
	MergedDatePicker.QuarterPicker = QuarterPicker;
	MergedDatePicker.displayName = "DatePicker";
	return MergedDatePicker;
};
var generatePicker_default = generatePicker;

//#endregion
//#region node_modules/antd/es/date-picker/index.js
var DatePicker = generatePicker_default(dayjs_default);
DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default(DatePicker, "popupAlign", void 0, "picker");
DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PurePanel_default(DatePicker.RangePicker, "popupAlign", void 0, "picker");
DatePicker.generatePicker = generatePicker_default;
var date_picker_default = DatePicker;

//#endregion
//#region node_modules/antd/es/descriptions/constant.js
var DEFAULT_COLUMN_MAP = {
	xxl: 3,
	xl: 3,
	lg: 3,
	md: 3,
	sm: 2,
	xs: 1
};
var constant_default = DEFAULT_COLUMN_MAP;

//#endregion
//#region node_modules/antd/es/descriptions/DescriptionsContext.js
var DescriptionsContext = /* @__PURE__ */ import_react.createContext({});
var DescriptionsContext_default = DescriptionsContext;

//#endregion
//#region node_modules/antd/es/descriptions/hooks/useItems.js
var __rest$58 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var transChildren2Items = (childNodes) => toArray(childNodes).map((node$1) => Object.assign(Object.assign({}, node$1 === null || node$1 === void 0 ? void 0 : node$1.props), { key: node$1.key }));
function useItems$2(screens, items, children) {
	const mergedItems = import_react.useMemo(() => items || transChildren2Items(children), [items, children]);
	return import_react.useMemo(() => mergedItems.map((_a) => {
		var { span } = _a, restItem = __rest$58(_a, ["span"]);
		if (span === "filled") return Object.assign(Object.assign({}, restItem), { filled: true });
		return Object.assign(Object.assign({}, restItem), { span: typeof span === "number" ? span : matchScreen(screens, span) });
	}), [mergedItems, screens]);
}

//#endregion
//#region node_modules/antd/es/descriptions/hooks/useRow.js
var __rest$57 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function getCalcRows(rowItems, mergedColumn) {
	let rows = [];
	let tmpRow = [];
	let exceed = false;
	let count = 0;
	rowItems.filter((n$1) => n$1).forEach((rowItem) => {
		const { filled } = rowItem, restItem = __rest$57(rowItem, ["filled"]);
		if (filled) {
			tmpRow.push(restItem);
			rows.push(tmpRow);
			tmpRow = [];
			count = 0;
			return;
		}
		const restSpan = mergedColumn - count;
		count += rowItem.span || 1;
		if (count >= mergedColumn) {
			if (count > mergedColumn) {
				exceed = true;
				tmpRow.push(Object.assign(Object.assign({}, restItem), { span: restSpan }));
			} else tmpRow.push(restItem);
			rows.push(tmpRow);
			tmpRow = [];
			count = 0;
		} else tmpRow.push(restItem);
	});
	if (tmpRow.length > 0) rows.push(tmpRow);
	rows = rows.map((rows$1) => {
		const count$1 = rows$1.reduce((acc, item) => acc + (item.span || 1), 0);
		if (count$1 < mergedColumn) {
			const last = rows$1[rows$1.length - 1];
			last.span = mergedColumn - (count$1 - (last.span || 1));
			return rows$1;
		}
		return rows$1;
	});
	return [rows, exceed];
}
var useRow = (mergedColumn, items) => {
	const [rows, exceed] = (0, import_react.useMemo)(() => getCalcRows(items, mergedColumn), [items, mergedColumn]);
	devUseWarning("Descriptions")(!exceed, "usage", "Sum of column `span` in a line not match `column` of Descriptions.");
	return rows;
};
var useRow_default = useRow;

//#endregion
//#region node_modules/antd/es/descriptions/Item.js
/* istanbul ignore next */
var DescriptionsItem = ({ children }) => children;
var Item_default$2 = DescriptionsItem;

//#endregion
//#region node_modules/antd/es/descriptions/Cell.js
var import_classnames$116 = /* @__PURE__ */ __toESM(require_classnames());
function notEmpty(val) {
	return val !== void 0 && val !== null;
}
var Cell$1 = (props) => {
	const { itemPrefixCls, component, span, className, style: style$1, labelStyle, contentStyle, bordered, label, content, colon, type: type$2, styles } = props;
	const Component$2 = component;
	const { classNames: descriptionsClassNames } = import_react.useContext(DescriptionsContext_default);
	if (bordered) return /* @__PURE__ */ import_react.createElement(Component$2, {
		className: (0, import_classnames$116.default)({
			[`${itemPrefixCls}-item-label`]: type$2 === "label",
			[`${itemPrefixCls}-item-content`]: type$2 === "content",
			[`${descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.label}`]: type$2 === "label",
			[`${descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.content}`]: type$2 === "content"
		}, className),
		style: style$1,
		colSpan: span
	}, notEmpty(label) && /* @__PURE__ */ import_react.createElement("span", { style: Object.assign(Object.assign({}, labelStyle), styles === null || styles === void 0 ? void 0 : styles.label) }, label), notEmpty(content) && /* @__PURE__ */ import_react.createElement("span", { style: Object.assign(Object.assign({}, labelStyle), styles === null || styles === void 0 ? void 0 : styles.content) }, content));
	return /* @__PURE__ */ import_react.createElement(Component$2, {
		className: (0, import_classnames$116.default)(`${itemPrefixCls}-item`, className),
		style: style$1,
		colSpan: span
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${itemPrefixCls}-item-container` }, (label || label === 0) && /* @__PURE__ */ import_react.createElement("span", {
		className: (0, import_classnames$116.default)(`${itemPrefixCls}-item-label`, descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.label, { [`${itemPrefixCls}-item-no-colon`]: !colon }),
		style: Object.assign(Object.assign({}, labelStyle), styles === null || styles === void 0 ? void 0 : styles.label)
	}, label), (content || content === 0) && /* @__PURE__ */ import_react.createElement("span", {
		className: (0, import_classnames$116.default)(`${itemPrefixCls}-item-content`, descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.content),
		style: Object.assign(Object.assign({}, contentStyle), styles === null || styles === void 0 ? void 0 : styles.content)
	}, content)));
};
var Cell_default$1 = Cell$1;

//#endregion
//#region node_modules/antd/es/descriptions/Row.js
function renderCells(items, { colon, prefixCls, bordered }, { component, type: type$2, showLabel, showContent, labelStyle: rootLabelStyle, contentStyle: rootContentStyle, styles: rootStyles }) {
	return items.map(({ label, children, prefixCls: itemPrefixCls = prefixCls, className, style: style$1, labelStyle, contentStyle, span = 1, key, styles }, index$2) => {
		if (typeof component === "string") return /* @__PURE__ */ import_react.createElement(Cell_default$1, {
			key: `${type$2}-${key || index$2}`,
			className,
			style: style$1,
			styles: {
				label: Object.assign(Object.assign(Object.assign(Object.assign({}, rootLabelStyle), rootStyles === null || rootStyles === void 0 ? void 0 : rootStyles.label), labelStyle), styles === null || styles === void 0 ? void 0 : styles.label),
				content: Object.assign(Object.assign(Object.assign(Object.assign({}, rootContentStyle), rootStyles === null || rootStyles === void 0 ? void 0 : rootStyles.content), contentStyle), styles === null || styles === void 0 ? void 0 : styles.content)
			},
			span,
			colon,
			component,
			itemPrefixCls,
			bordered,
			label: showLabel ? label : null,
			content: showContent ? children : null,
			type: type$2
		});
		return [/* @__PURE__ */ import_react.createElement(Cell_default$1, {
			key: `label-${key || index$2}`,
			className,
			style: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rootLabelStyle), rootStyles === null || rootStyles === void 0 ? void 0 : rootStyles.label), style$1), labelStyle), styles === null || styles === void 0 ? void 0 : styles.label),
			span: 1,
			colon,
			component: component[0],
			itemPrefixCls,
			bordered,
			label,
			type: "label"
		}), /* @__PURE__ */ import_react.createElement(Cell_default$1, {
			key: `content-${key || index$2}`,
			className,
			style: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rootContentStyle), rootStyles === null || rootStyles === void 0 ? void 0 : rootStyles.content), style$1), contentStyle), styles === null || styles === void 0 ? void 0 : styles.content),
			span: span * 2 - 1,
			component: component[1],
			itemPrefixCls,
			bordered,
			content: children,
			type: "content"
		})];
	});
}
var Row = (props) => {
	const descContext = import_react.useContext(DescriptionsContext_default);
	const { prefixCls, vertical, row, index: index$2, bordered } = props;
	if (vertical) return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("tr", {
		key: `label-${index$2}`,
		className: `${prefixCls}-row`
	}, renderCells(row, props, Object.assign({
		component: "th",
		type: "label",
		showLabel: true
	}, descContext))), /* @__PURE__ */ import_react.createElement("tr", {
		key: `content-${index$2}`,
		className: `${prefixCls}-row`
	}, renderCells(row, props, Object.assign({
		component: "td",
		type: "content",
		showContent: true
	}, descContext))));
	return /* @__PURE__ */ import_react.createElement("tr", {
		key: index$2,
		className: `${prefixCls}-row`
	}, renderCells(row, props, Object.assign({
		component: bordered ? ["th", "td"] : "td",
		type: "item",
		showLabel: true,
		showContent: true
	}, descContext)));
};
var Row_default = Row;

//#endregion
//#region node_modules/antd/es/descriptions/style/index.js
var genBorderedStyle$3 = (token$1) => {
	const { componentCls, labelBg } = token$1;
	return { [`&${componentCls}-bordered`]: {
		[`> ${componentCls}-view`]: {
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
			"> table": { tableLayout: "auto" },
			[`${componentCls}-row`]: {
				borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
				"&:first-child": { "> th:first-child, > td:first-child": { borderStartStartRadius: token$1.borderRadiusLG } },
				"&:last-child": {
					borderBottom: "none",
					"> th:first-child, > td:first-child": { borderEndStartRadius: token$1.borderRadiusLG }
				},
				[`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
					padding: `${unit(token$1.padding)} ${unit(token$1.paddingLG)}`,
					borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
					"&:last-child": { borderInlineEnd: "none" }
				},
				[`> ${componentCls}-item-label`]: {
					color: token$1.colorTextSecondary,
					backgroundColor: labelBg,
					"&::after": { display: "none" }
				}
			}
		},
		[`&${componentCls}-middle`]: { [`${componentCls}-row`]: { [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: { padding: `${unit(token$1.paddingSM)} ${unit(token$1.paddingLG)}` } } },
		[`&${componentCls}-small`]: { [`${componentCls}-row`]: { [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: { padding: `${unit(token$1.paddingXS)} ${unit(token$1.padding)}` } } }
	} };
};
var genDescriptionStyles = (token$1) => {
	const { componentCls, extraColor, itemPaddingBottom, itemPaddingEnd, colonMarginRight, colonMarginLeft, titleMarginBottom } = token$1;
	return { [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), genBorderedStyle$3(token$1)), {
		"&-rtl": { direction: "rtl" },
		[`${componentCls}-header`]: {
			display: "flex",
			alignItems: "center",
			marginBottom: titleMarginBottom
		},
		[`${componentCls}-title`]: Object.assign(Object.assign({}, textEllipsis), {
			flex: "auto",
			color: token$1.titleColor,
			fontWeight: token$1.fontWeightStrong,
			fontSize: token$1.fontSizeLG,
			lineHeight: token$1.lineHeightLG
		}),
		[`${componentCls}-extra`]: {
			marginInlineStart: "auto",
			color: extraColor,
			fontSize: token$1.fontSize
		},
		[`${componentCls}-view`]: {
			width: "100%",
			borderRadius: token$1.borderRadiusLG,
			table: {
				width: "100%",
				tableLayout: "fixed",
				borderCollapse: "collapse"
			}
		},
		[`${componentCls}-row`]: {
			"> th, > td": {
				paddingBottom: itemPaddingBottom,
				paddingInlineEnd: itemPaddingEnd
			},
			"> th:last-child, > td:last-child": { paddingInlineEnd: 0 },
			"&:last-child": {
				borderBottom: "none",
				"> th, > td": { paddingBottom: 0 }
			}
		},
		[`${componentCls}-item-label`]: {
			color: token$1.labelColor,
			fontWeight: "normal",
			fontSize: token$1.fontSize,
			lineHeight: token$1.lineHeight,
			textAlign: "start",
			"&::after": {
				content: "\":\"",
				position: "relative",
				top: -.5,
				marginInline: `${unit(colonMarginLeft)} ${unit(colonMarginRight)}`
			},
			[`&${componentCls}-item-no-colon::after`]: { content: "\"\"" }
		},
		[`${componentCls}-item-no-label`]: { "&::after": {
			margin: 0,
			content: "\"\""
		} },
		[`${componentCls}-item-content`]: {
			display: "table-cell",
			flex: 1,
			color: token$1.contentColor,
			fontSize: token$1.fontSize,
			lineHeight: token$1.lineHeight,
			wordBreak: "break-word",
			overflowWrap: "break-word"
		},
		[`${componentCls}-item`]: {
			paddingBottom: 0,
			verticalAlign: "top",
			"&-container": {
				display: "flex",
				[`${componentCls}-item-label`]: {
					display: "inline-flex",
					alignItems: "baseline"
				},
				[`${componentCls}-item-content`]: {
					display: "inline-flex",
					alignItems: "baseline",
					minWidth: "1em"
				}
			}
		},
		"&-middle": { [`${componentCls}-row`]: { "> th, > td": { paddingBottom: token$1.paddingSM } } },
		"&-small": { [`${componentCls}-row`]: { "> th, > td": { paddingBottom: token$1.paddingXS } } }
	}) };
};
const prepareComponentToken$26 = (token$1) => ({
	labelBg: token$1.colorFillAlter,
	labelColor: token$1.colorTextTertiary,
	titleColor: token$1.colorText,
	titleMarginBottom: token$1.fontSizeSM * token$1.lineHeightSM,
	itemPaddingBottom: token$1.padding,
	itemPaddingEnd: token$1.padding,
	colonMarginRight: token$1.marginXS,
	colonMarginLeft: token$1.marginXXS / 2,
	contentColor: token$1.colorText,
	extraColor: token$1.colorText
});
var style_default$31 = genStyleHooks("Descriptions", (token$1) => {
	const descriptionToken = merge(token$1, {});
	return genDescriptionStyles(descriptionToken);
}, prepareComponentToken$26);

//#endregion
//#region node_modules/antd/es/descriptions/index.js
var import_classnames$115 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$56 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Descriptions = (props) => {
	const { prefixCls: customizePrefixCls, title, extra, column: column$1, colon = true, bordered, layout, children, className, rootClassName, style: style$1, size: customizeSize, labelStyle, contentStyle, styles, items, classNames: descriptionsClassNames } = props, restProps = __rest$56(props, [
		"prefixCls",
		"title",
		"extra",
		"column",
		"colon",
		"bordered",
		"layout",
		"children",
		"className",
		"rootClassName",
		"style",
		"size",
		"labelStyle",
		"contentStyle",
		"styles",
		"items",
		"classNames"
	]);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("descriptions");
	const prefixCls = getPrefixCls("descriptions", customizePrefixCls);
	const screens = useBreakpoint_default();
	{
		const warning$4 = devUseWarning("Descriptions");
		[["labelStyle", "styles={{ label: {} }}"], ["contentStyle", "styles={{ content: {} }}"]].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
	}
	const mergedColumn = import_react.useMemo(() => {
		var _a;
		if (typeof column$1 === "number") return column$1;
		return (_a = matchScreen(screens, Object.assign(Object.assign({}, constant_default), column$1))) !== null && _a !== void 0 ? _a : 3;
	}, [screens, column$1]);
	const mergedItems = useItems$2(screens, items, children);
	const mergedSize = useSize_default(customizeSize);
	const rows = useRow_default(mergedColumn, mergedItems);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$31(prefixCls);
	const contextValue = import_react.useMemo(() => ({
		labelStyle,
		contentStyle,
		styles: {
			content: Object.assign(Object.assign({}, contextStyles.content), styles === null || styles === void 0 ? void 0 : styles.content),
			label: Object.assign(Object.assign({}, contextStyles.label), styles === null || styles === void 0 ? void 0 : styles.label)
		},
		classNames: {
			label: (0, import_classnames$115.default)(contextClassNames.label, descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.label),
			content: (0, import_classnames$115.default)(contextClassNames.content, descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.content)
		}
	}), [
		labelStyle,
		contentStyle,
		styles,
		descriptionsClassNames,
		contextClassNames,
		contextStyles
	]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(DescriptionsContext_default.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement("div", Object.assign({
		className: (0, import_classnames$115.default)(prefixCls, contextClassName, contextClassNames.root, descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.root, {
			[`${prefixCls}-${mergedSize}`]: mergedSize && mergedSize !== "default",
			[`${prefixCls}-bordered`]: !!bordered,
			[`${prefixCls}-rtl`]: direction === "rtl"
		}, className, rootClassName, hashId, cssVarCls),
		style: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyle), contextStyles.root), styles === null || styles === void 0 ? void 0 : styles.root), style$1)
	}, restProps), (title || extra) && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$115.default)(`${prefixCls}-header`, contextClassNames.header, descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.header),
		style: Object.assign(Object.assign({}, contextStyles.header), styles === null || styles === void 0 ? void 0 : styles.header)
	}, title && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$115.default)(`${prefixCls}-title`, contextClassNames.title, descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.title),
		style: Object.assign(Object.assign({}, contextStyles.title), styles === null || styles === void 0 ? void 0 : styles.title)
	}, title), extra && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$115.default)(`${prefixCls}-extra`, contextClassNames.extra, descriptionsClassNames === null || descriptionsClassNames === void 0 ? void 0 : descriptionsClassNames.extra),
		style: Object.assign(Object.assign({}, contextStyles.extra), styles === null || styles === void 0 ? void 0 : styles.extra)
	}, extra)), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-view` }, /* @__PURE__ */ import_react.createElement("table", null, /* @__PURE__ */ import_react.createElement("tbody", null, rows.map((row, index$2) => /* @__PURE__ */ import_react.createElement(Row_default, {
		key: index$2,
		index: index$2,
		colon,
		prefixCls,
		vertical: layout === "vertical",
		bordered,
		row
	}))))))));
};
Descriptions.displayName = "Descriptions";
Descriptions.Item = Item_default$2;
var descriptions_default = Descriptions;

//#endregion
//#region node_modules/rc-drawer/es/context.js
var DrawerContext = /* @__PURE__ */ import_react.createContext(null);
var RefContext = /* @__PURE__ */ import_react.createContext({});
var context_default$2 = DrawerContext;

//#endregion
//#region node_modules/rc-drawer/es/DrawerPanel.js
var import_classnames$114 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$27 = [
	"prefixCls",
	"className",
	"containerRef"
];
var DrawerPanel$1 = function DrawerPanel$2(props) {
	var prefixCls = props.prefixCls, className = props.className, containerRef = props.containerRef, restProps = _objectWithoutProperties(props, _excluded$27);
	var _React$useContext = import_react.useContext(RefContext), panelRef = _React$useContext.panel;
	var mergedRef = useComposeRef(panelRef, containerRef);
	return /* @__PURE__ */ import_react.createElement("div", _extends({
		className: (0, import_classnames$114.default)("".concat(prefixCls, "-content"), className),
		role: "dialog",
		ref: mergedRef
	}, pickAttrs(props, { aria: true }), { "aria-modal": "true" }, restProps));
};
DrawerPanel$1.displayName = "DrawerPanel";
var DrawerPanel_default$1 = DrawerPanel$1;

//#endregion
//#region node_modules/rc-drawer/es/util.js
function parseWidthHeight(value) {
	if (typeof value === "string" && String(Number(value)) === value) {
		warning_default(false, "Invalid value type of `width` or `height` which should be number type instead.");
		return Number(value);
	}
	return value;
}
function warnCheck(props) {
	warning_default(!("wrapperClassName" in props), "'wrapperClassName' is removed. Please use 'rootClassName' instead.");
	warning_default(canUseDom() || !props.open, "Drawer with 'open' in SSR is not work since no place to createPortal. Please move to 'useEffect' instead.");
}

//#endregion
//#region node_modules/rc-drawer/es/DrawerPopup.js
var import_classnames$113 = /* @__PURE__ */ __toESM(require_classnames());
var sentinelStyle = {
	width: 0,
	height: 0,
	overflow: "hidden",
	outline: "none",
	position: "absolute"
};
function DrawerPopup(props, ref) {
	var _ref, _pushConfig$distance, _pushConfig;
	var prefixCls = props.prefixCls, open$2 = props.open, placement = props.placement, inline$1 = props.inline, push = props.push, forceRender = props.forceRender, autoFocus = props.autoFocus, keyboard = props.keyboard, drawerClassNames = props.classNames, rootClassName = props.rootClassName, rootStyle = props.rootStyle, zIndex = props.zIndex, className = props.className, id = props.id, style$1 = props.style, motion$1 = props.motion, width = props.width, height = props.height, children = props.children, mask = props.mask, maskClosable = props.maskClosable, maskMotion = props.maskMotion, maskClassName = props.maskClassName, maskStyle = props.maskStyle, afterOpenChange = props.afterOpenChange, onClose = props.onClose, onMouseEnter = props.onMouseEnter, onMouseOver = props.onMouseOver, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown$1 = props.onKeyDown, onKeyUp = props.onKeyUp, styles = props.styles, drawerRender = props.drawerRender;
	var panelRef = import_react.useRef();
	var sentinelStartRef = import_react.useRef();
	var sentinelEndRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		return panelRef.current;
	});
	var onPanelKeyDown = function onPanelKeyDown$1(event) {
		var keyCode = event.keyCode, shiftKey = event.shiftKey;
		switch (keyCode) {
			case KeyCode_default.TAB:
				if (keyCode === KeyCode_default.TAB) {
					if (!shiftKey && document.activeElement === sentinelEndRef.current) {
						var _sentinelStartRef$cur;
						(_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 || _sentinelStartRef$cur.focus({ preventScroll: true });
					} else if (shiftKey && document.activeElement === sentinelStartRef.current) {
						var _sentinelEndRef$curre;
						(_sentinelEndRef$curre = sentinelEndRef.current) === null || _sentinelEndRef$curre === void 0 || _sentinelEndRef$curre.focus({ preventScroll: true });
					}
				}
				break;
			case KeyCode_default.ESC:
				if (onClose && keyboard) {
					event.stopPropagation();
					onClose(event);
				}
				break;
		}
	};
	import_react.useEffect(function() {
		if (open$2 && autoFocus) {
			var _panelRef$current;
			(_panelRef$current = panelRef.current) === null || _panelRef$current === void 0 || _panelRef$current.focus({ preventScroll: true });
		}
	}, [open$2]);
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), pushed = _React$useState2[0], setPushed = _React$useState2[1];
	var parentContext = import_react.useContext(context_default$2);
	var pushConfig;
	if (typeof push === "boolean") pushConfig = push ? {} : { distance: 0 };
	else pushConfig = push || {};
	var pushDistance = (_ref = (_pushConfig$distance = (_pushConfig = pushConfig) === null || _pushConfig === void 0 ? void 0 : _pushConfig.distance) !== null && _pushConfig$distance !== void 0 ? _pushConfig$distance : parentContext === null || parentContext === void 0 ? void 0 : parentContext.pushDistance) !== null && _ref !== void 0 ? _ref : 180;
	var mergedContext = import_react.useMemo(function() {
		return {
			pushDistance,
			push: function push$1() {
				setPushed(true);
			},
			pull: function pull() {
				setPushed(false);
			}
		};
	}, [pushDistance]);
	import_react.useEffect(function() {
		if (open$2) {
			var _parentContext$push;
			parentContext === null || parentContext === void 0 || (_parentContext$push = parentContext.push) === null || _parentContext$push === void 0 || _parentContext$push.call(parentContext);
		} else {
			var _parentContext$pull;
			parentContext === null || parentContext === void 0 || (_parentContext$pull = parentContext.pull) === null || _parentContext$pull === void 0 || _parentContext$pull.call(parentContext);
		}
	}, [open$2]);
	import_react.useEffect(function() {
		return function() {
			var _parentContext$pull2;
			parentContext === null || parentContext === void 0 || (_parentContext$pull2 = parentContext.pull) === null || _parentContext$pull2 === void 0 || _parentContext$pull2.call(parentContext);
		};
	}, []);
	var maskNode = /* @__PURE__ */ import_react.createElement(es_default$2, _extends({ key: "mask" }, maskMotion, { visible: mask && open$2 }), function(_ref2, maskRef) {
		var motionMaskClassName = _ref2.className, motionMaskStyle = _ref2.style;
		return /* @__PURE__ */ import_react.createElement("div", {
			className: (0, import_classnames$113.default)("".concat(prefixCls, "-mask"), motionMaskClassName, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.mask, maskClassName),
			style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionMaskStyle), maskStyle), styles === null || styles === void 0 ? void 0 : styles.mask),
			onClick: maskClosable && open$2 ? onClose : void 0,
			ref: maskRef
		});
	});
	var motionProps = typeof motion$1 === "function" ? motion$1(placement) : motion$1;
	var wrapperStyle = {};
	if (pushed && pushDistance) switch (placement) {
		case "top":
			wrapperStyle.transform = "translateY(".concat(pushDistance, "px)");
			break;
		case "bottom":
			wrapperStyle.transform = "translateY(".concat(-pushDistance, "px)");
			break;
		case "left":
			wrapperStyle.transform = "translateX(".concat(pushDistance, "px)");
			break;
		default:
			wrapperStyle.transform = "translateX(".concat(-pushDistance, "px)");
			break;
	}
	if (placement === "left" || placement === "right") wrapperStyle.width = parseWidthHeight(width);
	else wrapperStyle.height = parseWidthHeight(height);
	var eventHandlers = {
		onMouseEnter,
		onMouseOver,
		onMouseLeave,
		onClick,
		onKeyDown: onKeyDown$1,
		onKeyUp
	};
	var panelNode = /* @__PURE__ */ import_react.createElement(es_default$2, _extends({ key: "panel" }, motionProps, {
		visible: open$2,
		forceRender,
		onVisibleChanged: function onVisibleChanged(nextVisible) {
			afterOpenChange === null || afterOpenChange === void 0 || afterOpenChange(nextVisible);
		},
		removeOnLeave: false,
		leavedClassName: "".concat(prefixCls, "-content-wrapper-hidden")
	}), function(_ref3, motionRef) {
		var motionClassName = _ref3.className, motionStyle = _ref3.style;
		var content = /* @__PURE__ */ import_react.createElement(DrawerPanel_default$1, _extends({
			id,
			containerRef: motionRef,
			prefixCls,
			className: (0, import_classnames$113.default)(className, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.content),
			style: _objectSpread2(_objectSpread2({}, style$1), styles === null || styles === void 0 ? void 0 : styles.content)
		}, pickAttrs(props, { aria: true }), eventHandlers), children);
		return /* @__PURE__ */ import_react.createElement("div", _extends({
			className: (0, import_classnames$113.default)("".concat(prefixCls, "-content-wrapper"), drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.wrapper, motionClassName),
			style: _objectSpread2(_objectSpread2(_objectSpread2({}, wrapperStyle), motionStyle), styles === null || styles === void 0 ? void 0 : styles.wrapper)
		}, pickAttrs(props, { data: true })), drawerRender ? drawerRender(content) : content);
	});
	var containerStyle = _objectSpread2({}, rootStyle);
	if (zIndex) containerStyle.zIndex = zIndex;
	return /* @__PURE__ */ import_react.createElement(context_default$2.Provider, { value: mergedContext }, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$113.default)(prefixCls, "".concat(prefixCls, "-").concat(placement), rootClassName, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-open"), open$2), "".concat(prefixCls, "-inline"), inline$1)),
		style: containerStyle,
		tabIndex: -1,
		ref: panelRef,
		onKeyDown: onPanelKeyDown
	}, maskNode, /* @__PURE__ */ import_react.createElement("div", {
		tabIndex: 0,
		ref: sentinelStartRef,
		style: sentinelStyle,
		"aria-hidden": "true",
		"data-sentinel": "start"
	}), panelNode, /* @__PURE__ */ import_react.createElement("div", {
		tabIndex: 0,
		ref: sentinelEndRef,
		style: sentinelStyle,
		"aria-hidden": "true",
		"data-sentinel": "end"
	})));
}
var RefDrawerPopup = /* @__PURE__ */ import_react.forwardRef(DrawerPopup);
RefDrawerPopup.displayName = "DrawerPopup";
var DrawerPopup_default = RefDrawerPopup;

//#endregion
//#region node_modules/rc-drawer/es/Drawer.js
var Drawer$1 = function Drawer$2(props) {
	var _props$open = props.open, open$2 = _props$open === void 0 ? false : _props$open, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-drawer" : _props$prefixCls, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$width = props.width, width = _props$width === void 0 ? 378 : _props$width, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getContainer$1 = props.getContainer, forceRender = props.forceRender, afterOpenChange = props.afterOpenChange, destroyOnClose = props.destroyOnClose, onMouseEnter = props.onMouseEnter, onMouseOver = props.onMouseOver, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown$1 = props.onKeyDown, onKeyUp = props.onKeyUp, panelRef = props.panelRef;
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
	warnCheck(props);
	var _React$useState3 = import_react.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), mounted = _React$useState4[0], setMounted = _React$useState4[1];
	useLayoutEffect_default(function() {
		setMounted(true);
	}, []);
	var mergedOpen = mounted ? open$2 : false;
	var popupRef = import_react.useRef();
	var lastActiveRef = import_react.useRef();
	useLayoutEffect_default(function() {
		if (mergedOpen) lastActiveRef.current = document.activeElement;
	}, [mergedOpen]);
	var internalAfterOpenChange = function internalAfterOpenChange$1(nextVisible) {
		var _popupRef$current;
		setAnimatedVisible(nextVisible);
		afterOpenChange === null || afterOpenChange === void 0 || afterOpenChange(nextVisible);
		if (!nextVisible && lastActiveRef.current && !((_popupRef$current = popupRef.current) !== null && _popupRef$current !== void 0 && _popupRef$current.contains(lastActiveRef.current))) {
			var _lastActiveRef$curren;
			(_lastActiveRef$curren = lastActiveRef.current) === null || _lastActiveRef$curren === void 0 || _lastActiveRef$curren.focus({ preventScroll: true });
		}
	};
	var refContext = import_react.useMemo(function() {
		return { panel: panelRef };
	}, [panelRef]);
	if (!forceRender && !animatedVisible && !mergedOpen && destroyOnClose) return null;
	var eventHandlers = {
		onMouseEnter,
		onMouseOver,
		onMouseLeave,
		onClick,
		onKeyDown: onKeyDown$1,
		onKeyUp
	};
	var drawerPopupProps = _objectSpread2(_objectSpread2({}, props), {}, {
		open: mergedOpen,
		prefixCls,
		placement,
		autoFocus,
		keyboard,
		width,
		mask,
		maskClosable,
		inline: getContainer$1 === false,
		afterOpenChange: internalAfterOpenChange,
		ref: popupRef
	}, eventHandlers);
	return /* @__PURE__ */ import_react.createElement(RefContext.Provider, { value: refContext }, /* @__PURE__ */ import_react.createElement(es_default$6, {
		open: mergedOpen || forceRender || animatedVisible,
		autoDestroy: false,
		getContainer: getContainer$1,
		autoLock: mask && (mergedOpen || animatedVisible)
	}, /* @__PURE__ */ import_react.createElement(DrawerPopup_default, drawerPopupProps)));
};
Drawer$1.displayName = "Drawer";
var Drawer_default = Drawer$1;

//#endregion
//#region node_modules/rc-drawer/es/index.js
var es_default$18 = Drawer_default;

//#endregion
//#region node_modules/antd/es/drawer/DrawerPanel.js
var import_classnames$112 = /* @__PURE__ */ __toESM(require_classnames());
var DrawerPanel = (props) => {
	var _a, _b;
	const { prefixCls, title, footer, extra, loading, onClose, headerStyle, bodyStyle, footerStyle, children, classNames: drawerClassNames, styles: drawerStyles } = props;
	const drawerContext = useComponentConfig("drawer");
	const customCloseIconRender = import_react.useCallback((icon) => /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		onClick: onClose,
		className: `${prefixCls}-close`
	}, icon), [onClose]);
	const [mergedClosable, mergedCloseIcon] = useClosable(pickClosable(props), pickClosable(drawerContext), {
		closable: true,
		closeIconRender: customCloseIconRender
	});
	const headerNode = import_react.useMemo(() => {
		var _a$1, _b$1;
		if (!title && !mergedClosable) return null;
		return /* @__PURE__ */ import_react.createElement("div", {
			style: Object.assign(Object.assign(Object.assign({}, (_a$1 = drawerContext.styles) === null || _a$1 === void 0 ? void 0 : _a$1.header), headerStyle), drawerStyles === null || drawerStyles === void 0 ? void 0 : drawerStyles.header),
			className: (0, import_classnames$112.default)(`${prefixCls}-header`, { [`${prefixCls}-header-close-only`]: mergedClosable && !title && !extra }, (_b$1 = drawerContext.classNames) === null || _b$1 === void 0 ? void 0 : _b$1.header, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.header)
		}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-header-title` }, mergedCloseIcon, title && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-title` }, title)), extra && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-extra` }, extra));
	}, [
		mergedClosable,
		mergedCloseIcon,
		extra,
		headerStyle,
		prefixCls,
		title
	]);
	const footerNode = import_react.useMemo(() => {
		var _a$1, _b$1;
		if (!footer) return null;
		const footerClassName = `${prefixCls}-footer`;
		return /* @__PURE__ */ import_react.createElement("div", {
			className: (0, import_classnames$112.default)(footerClassName, (_a$1 = drawerContext.classNames) === null || _a$1 === void 0 ? void 0 : _a$1.footer, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.footer),
			style: Object.assign(Object.assign(Object.assign({}, (_b$1 = drawerContext.styles) === null || _b$1 === void 0 ? void 0 : _b$1.footer), footerStyle), drawerStyles === null || drawerStyles === void 0 ? void 0 : drawerStyles.footer)
		}, footer);
	}, [
		footer,
		footerStyle,
		prefixCls
	]);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, headerNode, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$112.default)(`${prefixCls}-body`, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.body, (_a = drawerContext.classNames) === null || _a === void 0 ? void 0 : _a.body),
		style: Object.assign(Object.assign(Object.assign({}, (_b = drawerContext.styles) === null || _b === void 0 ? void 0 : _b.body), bodyStyle), drawerStyles === null || drawerStyles === void 0 ? void 0 : drawerStyles.body)
	}, loading ? /* @__PURE__ */ import_react.createElement(skeleton_default, {
		active: true,
		title: false,
		paragraph: { rows: 5 },
		className: `${prefixCls}-body-skeleton`
	}) : children), footerNode);
};
var DrawerPanel_default = DrawerPanel;

//#endregion
//#region node_modules/antd/es/drawer/style/motion.js
var getMoveTranslate = (direction) => {
	const value = "100%";
	return {
		left: `translateX(-${value})`,
		right: `translateX(${value})`,
		top: `translateY(-${value})`,
		bottom: `translateY(${value})`
	}[direction];
};
var getEnterLeaveStyle = (startStyle, endStyle) => ({
	"&-enter, &-appear": Object.assign(Object.assign({}, startStyle), { "&-active": endStyle }),
	"&-leave": Object.assign(Object.assign({}, endStyle), { "&-active": startStyle })
});
var getFadeStyle = (from$1, duration) => Object.assign({ "&-enter, &-appear, &-leave": {
	"&-start": { transition: "none" },
	"&-active": { transition: `all ${duration}` }
} }, getEnterLeaveStyle({ opacity: from$1 }, { opacity: 1 }));
var getPanelMotionStyles = (direction, duration) => [getFadeStyle(.7, duration), getEnterLeaveStyle({ transform: getMoveTranslate(direction) }, { transform: "none" })];
var genMotionStyle$1 = (token$1) => {
	const { componentCls, motionDurationSlow } = token$1;
	return { [componentCls]: {
		[`${componentCls}-mask-motion`]: getFadeStyle(0, motionDurationSlow),
		[`${componentCls}-panel-motion`]: [
			"left",
			"right",
			"top",
			"bottom"
		].reduce((obj, direction) => Object.assign(Object.assign({}, obj), { [`&-${direction}`]: getPanelMotionStyles(direction, motionDurationSlow) }), {})
	} };
};
var motion_default$2 = genMotionStyle$1;

//#endregion
//#region node_modules/antd/es/drawer/style/index.js
var genDrawerStyle = (token$1) => {
	const { borderRadiusSM, componentCls, zIndexPopup, colorBgMask, colorBgElevated, motionDurationSlow, motionDurationMid, paddingXS, padding, paddingLG, fontSizeLG, lineHeightLG, lineWidth, lineType, colorSplit, marginXS, colorIcon, colorIconHover, colorBgTextHover, colorBgTextActive, colorText, fontWeightStrong, footerPaddingBlock, footerPaddingInline, calc } = token$1;
	const wrapperCls = `${componentCls}-content-wrapper`;
	return { [componentCls]: {
		position: "fixed",
		inset: 0,
		zIndex: zIndexPopup,
		pointerEvents: "none",
		color: colorText,
		"&-pure": {
			position: "relative",
			background: colorBgElevated,
			display: "flex",
			flexDirection: "column",
			[`&${componentCls}-left`]: { boxShadow: token$1.boxShadowDrawerLeft },
			[`&${componentCls}-right`]: { boxShadow: token$1.boxShadowDrawerRight },
			[`&${componentCls}-top`]: { boxShadow: token$1.boxShadowDrawerUp },
			[`&${componentCls}-bottom`]: { boxShadow: token$1.boxShadowDrawerDown }
		},
		"&-inline": { position: "absolute" },
		[`${componentCls}-mask`]: {
			position: "absolute",
			inset: 0,
			zIndex: zIndexPopup,
			background: colorBgMask,
			pointerEvents: "auto"
		},
		[wrapperCls]: {
			position: "absolute",
			zIndex: zIndexPopup,
			maxWidth: "100vw",
			transition: `all ${motionDurationSlow}`,
			"&-hidden": { display: "none" }
		},
		[`&-left > ${wrapperCls}`]: {
			top: 0,
			bottom: 0,
			left: {
				_skip_check_: true,
				value: 0
			},
			boxShadow: token$1.boxShadowDrawerLeft
		},
		[`&-right > ${wrapperCls}`]: {
			top: 0,
			right: {
				_skip_check_: true,
				value: 0
			},
			bottom: 0,
			boxShadow: token$1.boxShadowDrawerRight
		},
		[`&-top > ${wrapperCls}`]: {
			top: 0,
			insetInline: 0,
			boxShadow: token$1.boxShadowDrawerUp
		},
		[`&-bottom > ${wrapperCls}`]: {
			bottom: 0,
			insetInline: 0,
			boxShadow: token$1.boxShadowDrawerDown
		},
		[`${componentCls}-content`]: {
			display: "flex",
			flexDirection: "column",
			width: "100%",
			height: "100%",
			overflow: "auto",
			background: colorBgElevated,
			pointerEvents: "auto"
		},
		[`${componentCls}-header`]: {
			display: "flex",
			flex: 0,
			alignItems: "center",
			padding: `${unit(padding)} ${unit(paddingLG)}`,
			fontSize: fontSizeLG,
			lineHeight: lineHeightLG,
			borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			"&-title": {
				display: "flex",
				flex: 1,
				alignItems: "center",
				minWidth: 0,
				minHeight: 0
			}
		},
		[`${componentCls}-extra`]: { flex: "none" },
		[`${componentCls}-close`]: Object.assign({
			display: "inline-flex",
			width: calc(fontSizeLG).add(paddingXS).equal(),
			height: calc(fontSizeLG).add(paddingXS).equal(),
			borderRadius: borderRadiusSM,
			justifyContent: "center",
			alignItems: "center",
			marginInlineEnd: marginXS,
			color: colorIcon,
			fontWeight: fontWeightStrong,
			fontSize: fontSizeLG,
			fontStyle: "normal",
			lineHeight: 1,
			textAlign: "center",
			textTransform: "none",
			textDecoration: "none",
			background: "transparent",
			border: 0,
			cursor: "pointer",
			transition: `all ${motionDurationMid}`,
			textRendering: "auto",
			"&:hover": {
				color: colorIconHover,
				backgroundColor: colorBgTextHover,
				textDecoration: "none"
			},
			"&:active": { backgroundColor: colorBgTextActive }
		}, genFocusStyle(token$1)),
		[`${componentCls}-title`]: {
			flex: 1,
			margin: 0,
			fontWeight: token$1.fontWeightStrong,
			fontSize: fontSizeLG,
			lineHeight: lineHeightLG
		},
		[`${componentCls}-body`]: {
			flex: 1,
			minWidth: 0,
			minHeight: 0,
			padding: paddingLG,
			overflow: "auto",
			[`${componentCls}-body-skeleton`]: {
				width: "100%",
				height: "100%",
				display: "flex",
				justifyContent: "center"
			}
		},
		[`${componentCls}-footer`]: {
			flexShrink: 0,
			padding: `${unit(footerPaddingBlock)} ${unit(footerPaddingInline)}`,
			borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`
		},
		"&-rtl": { direction: "rtl" }
	} };
};
const prepareComponentToken$25 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase,
	footerPaddingBlock: token$1.paddingXS,
	footerPaddingInline: token$1.padding
});
var style_default$30 = genStyleHooks("Drawer", (token$1) => {
	const drawerToken = merge(token$1, {});
	return [genDrawerStyle(drawerToken), motion_default$2(drawerToken)];
}, prepareComponentToken$25);

//#endregion
//#region node_modules/antd/es/drawer/index.js
var import_classnames$111 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$55 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var defaultPushState = { distance: 180 };
var Drawer = (props) => {
	var _a;
	const { rootClassName, width, height, size = "default", mask = true, push = defaultPushState, open: open$2, afterOpenChange, onClose, prefixCls: customizePrefixCls, getContainer: customizeGetContainer, panelRef = null, style: style$1, className, visible, afterVisibleChange, maskStyle, drawerStyle, contentWrapperStyle, destroyOnClose, destroyOnHidden } = props, rest = __rest$55(props, [
		"rootClassName",
		"width",
		"height",
		"size",
		"mask",
		"push",
		"open",
		"afterOpenChange",
		"onClose",
		"prefixCls",
		"getContainer",
		"panelRef",
		"style",
		"className",
		"visible",
		"afterVisibleChange",
		"maskStyle",
		"drawerStyle",
		"contentWrapperStyle",
		"destroyOnClose",
		"destroyOnHidden"
	]);
	const { getPopupContainer, getPrefixCls, direction, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("drawer");
	const prefixCls = getPrefixCls("drawer", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$30(prefixCls);
	const getContainer$1 = customizeGetContainer === void 0 && getPopupContainer ? () => getPopupContainer(document.body) : customizeGetContainer;
	const drawerClassName = (0, import_classnames$111.default)({
		"no-mask": !mask,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, rootClassName, hashId, cssVarCls);
	{
		const warning$4 = devUseWarning("Drawer");
		[
			["visible", "open"],
			["afterVisibleChange", "afterOpenChange"],
			["headerStyle", "styles.header"],
			["bodyStyle", "styles.body"],
			["footerStyle", "styles.footer"],
			["contentWrapperStyle", "styles.wrapper"],
			["maskStyle", "styles.mask"],
			["drawerStyle", "styles.content"],
			["destroyInactivePanel", "destroyOnHidden"]
		].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in props), deprecatedName, newName);
		});
		if (getContainer$1 !== void 0 && ((_a = props.style) === null || _a === void 0 ? void 0 : _a.position) === "absolute") warning$4(false, "breaking", "`style` is replaced by `rootStyle` in v5. Please check that `position: absolute` is necessary.");
	}
	const mergedWidth = import_react.useMemo(() => width !== null && width !== void 0 ? width : size === "large" ? 736 : 378, [width, size]);
	const mergedHeight = import_react.useMemo(() => height !== null && height !== void 0 ? height : size === "large" ? 736 : 378, [height, size]);
	const maskMotion = {
		motionName: getTransitionName(prefixCls, "mask-motion"),
		motionAppear: true,
		motionEnter: true,
		motionLeave: true,
		motionDeadline: 500
	};
	const panelMotion = (motionPlacement) => ({
		motionName: getTransitionName(prefixCls, `panel-motion-${motionPlacement}`),
		motionAppear: true,
		motionEnter: true,
		motionLeave: true,
		motionDeadline: 500
	});
	const innerPanelRef = usePanelRef();
	const mergedPanelRef = composeRef(panelRef, innerPanelRef);
	const [zIndex, contextZIndex] = useZIndex("Drawer", rest.zIndex);
	const { classNames: propClassNames = {}, styles: propStyles = {} } = rest;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(ContextIsolator_default, {
		form: true,
		space: true
	}, /* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ import_react.createElement(es_default$18, Object.assign({
		prefixCls,
		onClose,
		maskMotion,
		motion: panelMotion
	}, rest, {
		classNames: {
			mask: (0, import_classnames$111.default)(propClassNames.mask, contextClassNames.mask),
			content: (0, import_classnames$111.default)(propClassNames.content, contextClassNames.content),
			wrapper: (0, import_classnames$111.default)(propClassNames.wrapper, contextClassNames.wrapper)
		},
		styles: {
			mask: Object.assign(Object.assign(Object.assign({}, propStyles.mask), maskStyle), contextStyles.mask),
			content: Object.assign(Object.assign(Object.assign({}, propStyles.content), drawerStyle), contextStyles.content),
			wrapper: Object.assign(Object.assign(Object.assign({}, propStyles.wrapper), contentWrapperStyle), contextStyles.wrapper)
		},
		open: open$2 !== null && open$2 !== void 0 ? open$2 : visible,
		mask,
		push,
		width: mergedWidth,
		height: mergedHeight,
		style: Object.assign(Object.assign({}, contextStyle), style$1),
		className: (0, import_classnames$111.default)(contextClassName, className),
		rootClassName: drawerClassName,
		getContainer: getContainer$1,
		afterOpenChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
		panelRef: mergedPanelRef,
		zIndex,
		destroyOnClose: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyOnClose
	}), /* @__PURE__ */ import_react.createElement(DrawerPanel_default, Object.assign({ prefixCls }, rest, { onClose }))))));
};
/** @private Internal Component. Do not use in your production. */
var PurePanel$6 = (props) => {
	const { prefixCls: customizePrefixCls, style: style$1, className, placement = "right" } = props, restProps = __rest$55(props, [
		"prefixCls",
		"style",
		"className",
		"placement"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("drawer", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$30(prefixCls);
	const cls$12 = (0, import_classnames$111.default)(prefixCls, `${prefixCls}-pure`, `${prefixCls}-${placement}`, hashId, cssVarCls, className);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
		className: cls$12,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement(DrawerPanel_default, Object.assign({ prefixCls }, restProps))));
};
Drawer._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$6;
Drawer.displayName = "Drawer";
var drawer_default = Drawer;

//#endregion
//#region node_modules/antd/es/_util/gapSize.js
function isPresetSize(size) {
	return [
		"small",
		"middle",
		"large"
	].includes(size);
}
function isValidGapNumber(size) {
	if (!size) return false;
	return typeof size === "number" && !Number.isNaN(size);
}

//#endregion
//#region node_modules/antd/es/space/context.js
const SpaceContext = /* @__PURE__ */ import_react.createContext({ latestIndex: 0 });
const SpaceContextProvider = SpaceContext.Provider;

//#endregion
//#region node_modules/antd/es/space/Item.js
var Item$1 = ({ className, index: index$2, children, split, style: style$1 }) => {
	const { latestIndex } = import_react.useContext(SpaceContext);
	if (children === null || children === void 0) return null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: style$1
	}, children), index$2 < latestIndex && split && /* @__PURE__ */ import_react.createElement("span", { className: `${className}-split` }, split));
};
var Item_default$1 = Item$1;

//#endregion
//#region node_modules/antd/es/space/index.js
var import_classnames$110 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$54 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Space = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a;
	const { getPrefixCls, direction: directionConfig, size: contextSize, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("space");
	const { size = contextSize !== null && contextSize !== void 0 ? contextSize : "small", align, className, rootClassName, children, direction = "horizontal", prefixCls: customizePrefixCls, split, style: style$1, wrap = false, classNames: customClassNames, styles } = props, otherProps = __rest$54(props, [
		"size",
		"align",
		"className",
		"rootClassName",
		"children",
		"direction",
		"prefixCls",
		"split",
		"style",
		"wrap",
		"classNames",
		"styles"
	]);
	const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
	const isPresetVerticalSize = isPresetSize(verticalSize);
	const isPresetHorizontalSize = isPresetSize(horizontalSize);
	const isValidVerticalSize = isValidGapNumber(verticalSize);
	const isValidHorizontalSize = isValidGapNumber(horizontalSize);
	const childNodes = toArray(children, { keepEmpty: true });
	const mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align;
	const prefixCls = getPrefixCls("space", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$29(prefixCls);
	const cls$12 = (0, import_classnames$110.default)(prefixCls, contextClassName, hashId, `${prefixCls}-${direction}`, {
		[`${prefixCls}-rtl`]: directionConfig === "rtl",
		[`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
		[`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
		[`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
	}, className, rootClassName, cssVarCls);
	const itemClassName = (0, import_classnames$110.default)(`${prefixCls}-item`, (_a = customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.item) !== null && _a !== void 0 ? _a : contextClassNames.item);
	let latestIndex = 0;
	const nodes = childNodes.map((child, i) => {
		var _a$1;
		if (child !== null && child !== void 0) latestIndex = i;
		const key = (child === null || child === void 0 ? void 0 : child.key) || `${itemClassName}-${i}`;
		return /* @__PURE__ */ import_react.createElement(Item_default$1, {
			className: itemClassName,
			key,
			index: i,
			split,
			style: (_a$1 = styles === null || styles === void 0 ? void 0 : styles.item) !== null && _a$1 !== void 0 ? _a$1 : contextStyles.item
		}, child);
	});
	const spaceContext = import_react.useMemo(() => ({ latestIndex }), [latestIndex]);
	if (childNodes.length === 0) return null;
	const gapStyle = {};
	if (wrap) gapStyle.flexWrap = "wrap";
	if (!isPresetHorizontalSize && isValidHorizontalSize) gapStyle.columnGap = horizontalSize;
	if (!isPresetVerticalSize && isValidVerticalSize) gapStyle.rowGap = verticalSize;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({
		ref,
		className: cls$12,
		style: Object.assign(Object.assign(Object.assign({}, gapStyle), contextStyle), style$1)
	}, otherProps), /* @__PURE__ */ import_react.createElement(SpaceContextProvider, { value: spaceContext }, nodes)));
});
Space.Compact = Compact_default;
Space.displayName = "Space";
var space_default = Space;

//#endregion
//#region node_modules/antd/es/dropdown/dropdown-button.js
var import_classnames$109 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$53 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var DropdownButton = (props) => {
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, type: type$2 = "default", danger, disabled, loading, onClick, htmlType, children, className, menu, arrow, autoFocus, overlay, trigger, align, open: open$2, onOpenChange, placement, getPopupContainer, href, icon = /* @__PURE__ */ import_react.createElement(EllipsisOutlined_default, null), title, buttonsRender = (buttons) => buttons, mouseEnterDelay, mouseLeaveDelay, overlayClassName, overlayStyle, destroyOnHidden, destroyPopupOnHide, dropdownRender, popupRender } = props, restProps = __rest$53(props, [
		"prefixCls",
		"type",
		"danger",
		"disabled",
		"loading",
		"onClick",
		"htmlType",
		"children",
		"className",
		"menu",
		"arrow",
		"autoFocus",
		"overlay",
		"trigger",
		"align",
		"open",
		"onOpenChange",
		"placement",
		"getPopupContainer",
		"href",
		"icon",
		"title",
		"buttonsRender",
		"mouseEnterDelay",
		"mouseLeaveDelay",
		"overlayClassName",
		"overlayStyle",
		"destroyOnHidden",
		"destroyPopupOnHide",
		"dropdownRender",
		"popupRender"
	]);
	const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
	const buttonPrefixCls = `${prefixCls}-button`;
	const dropdownProps = {
		menu,
		arrow,
		autoFocus,
		align,
		disabled,
		trigger: disabled ? [] : trigger,
		onOpenChange,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		mouseEnterDelay,
		mouseLeaveDelay,
		overlayClassName,
		overlayStyle,
		destroyOnHidden,
		popupRender: popupRender || dropdownRender
	};
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const classes = (0, import_classnames$109.default)(buttonPrefixCls, compactItemClassnames, className);
	if ("destroyPopupOnHide" in props) dropdownProps.destroyPopupOnHide = destroyPopupOnHide;
	if ("overlay" in props) dropdownProps.overlay = overlay;
	if ("open" in props) dropdownProps.open = open$2;
	if ("placement" in props) dropdownProps.placement = placement;
	else dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
	const [leftButtonToRender, rightButtonToRender] = buttonsRender([/* @__PURE__ */ import_react.createElement(button_default, {
		type: type$2,
		danger,
		disabled,
		loading,
		onClick,
		htmlType,
		href,
		title
	}, children), /* @__PURE__ */ import_react.createElement(button_default, {
		type: type$2,
		danger,
		icon
	})]);
	return /* @__PURE__ */ import_react.createElement(space_default.Compact, Object.assign({
		className: classes,
		size: compactSize,
		block: true
	}, restProps), leftButtonToRender, /* @__PURE__ */ import_react.createElement(dropdown_default$1, Object.assign({}, dropdownProps), rightButtonToRender));
};
DropdownButton.__ANT_BUTTON = true;
var dropdown_button_default = DropdownButton;

//#endregion
//#region node_modules/antd/es/dropdown/index.js
var Dropdown = dropdown_default$1;
Dropdown.Button = dropdown_button_default;
var dropdown_default = Dropdown;

//#endregion
//#region node_modules/antd/es/flex/utils.js
var import_classnames$108 = /* @__PURE__ */ __toESM(require_classnames());
const flexWrapValues = [
	"wrap",
	"nowrap",
	"wrap-reverse"
];
const justifyContentValues = [
	"flex-start",
	"flex-end",
	"start",
	"end",
	"center",
	"space-between",
	"space-around",
	"space-evenly",
	"stretch",
	"normal",
	"left",
	"right"
];
const alignItemsValues = [
	"center",
	"start",
	"end",
	"flex-start",
	"flex-end",
	"self-start",
	"self-end",
	"baseline",
	"normal",
	"stretch"
];
var genClsWrap = (prefixCls, props) => {
	const wrap = props.wrap === true ? "wrap" : props.wrap;
	return { [`${prefixCls}-wrap-${wrap}`]: wrap && flexWrapValues.includes(wrap) };
};
var genClsAlign = (prefixCls, props) => {
	const alignCls = {};
	alignItemsValues.forEach((cssKey) => {
		alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
	});
	alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
	return alignCls;
};
var genClsJustify = (prefixCls, props) => {
	const justifyCls = {};
	justifyContentValues.forEach((cssKey) => {
		justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
	});
	return justifyCls;
};
function createFlexClassNames(prefixCls, props) {
	return (0, import_classnames$108.default)(Object.assign(Object.assign(Object.assign({}, genClsWrap(prefixCls, props)), genClsAlign(prefixCls, props)), genClsJustify(prefixCls, props)));
}
var utils_default = createFlexClassNames;

//#endregion
//#region node_modules/antd/es/flex/style/index.js
var genFlexStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		display: "flex",
		margin: 0,
		padding: 0,
		"&-vertical": { flexDirection: "column" },
		"&-rtl": { direction: "rtl" },
		"&:empty": { display: "none" }
	} };
};
var genFlexGapStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		"&-gap-small": { gap: token$1.flexGapSM },
		"&-gap-middle": { gap: token$1.flexGap },
		"&-gap-large": { gap: token$1.flexGapLG }
	} };
};
var genFlexWrapStyle = (token$1) => {
	const { componentCls } = token$1;
	const wrapStyle = {};
	flexWrapValues.forEach((value) => {
		wrapStyle[`${componentCls}-wrap-${value}`] = { flexWrap: value };
	});
	return wrapStyle;
};
var genAlignItemsStyle = (token$1) => {
	const { componentCls } = token$1;
	const alignStyle = {};
	alignItemsValues.forEach((value) => {
		alignStyle[`${componentCls}-align-${value}`] = { alignItems: value };
	});
	return alignStyle;
};
var genJustifyContentStyle = (token$1) => {
	const { componentCls } = token$1;
	const justifyStyle = {};
	justifyContentValues.forEach((value) => {
		justifyStyle[`${componentCls}-justify-${value}`] = { justifyContent: value };
	});
	return justifyStyle;
};
const prepareComponentToken$24 = () => ({});
var style_default$28 = genStyleHooks("Flex", (token$1) => {
	const { paddingXS, padding, paddingLG } = token$1;
	const flexToken = merge(token$1, {
		flexGapSM: paddingXS,
		flexGap: padding,
		flexGapLG: paddingLG
	});
	return [
		genFlexStyle(flexToken),
		genFlexGapStyle(flexToken),
		genFlexWrapStyle(flexToken),
		genAlignItemsStyle(flexToken),
		genJustifyContentStyle(flexToken)
	];
}, prepareComponentToken$24, { resetStyle: false });

//#endregion
//#region node_modules/antd/es/flex/index.js
var import_classnames$107 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$52 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Flex = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, rootClassName, className, style: style$1, flex, gap, vertical = false, component: Component$2 = "div" } = props, othersProps = __rest$52(props, [
		"prefixCls",
		"rootClassName",
		"className",
		"style",
		"flex",
		"gap",
		"vertical",
		"component"
	]);
	const { flex: ctxFlex, direction: ctxDirection, getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("flex", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$28(prefixCls);
	const mergedVertical = vertical !== null && vertical !== void 0 ? vertical : ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.vertical;
	const mergedCls = (0, import_classnames$107.default)(className, rootClassName, ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.className, prefixCls, hashId, cssVarCls, utils_default(prefixCls, props), {
		[`${prefixCls}-rtl`]: ctxDirection === "rtl",
		[`${prefixCls}-gap-${gap}`]: isPresetSize(gap),
		[`${prefixCls}-vertical`]: mergedVertical
	});
	const mergedStyle = Object.assign(Object.assign({}, ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.style), style$1);
	if (flex) mergedStyle.flex = flex;
	if (gap && !isPresetSize(gap)) mergedStyle.gap = gap;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(Component$2, Object.assign({
		ref,
		className: mergedCls,
		style: mergedStyle
	}, omit(othersProps, [
		"justify",
		"wrap",
		"align"
	]))));
});
Flex.displayName = "Flex";
var flex_default = Flex;

//#endregion
//#region node_modules/antd/es/float-button/context.js
var FloatButtonGroupContext = /* @__PURE__ */ import_react.createContext(void 0);
const { Provider: FloatButtonGroupProvider } = FloatButtonGroupContext;
var context_default$1 = FloatButtonGroupContext;

//#endregion
//#region node_modules/antd/es/_util/convertToTooltipProps.js
function convertToTooltipProps(tooltip) {
	if (tooltip === void 0 || tooltip === null) return null;
	if (typeof tooltip === "object" && !/* @__PURE__ */ (0, import_react.isValidElement)(tooltip)) return tooltip;
	return { title: tooltip };
}
var convertToTooltipProps_default = convertToTooltipProps;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/FileTextOutlined.js
var FileTextOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" }
		}]
	},
	"name": "file-text",
	"theme": "outlined"
};
var FileTextOutlined_default$1 = FileTextOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/FileTextOutlined.js
/**![file-text](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg1NC42IDI4OC42TDYzOS40IDczLjRjLTYtNi0xNC4xLTkuNC0yMi42LTkuNEgxOTJjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjgzMmMwIDE3LjcgMTQuMyAzMiAzMiAzMmg2NDBjMTcuNyAwIDMyLTE0LjMgMzItMzJWMzExLjNjMC04LjUtMy40LTE2LjctOS40LTIyLjd6TTc5MC4yIDMyNkg2MDJWMTM3LjhMNzkwLjIgMzI2em0xLjggNTYySDIzMlYxMzZoMzAydjIxNmE0MiA0MiAwIDAwNDIgNDJoMjE2djQ5NHpNNTA0IDYxOEgzMjBjLTQuNCAwLTggMy42LTggOHY0OGMwIDQuNCAzLjYgOCA4IDhoMTg0YzQuNCAwIDgtMy42IDgtOHYtNDhjMC00LjQtMy42LTgtOC04ek0zMTIgNDkwdjQ4YzAgNC40IDMuNiA4IDggOGgzODRjNC40IDAgOC0zLjYgOC04di00OGMwLTQuNC0zLjYtOC04LThIMzIwYy00LjQgMC04IDMuNi04IDh6IiAvPjwvc3ZnPg==) */
var RefIcon$31 = /* @__PURE__ */ import_react.forwardRef(function FileTextOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: FileTextOutlined_default$1
	}));
});
RefIcon$31.displayName = "FileTextOutlined";
var FileTextOutlined_default = RefIcon$31;

//#endregion
//#region node_modules/antd/es/float-button/FloatButtonContent.js
var import_classnames$106 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$51 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var FloatButtonContent = (props) => {
	const { icon, description, prefixCls, className } = props, rest = __rest$51(props, [
		"icon",
		"description",
		"prefixCls",
		"className"
	]);
	const defaultElement = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-icon` }, /* @__PURE__ */ import_react.createElement(FileTextOutlined_default, null));
	return /* @__PURE__ */ import_react.createElement("div", Object.assign({}, rest, { className: (0, import_classnames$106.default)(className, `${prefixCls}-content`) }), icon || description ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, icon && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-icon` }, icon), description && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-description` }, description)) : defaultElement);
};
var FloatButtonContent_default = /* @__PURE__ */ (0, import_react.memo)(FloatButtonContent);

//#endregion
//#region node_modules/antd/es/float-button/util.js
var getOffset$2 = (radius$1) => {
	if (radius$1 === 0) return 0;
	return radius$1 - Math.sqrt(Math.pow(radius$1, 2) / 2);
};
var util_default = getOffset$2;

//#endregion
//#region node_modules/antd/es/float-button/style/keyframes.js
var floatButtonGroupMotion = (token$1) => {
	const { componentCls, floatButtonSize, motionDurationSlow, motionEaseInOutCirc, calc } = token$1;
	const moveTopIn = new Keyframes_default("antFloatButtonMoveTopIn", {
		"0%": {
			transform: `translate3d(0, ${unit(floatButtonSize)}, 0)`,
			transformOrigin: "0 0",
			opacity: 0
		},
		"100%": {
			transform: "translate3d(0, 0, 0)",
			transformOrigin: "0 0",
			opacity: 1
		}
	});
	const moveTopOut = new Keyframes_default("antFloatButtonMoveTopOut", {
		"0%": {
			transform: "translate3d(0, 0, 0)",
			transformOrigin: "0 0",
			opacity: 1
		},
		"100%": {
			transform: `translate3d(0, ${unit(floatButtonSize)}, 0)`,
			transformOrigin: "0 0",
			opacity: 0
		}
	});
	const moveRightIn$1 = new Keyframes_default("antFloatButtonMoveRightIn", {
		"0%": {
			transform: `translate3d(${unit(calc(floatButtonSize).mul(-1).equal())}, 0, 0)`,
			transformOrigin: "0 0",
			opacity: 0
		},
		"100%": {
			transform: "translate3d(0, 0, 0)",
			transformOrigin: "0 0",
			opacity: 1
		}
	});
	const moveRightOut$1 = new Keyframes_default("antFloatButtonMoveRightOut", {
		"0%": {
			transform: "translate3d(0, 0, 0)",
			transformOrigin: "0 0",
			opacity: 1
		},
		"100%": {
			transform: `translate3d(${unit(calc(floatButtonSize).mul(-1).equal())}, 0, 0)`,
			transformOrigin: "0 0",
			opacity: 0
		}
	});
	const moveBottomIn = new Keyframes_default("antFloatButtonMoveBottomIn", {
		"0%": {
			transform: `translate3d(0, ${unit(calc(floatButtonSize).mul(-1).equal())}, 0)`,
			transformOrigin: "0 0",
			opacity: 0
		},
		"100%": {
			transform: "translate3d(0, 0, 0)",
			transformOrigin: "0 0",
			opacity: 1
		}
	});
	const moveBottomOut = new Keyframes_default("antFloatButtonMoveBottomOut", {
		"0%": {
			transform: "translate3d(0, 0, 0)",
			transformOrigin: "0 0",
			opacity: 1
		},
		"100%": {
			transform: `translate3d(0, ${unit(calc(floatButtonSize).mul(-1).equal())}, 0)`,
			transformOrigin: "0 0",
			opacity: 0
		}
	});
	const moveLeftIn$1 = new Keyframes_default("antFloatButtonMoveLeftIn", {
		"0%": {
			transform: `translate3d(${unit(floatButtonSize)}, 0, 0)`,
			transformOrigin: "0 0",
			opacity: 0
		},
		"100%": {
			transform: "translate3d(0, 0, 0)",
			transformOrigin: "0 0",
			opacity: 1
		}
	});
	const moveLeftOut$1 = new Keyframes_default("antFloatButtonMoveLeftOut", {
		"0%": {
			transform: "translate3d(0, 0, 0)",
			transformOrigin: "0 0",
			opacity: 1
		},
		"100%": {
			transform: `translate3d(${unit(floatButtonSize)}, 0, 0)`,
			transformOrigin: "0 0",
			opacity: 0
		}
	});
	const groupPrefixCls = `${componentCls}-group`;
	return [{ [groupPrefixCls]: {
		[`&${groupPrefixCls}-top ${groupPrefixCls}-wrap`]: initMotion(`${groupPrefixCls}-wrap`, moveTopIn, moveTopOut, motionDurationSlow, true),
		[`&${groupPrefixCls}-bottom ${groupPrefixCls}-wrap`]: initMotion(`${groupPrefixCls}-wrap`, moveBottomIn, moveBottomOut, motionDurationSlow, true),
		[`&${groupPrefixCls}-left ${groupPrefixCls}-wrap`]: initMotion(`${groupPrefixCls}-wrap`, moveLeftIn$1, moveLeftOut$1, motionDurationSlow, true),
		[`&${groupPrefixCls}-right ${groupPrefixCls}-wrap`]: initMotion(`${groupPrefixCls}-wrap`, moveRightIn$1, moveRightOut$1, motionDurationSlow, true)
	} }, { [`${groupPrefixCls}-wrap`]: {
		[`&${groupPrefixCls}-wrap-enter, &${groupPrefixCls}-wrap-appear`]: {
			opacity: 0,
			animationTimingFunction: motionEaseInOutCirc
		},
		[`&${groupPrefixCls}-wrap-leave`]: {
			opacity: 1,
			animationTimingFunction: motionEaseInOutCirc
		}
	} }];
};
var keyframes_default = floatButtonGroupMotion;

//#endregion
//#region node_modules/antd/es/float-button/style/index.js
var floatButtonGroupStyle = (token$1) => {
	const { antCls, componentCls, floatButtonSize, margin, borderRadiusLG, borderRadiusSM, badgeOffset, floatButtonBodyPadding, zIndexPopupBase, calc } = token$1;
	const groupPrefixCls = `${componentCls}-group`;
	return {
		[groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			zIndex: zIndexPopupBase,
			display: "flex",
			flexDirection: "column",
			alignItems: "center",
			justifyContent: "center",
			border: "none",
			position: "fixed",
			height: "auto",
			boxShadow: "none",
			minWidth: floatButtonSize,
			minHeight: floatButtonSize,
			insetInlineEnd: token$1.floatButtonInsetInlineEnd,
			bottom: token$1.floatButtonInsetBlockEnd,
			borderRadius: borderRadiusLG,
			[`${groupPrefixCls}-wrap`]: {
				zIndex: -1,
				display: "flex",
				justifyContent: "center",
				alignItems: "center",
				position: "absolute"
			},
			[`&${groupPrefixCls}-rtl`]: { direction: "rtl" },
			[componentCls]: { position: "static" }
		}),
		[`${groupPrefixCls}-top > ${groupPrefixCls}-wrap`]: {
			flexDirection: "column",
			top: "auto",
			bottom: calc(floatButtonSize).add(margin).equal(),
			"&::after": {
				content: "\"\"",
				position: "absolute",
				width: "100%",
				height: margin,
				bottom: calc(margin).mul(-1).equal()
			}
		},
		[`${groupPrefixCls}-bottom > ${groupPrefixCls}-wrap`]: {
			flexDirection: "column",
			top: calc(floatButtonSize).add(margin).equal(),
			bottom: "auto",
			"&::after": {
				content: "\"\"",
				position: "absolute",
				width: "100%",
				height: margin,
				top: calc(margin).mul(-1).equal()
			}
		},
		[`${groupPrefixCls}-right > ${groupPrefixCls}-wrap`]: {
			flexDirection: "row",
			left: {
				_skip_check_: true,
				value: calc(floatButtonSize).add(margin).equal()
			},
			right: {
				_skip_check_: true,
				value: "auto"
			},
			"&::after": {
				content: "\"\"",
				position: "absolute",
				width: margin,
				height: "100%",
				left: {
					_skip_check_: true,
					value: calc(margin).mul(-1).equal()
				}
			}
		},
		[`${groupPrefixCls}-left > ${groupPrefixCls}-wrap`]: {
			flexDirection: "row",
			left: {
				_skip_check_: true,
				value: "auto"
			},
			right: {
				_skip_check_: true,
				value: calc(floatButtonSize).add(margin).equal()
			},
			"&::after": {
				content: "\"\"",
				position: "absolute",
				width: margin,
				height: "100%",
				right: {
					_skip_check_: true,
					value: calc(margin).mul(-1).equal()
				}
			}
		},
		[`${groupPrefixCls}-circle`]: {
			gap: margin,
			[`${groupPrefixCls}-wrap`]: { gap: margin }
		},
		[`${groupPrefixCls}-square`]: {
			[`${componentCls}-square`]: {
				padding: 0,
				borderRadius: 0,
				[`&${groupPrefixCls}-trigger`]: { borderRadius: borderRadiusLG },
				"&:first-child": {
					borderStartStartRadius: borderRadiusLG,
					borderStartEndRadius: borderRadiusLG
				},
				"&:last-child": {
					borderEndStartRadius: borderRadiusLG,
					borderEndEndRadius: borderRadiusLG
				},
				"&:not(:last-child)": { borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
				[`${antCls}-badge`]: { [`${antCls}-badge-count`]: {
					top: calc(calc(floatButtonBodyPadding).add(badgeOffset)).mul(-1).equal(),
					insetInlineEnd: calc(calc(floatButtonBodyPadding).add(badgeOffset)).mul(-1).equal()
				} }
			},
			[`${groupPrefixCls}-wrap`]: {
				borderRadius: borderRadiusLG,
				boxShadow: token$1.boxShadowSecondary,
				[`${componentCls}-square`]: {
					boxShadow: "none",
					borderRadius: 0,
					padding: floatButtonBodyPadding,
					[`${componentCls}-body`]: {
						width: token$1.floatButtonBodySize,
						height: token$1.floatButtonBodySize,
						borderRadius: borderRadiusSM
					}
				}
			}
		},
		[`${groupPrefixCls}-top > ${groupPrefixCls}-wrap, ${groupPrefixCls}-bottom > ${groupPrefixCls}-wrap`]: { [`> ${componentCls}-square`]: {
			"&:first-child": {
				borderStartStartRadius: borderRadiusLG,
				borderStartEndRadius: borderRadiusLG
			},
			"&:last-child": {
				borderEndStartRadius: borderRadiusLG,
				borderEndEndRadius: borderRadiusLG
			},
			"&:not(:last-child)": { borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` }
		} },
		[`${groupPrefixCls}-left > ${groupPrefixCls}-wrap, ${groupPrefixCls}-right > ${groupPrefixCls}-wrap`]: { [`> ${componentCls}-square`]: {
			"&:first-child": {
				borderStartStartRadius: borderRadiusLG,
				borderEndStartRadius: borderRadiusLG
			},
			"&:last-child": {
				borderStartEndRadius: borderRadiusLG,
				borderEndEndRadius: borderRadiusLG
			},
			"&:not(:last-child)": {
				borderBottom: "none",
				borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`
			}
		} },
		[`${groupPrefixCls}-circle-shadow`]: { boxShadow: "none" },
		[`${groupPrefixCls}-square-shadow`]: {
			boxShadow: token$1.boxShadowSecondary,
			[`${componentCls}-square`]: {
				boxShadow: "none",
				padding: floatButtonBodyPadding,
				[`${componentCls}-body`]: {
					width: token$1.floatButtonBodySize,
					height: token$1.floatButtonBodySize,
					borderRadius: borderRadiusSM
				}
			}
		}
	};
};
var sharedFloatButtonStyle = (token$1) => {
	const { antCls, componentCls, floatButtonBodyPadding, floatButtonIconSize, floatButtonSize, borderRadiusLG, badgeOffset, dotOffsetInSquare, dotOffsetInCircle, zIndexPopupBase, calc } = token$1;
	return {
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			border: "none",
			position: "fixed",
			cursor: "pointer",
			zIndex: zIndexPopupBase,
			display: "block",
			width: floatButtonSize,
			height: floatButtonSize,
			insetInlineEnd: token$1.floatButtonInsetInlineEnd,
			bottom: token$1.floatButtonInsetBlockEnd,
			boxShadow: token$1.boxShadowSecondary,
			"&-pure": {
				position: "relative",
				inset: "auto"
			},
			"&:empty": { display: "none" },
			[`${antCls}-badge`]: {
				width: "100%",
				height: "100%",
				[`${antCls}-badge-count`]: {
					transform: "translate(0, 0)",
					transformOrigin: "center",
					top: calc(badgeOffset).mul(-1).equal(),
					insetInlineEnd: calc(badgeOffset).mul(-1).equal()
				}
			},
			[`${componentCls}-body`]: {
				width: "100%",
				height: "100%",
				display: "flex",
				justifyContent: "center",
				alignItems: "center",
				transition: `all ${token$1.motionDurationMid}`,
				[`${componentCls}-content`]: {
					overflow: "hidden",
					textAlign: "center",
					minHeight: floatButtonSize,
					display: "flex",
					flexDirection: "column",
					justifyContent: "center",
					alignItems: "center",
					padding: `${unit(calc(floatButtonBodyPadding).div(2).equal())} ${unit(floatButtonBodyPadding)}`,
					[`${componentCls}-icon`]: {
						textAlign: "center",
						margin: "auto",
						width: floatButtonIconSize,
						fontSize: floatButtonIconSize,
						lineHeight: 1
					}
				}
			}
		}),
		[`${componentCls}-rtl`]: { direction: "rtl" },
		[`${componentCls}-circle`]: {
			height: floatButtonSize,
			borderRadius: "50%",
			[`${antCls}-badge`]: { [`${antCls}-badge-dot`]: {
				top: dotOffsetInCircle,
				insetInlineEnd: dotOffsetInCircle
			} },
			[`${componentCls}-body`]: { borderRadius: "50%" }
		},
		[`${componentCls}-square`]: {
			height: "auto",
			minHeight: floatButtonSize,
			borderRadius: borderRadiusLG,
			[`${antCls}-badge`]: { [`${antCls}-badge-dot`]: {
				top: dotOffsetInSquare,
				insetInlineEnd: dotOffsetInSquare
			} },
			[`${componentCls}-body`]: {
				height: "auto",
				borderRadius: borderRadiusLG
			}
		},
		[`${componentCls}-default`]: {
			backgroundColor: token$1.floatButtonBackgroundColor,
			transition: `background-color ${token$1.motionDurationMid}`,
			[`${componentCls}-body`]: {
				backgroundColor: token$1.floatButtonBackgroundColor,
				transition: `background-color ${token$1.motionDurationMid}`,
				"&:hover": { backgroundColor: token$1.colorFillContent },
				[`${componentCls}-content`]: {
					[`${componentCls}-icon`]: { color: token$1.colorText },
					[`${componentCls}-description`]: {
						display: "flex",
						alignItems: "center",
						lineHeight: unit(token$1.fontSizeLG),
						color: token$1.colorText,
						fontSize: token$1.fontSizeSM
					}
				}
			}
		},
		[`${componentCls}-primary`]: {
			backgroundColor: token$1.colorPrimary,
			[`${componentCls}-body`]: {
				backgroundColor: token$1.colorPrimary,
				transition: `background-color ${token$1.motionDurationMid}`,
				"&:hover": { backgroundColor: token$1.colorPrimaryHover },
				[`${componentCls}-content`]: {
					[`${componentCls}-icon`]: { color: token$1.colorTextLightSolid },
					[`${componentCls}-description`]: {
						display: "flex",
						alignItems: "center",
						lineHeight: unit(token$1.fontSizeLG),
						color: token$1.colorTextLightSolid,
						fontSize: token$1.fontSizeSM
					}
				}
			}
		}
	};
};
const prepareComponentToken$23 = (token$1) => ({
	dotOffsetInCircle: util_default(token$1.controlHeightLG / 2),
	dotOffsetInSquare: util_default(token$1.borderRadiusLG)
});
var style_default$27 = genStyleHooks("FloatButton", (token$1) => {
	const { colorTextLightSolid, colorBgElevated, controlHeightLG, marginXXL, marginLG, fontSize, fontSizeIcon, controlItemBgHover, paddingXXS, calc } = token$1;
	const floatButtonToken = merge(token$1, {
		floatButtonBackgroundColor: colorBgElevated,
		floatButtonColor: colorTextLightSolid,
		floatButtonHoverBackgroundColor: controlItemBgHover,
		floatButtonFontSize: fontSize,
		floatButtonIconSize: calc(fontSizeIcon).mul(1.5).equal(),
		floatButtonSize: controlHeightLG,
		floatButtonInsetBlockEnd: marginXXL,
		floatButtonInsetInlineEnd: marginLG,
		floatButtonBodySize: calc(controlHeightLG).sub(calc(paddingXXS).mul(2)).equal(),
		floatButtonBodyPadding: paddingXXS,
		badgeOffset: calc(paddingXXS).mul(1.5).equal()
	});
	return [
		floatButtonGroupStyle(floatButtonToken),
		sharedFloatButtonStyle(floatButtonToken),
		initFadeMotion(token$1),
		keyframes_default(floatButtonToken)
	];
}, prepareComponentToken$23);

//#endregion
//#region node_modules/antd/es/float-button/FloatButton.js
var import_classnames$105 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$50 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const floatButtonPrefixCls = "float-btn";
var FloatButton = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, type: type$2 = "default", shape = "circle", icon, description, tooltip, htmlType = "button", badge = {} } = props, restProps = __rest$50(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"style",
		"type",
		"shape",
		"icon",
		"description",
		"tooltip",
		"htmlType",
		"badge"
	]);
	const { getPrefixCls, direction } = (0, import_react.useContext)(ConfigContext);
	const groupShape = (0, import_react.useContext)(context_default$1);
	const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$27(prefixCls, rootCls);
	const mergedShape = groupShape || shape;
	const classString = (0, import_classnames$105.default)(hashId, cssVarCls, rootCls, prefixCls, className, rootClassName, `${prefixCls}-${type$2}`, `${prefixCls}-${mergedShape}`, { [`${prefixCls}-rtl`]: direction === "rtl" });
	const [zIndex] = useZIndex("FloatButton", style$1 === null || style$1 === void 0 ? void 0 : style$1.zIndex);
	const mergedStyle = Object.assign(Object.assign({}, style$1), { zIndex });
	const badgeProps = omit(badge, [
		"title",
		"children",
		"status",
		"text"
	]);
	let buttonNode = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-body` }, /* @__PURE__ */ import_react.createElement(FloatButtonContent_default, {
		prefixCls,
		description,
		icon
	}));
	if ("badge" in props) buttonNode = /* @__PURE__ */ import_react.createElement(badge_default, Object.assign({}, badgeProps), buttonNode);
	const tooltipProps = convertToTooltipProps_default(tooltip);
	if (tooltipProps) buttonNode = /* @__PURE__ */ import_react.createElement(tooltip_default, Object.assign({}, tooltipProps), buttonNode);
	devUseWarning("FloatButton")(!(mergedShape === "circle" && description), "usage", "supported only when `shape` is `square`. Due to narrow space for text, short sentence is recommended.");
	return wrapCSSVar(props.href ? /* @__PURE__ */ import_react.createElement("a", Object.assign({ ref }, restProps, {
		className: classString,
		style: mergedStyle
	}), buttonNode) : /* @__PURE__ */ import_react.createElement("button", Object.assign({ ref }, restProps, {
		className: classString,
		style: mergedStyle,
		type: htmlType
	}), buttonNode));
});
FloatButton.displayName = "FloatButton";
var FloatButton_default = FloatButton;

//#endregion
//#region node_modules/antd/es/float-button/BackTop.js
var import_classnames$104 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$49 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var defaultIcon = /* @__PURE__ */ import_react.createElement(VerticalAlignTopOutlined_default, null);
var BackTop = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a;
	const { backTopIcon: contextIcon } = useComponentConfig("floatButton");
	const { prefixCls: customizePrefixCls, className, type: type$2 = "default", shape = "circle", visibilityHeight = 400, icon, target, onClick, duration = 450 } = props, restProps = __rest$49(props, [
		"prefixCls",
		"className",
		"type",
		"shape",
		"visibilityHeight",
		"icon",
		"target",
		"onClick",
		"duration"
	]);
	const mergedIcon = (_a = icon !== null && icon !== void 0 ? icon : contextIcon) !== null && _a !== void 0 ? _a : defaultIcon;
	const [visible, setVisible] = (0, import_react.useState)(visibilityHeight === 0);
	const internalRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: internalRef.current }));
	const getDefaultTarget$1 = () => {
		var _a$1;
		return ((_a$1 = internalRef.current) === null || _a$1 === void 0 ? void 0 : _a$1.ownerDocument) || window;
	};
	const handleScroll = throttleByAnimationFrame_default((e$2) => {
		const scrollTop = getScroll_default(e$2.target);
		setVisible(scrollTop >= visibilityHeight);
	});
	(0, import_react.useEffect)(() => {
		const container = (target || getDefaultTarget$1)();
		handleScroll({ target: container });
		container === null || container === void 0 || container.addEventListener("scroll", handleScroll);
		return () => {
			handleScroll.cancel();
			container === null || container === void 0 || container.removeEventListener("scroll", handleScroll);
		};
	}, [target]);
	const scrollToTop = (e$2) => {
		scrollTo(0, {
			getContainer: target || getDefaultTarget$1,
			duration
		});
		onClick === null || onClick === void 0 || onClick(e$2);
	};
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const mergedShape = (0, import_react.useContext)(context_default$1) || shape;
	const contentProps = Object.assign({
		prefixCls,
		icon: mergedIcon,
		type: type$2,
		shape: mergedShape
	}, restProps);
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible,
		motionName: `${rootPrefixCls}-fade`
	}, ({ className: motionClassName }, setRef) => /* @__PURE__ */ import_react.createElement(FloatButton_default, Object.assign({ ref: composeRef(internalRef, setRef) }, contentProps, {
		onClick: scrollToTop,
		className: (0, import_classnames$104.default)(className, motionClassName)
	})));
});
BackTop.displayName = "BackTop";
var BackTop_default = BackTop;

//#endregion
//#region node_modules/antd/es/float-button/FloatButtonGroup.js
var import_classnames$103 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$48 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var FloatButtonGroup = (props) => {
	var _a;
	const { prefixCls: customizePrefixCls, className, style: style$1, shape = "circle", type: type$2 = "default", placement = "top", icon = /* @__PURE__ */ import_react.createElement(FileTextOutlined_default, null), closeIcon, description, trigger, children, onOpenChange, open: customOpen, onClick: onTriggerButtonClick } = props, floatButtonProps = __rest$48(props, [
		"prefixCls",
		"className",
		"style",
		"shape",
		"type",
		"placement",
		"icon",
		"closeIcon",
		"description",
		"trigger",
		"children",
		"onOpenChange",
		"open",
		"onClick"
	]);
	const { direction, getPrefixCls, closeIcon: contextCloseIcon } = useComponentConfig("floatButtonGroup");
	const mergedCloseIcon = (_a = closeIcon !== null && closeIcon !== void 0 ? closeIcon : contextCloseIcon) !== null && _a !== void 0 ? _a : /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null);
	const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$27(prefixCls, rootCls);
	const groupPrefixCls = `${prefixCls}-group`;
	const isMenuMode = trigger && ["click", "hover"].includes(trigger);
	const isValidPlacement = placement && [
		"top",
		"left",
		"right",
		"bottom"
	].includes(placement);
	const groupCls = (0, import_classnames$103.default)(groupPrefixCls, hashId, cssVarCls, rootCls, className, {
		[`${groupPrefixCls}-rtl`]: direction === "rtl",
		[`${groupPrefixCls}-${shape}`]: shape,
		[`${groupPrefixCls}-${shape}-shadow`]: !isMenuMode,
		[`${groupPrefixCls}-${placement}`]: isMenuMode && isValidPlacement
	});
	const [zIndex] = useZIndex("FloatButton", style$1 === null || style$1 === void 0 ? void 0 : style$1.zIndex);
	const mergedStyle = Object.assign(Object.assign({}, style$1), { zIndex });
	const wrapperCls = (0, import_classnames$103.default)(hashId, `${groupPrefixCls}-wrap`);
	const [open$2, setOpen] = useMergedState(false, { value: customOpen });
	const floatButtonGroupRef = import_react.useRef(null);
	const hoverTrigger = trigger === "hover";
	const clickTrigger = trigger === "click";
	const triggerOpen = useEvent((nextOpen) => {
		if (open$2 !== nextOpen) {
			setOpen(nextOpen);
			onOpenChange === null || onOpenChange === void 0 || onOpenChange(nextOpen);
		}
	});
	const onMouseEnter = () => {
		if (hoverTrigger) triggerOpen(true);
	};
	const onMouseLeave = () => {
		if (hoverTrigger) triggerOpen(false);
	};
	const onInternalTriggerButtonClick = (e$2) => {
		if (clickTrigger) triggerOpen(!open$2);
		onTriggerButtonClick === null || onTriggerButtonClick === void 0 || onTriggerButtonClick(e$2);
	};
	import_react.useEffect(() => {
		if (clickTrigger) {
			const onDocClick = (e$2) => {
				var _a$1;
				if ((_a$1 = floatButtonGroupRef.current) === null || _a$1 === void 0 ? void 0 : _a$1.contains(e$2.target)) return;
				triggerOpen(false);
			};
			document.addEventListener("click", onDocClick, { capture: true });
			return () => document.removeEventListener("click", onDocClick, { capture: true });
		}
	}, [clickTrigger]);
	devUseWarning("FloatButton.Group")(!("open" in props) || !!trigger, "usage", "`open` need to be used together with `trigger`");
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(FloatButtonGroupProvider, { value: shape }, /* @__PURE__ */ import_react.createElement("div", {
		ref: floatButtonGroupRef,
		className: groupCls,
		style: mergedStyle,
		onMouseEnter,
		onMouseLeave
	}, isMenuMode ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible: open$2,
		motionName: `${groupPrefixCls}-wrap`
	}, ({ className: motionClassName }) => /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$103.default)(motionClassName, wrapperCls) }, children)), /* @__PURE__ */ import_react.createElement(FloatButton_default, Object.assign({
		type: type$2,
		icon: open$2 ? mergedCloseIcon : icon,
		description,
		"aria-label": props["aria-label"],
		className: `${groupPrefixCls}-trigger`,
		onClick: onInternalTriggerButtonClick
	}, floatButtonProps))) : children)));
};
var FloatButtonGroup_default = FloatButtonGroup;

//#endregion
//#region node_modules/antd/es/float-button/PurePanel.js
var import_classnames$102 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$47 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var PureFloatButton = (_a) => {
	var { backTop } = _a, props = __rest$47(_a, ["backTop"]);
	return backTop ? /* @__PURE__ */ import_react.createElement(BackTop_default, Object.assign({}, props, { visibilityHeight: 0 })) : /* @__PURE__ */ import_react.createElement(FloatButton_default, Object.assign({}, props));
};
/** @private Internal Component. Do not use in your production. */
var PurePanel$5 = (_a) => {
	var { className, items } = _a, props = __rest$47(_a, ["className", "items"]);
	const { prefixCls: customizePrefixCls } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const pureCls = `${getPrefixCls(floatButtonPrefixCls, customizePrefixCls)}-pure`;
	if (items) return /* @__PURE__ */ import_react.createElement(FloatButtonGroup_default, Object.assign({ className: (0, import_classnames$102.default)(className, pureCls) }, props), items.map((item, index$2) => /* @__PURE__ */ import_react.createElement(PureFloatButton, Object.assign({ key: index$2 }, item))));
	return /* @__PURE__ */ import_react.createElement(PureFloatButton, Object.assign({ className: (0, import_classnames$102.default)(className, pureCls) }, props));
};
var PurePanel_default$7 = PurePanel$5;

//#endregion
//#region node_modules/antd/es/float-button/index.js
FloatButton_default.BackTop = BackTop_default;
FloatButton_default.Group = FloatButtonGroup_default;
FloatButton_default._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$7;
var float_button_default = FloatButton_default;

//#endregion
//#region node_modules/antd/es/form/hooks/useDebounce.js
function useDebounce(value) {
	const [cacheValue, setCacheValue] = import_react.useState(value);
	import_react.useEffect(() => {
		const timeout = setTimeout(() => {
			setCacheValue(value);
		}, value.length ? 0 : 10);
		return () => {
			clearTimeout(timeout);
		};
	}, [value]);
	return cacheValue;
}

//#endregion
//#region node_modules/antd/es/form/style/explain.js
var genFormValidateMotionStyle = (token$1) => {
	const { componentCls } = token$1;
	const helpCls = `${componentCls}-show-help`;
	const helpItemCls = `${componentCls}-show-help-item`;
	return { [helpCls]: {
		transition: `opacity ${token$1.motionDurationFast} ${token$1.motionEaseInOut}`,
		"&-appear, &-enter": {
			opacity: 0,
			"&-active": { opacity: 1 }
		},
		"&-leave": {
			opacity: 1,
			"&-active": { opacity: 0 }
		},
		[helpItemCls]: {
			overflow: "hidden",
			transition: `height ${token$1.motionDurationFast} ${token$1.motionEaseInOut},
                     opacity ${token$1.motionDurationFast} ${token$1.motionEaseInOut},
                     transform ${token$1.motionDurationFast} ${token$1.motionEaseInOut} !important`,
			[`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
				transform: `translateY(-5px)`,
				opacity: 0,
				"&-active": {
					transform: "translateY(0)",
					opacity: 1
				}
			},
			[`&${helpItemCls}-leave-active`]: { transform: `translateY(-5px)` }
		}
	} };
};
var explain_default = genFormValidateMotionStyle;

//#endregion
//#region node_modules/antd/es/form/style/index.js
var resetForm = (token$1) => ({
	legend: {
		display: "block",
		width: "100%",
		marginBottom: token$1.marginLG,
		padding: 0,
		color: token$1.colorTextDescription,
		fontSize: token$1.fontSizeLG,
		lineHeight: "inherit",
		border: 0,
		borderBottom: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`
	},
	"input[type=\"search\"]": { boxSizing: "border-box" },
	"input[type=\"radio\"], input[type=\"checkbox\"]": { lineHeight: "normal" },
	"input[type=\"file\"]": { display: "block" },
	"input[type=\"range\"]": {
		display: "block",
		width: "100%"
	},
	"select[multiple], select[size]": { height: "auto" },
	[`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
		outline: 0,
		boxShadow: `0 0 0 ${unit(token$1.controlOutlineWidth)} ${token$1.controlOutline}`
	},
	output: {
		display: "block",
		paddingTop: 15,
		color: token$1.colorText,
		fontSize: token$1.fontSize,
		lineHeight: token$1.lineHeight
	}
});
var genFormSize = (token$1, height) => {
	const { formItemCls } = token$1;
	return { [formItemCls]: {
		[`${formItemCls}-label > label`]: { height },
		[`${formItemCls}-control-input`]: { minHeight: height }
	} };
};
var genFormStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [token$1.componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), resetForm(token$1)), {
		[`${componentCls}-text`]: {
			display: "inline-block",
			paddingInlineEnd: token$1.paddingSM
		},
		"&-small": Object.assign({}, genFormSize(token$1, token$1.controlHeightSM)),
		"&-large": Object.assign({}, genFormSize(token$1, token$1.controlHeightLG))
	}) };
};
var genFormItemStyle = (token$1) => {
	const { formItemCls, iconCls, rootPrefixCls, antCls, labelRequiredMarkColor, labelColor, labelFontSize, labelHeight, labelColonMarginInlineStart, labelColonMarginInlineEnd, itemMarginBottom } = token$1;
	return { [formItemCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		marginBottom: itemMarginBottom,
		verticalAlign: "top",
		"&-with-help": { transition: "none" },
		[`&-hidden,
        &-hidden${antCls}-row`]: { display: "none" },
		"&-has-warning": { [`${formItemCls}-split`]: { color: token$1.colorError } },
		"&-has-error": { [`${formItemCls}-split`]: { color: token$1.colorWarning } },
		[`${formItemCls}-label`]: {
			flexGrow: 0,
			overflow: "hidden",
			whiteSpace: "nowrap",
			textAlign: "end",
			verticalAlign: "middle",
			"&-left": { textAlign: "start" },
			"&-wrap": {
				overflow: "unset",
				lineHeight: token$1.lineHeight,
				whiteSpace: "unset",
				"> label": {
					verticalAlign: "middle",
					textWrap: "balance"
				}
			},
			"> label": {
				position: "relative",
				display: "inline-flex",
				alignItems: "center",
				maxWidth: "100%",
				height: labelHeight,
				color: labelColor,
				fontSize: labelFontSize,
				[`> ${iconCls}`]: {
					fontSize: token$1.fontSize,
					verticalAlign: "top"
				},
				[`&${formItemCls}-required`]: {
					"&::before": {
						display: "inline-block",
						marginInlineEnd: token$1.marginXXS,
						color: labelRequiredMarkColor,
						fontSize: token$1.fontSize,
						fontFamily: "SimSun, sans-serif",
						lineHeight: 1,
						content: "\"*\""
					},
					[`&${formItemCls}-required-mark-hidden, &${formItemCls}-required-mark-optional`]: { "&::before": { display: "none" } }
				},
				[`${formItemCls}-optional`]: {
					display: "inline-block",
					marginInlineStart: token$1.marginXXS,
					color: token$1.colorTextDescription,
					[`&${formItemCls}-required-mark-hidden`]: { display: "none" }
				},
				[`${formItemCls}-tooltip`]: {
					color: token$1.colorTextDescription,
					cursor: "help",
					writingMode: "horizontal-tb",
					marginInlineStart: token$1.marginXXS
				},
				"&::after": {
					content: "\":\"",
					position: "relative",
					marginBlock: 0,
					marginInlineStart: labelColonMarginInlineStart,
					marginInlineEnd: labelColonMarginInlineEnd
				},
				[`&${formItemCls}-no-colon::after`]: { content: "\"\\a0\"" }
			}
		},
		[`${formItemCls}-control`]: {
			["--ant-display"]: "flex",
			flexDirection: "column",
			flexGrow: 1,
			[`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: { width: "100%" },
			"&-input": {
				position: "relative",
				display: "flex",
				alignItems: "center",
				minHeight: token$1.controlHeight,
				"&-content": {
					flex: "auto",
					maxWidth: "100%",
					[`&:has(> ${antCls}-switch:only-child, > ${antCls}-rate:only-child)`]: {
						display: "flex",
						alignItems: "center"
					}
				}
			}
		},
		[formItemCls]: {
			"&-additional": {
				display: "flex",
				flexDirection: "column"
			},
			"&-explain, &-extra": {
				clear: "both",
				color: token$1.colorTextDescription,
				fontSize: token$1.fontSize,
				lineHeight: token$1.lineHeight
			},
			"&-explain-connected": { width: "100%" },
			"&-extra": {
				minHeight: token$1.controlHeightSM,
				transition: `color ${token$1.motionDurationMid} ${token$1.motionEaseOut}`
			},
			"&-explain": {
				"&-error": { color: token$1.colorError },
				"&-warning": { color: token$1.colorWarning }
			}
		},
		[`&-with-help ${formItemCls}-explain`]: {
			height: "auto",
			opacity: 1
		},
		[`${formItemCls}-feedback-icon`]: {
			fontSize: token$1.fontSize,
			textAlign: "center",
			visibility: "visible",
			animationName: zoomIn,
			animationDuration: token$1.motionDurationMid,
			animationTimingFunction: token$1.motionEaseOutBack,
			pointerEvents: "none",
			"&-success": { color: token$1.colorSuccess },
			"&-error": { color: token$1.colorError },
			"&-warning": { color: token$1.colorWarning },
			"&-validating": { color: token$1.colorPrimary }
		}
	}) };
};
var makeVerticalLayoutLabel = (token$1) => ({
	padding: token$1.verticalLabelPadding,
	margin: token$1.verticalLabelMargin,
	whiteSpace: "initial",
	textAlign: "start",
	"> label": {
		margin: 0,
		"&::after": { visibility: "hidden" }
	}
});
var genHorizontalStyle$1 = (token$1) => {
	const { antCls, formItemCls } = token$1;
	return { [`${formItemCls}-horizontal`]: {
		[`${formItemCls}-label`]: { flexGrow: 0 },
		[`${formItemCls}-control`]: {
			flex: "1 1 0",
			minWidth: 0
		},
		[`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: { [`& + ${formItemCls}-control`]: { minWidth: "unset" } },
		[`${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1)
	} };
};
var genInlineStyle = (token$1) => {
	const { componentCls, formItemCls, inlineItemMarginBottom } = token$1;
	return { [`${componentCls}-inline`]: {
		display: "flex",
		flexWrap: "wrap",
		[`${formItemCls}-inline`]: {
			flex: "none",
			marginInlineEnd: token$1.margin,
			marginBottom: inlineItemMarginBottom,
			"&-row": { flexWrap: "nowrap" },
			[`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
				display: "inline-block",
				verticalAlign: "top"
			},
			[`> ${formItemCls}-label`]: { flex: "none" },
			[`${componentCls}-text`]: { display: "inline-block" },
			[`${formItemCls}-has-feedback`]: { display: "inline-block" }
		}
	} };
};
var makeVerticalLayout = (token$1) => {
	const { componentCls, formItemCls, rootPrefixCls } = token$1;
	return {
		[`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token$1),
		[`${componentCls}:not(${componentCls}-inline)`]: { [formItemCls]: {
			flexWrap: "wrap",
			[`${formItemCls}-label, ${formItemCls}-control`]: { [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
				flex: "0 0 100%",
				maxWidth: "100%"
			} }
		} }
	};
};
var genVerticalStyle = (token$1) => {
	const { componentCls, formItemCls, antCls } = token$1;
	return {
		[`${formItemCls}-vertical`]: {
			[`${formItemCls}-row`]: { flexDirection: "column" },
			[`${formItemCls}-label > label`]: { height: "auto" },
			[`${formItemCls}-control`]: { width: "100%" },
			[`${formItemCls}-label,
        ${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1)
		},
		[`@media (max-width: ${unit(token$1.screenXSMax)})`]: [makeVerticalLayout(token$1), { [componentCls]: { [`${formItemCls}:not(${formItemCls}-horizontal)`]: { [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1) } } }],
		[`@media (max-width: ${unit(token$1.screenSMMax)})`]: { [componentCls]: { [`${formItemCls}:not(${formItemCls}-horizontal)`]: { [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1) } } },
		[`@media (max-width: ${unit(token$1.screenMDMax)})`]: { [componentCls]: { [`${formItemCls}:not(${formItemCls}-horizontal)`]: { [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1) } } },
		[`@media (max-width: ${unit(token$1.screenLGMax)})`]: { [componentCls]: { [`${formItemCls}:not(${formItemCls}-horizontal)`]: { [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token$1) } } }
	};
};
const prepareComponentToken$22 = (token$1) => ({
	labelRequiredMarkColor: token$1.colorError,
	labelColor: token$1.colorTextHeading,
	labelFontSize: token$1.fontSize,
	labelHeight: token$1.controlHeight,
	labelColonMarginInlineStart: token$1.marginXXS / 2,
	labelColonMarginInlineEnd: token$1.marginXS,
	itemMarginBottom: token$1.marginLG,
	verticalLabelPadding: `0 0 ${token$1.paddingXS}px`,
	verticalLabelMargin: 0,
	inlineItemMarginBottom: 0
});
const prepareToken$2 = (token$1, rootPrefixCls) => {
	return merge(token$1, {
		formItemCls: `${token$1.componentCls}-item`,
		rootPrefixCls
	});
};
var style_default$26 = genStyleHooks("Form", (token$1, { rootPrefixCls }) => {
	const formToken = prepareToken$2(token$1, rootPrefixCls);
	return [
		genFormStyle(formToken),
		genFormItemStyle(formToken),
		explain_default(formToken),
		genHorizontalStyle$1(formToken),
		genInlineStyle(formToken),
		genVerticalStyle(formToken),
		collapse_default$1(formToken),
		zoomIn
	];
}, prepareComponentToken$22, { order: -1e3 });

//#endregion
//#region node_modules/antd/es/form/ErrorList.js
var import_classnames$101 = /* @__PURE__ */ __toESM(require_classnames());
var EMPTY_LIST$2 = [];
function toErrorEntity(error, prefix, errorStatus, index$2 = 0) {
	return {
		key: typeof error === "string" ? error : `${prefix}-${index$2}`,
		error,
		errorStatus
	};
}
var ErrorList = ({ help, helpStatus, errors = EMPTY_LIST$2, warnings = EMPTY_LIST$2, className: rootClassName, fieldId, onVisibleChanged }) => {
	const { prefixCls } = import_react.useContext(FormItemPrefixContext);
	const baseClassName = `${prefixCls}-item-explain`;
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$26(prefixCls, rootCls);
	const collapseMotion = import_react.useMemo(() => motion_default(prefixCls), [prefixCls]);
	const debounceErrors = useDebounce(errors);
	const debounceWarnings = useDebounce(warnings);
	const fullKeyList = import_react.useMemo(() => {
		if (help !== void 0 && help !== null) return [toErrorEntity(help, "help", helpStatus)];
		return [].concat(_toConsumableArray(debounceErrors.map((error, index$2) => toErrorEntity(error, "error", "error", index$2))), _toConsumableArray(debounceWarnings.map((warning$4, index$2) => toErrorEntity(warning$4, "warning", "warning", index$2))));
	}, [
		help,
		helpStatus,
		debounceErrors,
		debounceWarnings
	]);
	const filledKeyFullKeyList = import_react.useMemo(() => {
		const keysCount = {};
		fullKeyList.forEach(({ key }) => {
			keysCount[key] = (keysCount[key] || 0) + 1;
		});
		return fullKeyList.map((entity, index$2) => Object.assign(Object.assign({}, entity), { key: keysCount[entity.key] > 1 ? `${entity.key}-fallback-${index$2}` : entity.key }));
	}, [fullKeyList]);
	const helpProps = {};
	if (fieldId) helpProps.id = `${fieldId}_help`;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$2, {
		motionDeadline: collapseMotion.motionDeadline,
		motionName: `${prefixCls}-show-help`,
		visible: !!filledKeyFullKeyList.length,
		onVisibleChanged
	}, (holderProps) => {
		const { className: holderClassName, style: holderStyle } = holderProps;
		return /* @__PURE__ */ import_react.createElement("div", Object.assign({}, helpProps, {
			className: (0, import_classnames$101.default)(baseClassName, holderClassName, cssVarCls, rootCls, rootClassName, hashId),
			style: holderStyle
		}), /* @__PURE__ */ import_react.createElement(CSSMotionList_default, Object.assign({ keys: filledKeyFullKeyList }, motion_default(prefixCls), {
			motionName: `${prefixCls}-show-help-item`,
			component: false
		}), (itemProps) => {
			const { key, error, errorStatus, className: itemClassName, style: itemStyle } = itemProps;
			return /* @__PURE__ */ import_react.createElement("div", {
				key,
				className: (0, import_classnames$101.default)(itemClassName, { [`${baseClassName}-${errorStatus}`]: errorStatus }),
				style: itemStyle
			}, error);
		}));
	}));
};
var ErrorList_default = ErrorList;

//#endregion
//#region node_modules/antd/es/form/hooks/useFormWarning.js
var names = {};
function useFormWarning({ name }) {
	const warning$4 = devUseWarning("Form");
	import_react.useEffect(() => {
		if (name) {
			names[name] = (names[name] || 0) + 1;
			warning$4(names[name] <= 1, "usage", "There exist multiple Form with same `name`.");
			return () => {
				names[name] -= 1;
			};
		}
	}, [name]);
}

//#endregion
//#region node_modules/antd/es/form/Form.js
var import_classnames$100 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$46 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var InternalForm = (props, ref) => {
	const contextDisabled = import_react.useContext(DisabledContext_default);
	const { getPrefixCls, direction, requiredMark: contextRequiredMark, colon: contextColon, scrollToFirstError: contextScrollToFirstError, className: contextClassName, style: contextStyle } = useComponentConfig("form");
	const { prefixCls: customizePrefixCls, className, rootClassName, size, disabled = contextDisabled, form, colon, labelAlign, labelWrap, labelCol, wrapperCol, hideRequiredMark, layout = "horizontal", scrollToFirstError, requiredMark, onFinishFailed, name, style: style$1, feedbackIcons, variant } = props, restFormProps = __rest$46(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"size",
		"disabled",
		"form",
		"colon",
		"labelAlign",
		"labelWrap",
		"labelCol",
		"wrapperCol",
		"hideRequiredMark",
		"layout",
		"scrollToFirstError",
		"requiredMark",
		"onFinishFailed",
		"name",
		"style",
		"feedbackIcons",
		"variant"
	]);
	const mergedSize = useSize_default(size);
	const contextValidateMessages = import_react.useContext(validateMessagesContext_default);
	useFormWarning(props);
	const mergedRequiredMark = import_react.useMemo(() => {
		if (requiredMark !== void 0) return requiredMark;
		if (hideRequiredMark) return false;
		if (contextRequiredMark !== void 0) return contextRequiredMark;
		return true;
	}, [
		hideRequiredMark,
		requiredMark,
		contextRequiredMark
	]);
	const mergedColon = colon !== null && colon !== void 0 ? colon : contextColon;
	const prefixCls = getPrefixCls("form", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$26(prefixCls, rootCls);
	const formClassName = (0, import_classnames$100.default)(prefixCls, `${prefixCls}-${layout}`, {
		[`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${mergedSize}`]: mergedSize
	}, cssVarCls, rootCls, hashId, contextClassName, className, rootClassName);
	const [wrapForm] = useForm(form);
	const { __INTERNAL__ } = wrapForm;
	__INTERNAL__.name = name;
	const formContextValue = import_react.useMemo(() => ({
		name,
		labelAlign,
		labelCol,
		labelWrap,
		wrapperCol,
		layout,
		colon: mergedColon,
		requiredMark: mergedRequiredMark,
		itemRef: __INTERNAL__.itemRef,
		form: wrapForm,
		feedbackIcons
	}), [
		name,
		labelAlign,
		labelCol,
		wrapperCol,
		layout,
		mergedColon,
		mergedRequiredMark,
		wrapForm,
		feedbackIcons
	]);
	const nativeElementRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => {
		var _a;
		return Object.assign(Object.assign({}, wrapForm), { nativeElement: (_a = nativeElementRef.current) === null || _a === void 0 ? void 0 : _a.nativeElement });
	});
	const scrollToField = (options, fieldName) => {
		if (options) {
			let defaultScrollToFirstError = { block: "nearest" };
			if (typeof options === "object") defaultScrollToFirstError = Object.assign(Object.assign({}, defaultScrollToFirstError), options);
			wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
		}
	};
	const onInternalFinishFailed = (errorInfo) => {
		onFinishFailed === null || onFinishFailed === void 0 || onFinishFailed(errorInfo);
		if (errorInfo.errorFields.length) {
			const fieldName = errorInfo.errorFields[0].name;
			if (scrollToFirstError !== void 0) {
				scrollToField(scrollToFirstError, fieldName);
				return;
			}
			if (contextScrollToFirstError !== void 0) scrollToField(contextScrollToFirstError, fieldName);
		}
	};
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(VariantContext.Provider, { value: variant }, /* @__PURE__ */ import_react.createElement(DisabledContextProvider, { disabled }, /* @__PURE__ */ import_react.createElement(SizeContext_default.Provider, { value: mergedSize }, /* @__PURE__ */ import_react.createElement(FormProvider, { validateMessages: contextValidateMessages }, /* @__PURE__ */ import_react.createElement(FormContext.Provider, { value: formContextValue }, /* @__PURE__ */ import_react.createElement(NoFormStyle, { status: true }, /* @__PURE__ */ import_react.createElement(es_default$17, Object.assign({ id: name }, restFormProps, {
		name,
		onFinishFailed: onInternalFinishFailed,
		form: wrapForm,
		ref: nativeElementRef,
		style: Object.assign(Object.assign({}, contextStyle), style$1),
		className: formClassName
	})))))))));
};
var Form$1 = /* @__PURE__ */ import_react.forwardRef(InternalForm);
Form$1.displayName = "Form";
var Form_default = Form$1;

//#endregion
//#region node_modules/antd/es/form/hooks/useChildren.js
function useChildren(children) {
	if (typeof children === "function") return children;
	const childList = toArray(children);
	return childList.length <= 1 ? childList[0] : childList;
}

//#endregion
//#region node_modules/antd/es/form/hooks/useFormItemStatus.js
var useFormItemStatus = () => {
	const { status, errors = [], warnings = [] } = import_react.useContext(FormItemInputContext);
	devUseWarning("Form.Item")(status !== void 0, "usage", "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus");
	return {
		status,
		errors,
		warnings
	};
};
useFormItemStatus.Context = FormItemInputContext;
var useFormItemStatus_default = useFormItemStatus;

//#endregion
//#region node_modules/antd/es/form/hooks/useFrameState.js
function useFrameState(defaultValue) {
	const [value, setValue] = import_react.useState(defaultValue);
	const frameRef = import_react.useRef(null);
	const batchRef = import_react.useRef([]);
	const destroyRef = import_react.useRef(false);
	import_react.useEffect(() => {
		destroyRef.current = false;
		return () => {
			destroyRef.current = true;
			raf_default.cancel(frameRef.current);
			frameRef.current = null;
		};
	}, []);
	function setFrameValue(updater) {
		if (destroyRef.current) return;
		if (frameRef.current === null) {
			batchRef.current = [];
			frameRef.current = raf_default(() => {
				frameRef.current = null;
				setValue((prevValue) => {
					let current = prevValue;
					batchRef.current.forEach((func) => {
						current = func(current);
					});
					return current;
				});
			});
		}
		batchRef.current.push(updater);
	}
	return [value, setFrameValue];
}

//#endregion
//#region node_modules/antd/es/form/hooks/useItemRef.js
function useItemRef() {
	const { itemRef } = import_react.useContext(FormContext);
	const cacheRef = import_react.useRef({});
	function getRef(name, children) {
		const childrenRef = children && typeof children === "object" && getNodeRef(children);
		const nameStr = name.join("_");
		if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
			cacheRef.current.name = nameStr;
			cacheRef.current.originRef = childrenRef;
			cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
		}
		return cacheRef.current.ref;
	}
	return getRef;
}

//#endregion
//#region node_modules/antd/es/form/style/fallbackCmp.js
var genFallbackStyle = (token$1) => {
	const { formItemCls } = token$1;
	return { "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": { [`${formItemCls}-control`]: { display: "flex" } } };
};
var fallbackCmp_default = genSubStyleComponent(["Form", "item-item"], (token$1, { rootPrefixCls }) => {
	const formToken = prepareToken$2(token$1, rootPrefixCls);
	return genFallbackStyle(formToken);
});

//#endregion
//#region node_modules/antd/es/form/FormItemInput.js
var import_classnames$99 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$45 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var GRID_MAX = 24;
var FormItemInput = (props) => {
	const { prefixCls, status, labelCol, wrapperCol, children, errors, warnings, _internalItemRender: formItemRender, extra, help, fieldId, marginBottom, onErrorVisibleChanged, label } = props;
	const baseClassName = `${prefixCls}-item`;
	const formContext = import_react.useContext(FormContext);
	const mergedWrapperCol = import_react.useMemo(() => {
		let mergedWrapper = Object.assign({}, wrapperCol || formContext.wrapperCol || {});
		if (label === null && !labelCol && !wrapperCol && formContext.labelCol) [
			void 0,
			"xs",
			"sm",
			"md",
			"lg",
			"xl",
			"xxl"
		].forEach((size) => {
			const _size = size ? [size] : [];
			const formLabel = get(formContext.labelCol, _size);
			const formLabelObj = typeof formLabel === "object" ? formLabel : {};
			const wrapper = get(mergedWrapper, _size);
			const wrapperObj = typeof wrapper === "object" ? wrapper : {};
			if ("span" in formLabelObj && !("offset" in wrapperObj) && formLabelObj.span < GRID_MAX) mergedWrapper = set(mergedWrapper, [].concat(_size, ["offset"]), formLabelObj.span);
		});
		return mergedWrapper;
	}, [wrapperCol, formContext]);
	const className = (0, import_classnames$99.default)(`${baseClassName}-control`, mergedWrapperCol.className);
	const subFormContext = import_react.useMemo(() => {
		const { labelCol: labelCol$1, wrapperCol: wrapperCol$1 } = formContext;
		return __rest$45(formContext, ["labelCol", "wrapperCol"]);
	}, [formContext]);
	const extraRef = import_react.useRef(null);
	const [extraHeight, setExtraHeight] = import_react.useState(0);
	useLayoutEffect_default(() => {
		if (extra && extraRef.current) setExtraHeight(extraRef.current.clientHeight);
		else setExtraHeight(0);
	}, [extra]);
	const inputDom = /* @__PURE__ */ import_react.createElement("div", { className: `${baseClassName}-control-input` }, /* @__PURE__ */ import_react.createElement("div", { className: `${baseClassName}-control-input-content` }, children));
	const formItemContext = import_react.useMemo(() => ({
		prefixCls,
		status
	}), [prefixCls, status]);
	const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ import_react.createElement(FormItemPrefixContext.Provider, { value: formItemContext }, /* @__PURE__ */ import_react.createElement(ErrorList_default, {
		fieldId,
		errors,
		warnings,
		help,
		helpStatus: status,
		className: `${baseClassName}-explain-connected`,
		onVisibleChanged: onErrorVisibleChanged
	})) : null;
	const extraProps = {};
	if (fieldId) extraProps.id = `${fieldId}_extra`;
	const extraDom = extra ? /* @__PURE__ */ import_react.createElement("div", Object.assign({}, extraProps, {
		className: `${baseClassName}-extra`,
		ref: extraRef
	}), extra) : null;
	const additionalDom = errorListDom || extraDom ? /* @__PURE__ */ import_react.createElement("div", {
		className: `${baseClassName}-additional`,
		style: marginBottom ? { minHeight: marginBottom + extraHeight } : {}
	}, errorListDom, extraDom) : null;
	const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
		input: inputDom,
		errorList: errorListDom,
		extra: extraDom
	}) : /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, inputDom, additionalDom);
	return /* @__PURE__ */ import_react.createElement(FormContext.Provider, { value: subFormContext }, /* @__PURE__ */ import_react.createElement(col_default$1, Object.assign({}, mergedWrapperCol, { className }), dom), /* @__PURE__ */ import_react.createElement(fallbackCmp_default, { prefixCls }));
};
var FormItemInput_default = FormItemInput;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/QuestionCircleOutlined.js
var QuestionCircleOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" }
		}]
	},
	"name": "question-circle",
	"theme": "outlined"
};
var QuestionCircleOutlined_default$1 = QuestionCircleOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/QuestionCircleOutlined.js
/**![question-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0wIDgyMGMtMjA1LjQgMC0zNzItMTY2LjYtMzcyLTM3MnMxNjYuNi0zNzIgMzcyLTM3MiAzNzIgMTY2LjYgMzcyIDM3Mi0xNjYuNiAzNzItMzcyIDM3MnoiIC8+PHBhdGggZD0iTTYyMy42IDMxNi43QzU5My42IDI5MC40IDU1NCAyNzYgNTEyIDI3NnMtODEuNiAxNC41LTExMS42IDQwLjdDMzY5LjIgMzQ0IDM1MiAzODAuNyAzNTIgNDIwdjcuNmMwIDQuNCAzLjYgOCA4IDhoNDhjNC40IDAgOC0zLjYgOC04VjQyMGMwLTQ0LjEgNDMuMS04MCA5Ni04MHM5NiAzNS45IDk2IDgwYzAgMzEuMS0yMiA1OS42LTU2LjEgNzIuNy0yMS4yIDguMS0zOS4yIDIyLjMtNTIuMSA0MC45LTEzLjEgMTktMTkuOSA0MS44LTE5LjkgNjQuOVY2MjBjMCA0LjQgMy42IDggOCA4aDQ4YzQuNCAwIDgtMy42IDgtOHYtMjIuN2E0OC4zIDQ4LjMgMCAwMTMwLjktNDQuOGM1OS0yMi43IDk3LjEtNzQuNyA5Ny4xLTEzMi41LjEtMzkuMy0xNy4xLTc2LTQ4LjMtMTAzLjN6TTQ3MiA3MzJhNDAgNDAgMCAxMDgwIDAgNDAgNDAgMCAxMC04MCAweiIgLz48L3N2Zz4=) */
var RefIcon$30 = /* @__PURE__ */ import_react.forwardRef(function QuestionCircleOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: QuestionCircleOutlined_default$1
	}));
});
RefIcon$30.displayName = "QuestionCircleOutlined";
var QuestionCircleOutlined_default = RefIcon$30;

//#endregion
//#region node_modules/antd/es/form/FormItemLabel.js
var import_classnames$98 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$44 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var FormItemLabel = ({ prefixCls, label, htmlFor, labelCol, labelAlign, colon, required: required$2, requiredMark, tooltip, vertical }) => {
	var _a;
	const [formLocale] = useLocale_default("Form");
	const { labelAlign: contextLabelAlign, labelCol: contextLabelCol, labelWrap, colon: contextColon } = import_react.useContext(FormContext);
	if (!label) return null;
	const mergedLabelCol = labelCol || contextLabelCol || {};
	const mergedLabelAlign = labelAlign || contextLabelAlign;
	const labelClsBasic = `${prefixCls}-item-label`;
	const labelColClassName = (0, import_classnames$98.default)(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, { [`${labelClsBasic}-wrap`]: !!labelWrap });
	let labelChildren = label;
	const computedColon = colon === true || contextColon !== false && colon !== false;
	if (computedColon && !vertical && typeof label === "string" && label.trim()) labelChildren = label.replace(/[:|]\s*$/, "");
	const tooltipProps = convertToTooltipProps_default(tooltip);
	if (tooltipProps) {
		const { icon = /* @__PURE__ */ import_react.createElement(QuestionCircleOutlined_default, null) } = tooltipProps, restTooltipProps = __rest$44(tooltipProps, ["icon"]);
		const tooltipNode = /* @__PURE__ */ import_react.createElement(tooltip_default, Object.assign({}, restTooltipProps), /* @__PURE__ */ import_react.cloneElement(icon, {
			className: `${prefixCls}-item-tooltip`,
			title: "",
			onClick: (e$2) => {
				e$2.preventDefault();
			},
			tabIndex: null
		}));
		labelChildren = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, labelChildren, tooltipNode);
	}
	const isOptionalMark = requiredMark === "optional";
	const isRenderMark = typeof requiredMark === "function";
	const hideRequiredMark = requiredMark === false;
	if (isRenderMark) labelChildren = requiredMark(labelChildren, { required: !!required$2 });
	else if (isOptionalMark && !required$2) labelChildren = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, labelChildren, /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-item-optional`,
		title: ""
	}, (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = en_US_default.Form) === null || _a === void 0 ? void 0 : _a.optional)));
	let markType;
	if (hideRequiredMark) markType = "hidden";
	else if (isOptionalMark || isRenderMark) markType = "optional";
	const labelClassName = (0, import_classnames$98.default)({
		[`${prefixCls}-item-required`]: required$2,
		[`${prefixCls}-item-required-mark-${markType}`]: markType,
		[`${prefixCls}-item-no-colon`]: !computedColon
	});
	return /* @__PURE__ */ import_react.createElement(col_default$1, Object.assign({}, mergedLabelCol, { className: labelColClassName }), /* @__PURE__ */ import_react.createElement("label", {
		htmlFor,
		className: labelClassName,
		title: typeof label === "string" ? label : ""
	}, labelChildren));
};
var FormItemLabel_default = FormItemLabel;

//#endregion
//#region node_modules/antd/es/form/FormItem/StatusProvider.js
var import_classnames$97 = /* @__PURE__ */ __toESM(require_classnames());
var iconMap = {
	success: CheckCircleFilled_default,
	warning: ExclamationCircleFilled_default,
	error: CloseCircleFilled_default,
	validating: LoadingOutlined_default
};
function StatusProvider({ children, errors, warnings, hasFeedback, validateStatus, prefixCls, meta, noStyle, name }) {
	const itemPrefixCls = `${prefixCls}-item`;
	const { feedbackIcons } = import_react.useContext(FormContext);
	const mergedValidateStatus = getStatus(errors, warnings, meta, null, !!hasFeedback, validateStatus);
	const { isFormItemInput: parentIsFormItemInput, status: parentStatus, hasFeedback: parentHasFeedback, feedbackIcon: parentFeedbackIcon, name: parentName } = import_react.useContext(FormItemInputContext);
	const formItemStatusContext = import_react.useMemo(() => {
		var _a;
		let feedbackIcon;
		if (hasFeedback) {
			const customIcons = hasFeedback !== true && hasFeedback.icons || feedbackIcons;
			const customIconNode = mergedValidateStatus && ((_a = customIcons === null || customIcons === void 0 ? void 0 : customIcons({
				status: mergedValidateStatus,
				errors,
				warnings
			})) === null || _a === void 0 ? void 0 : _a[mergedValidateStatus]);
			const IconNode$1 = mergedValidateStatus && iconMap[mergedValidateStatus];
			feedbackIcon = customIconNode !== false && IconNode$1 ? /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$97.default)(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`) }, customIconNode || /* @__PURE__ */ import_react.createElement(IconNode$1, null)) : null;
		}
		const context = {
			status: mergedValidateStatus || "",
			errors,
			warnings,
			hasFeedback: !!hasFeedback,
			feedbackIcon,
			isFormItemInput: true,
			name
		};
		if (noStyle) {
			context.status = (mergedValidateStatus !== null && mergedValidateStatus !== void 0 ? mergedValidateStatus : parentStatus) || "";
			context.isFormItemInput = parentIsFormItemInput;
			context.hasFeedback = !!(hasFeedback !== null && hasFeedback !== void 0 ? hasFeedback : parentHasFeedback);
			context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon;
			context.name = name !== null && name !== void 0 ? name : parentName;
		}
		return context;
	}, [
		mergedValidateStatus,
		hasFeedback,
		noStyle,
		parentIsFormItemInput,
		parentStatus
	]);
	return /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: formItemStatusContext }, children);
}

//#endregion
//#region node_modules/antd/es/form/FormItem/ItemHolder.js
var import_classnames$96 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$43 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function ItemHolder(props) {
	const { prefixCls, className, rootClassName, style: style$1, help, errors, warnings, validateStatus, meta, hasFeedback, hidden, children, fieldId, required: required$2, isRequired, onSubItemMetaChange, layout: propsLayout, name } = props, restProps = __rest$43(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"style",
		"help",
		"errors",
		"warnings",
		"validateStatus",
		"meta",
		"hasFeedback",
		"hidden",
		"children",
		"fieldId",
		"required",
		"isRequired",
		"onSubItemMetaChange",
		"layout",
		"name"
	]);
	const itemPrefixCls = `${prefixCls}-item`;
	const { requiredMark, layout: formLayout } = import_react.useContext(FormContext);
	const layout = propsLayout || formLayout;
	const vertical = layout === "vertical";
	const itemRef = import_react.useRef(null);
	const debounceErrors = useDebounce(errors);
	const debounceWarnings = useDebounce(warnings);
	const hasHelp = help !== void 0 && help !== null;
	const hasError = !!(hasHelp || errors.length || warnings.length);
	const isOnScreen = !!itemRef.current && isVisible_default(itemRef.current);
	const [marginBottom, setMarginBottom] = import_react.useState(null);
	useLayoutEffect_default(() => {
		if (hasError && itemRef.current) {
			const itemStyle = getComputedStyle(itemRef.current);
			setMarginBottom(parseInt(itemStyle.marginBottom, 10));
		}
	}, [hasError, isOnScreen]);
	const onErrorVisibleChanged = (nextVisible) => {
		if (!nextVisible) setMarginBottom(null);
	};
	const getValidateState = (isDebounce = false) => {
		const _errors = isDebounce ? debounceErrors : meta.errors;
		const _warnings = isDebounce ? debounceWarnings : meta.warnings;
		return getStatus(_errors, _warnings, meta, "", !!hasFeedback, validateStatus);
	};
	const mergedValidateStatus = getValidateState();
	const itemClassName = (0, import_classnames$96.default)(itemPrefixCls, className, rootClassName, {
		[`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
		[`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
		[`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
		[`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
		[`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
		[`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
		[`${itemPrefixCls}-hidden`]: hidden,
		[`${itemPrefixCls}-${layout}`]: layout
	});
	return /* @__PURE__ */ import_react.createElement("div", {
		className: itemClassName,
		style: style$1,
		ref: itemRef
	}, /* @__PURE__ */ import_react.createElement(row_default$1, Object.assign({ className: `${itemPrefixCls}-row` }, omit(restProps, [
		"_internalItemRender",
		"colon",
		"dependencies",
		"extra",
		"fieldKey",
		"getValueFromEvent",
		"getValueProps",
		"htmlFor",
		"id",
		"initialValue",
		"isListField",
		"label",
		"labelAlign",
		"labelCol",
		"labelWrap",
		"messageVariables",
		"name",
		"normalize",
		"noStyle",
		"preserve",
		"requiredMark",
		"rules",
		"shouldUpdate",
		"trigger",
		"tooltip",
		"validateFirst",
		"validateTrigger",
		"valuePropName",
		"wrapperCol",
		"validateDebounce"
	])), /* @__PURE__ */ import_react.createElement(FormItemLabel_default, Object.assign({ htmlFor: fieldId }, props, {
		requiredMark,
		required: required$2 !== null && required$2 !== void 0 ? required$2 : isRequired,
		prefixCls,
		vertical
	})), /* @__PURE__ */ import_react.createElement(FormItemInput_default, Object.assign({}, props, meta, {
		errors: debounceErrors,
		warnings: debounceWarnings,
		prefixCls,
		status: mergedValidateStatus,
		help,
		marginBottom,
		onErrorVisibleChanged
	}), /* @__PURE__ */ import_react.createElement(NoStyleItemContext.Provider, { value: onSubItemMetaChange }, /* @__PURE__ */ import_react.createElement(StatusProvider, {
		prefixCls,
		meta,
		errors: meta.errors,
		warnings: meta.warnings,
		hasFeedback,
		validateStatus: mergedValidateStatus,
		name
	}, children)))), !!marginBottom && /* @__PURE__ */ import_react.createElement("div", {
		className: `${itemPrefixCls}-margin-offset`,
		style: { marginBottom: -marginBottom }
	}));
}

//#endregion
//#region node_modules/antd/es/form/FormItem/index.js
var import_classnames$95 = /* @__PURE__ */ __toESM(require_classnames());
var NAME_SPLIT = "__SPLIT__";
function isSimilarControl(a, b) {
	const keysA = Object.keys(a);
	const keysB = Object.keys(b);
	return keysA.length === keysB.length && keysA.every((key) => {
		const propValueA = a[key];
		const propValueB = b[key];
		return propValueA === propValueB || typeof propValueA === "function" || typeof propValueB === "function";
	});
}
var MemoInput = /* @__PURE__ */ import_react.memo(({ children }) => children, (prev$1, next$1) => isSimilarControl(prev$1.control, next$1.control) && prev$1.update === next$1.update && prev$1.childProps.length === next$1.childProps.length && prev$1.childProps.every((value, index$2) => value === next$1.childProps[index$2]));
function genEmptyMeta() {
	return {
		errors: [],
		warnings: [],
		touched: false,
		validating: false,
		name: [],
		validated: false
	};
}
function InternalFormItem(props) {
	const { name, noStyle, className, dependencies, prefixCls: customizePrefixCls, shouldUpdate, rules, children, required: required$2, label, messageVariables, trigger = "onChange", validateTrigger, hidden, help, layout } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const { name: formName } = import_react.useContext(FormContext);
	const mergedChildren = useChildren(children);
	const isRenderProps = typeof mergedChildren === "function";
	const notifyParentMetaChange = import_react.useContext(NoStyleItemContext);
	const { validateTrigger: contextValidateTrigger } = import_react.useContext(FieldContext_default);
	const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
	const hasName = !(name === void 0 || name === null);
	const prefixCls = getPrefixCls("form", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$26(prefixCls, rootCls);
	const warning$4 = devUseWarning("Form.Item");
	warning$4(name !== null, "usage", "`null` is passed as `name` property");
	const listContext = import_react.useContext(ListContext_default);
	const fieldKeyPathRef = import_react.useRef(null);
	const [subFieldErrors, setSubFieldErrors] = useFrameState({});
	const [meta, setMeta] = useSafeState(() => genEmptyMeta());
	const onMetaChange = (nextMeta) => {
		const keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
		setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
		if (noStyle && help !== false && notifyParentMetaChange) {
			let namePath = nextMeta.name;
			if (!nextMeta.destroy) {
				if (keyInfo !== void 0) {
					const [fieldKey, restPath] = keyInfo;
					namePath = [fieldKey].concat(_toConsumableArray(restPath));
					fieldKeyPathRef.current = namePath;
				}
			} else namePath = fieldKeyPathRef.current || namePath;
			notifyParentMetaChange(nextMeta, namePath);
		}
	};
	const onSubItemMetaChange = (subMeta, uniqueKeys) => {
		setSubFieldErrors((prevSubFieldErrors) => {
			const clone = Object.assign({}, prevSubFieldErrors);
			const mergedNameKey = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys)).join(NAME_SPLIT);
			if (subMeta.destroy) delete clone[mergedNameKey];
			else clone[mergedNameKey] = subMeta;
			return clone;
		});
	};
	const [mergedErrors, mergedWarnings] = import_react.useMemo(() => {
		const errorList = _toConsumableArray(meta.errors);
		const warningList = _toConsumableArray(meta.warnings);
		Object.values(subFieldErrors).forEach((subFieldError) => {
			errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
			warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
		});
		return [errorList, warningList];
	}, [
		subFieldErrors,
		meta.errors,
		meta.warnings
	]);
	const getItemRef = useItemRef();
	function renderLayout(baseChildren, fieldId, isRequired) {
		if (noStyle && !hidden) return /* @__PURE__ */ import_react.createElement(StatusProvider, {
			prefixCls,
			hasFeedback: props.hasFeedback,
			validateStatus: props.validateStatus,
			meta,
			errors: mergedErrors,
			warnings: mergedWarnings,
			noStyle: true,
			name
		}, baseChildren);
		return /* @__PURE__ */ import_react.createElement(ItemHolder, Object.assign({ key: "row" }, props, {
			className: (0, import_classnames$95.default)(className, cssVarCls, rootCls, hashId),
			prefixCls,
			fieldId,
			isRequired,
			errors: mergedErrors,
			warnings: mergedWarnings,
			meta,
			onSubItemMetaChange,
			layout,
			name
		}), baseChildren);
	}
	if (!hasName && !isRenderProps && !dependencies) return wrapCSSVar(renderLayout(mergedChildren));
	let variables = {};
	if (typeof label === "string") variables.label = label;
	else if (name) variables.label = String(name);
	if (messageVariables) variables = Object.assign(Object.assign({}, variables), messageVariables);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(Field_default, Object.assign({}, props, {
		messageVariables: variables,
		trigger,
		validateTrigger: mergedValidateTrigger,
		onMetaChange
	}), (control, renderMeta, context) => {
		const mergedName = toArray$4(name).length && renderMeta ? renderMeta.name : [];
		const fieldId = getFieldId(mergedName, formName);
		const isRequired = required$2 !== void 0 ? required$2 : !!(rules === null || rules === void 0 ? void 0 : rules.some((rule) => {
			if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) return true;
			if (typeof rule === "function") {
				const ruleEntity = rule(context);
				return (ruleEntity === null || ruleEntity === void 0 ? void 0 : ruleEntity.required) && !(ruleEntity === null || ruleEntity === void 0 ? void 0 : ruleEntity.warningOnly);
			}
			return false;
		}));
		const mergedControl = Object.assign({}, control);
		let childNode = null;
		warning$4(!(shouldUpdate && dependencies), "usage", "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps.");
		if (Array.isArray(mergedChildren) && hasName) {
			warning$4(false, "usage", "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item.");
			childNode = mergedChildren;
		} else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName)) {
			warning$4(!!(shouldUpdate || dependencies), "usage", "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`.");
			warning$4(!hasName, "usage", "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop.");
		} else if (dependencies && !isRenderProps && !hasName) warning$4(false, "usage", "Must set `name` or use a render function when `dependencies` is set.");
		else if (/* @__PURE__ */ import_react.isValidElement(mergedChildren)) {
			warning$4(mergedChildren.props.defaultValue === void 0, "usage", "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead.");
			const childProps = Object.assign(Object.assign({}, mergedChildren.props), mergedControl);
			if (!childProps.id) childProps.id = fieldId;
			if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
				const describedbyArr = [];
				if (help || mergedErrors.length > 0) describedbyArr.push(`${fieldId}_help`);
				if (props.extra) describedbyArr.push(`${fieldId}_extra`);
				childProps["aria-describedby"] = describedbyArr.join(" ");
			}
			if (mergedErrors.length > 0) childProps["aria-invalid"] = "true";
			if (isRequired) childProps["aria-required"] = "true";
			if (supportRef(mergedChildren)) childProps.ref = getItemRef(mergedName, mergedChildren);
			new Set([].concat(_toConsumableArray(toArray$4(trigger)), _toConsumableArray(toArray$4(mergedValidateTrigger)))).forEach((eventName) => {
				childProps[eventName] = (...args) => {
					var _a2, _c2;
					var _a, _b, _c;
					(_a = mergedControl[eventName]) === null || _a === void 0 || (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
					(_c = (_b = mergedChildren.props)[eventName]) === null || _c === void 0 || (_c2 = _c).call.apply(_c2, [_b].concat(args));
				};
			});
			const watchingChildProps = [
				childProps["aria-required"],
				childProps["aria-invalid"],
				childProps["aria-describedby"]
			];
			childNode = /* @__PURE__ */ import_react.createElement(MemoInput, {
				control: mergedControl,
				update: mergedChildren,
				childProps: watchingChildProps
			}, cloneElement(mergedChildren, childProps));
		} else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) childNode = mergedChildren(context);
		else {
			warning$4(!mergedName.length || !!noStyle, "usage", "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead.");
			childNode = mergedChildren;
		}
		return renderLayout(childNode, fieldId, isRequired);
	}));
}
var FormItem = InternalFormItem;
FormItem.useStatus = useFormItemStatus_default;
var FormItem_default = FormItem;

//#endregion
//#region node_modules/antd/es/form/FormList.js
var __rest$42 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var FormList = (_a) => {
	var { prefixCls: customizePrefixCls, children } = _a, props = __rest$42(_a, ["prefixCls", "children"]);
	devUseWarning("Form.List")(typeof props.name === "number" || (Array.isArray(props.name) ? !!props.name.length : !!props.name), "usage", "Miss `name` prop.");
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("form", customizePrefixCls);
	const contextValue = import_react.useMemo(() => ({
		prefixCls,
		status: "error"
	}), [prefixCls]);
	return /* @__PURE__ */ import_react.createElement(List_default, Object.assign({}, props), (fields, operation, meta) => /* @__PURE__ */ import_react.createElement(FormItemPrefixContext.Provider, { value: contextValue }, children(fields.map((field) => Object.assign(Object.assign({}, field), { fieldKey: field.key })), operation, {
		errors: meta.errors,
		warnings: meta.warnings
	})));
};
var FormList_default = FormList;

//#endregion
//#region node_modules/antd/es/form/hooks/useFormInstance.js
function useFormInstance() {
	const { form } = import_react.useContext(FormContext);
	return form;
}

//#endregion
//#region node_modules/antd/es/form/index.js
var Form = Form_default;
Form.Item = FormItem_default;
Form.List = FormList_default;
Form.ErrorList = ErrorList_default;
Form.useForm = useForm;
Form.useFormInstance = useFormInstance;
Form.useWatch = useWatch_default;
Form.Provider = FormProvider;
Form.create = () => {
	warning_default$1(false, "Form", "antd v4 removed `Form.create`. Please remove or use `@ant-design/compatible` instead.");
};
var form_default = Form;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/EyeOutlined.js
var EyeOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" }
		}]
	},
	"name": "eye",
	"theme": "outlined"
};
var EyeOutlined_default$1 = EyeOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/EyeOutlined.js
/**![eye](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk0Mi4yIDQ4Ni4yQzg0Ny40IDI4Ni41IDcwNC4xIDE4NiA1MTIgMTg2Yy0xOTIuMiAwLTMzNS40IDEwMC41LTQzMC4yIDMwMC4zYTYwLjMgNjAuMyAwIDAwMCA1MS41QzE3Ni42IDczNy41IDMxOS45IDgzOCA1MTIgODM4YzE5Mi4yIDAgMzM1LjQtMTAwLjUgNDMwLjItMzAwLjMgNy43LTE2LjIgNy43LTM1IDAtNTEuNXpNNTEyIDc2NmMtMTYxLjMgMC0yNzkuNC04MS44LTM2Mi43LTI1NEMyMzIuNiAzMzkuOCAzNTAuNyAyNTggNTEyIDI1OGMxNjEuMyAwIDI3OS40IDgxLjggMzYyLjcgMjU0Qzc5MS41IDY4NC4yIDY3My40IDc2NiA1MTIgNzY2em0tNC00MzBjLTk3LjIgMC0xNzYgNzguOC0xNzYgMTc2czc4LjggMTc2IDE3NiAxNzYgMTc2LTc4LjggMTc2LTE3Ni03OC44LTE3Ni0xNzYtMTc2em0wIDI4OGMtNjEuOSAwLTExMi01MC4xLTExMi0xMTJzNTAuMS0xMTIgMTEyLTExMiAxMTIgNTAuMSAxMTIgMTEyLTUwLjEgMTEyLTExMiAxMTJ6IiAvPjwvc3ZnPg==) */
var RefIcon$29 = /* @__PURE__ */ import_react.forwardRef(function EyeOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: EyeOutlined_default$1
	}));
});
RefIcon$29.displayName = "EyeOutlined";
var EyeOutlined_default = RefIcon$29;

//#endregion
//#region node_modules/rc-util/es/Dom/css.js
function getClientSize() {
	var width = document.documentElement.clientWidth;
	var height = window.innerHeight || document.documentElement.clientHeight;
	return {
		width,
		height
	};
}
function getOffset$1(node$1) {
	var box$1 = node$1.getBoundingClientRect();
	var docElem = document.documentElement;
	return {
		left: box$1.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
		top: box$1.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
	};
}

//#endregion
//#region node_modules/rc-util/es/Dom/addEventListener.js
var import_react_dom$2 = /* @__PURE__ */ __toESM(require_react_dom());
function addEventListenerWrap(target, eventType, cb, option) {
	var callback = import_react_dom$2.unstable_batchedUpdates ? function run(e$2) {
		import_react_dom$2.unstable_batchedUpdates(cb, e$2);
	} : cb;
	if (target !== null && target !== void 0 && target.addEventListener) target.addEventListener(eventType, callback, option);
	return { remove: function remove() {
		if (target !== null && target !== void 0 && target.removeEventListener) target.removeEventListener(eventType, callback, option);
	} };
}

//#endregion
//#region node_modules/rc-image/es/context.js
var PreviewGroupContext = /* @__PURE__ */ import_react.createContext(null);

//#endregion
//#region node_modules/rc-image/es/Operations.js
var import_classnames$94 = /* @__PURE__ */ __toESM(require_classnames());
var Operations = function Operations$1(props) {
	var visible = props.visible, maskTransitionName = props.maskTransitionName, getContainer$1 = props.getContainer, prefixCls = props.prefixCls, rootClassName = props.rootClassName, icons$1 = props.icons, countRender = props.countRender, showSwitch = props.showSwitch, showProgress = props.showProgress, current = props.current, transform = props.transform, count = props.count, scale = props.scale, minScale = props.minScale, maxScale = props.maxScale, closeIcon = props.closeIcon, onActive = props.onActive, onClose = props.onClose, onZoomIn = props.onZoomIn, onZoomOut = props.onZoomOut, onRotateRight = props.onRotateRight, onRotateLeft = props.onRotateLeft, onFlipX = props.onFlipX, onFlipY = props.onFlipY, onReset = props.onReset, toolbarRender = props.toolbarRender, zIndex = props.zIndex, image = props.image;
	var groupContext = (0, import_react.useContext)(PreviewGroupContext);
	var rotateLeft = icons$1.rotateLeft, rotateRight = icons$1.rotateRight, zoomIn$1 = icons$1.zoomIn, zoomOut$1 = icons$1.zoomOut, close = icons$1.close, left = icons$1.left, right = icons$1.right, flipX = icons$1.flipX, flipY = icons$1.flipY;
	var toolClassName = "".concat(prefixCls, "-operations-operation");
	import_react.useEffect(function() {
		var onKeyDown$1 = function onKeyDown$2(e$2) {
			if (e$2.keyCode === KeyCode_default.ESC) onClose();
		};
		if (visible) window.addEventListener("keydown", onKeyDown$1);
		return function() {
			window.removeEventListener("keydown", onKeyDown$1);
		};
	}, [visible]);
	var handleActive = function handleActive$1(e$2, offset$2) {
		e$2.preventDefault();
		e$2.stopPropagation();
		onActive(offset$2);
	};
	var renderOperation = import_react.useCallback(function(_ref) {
		var type$2 = _ref.type, disabled = _ref.disabled, onClick = _ref.onClick, icon = _ref.icon;
		return /* @__PURE__ */ import_react.createElement("div", {
			key: type$2,
			className: (0, import_classnames$94.default)(toolClassName, "".concat(prefixCls, "-operations-operation-").concat(type$2), _defineProperty({}, "".concat(prefixCls, "-operations-operation-disabled"), !!disabled)),
			onClick
		}, icon);
	}, [toolClassName, prefixCls]);
	var switchPrevNode = showSwitch ? renderOperation({
		icon: left,
		onClick: function onClick(e$2) {
			return handleActive(e$2, -1);
		},
		type: "prev",
		disabled: current === 0
	}) : void 0;
	var switchNextNode = showSwitch ? renderOperation({
		icon: right,
		onClick: function onClick(e$2) {
			return handleActive(e$2, 1);
		},
		type: "next",
		disabled: current === count - 1
	}) : void 0;
	var flipYNode = renderOperation({
		icon: flipY,
		onClick: onFlipY,
		type: "flipY"
	});
	var flipXNode = renderOperation({
		icon: flipX,
		onClick: onFlipX,
		type: "flipX"
	});
	var rotateLeftNode = renderOperation({
		icon: rotateLeft,
		onClick: onRotateLeft,
		type: "rotateLeft"
	});
	var rotateRightNode = renderOperation({
		icon: rotateRight,
		onClick: onRotateRight,
		type: "rotateRight"
	});
	var zoomOutNode = renderOperation({
		icon: zoomOut$1,
		onClick: onZoomOut,
		type: "zoomOut",
		disabled: scale <= minScale
	});
	var zoomInNode = renderOperation({
		icon: zoomIn$1,
		onClick: onZoomIn,
		type: "zoomIn",
		disabled: scale === maxScale
	});
	var toolbarNode = /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-operations") }, flipYNode, flipXNode, rotateLeftNode, rotateRightNode, zoomOutNode, zoomInNode);
	return /* @__PURE__ */ import_react.createElement(es_default$2, {
		visible,
		motionName: maskTransitionName
	}, function(_ref2) {
		var className = _ref2.className, style$1 = _ref2.style;
		return /* @__PURE__ */ import_react.createElement(es_default$6, {
			open: true,
			getContainer: getContainer$1 !== null && getContainer$1 !== void 0 ? getContainer$1 : document.body
		}, /* @__PURE__ */ import_react.createElement("div", {
			className: (0, import_classnames$94.default)("".concat(prefixCls, "-operations-wrapper"), className, rootClassName),
			style: _objectSpread2(_objectSpread2({}, style$1), {}, { zIndex })
		}, closeIcon === null ? null : /* @__PURE__ */ import_react.createElement("button", {
			className: "".concat(prefixCls, "-close"),
			onClick: onClose
		}, closeIcon || close), showSwitch && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("div", {
			className: (0, import_classnames$94.default)("".concat(prefixCls, "-switch-left"), _defineProperty({}, "".concat(prefixCls, "-switch-left-disabled"), current === 0)),
			onClick: function onClick(e$2) {
				return handleActive(e$2, -1);
			}
		}, left), /* @__PURE__ */ import_react.createElement("div", {
			className: (0, import_classnames$94.default)("".concat(prefixCls, "-switch-right"), _defineProperty({}, "".concat(prefixCls, "-switch-right-disabled"), current === count - 1)),
			onClick: function onClick(e$2) {
				return handleActive(e$2, 1);
			}
		}, right)), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-footer") }, showProgress && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-progress") }, countRender ? countRender(current + 1, count) : /* @__PURE__ */ import_react.createElement("bdi", null, "".concat(current + 1, " / ").concat(count))), toolbarRender ? toolbarRender(toolbarNode, _objectSpread2(_objectSpread2({
			icons: {
				prevIcon: switchPrevNode,
				nextIcon: switchNextNode,
				flipYIcon: flipYNode,
				flipXIcon: flipXNode,
				rotateLeftIcon: rotateLeftNode,
				rotateRightIcon: rotateRightNode,
				zoomOutIcon: zoomOutNode,
				zoomInIcon: zoomInNode
			},
			actions: {
				onActive,
				onFlipY,
				onFlipX,
				onRotateLeft,
				onRotateRight,
				onZoomOut,
				onZoomIn,
				onReset,
				onClose
			},
			transform
		}, groupContext ? {
			current,
			total: count
		} : {}), {}, { image })) : toolbarNode)));
	});
};
var Operations_default = Operations;

//#endregion
//#region node_modules/rc-image/es/hooks/useImageTransform.js
var initialTransform = {
	x: 0,
	y: 0,
	rotate: 0,
	scale: 1,
	flipX: false,
	flipY: false
};
function useImageTransform(imgRef, minScale, maxScale, onTransform) {
	var frame = (0, import_react.useRef)(null);
	var queue = (0, import_react.useRef)([]);
	var _useState = (0, import_react.useState)(initialTransform), _useState2 = _slicedToArray(_useState, 2), transform = _useState2[0], setTransform = _useState2[1];
	var resetTransform = function resetTransform$1(action) {
		setTransform(initialTransform);
		if (!isEqual_default(initialTransform, transform)) onTransform === null || onTransform === void 0 || onTransform({
			transform: initialTransform,
			action
		});
	};
	/** Direct update transform */
	var updateTransform = function updateTransform$1(newTransform, action) {
		if (frame.current === null) {
			queue.current = [];
			frame.current = raf_default(function() {
				setTransform(function(preState) {
					var memoState = preState;
					queue.current.forEach(function(queueState) {
						memoState = _objectSpread2(_objectSpread2({}, memoState), queueState);
					});
					frame.current = null;
					onTransform === null || onTransform === void 0 || onTransform({
						transform: memoState,
						action
					});
					return memoState;
				});
			});
		}
		queue.current.push(_objectSpread2(_objectSpread2({}, transform), newTransform));
	};
	return {
		transform,
		resetTransform,
		updateTransform,
		dispatchZoomChange: function dispatchZoomChange(ratio, action, centerX, centerY, isTouch) {
			var _imgRef$current = imgRef.current, width = _imgRef$current.width, height = _imgRef$current.height, offsetWidth = _imgRef$current.offsetWidth, offsetHeight = _imgRef$current.offsetHeight, offsetLeft = _imgRef$current.offsetLeft, offsetTop = _imgRef$current.offsetTop;
			var newRatio = ratio;
			var newScale = transform.scale * ratio;
			if (newScale > maxScale) {
				newScale = maxScale;
				newRatio = maxScale / transform.scale;
			} else if (newScale < minScale) {
				newScale = isTouch ? newScale : minScale;
				newRatio = newScale / transform.scale;
			}
			/** Default center point scaling */
			var mergedCenterX = centerX !== null && centerX !== void 0 ? centerX : innerWidth / 2;
			var mergedCenterY = centerY !== null && centerY !== void 0 ? centerY : innerHeight / 2;
			var diffRatio = newRatio - 1;
			/** Deviation calculated from image size */
			var diffImgX = diffRatio * width * .5;
			var diffImgY = diffRatio * height * .5;
			/** The difference between the click position and the edge of the document */
			var diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);
			var diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);
			/** Final positioning */
			var newX = transform.x - (diffOffsetLeft - diffImgX);
			var newY = transform.y - (diffOffsetTop - diffImgY);
			/**
			* When zooming the image
			* When the image size is smaller than the width and height of the window, the position is initialized
			*/
			if (ratio < 1 && newScale === 1) {
				var mergedWidth = offsetWidth * newScale;
				var mergedHeight = offsetHeight * newScale;
				var _getClientSize = getClientSize(), clientWidth = _getClientSize.width, clientHeight = _getClientSize.height;
				if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {
					newX = 0;
					newY = 0;
				}
			}
			updateTransform({
				x: newX,
				y: newY,
				scale: newScale
			}, action);
		}
	};
}

//#endregion
//#region node_modules/rc-image/es/getFixScaleEleTransPosition.js
function fixPoint(key, start, width, clientWidth) {
	var startAddWidth = start + width;
	var offsetStart = (width - clientWidth) / 2;
	if (width > clientWidth) {
		if (start > 0) return _defineProperty({}, key, offsetStart);
		if (start < 0 && startAddWidth < clientWidth) return _defineProperty({}, key, -offsetStart);
	} else if (start < 0 || startAddWidth > clientWidth) return _defineProperty({}, key, start < 0 ? offsetStart : -offsetStart);
	return {};
}
/**
* Fix positon x,y point when
*
* Ele width && height < client
* - Back origin
*
* - Ele width | height > clientWidth | clientHeight
* - left | top > 0 -> Back 0
* - left | top + width | height < clientWidth | clientHeight -> Back left | top + width | height === clientWidth | clientHeight
*
* Regardless of other
*/
function getFixScaleEleTransPosition(width, height, left, top) {
	var _getClientSize = getClientSize(), clientWidth = _getClientSize.width, clientHeight = _getClientSize.height;
	var fixPos = null;
	if (width <= clientWidth && height <= clientHeight) fixPos = {
		x: 0,
		y: 0
	};
	else if (width > clientWidth || height > clientHeight) fixPos = _objectSpread2(_objectSpread2({}, fixPoint("x", left, width, clientWidth)), fixPoint("y", top, height, clientHeight));
	return fixPos;
}

//#endregion
//#region node_modules/rc-image/es/previewConfig.js
/** Scale the ratio base */
var BASE_SCALE_RATIO = 1;
/** The maximum zoom ratio when the mouse zooms in, adjustable */
var WHEEL_MAX_SCALE_RATIO = 1;

//#endregion
//#region node_modules/rc-image/es/hooks/useMouseEvent.js
function useMouseEvent(imgRef, movable, visible, scaleStep, transform, updateTransform, dispatchZoomChange) {
	var rotate = transform.rotate, scale = transform.scale, x = transform.x, y = transform.y;
	var _useState = (0, import_react.useState)(false), _useState2 = _slicedToArray(_useState, 2), isMoving = _useState2[0], setMoving = _useState2[1];
	var startPositionInfo = (0, import_react.useRef)({
		diffX: 0,
		diffY: 0,
		transformX: 0,
		transformY: 0
	});
	var onMouseDown = function onMouseDown$1(event) {
		if (!movable || event.button !== 0) return;
		event.preventDefault();
		event.stopPropagation();
		startPositionInfo.current = {
			diffX: event.pageX - x,
			diffY: event.pageY - y,
			transformX: x,
			transformY: y
		};
		setMoving(true);
	};
	var onMouseMove = function onMouseMove$1(event) {
		if (visible && isMoving) updateTransform({
			x: event.pageX - startPositionInfo.current.diffX,
			y: event.pageY - startPositionInfo.current.diffY
		}, "move");
	};
	var onMouseUp = function onMouseUp$1() {
		if (visible && isMoving) {
			setMoving(false);
			/** No need to restore the position when the picture is not moved, So as not to interfere with the click */
			var _startPositionInfo$cu = startPositionInfo.current, transformX = _startPositionInfo$cu.transformX, transformY = _startPositionInfo$cu.transformY;
			if (!(x !== transformX && y !== transformY)) return;
			var width = imgRef.current.offsetWidth * scale;
			var height = imgRef.current.offsetHeight * scale;
			var _imgRef$current$getBo = imgRef.current.getBoundingClientRect(), left = _imgRef$current$getBo.left, top = _imgRef$current$getBo.top;
			var isRotate = rotate % 180 !== 0;
			var fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
			if (fixState) updateTransform(_objectSpread2({}, fixState), "dragRebound");
		}
	};
	var onWheel = function onWheel$1(event) {
		if (!visible || event.deltaY == 0) return;
		var scaleRatio = Math.abs(event.deltaY / 100);
		var ratio = BASE_SCALE_RATIO + Math.min(scaleRatio, WHEEL_MAX_SCALE_RATIO) * scaleStep;
		if (event.deltaY > 0) ratio = BASE_SCALE_RATIO / ratio;
		dispatchZoomChange(ratio, "wheel", event.clientX, event.clientY);
	};
	(0, import_react.useEffect)(function() {
		var onTopMouseUpListener;
		var onTopMouseMoveListener;
		var onMouseUpListener;
		var onMouseMoveListener;
		if (movable) {
			onMouseUpListener = addEventListenerWrap(window, "mouseup", onMouseUp, false);
			onMouseMoveListener = addEventListenerWrap(window, "mousemove", onMouseMove, false);
			try {
				/* istanbul ignore next */
				if (window.top !== window.self) {
					onTopMouseUpListener = addEventListenerWrap(window.top, "mouseup", onMouseUp, false);
					onTopMouseMoveListener = addEventListenerWrap(window.top, "mousemove", onMouseMove, false);
				}
			} catch (error) {
				/* istanbul ignore next */
				warning(false, "[rc-image] ".concat(error));
			}
		}
		return function() {
			var _onMouseUpListener, _onMouseMoveListener, _onTopMouseUpListener, _onTopMouseMoveListen;
			(_onMouseUpListener = onMouseUpListener) === null || _onMouseUpListener === void 0 || _onMouseUpListener.remove();
			(_onMouseMoveListener = onMouseMoveListener) === null || _onMouseMoveListener === void 0 || _onMouseMoveListener.remove();
			/* istanbul ignore next */
			(_onTopMouseUpListener = onTopMouseUpListener) === null || _onTopMouseUpListener === void 0 || _onTopMouseUpListener.remove();
			/* istanbul ignore next */
			(_onTopMouseMoveListen = onTopMouseMoveListener) === null || _onTopMouseMoveListen === void 0 || _onTopMouseMoveListen.remove();
		};
	}, [
		visible,
		isMoving,
		x,
		y,
		rotate,
		movable
	]);
	return {
		isMoving,
		onMouseDown,
		onMouseMove,
		onMouseUp,
		onWheel
	};
}

//#endregion
//#region node_modules/rc-image/es/util.js
function isImageValid(src) {
	return new Promise(function(resolve) {
		if (!src) {
			resolve(false);
			return;
		}
		var img = document.createElement("img");
		img.onerror = function() {
			return resolve(false);
		};
		img.onload = function() {
			return resolve(true);
		};
		img.src = src;
	});
}

//#endregion
//#region node_modules/rc-image/es/hooks/useStatus.js
function useStatus(_ref) {
	var src = _ref.src, isCustomPlaceholder = _ref.isCustomPlaceholder, fallback = _ref.fallback;
	var _useState = (0, import_react.useState)(isCustomPlaceholder ? "loading" : "normal"), _useState2 = _slicedToArray(_useState, 2), status = _useState2[0], setStatus = _useState2[1];
	var isLoaded = (0, import_react.useRef)(false);
	var isError = status === "error";
	(0, import_react.useEffect)(function() {
		var isCurrentSrc = true;
		isImageValid(src).then(function(isValid) {
			if (!isValid && isCurrentSrc) setStatus("error");
		});
		return function() {
			isCurrentSrc = false;
		};
	}, [src]);
	(0, import_react.useEffect)(function() {
		if (isCustomPlaceholder && !isLoaded.current) setStatus("loading");
		else if (isError) setStatus("normal");
	}, [src]);
	var onLoad = function onLoad$1() {
		setStatus("normal");
	};
	return [
		function getImgRef(img) {
			isLoaded.current = false;
			if (status === "loading" && img !== null && img !== void 0 && img.complete && (img.naturalWidth || img.naturalHeight)) {
				isLoaded.current = true;
				onLoad();
			}
		},
		isError && fallback ? { src: fallback } : {
			onLoad,
			src
		},
		status
	];
}

//#endregion
//#region node_modules/rc-image/es/hooks/useTouchEvent.js
function getDistance(a, b) {
	var x = a.x - b.x;
	var y = a.y - b.y;
	return Math.hypot(x, y);
}
function getCenter(oldPoint1, oldPoint2, newPoint1, newPoint2) {
	var distance1 = getDistance(oldPoint1, newPoint1);
	var distance2 = getDistance(oldPoint2, newPoint2);
	if (distance1 === 0 && distance2 === 0) return [oldPoint1.x, oldPoint1.y];
	var ratio = distance1 / (distance1 + distance2);
	var x = oldPoint1.x + ratio * (oldPoint2.x - oldPoint1.x);
	var y = oldPoint1.y + ratio * (oldPoint2.y - oldPoint1.y);
	return [x, y];
}
function useTouchEvent(imgRef, movable, visible, minScale, transform, updateTransform, dispatchZoomChange) {
	var rotate = transform.rotate, scale = transform.scale, x = transform.x, y = transform.y;
	var _useState = (0, import_react.useState)(false), _useState2 = _slicedToArray(_useState, 2), isTouching = _useState2[0], setIsTouching = _useState2[1];
	var touchPointInfo = (0, import_react.useRef)({
		point1: {
			x: 0,
			y: 0
		},
		point2: {
			x: 0,
			y: 0
		},
		eventType: "none"
	});
	var updateTouchPointInfo = function updateTouchPointInfo$1(values) {
		touchPointInfo.current = _objectSpread2(_objectSpread2({}, touchPointInfo.current), values);
	};
	var onTouchStart = function onTouchStart$1(event) {
		if (!movable) return;
		event.stopPropagation();
		setIsTouching(true);
		var _event$touches = event.touches, touches = _event$touches === void 0 ? [] : _event$touches;
		if (touches.length > 1) updateTouchPointInfo({
			point1: {
				x: touches[0].clientX,
				y: touches[0].clientY
			},
			point2: {
				x: touches[1].clientX,
				y: touches[1].clientY
			},
			eventType: "touchZoom"
		});
		else updateTouchPointInfo({
			point1: {
				x: touches[0].clientX - x,
				y: touches[0].clientY - y
			},
			eventType: "move"
		});
	};
	var onTouchMove = function onTouchMove$1(event) {
		var _event$touches2 = event.touches, touches = _event$touches2 === void 0 ? [] : _event$touches2;
		var _touchPointInfo$curre = touchPointInfo.current, point1 = _touchPointInfo$curre.point1, point2 = _touchPointInfo$curre.point2, eventType = _touchPointInfo$curre.eventType;
		if (touches.length > 1 && eventType === "touchZoom") {
			var newPoint1 = {
				x: touches[0].clientX,
				y: touches[0].clientY
			};
			var newPoint2 = {
				x: touches[1].clientX,
				y: touches[1].clientY
			};
			var _getCenter = getCenter(point1, point2, newPoint1, newPoint2), _getCenter2 = _slicedToArray(_getCenter, 2), centerX = _getCenter2[0], centerY = _getCenter2[1];
			var ratio = getDistance(newPoint1, newPoint2) / getDistance(point1, point2);
			dispatchZoomChange(ratio, "touchZoom", centerX, centerY, true);
			updateTouchPointInfo({
				point1: newPoint1,
				point2: newPoint2,
				eventType: "touchZoom"
			});
		} else if (eventType === "move") {
			updateTransform({
				x: touches[0].clientX - point1.x,
				y: touches[0].clientY - point1.y
			}, "move");
			updateTouchPointInfo({ eventType: "move" });
		}
	};
	var onTouchEnd = function onTouchEnd$1() {
		if (!visible) return;
		if (isTouching) setIsTouching(false);
		updateTouchPointInfo({ eventType: "none" });
		if (minScale > scale)
 /** When the scaling ratio is less than the minimum scaling ratio, reset the scaling ratio */
		return updateTransform({
			x: 0,
			y: 0,
			scale: minScale
		}, "touchZoom");
		var width = imgRef.current.offsetWidth * scale;
		var height = imgRef.current.offsetHeight * scale;
		var _imgRef$current$getBo = imgRef.current.getBoundingClientRect(), left = _imgRef$current$getBo.left, top = _imgRef$current$getBo.top;
		var isRotate = rotate % 180 !== 0;
		var fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
		if (fixState) updateTransform(_objectSpread2({}, fixState), "dragRebound");
	};
	(0, import_react.useEffect)(function() {
		var onTouchMoveListener;
		if (visible && movable) onTouchMoveListener = addEventListenerWrap(window, "touchmove", function(e$2) {
			return e$2.preventDefault();
		}, { passive: false });
		return function() {
			var _onTouchMoveListener;
			(_onTouchMoveListener = onTouchMoveListener) === null || _onTouchMoveListener === void 0 || _onTouchMoveListener.remove();
		};
	}, [visible, movable]);
	return {
		isTouching,
		onTouchStart,
		onTouchMove,
		onTouchEnd
	};
}

//#endregion
//#region node_modules/rc-image/es/Preview.js
var import_classnames$93 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$26 = [
	"fallback",
	"src",
	"imgRef"
], _excluded2$4 = [
	"prefixCls",
	"src",
	"alt",
	"imageInfo",
	"fallback",
	"movable",
	"onClose",
	"visible",
	"icons",
	"rootClassName",
	"closeIcon",
	"getContainer",
	"current",
	"count",
	"countRender",
	"scaleStep",
	"minScale",
	"maxScale",
	"transitionName",
	"maskTransitionName",
	"imageRender",
	"imgCommonProps",
	"toolbarRender",
	"onTransform",
	"onChange"
];
var PreviewImage = function PreviewImage$1(_ref) {
	var fallback = _ref.fallback, src = _ref.src, imgRef = _ref.imgRef, props = _objectWithoutProperties(_ref, _excluded$26);
	var _useStatus = useStatus({
		src,
		fallback
	}), _useStatus2 = _slicedToArray(_useStatus, 2), getImgRef = _useStatus2[0], srcAndOnload = _useStatus2[1];
	return /* @__PURE__ */ import_react.createElement("img", _extends({ ref: function ref(_ref2) {
		imgRef.current = _ref2;
		getImgRef(_ref2);
	} }, props, srcAndOnload));
};
var Preview = function Preview$1(props) {
	var prefixCls = props.prefixCls, src = props.src, alt = props.alt, imageInfo = props.imageInfo, fallback = props.fallback, _props$movable = props.movable, movable = _props$movable === void 0 ? true : _props$movable, onClose = props.onClose, visible = props.visible, _props$icons = props.icons, icons$1 = _props$icons === void 0 ? {} : _props$icons, rootClassName = props.rootClassName, closeIcon = props.closeIcon, getContainer$1 = props.getContainer, _props$current = props.current, current = _props$current === void 0 ? 0 : _props$current, _props$count = props.count, count = _props$count === void 0 ? 1 : _props$count, countRender = props.countRender, _props$scaleStep = props.scaleStep, scaleStep = _props$scaleStep === void 0 ? .5 : _props$scaleStep, _props$minScale = props.minScale, minScale = _props$minScale === void 0 ? 1 : _props$minScale, _props$maxScale = props.maxScale, maxScale = _props$maxScale === void 0 ? 50 : _props$maxScale, _props$transitionName = props.transitionName, transitionName = _props$transitionName === void 0 ? "zoom" : _props$transitionName, _props$maskTransition = props.maskTransitionName, maskTransitionName = _props$maskTransition === void 0 ? "fade" : _props$maskTransition, imageRender = props.imageRender, imgCommonProps = props.imgCommonProps, toolbarRender = props.toolbarRender, onTransform = props.onTransform, onChange = props.onChange, restProps = _objectWithoutProperties(props, _excluded2$4);
	var imgRef = (0, import_react.useRef)();
	var groupContext = (0, import_react.useContext)(PreviewGroupContext);
	var showLeftOrRightSwitches = groupContext && count > 1;
	var showOperationsProgress = groupContext && count >= 1;
	var _useState = (0, import_react.useState)(true), _useState2 = _slicedToArray(_useState, 2), enableTransition = _useState2[0], setEnableTransition = _useState2[1];
	var _useImageTransform = useImageTransform(imgRef, minScale, maxScale, onTransform), transform = _useImageTransform.transform, resetTransform = _useImageTransform.resetTransform, updateTransform = _useImageTransform.updateTransform, dispatchZoomChange = _useImageTransform.dispatchZoomChange;
	var _useMouseEvent = useMouseEvent(imgRef, movable, visible, scaleStep, transform, updateTransform, dispatchZoomChange), isMoving = _useMouseEvent.isMoving, onMouseDown = _useMouseEvent.onMouseDown, onWheel = _useMouseEvent.onWheel;
	var _useTouchEvent = useTouchEvent(imgRef, movable, visible, minScale, transform, updateTransform, dispatchZoomChange), isTouching = _useTouchEvent.isTouching, onTouchStart = _useTouchEvent.onTouchStart, onTouchMove = _useTouchEvent.onTouchMove, onTouchEnd = _useTouchEvent.onTouchEnd;
	var rotate = transform.rotate, scale = transform.scale;
	var wrapClassName = (0, import_classnames$93.default)(_defineProperty({}, "".concat(prefixCls, "-moving"), isMoving));
	(0, import_react.useEffect)(function() {
		if (!enableTransition) setEnableTransition(true);
	}, [enableTransition]);
	var onAfterClose = function onAfterClose$1() {
		resetTransform("close");
	};
	var onZoomIn = function onZoomIn$1() {
		dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "zoomIn");
	};
	var onZoomOut = function onZoomOut$1() {
		dispatchZoomChange(BASE_SCALE_RATIO / (BASE_SCALE_RATIO + scaleStep), "zoomOut");
	};
	var onRotateRight = function onRotateRight$1() {
		updateTransform({ rotate: rotate + 90 }, "rotateRight");
	};
	var onRotateLeft = function onRotateLeft$1() {
		updateTransform({ rotate: rotate - 90 }, "rotateLeft");
	};
	var onFlipX = function onFlipX$1() {
		updateTransform({ flipX: !transform.flipX }, "flipX");
	};
	var onFlipY = function onFlipY$1() {
		updateTransform({ flipY: !transform.flipY }, "flipY");
	};
	var onReset = function onReset$1() {
		resetTransform("reset");
	};
	var onActive = function onActive$1(offset$2) {
		var position$2 = current + offset$2;
		if (!Number.isInteger(position$2) || position$2 < 0 || position$2 > count - 1) return;
		setEnableTransition(false);
		resetTransform(offset$2 < 0 ? "prev" : "next");
		onChange === null || onChange === void 0 || onChange(position$2, current);
	};
	var onKeyDown$1 = function onKeyDown$2(event) {
		if (!visible || !showLeftOrRightSwitches) return;
		if (event.keyCode === KeyCode_default.LEFT) onActive(-1);
		else if (event.keyCode === KeyCode_default.RIGHT) onActive(1);
	};
	var onDoubleClick = function onDoubleClick$1(event) {
		if (visible) if (scale !== 1) updateTransform({
			x: 0,
			y: 0,
			scale: 1
		}, "doubleClick");
		else dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "doubleClick", event.clientX, event.clientY);
	};
	(0, import_react.useEffect)(function() {
		var onKeyDownListener = addEventListenerWrap(window, "keydown", onKeyDown$1, false);
		return function() {
			onKeyDownListener.remove();
		};
	}, [
		visible,
		showLeftOrRightSwitches,
		current
	]);
	var imgNode = /* @__PURE__ */ import_react.createElement(PreviewImage, _extends({}, imgCommonProps, {
		width: props.width,
		height: props.height,
		imgRef,
		className: "".concat(prefixCls, "-img"),
		alt,
		style: {
			transform: "translate3d(".concat(transform.x, "px, ").concat(transform.y, "px, 0) scale3d(").concat(transform.flipX ? "-" : "").concat(scale, ", ").concat(transform.flipY ? "-" : "").concat(scale, ", 1) rotate(").concat(rotate, "deg)"),
			transitionDuration: (!enableTransition || isTouching) && "0s"
		},
		fallback,
		src,
		onWheel,
		onMouseDown,
		onDoubleClick,
		onTouchStart,
		onTouchMove,
		onTouchEnd,
		onTouchCancel: onTouchEnd
	}));
	var image = _objectSpread2({
		url: src,
		alt
	}, imageInfo);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(es_default$16, _extends({
		transitionName,
		maskTransitionName,
		closable: false,
		keyboard: true,
		prefixCls,
		onClose,
		visible,
		classNames: { wrapper: wrapClassName },
		rootClassName,
		getContainer: getContainer$1
	}, restProps, { afterClose: onAfterClose }), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-img-wrapper") }, imageRender ? imageRender(imgNode, _objectSpread2({
		transform,
		image
	}, groupContext ? { current } : {})) : imgNode)), /* @__PURE__ */ import_react.createElement(Operations_default, {
		visible,
		transform,
		maskTransitionName,
		closeIcon,
		getContainer: getContainer$1,
		prefixCls,
		rootClassName,
		icons: icons$1,
		countRender,
		showSwitch: showLeftOrRightSwitches,
		showProgress: showOperationsProgress,
		current,
		count,
		scale,
		minScale,
		maxScale,
		toolbarRender,
		onActive,
		onZoomIn,
		onZoomOut,
		onRotateRight,
		onRotateLeft,
		onFlipX,
		onFlipY,
		onClose,
		onReset,
		zIndex: restProps.zIndex !== void 0 ? restProps.zIndex + 1 : void 0,
		image
	}));
};
var Preview_default = Preview;

//#endregion
//#region node_modules/rc-image/es/common.js
var COMMON_PROPS = [
	"crossOrigin",
	"decoding",
	"draggable",
	"loading",
	"referrerPolicy",
	"sizes",
	"srcSet",
	"useMap",
	"alt"
];

//#endregion
//#region node_modules/rc-image/es/hooks/usePreviewItems.js
/**
* Merge props provided `items` or context collected images
*/
function usePreviewItems(items) {
	var _React$useState = import_react.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), images = _React$useState2[0], setImages = _React$useState2[1];
	var registerImage = import_react.useCallback(function(id, data) {
		setImages(function(imgs) {
			return _objectSpread2(_objectSpread2({}, imgs), {}, _defineProperty({}, id, data));
		});
		return function() {
			setImages(function(imgs) {
				var cloneImgs = _objectSpread2({}, imgs);
				delete cloneImgs[id];
				return cloneImgs;
			});
		};
	}, []);
	return [
		import_react.useMemo(function() {
			if (items) return items.map(function(item) {
				if (typeof item === "string") return { data: { src: item } };
				var data = {};
				Object.keys(item).forEach(function(key) {
					if (["src"].concat(_toConsumableArray(COMMON_PROPS)).includes(key)) data[key] = item[key];
				});
				return { data };
			});
			return Object.keys(images).reduce(function(total, id) {
				var _images$id = images[id], canPreview = _images$id.canPreview, data = _images$id.data;
				if (canPreview) total.push({
					data,
					id
				});
				return total;
			}, []);
		}, [items, images]),
		registerImage,
		!!items
	];
}

//#endregion
//#region node_modules/rc-image/es/PreviewGroup.js
var _excluded$25 = [
	"visible",
	"onVisibleChange",
	"getContainer",
	"current",
	"movable",
	"minScale",
	"maxScale",
	"countRender",
	"closeIcon",
	"onChange",
	"onTransform",
	"toolbarRender",
	"imageRender"
], _excluded2$3 = ["src"];
var Group$1 = function Group$2(_ref) {
	var _mergedItems$current;
	var _ref$previewPrefixCls = _ref.previewPrefixCls, previewPrefixCls = _ref$previewPrefixCls === void 0 ? "rc-image-preview" : _ref$previewPrefixCls, children = _ref.children, _ref$icons = _ref.icons, icons$1 = _ref$icons === void 0 ? {} : _ref$icons, items = _ref.items, preview = _ref.preview, fallback = _ref.fallback;
	var _ref2 = _typeof(preview) === "object" ? preview : {}, previewVisible = _ref2.visible, onVisibleChange = _ref2.onVisibleChange, getContainer$1 = _ref2.getContainer, currentIndex = _ref2.current, movable = _ref2.movable, minScale = _ref2.minScale, maxScale = _ref2.maxScale, countRender = _ref2.countRender, closeIcon = _ref2.closeIcon, onChange = _ref2.onChange, onTransform = _ref2.onTransform, toolbarRender = _ref2.toolbarRender, imageRender = _ref2.imageRender, dialogProps = _objectWithoutProperties(_ref2, _excluded$25);
	var _usePreviewItems = usePreviewItems(items), _usePreviewItems2 = _slicedToArray(_usePreviewItems, 3), mergedItems = _usePreviewItems2[0], register = _usePreviewItems2[1], fromItems = _usePreviewItems2[2];
	var _useMergedState = useMergedState(0, { value: currentIndex }), _useMergedState2 = _slicedToArray(_useMergedState, 2), current = _useMergedState2[0], setCurrent = _useMergedState2[1];
	var _useState = (0, import_react.useState)(false), _useState2 = _slicedToArray(_useState, 2), keepOpenIndex = _useState2[0], setKeepOpenIndex = _useState2[1];
	var _ref3 = ((_mergedItems$current = mergedItems[current]) === null || _mergedItems$current === void 0 ? void 0 : _mergedItems$current.data) || {}, src = _ref3.src, imgCommonProps = _objectWithoutProperties(_ref3, _excluded2$3);
	var _useMergedState3 = useMergedState(!!previewVisible, {
		value: previewVisible,
		onChange: function onChange$1(val, prevVal) {
			onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(val, prevVal, current);
		}
	}), _useMergedState4 = _slicedToArray(_useMergedState3, 2), isShowPreview = _useMergedState4[0], setShowPreview = _useMergedState4[1];
	var _useState3 = (0, import_react.useState)(null), _useState4 = _slicedToArray(_useState3, 2), mousePosition$1 = _useState4[0], setMousePosition = _useState4[1];
	var onPreviewFromImage = import_react.useCallback(function(id, imageSrc, mouseX, mouseY) {
		var index$2 = fromItems ? mergedItems.findIndex(function(item) {
			return item.data.src === imageSrc;
		}) : mergedItems.findIndex(function(item) {
			return item.id === id;
		});
		setCurrent(index$2 < 0 ? 0 : index$2);
		setShowPreview(true);
		setMousePosition({
			x: mouseX,
			y: mouseY
		});
		setKeepOpenIndex(true);
	}, [mergedItems, fromItems]);
	import_react.useEffect(function() {
		if (isShowPreview) {
			if (!keepOpenIndex) setCurrent(0);
		} else setKeepOpenIndex(false);
	}, [isShowPreview]);
	var onInternalChange = function onInternalChange$1(next$1, prev$1) {
		setCurrent(next$1);
		onChange === null || onChange === void 0 || onChange(next$1, prev$1);
	};
	var onPreviewClose = function onPreviewClose$1() {
		setShowPreview(false);
		setMousePosition(null);
	};
	var previewGroupContext = import_react.useMemo(function() {
		return {
			register,
			onPreview: onPreviewFromImage
		};
	}, [register, onPreviewFromImage]);
	return /* @__PURE__ */ import_react.createElement(PreviewGroupContext.Provider, { value: previewGroupContext }, children, /* @__PURE__ */ import_react.createElement(Preview_default, _extends({
		"aria-hidden": !isShowPreview,
		movable,
		visible: isShowPreview,
		prefixCls: previewPrefixCls,
		closeIcon,
		onClose: onPreviewClose,
		mousePosition: mousePosition$1,
		imgCommonProps,
		src,
		fallback,
		icons: icons$1,
		minScale,
		maxScale,
		getContainer: getContainer$1,
		current,
		count: mergedItems.length,
		countRender,
		onTransform,
		toolbarRender,
		imageRender,
		onChange: onInternalChange
	}, dialogProps)));
};
var PreviewGroup_default$1 = Group$1;

//#endregion
//#region node_modules/rc-image/es/hooks/useRegisterImage.js
var uid$1 = 0;
function useRegisterImage(canPreview, data) {
	var _React$useState = import_react.useState(function() {
		uid$1 += 1;
		return String(uid$1);
	}), _React$useState2 = _slicedToArray(_React$useState, 1), id = _React$useState2[0];
	var groupContext = import_react.useContext(PreviewGroupContext);
	var registerData = {
		data,
		canPreview
	};
	import_react.useEffect(function() {
		if (groupContext) return groupContext.register(id, registerData);
	}, []);
	import_react.useEffect(function() {
		if (groupContext) groupContext.register(id, registerData);
	}, [canPreview, data]);
	return id;
}

//#endregion
//#region node_modules/rc-image/es/Image.js
var import_classnames$92 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$24 = [
	"src",
	"alt",
	"onPreviewClose",
	"prefixCls",
	"previewPrefixCls",
	"placeholder",
	"fallback",
	"width",
	"height",
	"style",
	"preview",
	"className",
	"onClick",
	"onError",
	"wrapperClassName",
	"wrapperStyle",
	"rootClassName"
], _excluded2$2 = [
	"src",
	"visible",
	"onVisibleChange",
	"getContainer",
	"mask",
	"maskClassName",
	"movable",
	"icons",
	"scaleStep",
	"minScale",
	"maxScale",
	"imageRender",
	"toolbarRender"
];
var ImageInternal = function ImageInternal$1(props) {
	var imgSrc = props.src, alt = props.alt, onInitialPreviewClose = props.onPreviewClose, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-image" : _props$prefixCls, _props$previewPrefixC = props.previewPrefixCls, previewPrefixCls = _props$previewPrefixC === void 0 ? "".concat(prefixCls, "-preview") : _props$previewPrefixC, placeholder = props.placeholder, fallback = props.fallback, width = props.width, height = props.height, style$1 = props.style, _props$preview = props.preview, preview = _props$preview === void 0 ? true : _props$preview, className = props.className, onClick = props.onClick, onError = props.onError, wrapperClassName = props.wrapperClassName, wrapperStyle = props.wrapperStyle, rootClassName = props.rootClassName, otherProps = _objectWithoutProperties(props, _excluded$24);
	var isCustomPlaceholder = placeholder && placeholder !== true;
	var _ref = _typeof(preview) === "object" ? preview : {}, previewSrc = _ref.src, _ref$visible = _ref.visible, previewVisible = _ref$visible === void 0 ? void 0 : _ref$visible, _ref$onVisibleChange = _ref.onVisibleChange, onPreviewVisibleChange = _ref$onVisibleChange === void 0 ? onInitialPreviewClose : _ref$onVisibleChange, _ref$getContainer = _ref.getContainer, getPreviewContainer = _ref$getContainer === void 0 ? void 0 : _ref$getContainer, previewMask = _ref.mask, maskClassName = _ref.maskClassName, movable = _ref.movable, icons$1 = _ref.icons, scaleStep = _ref.scaleStep, minScale = _ref.minScale, maxScale = _ref.maxScale, imageRender = _ref.imageRender, toolbarRender = _ref.toolbarRender, dialogProps = _objectWithoutProperties(_ref, _excluded2$2);
	var src = previewSrc !== null && previewSrc !== void 0 ? previewSrc : imgSrc;
	var _useMergedState = useMergedState(!!previewVisible, {
		value: previewVisible,
		onChange: onPreviewVisibleChange
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), isShowPreview = _useMergedState2[0], setShowPreview = _useMergedState2[1];
	var _useStatus = useStatus({
		src: imgSrc,
		isCustomPlaceholder,
		fallback
	}), _useStatus2 = _slicedToArray(_useStatus, 3), getImgRef = _useStatus2[0], srcAndOnload = _useStatus2[1], status = _useStatus2[2];
	var _useState = (0, import_react.useState)(null), _useState2 = _slicedToArray(_useState, 2), mousePosition$1 = _useState2[0], setMousePosition = _useState2[1];
	var groupContext = (0, import_react.useContext)(PreviewGroupContext);
	var canPreview = !!preview;
	var onPreviewClose = function onPreviewClose$1() {
		setShowPreview(false);
		setMousePosition(null);
	};
	var wrapperClass = (0, import_classnames$92.default)(prefixCls, wrapperClassName, rootClassName, _defineProperty({}, "".concat(prefixCls, "-error"), status === "error"));
	var imgCommonProps = (0, import_react.useMemo)(function() {
		var obj = {};
		COMMON_PROPS.forEach(function(prop) {
			if (props[prop] !== void 0) obj[prop] = props[prop];
		});
		return obj;
	}, COMMON_PROPS.map(function(prop) {
		return props[prop];
	}));
	var registerData = (0, import_react.useMemo)(function() {
		return _objectSpread2(_objectSpread2({}, imgCommonProps), {}, { src });
	}, [src, imgCommonProps]);
	var imageId = useRegisterImage(canPreview, registerData);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("div", _extends({}, otherProps, {
		className: wrapperClass,
		onClick: canPreview ? function onPreview(e$2) {
			var _getOffset = getOffset$1(e$2.target), left = _getOffset.left, top = _getOffset.top;
			if (groupContext) groupContext.onPreview(imageId, src, left, top);
			else {
				setMousePosition({
					x: left,
					y: top
				});
				setShowPreview(true);
			}
			onClick === null || onClick === void 0 || onClick(e$2);
		} : onClick,
		style: _objectSpread2({
			width,
			height
		}, wrapperStyle)
	}), /* @__PURE__ */ import_react.createElement("img", _extends({}, imgCommonProps, {
		className: (0, import_classnames$92.default)("".concat(prefixCls, "-img"), _defineProperty({}, "".concat(prefixCls, "-img-placeholder"), placeholder === true), className),
		style: _objectSpread2({ height }, style$1),
		ref: getImgRef
	}, srcAndOnload, {
		width,
		height,
		onError
	})), status === "loading" && /* @__PURE__ */ import_react.createElement("div", {
		"aria-hidden": "true",
		className: "".concat(prefixCls, "-placeholder")
	}, placeholder), previewMask && canPreview && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$92.default)("".concat(prefixCls, "-mask"), maskClassName),
		style: { display: (style$1 === null || style$1 === void 0 ? void 0 : style$1.display) === "none" ? "none" : void 0 }
	}, previewMask)), !groupContext && canPreview && /* @__PURE__ */ import_react.createElement(Preview_default, _extends({
		"aria-hidden": !isShowPreview,
		visible: isShowPreview,
		prefixCls: previewPrefixCls,
		onClose: onPreviewClose,
		mousePosition: mousePosition$1,
		src,
		alt,
		imageInfo: {
			width,
			height
		},
		fallback,
		getContainer: getPreviewContainer,
		icons: icons$1,
		movable,
		scaleStep,
		minScale,
		maxScale,
		rootClassName,
		imageRender,
		imgCommonProps,
		toolbarRender
	}, dialogProps)));
};
ImageInternal.PreviewGroup = PreviewGroup_default$1;
ImageInternal.displayName = "Image";
var Image_default = ImageInternal;

//#endregion
//#region node_modules/rc-image/es/index.js
var es_default$15 = Image_default;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/RotateLeftOutlined.js
var RotateLeftOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [
			{
				"tag": "defs",
				"attrs": {},
				"children": [{
					"tag": "style",
					"attrs": {}
				}]
			},
			{
				"tag": "path",
				"attrs": { "d": "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" }
			},
			{
				"tag": "path",
				"attrs": { "d": "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" }
			}
		]
	},
	"name": "rotate-left",
	"theme": "outlined"
};
var RotateLeftOutlined_default$1 = RotateLeftOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/RotateLeftOutlined.js
/**![rotate-left](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHN0eWxlIC8+PC9kZWZzPjxwYXRoIGQ9Ik02NzIgNDE4SDE0NGMtMTcuNyAwLTMyIDE0LjMtMzIgMzJ2NDE0YzAgMTcuNyAxNC4zIDMyIDMyIDMyaDUyOGMxNy43IDAgMzItMTQuMyAzMi0zMlY0NTBjMC0xNy43LTE0LjMtMzItMzItMzJ6bS00NCA0MDJIMTg4VjQ5NGg0NDB2MzI2eiIgLz48cGF0aCBkPSJNODE5LjMgMzI4LjVjLTc4LjgtMTAwLjctMTk2LTE1My42LTMxNC42LTE1NC4ybC0uMi02NGMwLTYuNS03LjYtMTAuMS0xMi42LTYuMWwtMTI4IDEwMWMtNCAzLjEtMy45IDkuMSAwIDEyLjNMNDkyIDMxOC42YzUuMSA0IDEyLjcuNCAxMi42LTYuMXYtNjMuOWMxMi45LjEgMjUuOS45IDM4LjggMi41IDQyLjEgNS4yIDgyLjEgMTguMiAxMTkgMzguNyAzOC4xIDIxLjIgNzEuMiA0OS43IDk4LjQgODQuMyAyNy4xIDM0LjcgNDYuNyA3My43IDU4LjEgMTE1LjhhMzI1Ljk1IDMyNS45NSAwIDAxNi41IDE0MC45aDc0LjljMTQuOC0xMDMuNi0xMS4zLTIxMy04MS0zMDIuM3oiIC8+PC9zdmc+) */
var RefIcon$28 = /* @__PURE__ */ import_react.forwardRef(function RotateLeftOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: RotateLeftOutlined_default$1
	}));
});
RefIcon$28.displayName = "RotateLeftOutlined";
var RotateLeftOutlined_default = RefIcon$28;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/RotateRightOutlined.js
var RotateRightOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [
			{
				"tag": "defs",
				"attrs": {},
				"children": [{
					"tag": "style",
					"attrs": {}
				}]
			},
			{
				"tag": "path",
				"attrs": { "d": "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" }
			},
			{
				"tag": "path",
				"attrs": { "d": "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" }
			}
		]
	},
	"name": "rotate-right",
	"theme": "outlined"
};
var RotateRightOutlined_default$1 = RotateRightOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/RotateRightOutlined.js
/**![rotate-right](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHN0eWxlIC8+PC9kZWZzPjxwYXRoIGQ9Ik00ODAuNSAyNTEuMmMxMy0xLjYgMjUuOS0yLjQgMzguOC0yLjV2NjMuOWMwIDYuNSA3LjUgMTAuMSAxMi42IDYuMUw2NjAgMjE3LjZjNC0zLjIgNC05LjIgMC0xMi4zbC0xMjgtMTAxYy01LjEtNC0xMi42LS40LTEyLjYgNi4xbC0uMiA2NGMtMTE4LjYuNS0yMzUuOCA1My40LTMxNC42IDE1NC4yQTM5OS43NSAzOTkuNzUgMCAwMDEyMy41IDYzMWg3NC45Yy0uOS01LjMtMS43LTEwLjctMi40LTE2LjEtNS4xLTQyLjEtMi4xLTg0LjEgOC45LTEyNC44IDExLjQtNDIuMiAzMS04MS4xIDU4LjEtMTE1LjggMjcuMi0zNC43IDYwLjMtNjMuMiA5OC40LTg0LjMgMzctMjAuNiA3Ni45LTMzLjYgMTE5LjEtMzguOHoiIC8+PHBhdGggZD0iTTg4MCA0MThIMzUyYy0xNy43IDAtMzIgMTQuMy0zMiAzMnY0MTRjMCAxNy43IDE0LjMgMzIgMzIgMzJoNTI4YzE3LjcgMCAzMi0xNC4zIDMyLTMyVjQ1MGMwLTE3LjctMTQuMy0zMi0zMi0zMnptLTQ0IDQwMkgzOTZWNDk0aDQ0MHYzMjZ6IiAvPjwvc3ZnPg==) */
var RefIcon$27 = /* @__PURE__ */ import_react.forwardRef(function RotateRightOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: RotateRightOutlined_default$1
	}));
});
RefIcon$27.displayName = "RotateRightOutlined";
var RotateRightOutlined_default = RefIcon$27;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/SwapOutlined.js
var SwapOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" }
		}]
	},
	"name": "swap",
	"theme": "outlined"
};
var SwapOutlined_default$1 = SwapOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/SwapOutlined.js
/**![swap](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg0Ny45IDU5MkgxNTJjLTQuNCAwLTggMy42LTggOHY2MGMwIDQuNCAzLjYgOCA4IDhoNjA1LjJMNjEyLjkgODUxYy00LjEgNS4yLS40IDEzIDYuMyAxM2g3Mi41YzQuOSAwIDkuNS0yLjIgMTIuNi02LjFsMTY4LjgtMjE0LjFjMTYuNS0yMSAxLjYtNTEuOC0yNS4yLTUxLjh6TTg3MiAzNTZIMjY2LjhsMTQ0LjMtMTgzYzQuMS01LjIuNC0xMy02LjMtMTNoLTcyLjVjLTQuOSAwLTkuNSAyLjItMTIuNiA2LjFMMTUwLjkgMzgwLjJjLTE2LjUgMjEtMS42IDUxLjggMjUuMSA1MS44aDY5NmM0LjQgMCA4LTMuNiA4LTh2LTYwYzAtNC40LTMuNi04LTgtOHoiIC8+PC9zdmc+) */
var RefIcon$26 = /* @__PURE__ */ import_react.forwardRef(function SwapOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: SwapOutlined_default$1
	}));
});
RefIcon$26.displayName = "SwapOutlined";
var SwapOutlined_default = RefIcon$26;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/ZoomInOutlined.js
var ZoomInOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" }
		}]
	},
	"name": "zoom-in",
	"theme": "outlined"
};
var ZoomInOutlined_default$1 = ZoomInOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/ZoomInOutlined.js
/**![zoom-in](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYzNyA0NDNINTE5VjMwOWMwLTQuNC0zLjYtOC04LThoLTYwYy00LjQgMC04IDMuNi04IDh2MTM0SDMyNWMtNC40IDAtOCAzLjYtOCA4djYwYzAgNC40IDMuNiA4IDggOGgxMTh2MTM0YzAgNC40IDMuNiA4IDggOGg2MGM0LjQgMCA4LTMuNiA4LThWNTE5aDExOGM0LjQgMCA4LTMuNiA4LTh2LTYwYzAtNC40LTMuNi04LTgtOHptMjg0IDQyNEw3NzUgNzIxYzEyMi4xLTE0OC45IDExMy42LTM2OS41LTI2LTUwOS0xNDgtMTQ4LjEtMzg4LjQtMTQ4LjEtNTM3IDAtMTQ4LjEgMTQ4LjYtMTQ4LjEgMzg5IDAgNTM3IDEzOS41IDEzOS42IDM2MC4xIDE0OC4xIDUwOSAyNmwxNDYgMTQ2YzMuMiAyLjggOC4zIDIuOCAxMSAwbDQzLTQzYzIuOC0yLjcgMi44LTcuOCAwLTExek02OTYgNjk2Yy0xMTguOCAxMTguNy0zMTEuMiAxMTguNy00MzAgMC0xMTguNy0xMTguOC0xMTguNy0zMTEuMiAwLTQzMCAxMTguOC0xMTguNyAzMTEuMi0xMTguNyA0MzAgMCAxMTguNyAxMTguOCAxMTguNyAzMTEuMiAwIDQzMHoiIC8+PC9zdmc+) */
var RefIcon$25 = /* @__PURE__ */ import_react.forwardRef(function ZoomInOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: ZoomInOutlined_default$1
	}));
});
RefIcon$25.displayName = "ZoomInOutlined";
var ZoomInOutlined_default = RefIcon$25;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/ZoomOutOutlined.js
var ZoomOutOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" }
		}]
	},
	"name": "zoom-out",
	"theme": "outlined"
};
var ZoomOutOutlined_default$1 = ZoomOutOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/ZoomOutOutlined.js
/**![zoom-out](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYzNyA0NDNIMzI1Yy00LjQgMC04IDMuNi04IDh2NjBjMCA0LjQgMy42IDggOCA4aDMxMmM0LjQgMCA4LTMuNiA4LTh2LTYwYzAtNC40LTMuNi04LTgtOHptMjg0IDQyNEw3NzUgNzIxYzEyMi4xLTE0OC45IDExMy42LTM2OS41LTI2LTUwOS0xNDgtMTQ4LjEtMzg4LjQtMTQ4LjEtNTM3IDAtMTQ4LjEgMTQ4LjYtMTQ4LjEgMzg5IDAgNTM3IDEzOS41IDEzOS42IDM2MC4xIDE0OC4xIDUwOSAyNmwxNDYgMTQ2YzMuMiAyLjggOC4zIDIuOCAxMSAwbDQzLTQzYzIuOC0yLjcgMi44LTcuOCAwLTExek02OTYgNjk2Yy0xMTguOCAxMTguNy0zMTEuMiAxMTguNy00MzAgMC0xMTguNy0xMTguOC0xMTguNy0zMTEuMiAwLTQzMCAxMTguOC0xMTguNyAzMTEuMi0xMTguNyA0MzAgMCAxMTguNyAxMTguOCAxMTguNyAzMTEuMiAwIDQzMHoiIC8+PC9zdmc+) */
var RefIcon$24 = /* @__PURE__ */ import_react.forwardRef(function ZoomOutOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: ZoomOutOutlined_default$1
	}));
});
RefIcon$24.displayName = "ZoomOutOutlined";
var ZoomOutOutlined_default = RefIcon$24;

//#endregion
//#region node_modules/antd/es/image/style/index.js
const genBoxStyle = (position$2) => ({
	position: position$2 || "absolute",
	inset: 0
});
const genImageMaskStyle = (token$1) => {
	const { iconCls, motionDurationSlow, paddingXXS, marginXXS, prefixCls, colorTextLightSolid } = token$1;
	return {
		position: "absolute",
		inset: 0,
		display: "flex",
		alignItems: "center",
		justifyContent: "center",
		color: colorTextLightSolid,
		background: new FastColor("#000").setA(.5).toRgbString(),
		cursor: "pointer",
		opacity: 0,
		transition: `opacity ${motionDurationSlow}`,
		[`.${prefixCls}-mask-info`]: Object.assign(Object.assign({}, textEllipsis), {
			padding: `0 ${unit(paddingXXS)}`,
			[iconCls]: {
				marginInlineEnd: marginXXS,
				svg: { verticalAlign: "baseline" }
			}
		})
	};
};
const genPreviewOperationsStyle = (token$1) => {
	const { previewCls, modalMaskBg, paddingSM, marginXL, margin, paddingLG, previewOperationColorDisabled, previewOperationHoverColor, motionDurationSlow, iconCls, colorTextLightSolid } = token$1;
	const operationBg = new FastColor(modalMaskBg).setA(.1);
	const operationBgHover = operationBg.clone().setA(.2);
	return {
		[`${previewCls}-footer`]: {
			position: "fixed",
			bottom: marginXL,
			left: {
				_skip_check_: true,
				value: "50%"
			},
			display: "flex",
			flexDirection: "column",
			alignItems: "center",
			color: token$1.previewOperationColor,
			transform: "translateX(-50%)"
		},
		[`${previewCls}-progress`]: { marginBottom: margin },
		[`${previewCls}-close`]: {
			position: "fixed",
			top: marginXL,
			right: {
				_skip_check_: true,
				value: marginXL
			},
			display: "flex",
			color: colorTextLightSolid,
			backgroundColor: operationBg.toRgbString(),
			borderRadius: "50%",
			padding: paddingSM,
			outline: 0,
			border: 0,
			cursor: "pointer",
			transition: `all ${motionDurationSlow}`,
			"&:hover": { backgroundColor: operationBgHover.toRgbString() },
			[`& > ${iconCls}`]: { fontSize: token$1.previewOperationSize }
		},
		[`${previewCls}-operations`]: {
			display: "flex",
			alignItems: "center",
			padding: `0 ${unit(paddingLG)}`,
			backgroundColor: operationBg.toRgbString(),
			borderRadius: 100,
			"&-operation": {
				marginInlineStart: paddingSM,
				padding: paddingSM,
				cursor: "pointer",
				transition: `all ${motionDurationSlow}`,
				userSelect: "none",
				[`&:not(${previewCls}-operations-operation-disabled):hover > ${iconCls}`]: { color: previewOperationHoverColor },
				"&-disabled": {
					color: previewOperationColorDisabled,
					cursor: "not-allowed"
				},
				"&:first-of-type": { marginInlineStart: 0 },
				[`& > ${iconCls}`]: { fontSize: token$1.previewOperationSize }
			}
		}
	};
};
const genPreviewSwitchStyle = (token$1) => {
	const { modalMaskBg, iconCls, previewOperationColorDisabled, previewCls, zIndexPopup, motionDurationSlow } = token$1;
	const operationBg = new FastColor(modalMaskBg).setA(.1);
	const operationBgHover = operationBg.clone().setA(.2);
	return {
		[`${previewCls}-switch-left, ${previewCls}-switch-right`]: {
			position: "fixed",
			insetBlockStart: "50%",
			zIndex: token$1.calc(zIndexPopup).add(1).equal(),
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			width: token$1.imagePreviewSwitchSize,
			height: token$1.imagePreviewSwitchSize,
			marginTop: token$1.calc(token$1.imagePreviewSwitchSize).mul(-1).div(2).equal(),
			color: token$1.previewOperationColor,
			background: operationBg.toRgbString(),
			borderRadius: "50%",
			transform: `translateY(-50%)`,
			cursor: "pointer",
			transition: `all ${motionDurationSlow}`,
			userSelect: "none",
			"&:hover": { background: operationBgHover.toRgbString() },
			"&-disabled": { "&, &:hover": {
				color: previewOperationColorDisabled,
				background: "transparent",
				cursor: "not-allowed",
				[`> ${iconCls}`]: { cursor: "not-allowed" }
			} },
			[`> ${iconCls}`]: { fontSize: token$1.previewOperationSize }
		},
		[`${previewCls}-switch-left`]: { insetInlineStart: token$1.marginSM },
		[`${previewCls}-switch-right`]: { insetInlineEnd: token$1.marginSM }
	};
};
const genImagePreviewStyle = (token$1) => {
	const { motionEaseOut, previewCls, motionDurationSlow, componentCls } = token$1;
	return [
		{ [`${componentCls}-preview-root`]: {
			[previewCls]: {
				height: "100%",
				textAlign: "center",
				pointerEvents: "none"
			},
			[`${previewCls}-body`]: Object.assign(Object.assign({}, genBoxStyle()), { overflow: "hidden" }),
			[`${previewCls}-img`]: {
				maxWidth: "100%",
				maxHeight: "70%",
				verticalAlign: "middle",
				transform: "scale3d(1, 1, 1)",
				cursor: "grab",
				transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
				userSelect: "none",
				"&-wrapper": Object.assign(Object.assign({}, genBoxStyle()), {
					transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
					display: "flex",
					justifyContent: "center",
					alignItems: "center",
					"& > *": { pointerEvents: "auto" },
					"&::before": {
						display: "inline-block",
						width: 1,
						height: "50%",
						marginInlineEnd: -1,
						content: "\"\""
					}
				})
			},
			[`${previewCls}-moving`]: { [`${previewCls}-preview-img`]: {
				cursor: "grabbing",
				"&-wrapper": { transitionDuration: "0s" }
			} }
		} },
		{ [`${componentCls}-preview-root`]: { [`${previewCls}-wrap`]: { zIndex: token$1.zIndexPopup } } },
		{
			[`${componentCls}-preview-operations-wrapper`]: {
				position: "fixed",
				zIndex: token$1.calc(token$1.zIndexPopup).add(1).equal()
			},
			"&": [genPreviewOperationsStyle(token$1), genPreviewSwitchStyle(token$1)]
		}
	];
};
var genImageStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: {
		position: "relative",
		display: "inline-block",
		[`${componentCls}-img`]: {
			width: "100%",
			height: "auto",
			verticalAlign: "middle"
		},
		[`${componentCls}-img-placeholder`]: {
			backgroundColor: token$1.colorBgContainerDisabled,
			backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center",
			backgroundSize: "30%"
		},
		[`${componentCls}-mask`]: Object.assign({}, genImageMaskStyle(token$1)),
		[`${componentCls}-mask:hover`]: { opacity: 1 },
		[`${componentCls}-placeholder`]: Object.assign({}, genBoxStyle())
	} };
};
var genPreviewMotion = (token$1) => {
	const { previewCls } = token$1;
	return {
		[`${previewCls}-root`]: initZoomMotion(token$1, "zoom"),
		"&": initFadeMotion(token$1, true)
	};
};
const prepareComponentToken$21 = (token$1) => ({
	zIndexPopup: token$1.zIndexPopupBase + 80,
	previewOperationColor: new FastColor(token$1.colorTextLightSolid).setA(.65).toRgbString(),
	previewOperationHoverColor: new FastColor(token$1.colorTextLightSolid).setA(.85).toRgbString(),
	previewOperationColorDisabled: new FastColor(token$1.colorTextLightSolid).setA(.25).toRgbString(),
	previewOperationSize: token$1.fontSizeIcon * 1.5
});
var style_default$25 = genStyleHooks("Image", (token$1) => {
	const previewCls = `${token$1.componentCls}-preview`;
	const imageToken = merge(token$1, {
		previewCls,
		modalMaskBg: new FastColor("#000").setA(.45).toRgbString(),
		imagePreviewSwitchSize: token$1.controlHeightLG
	});
	return [
		genImageStyle(imageToken),
		genImagePreviewStyle(imageToken),
		genModalMaskStyle(merge(imageToken, { componentCls: previewCls })),
		genPreviewMotion(imageToken)
	];
}, prepareComponentToken$21);

//#endregion
//#region node_modules/antd/es/image/PreviewGroup.js
var import_classnames$91 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$41 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const icons = {
	rotateLeft: /* @__PURE__ */ import_react.createElement(RotateLeftOutlined_default, null),
	rotateRight: /* @__PURE__ */ import_react.createElement(RotateRightOutlined_default, null),
	zoomIn: /* @__PURE__ */ import_react.createElement(ZoomInOutlined_default, null),
	zoomOut: /* @__PURE__ */ import_react.createElement(ZoomOutOutlined_default, null),
	close: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null),
	left: /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null),
	right: /* @__PURE__ */ import_react.createElement(RightOutlined_default, null),
	flipX: /* @__PURE__ */ import_react.createElement(SwapOutlined_default, null),
	flipY: /* @__PURE__ */ import_react.createElement(SwapOutlined_default, { rotate: 90 })
};
var InternalPreviewGroup = (_a) => {
	var { previewPrefixCls: customizePrefixCls, preview } = _a, otherProps = __rest$41(_a, ["previewPrefixCls", "preview"]);
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("image", customizePrefixCls);
	const previewPrefixCls = `${prefixCls}-preview`;
	const rootPrefixCls = getPrefixCls();
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$25(prefixCls, rootCls);
	const [zIndex] = useZIndex("ImagePreview", typeof preview === "object" ? preview.zIndex : void 0);
	const memoizedIcons = import_react.useMemo(() => Object.assign(Object.assign({}, icons), {
		left: direction === "rtl" ? /* @__PURE__ */ import_react.createElement(RightOutlined_default, null) : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null),
		right: direction === "rtl" ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null)
	}), [direction]);
	const mergedPreview = import_react.useMemo(() => {
		var _a$1;
		if (preview === false) return preview;
		const _preview = typeof preview === "object" ? preview : {};
		const mergedRootClassName = (0, import_classnames$91.default)(hashId, cssVarCls, rootCls, (_a$1 = _preview.rootClassName) !== null && _a$1 !== void 0 ? _a$1 : "");
		return Object.assign(Object.assign({}, _preview), {
			transitionName: getTransitionName(rootPrefixCls, "zoom", _preview.transitionName),
			maskTransitionName: getTransitionName(rootPrefixCls, "fade", _preview.maskTransitionName),
			rootClassName: mergedRootClassName,
			zIndex
		});
	}, [preview]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$15.PreviewGroup, Object.assign({
		preview: mergedPreview,
		previewPrefixCls,
		icons: memoizedIcons
	}, otherProps)));
};
var PreviewGroup_default = InternalPreviewGroup;

//#endregion
//#region node_modules/antd/es/image/index.js
var import_classnames$90 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$40 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Image$1 = (props) => {
	const { prefixCls: customizePrefixCls, preview, className, rootClassName, style: style$1 } = props, otherProps = __rest$40(props, [
		"prefixCls",
		"preview",
		"className",
		"rootClassName",
		"style"
	]);
	devUseWarning("Image").deprecated(!(preview && typeof preview === "object" && "destroyOnClose" in preview), "destroyOnClose", "destroyOnHidden");
	const { getPrefixCls, getPopupContainer: getContextPopupContainer, className: contextClassName, style: contextStyle, preview: contextPreview } = useComponentConfig("image");
	const [imageLocale] = useLocale_default("Image");
	const prefixCls = getPrefixCls("image", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$25(prefixCls, rootCls);
	const mergedRootClassName = (0, import_classnames$90.default)(rootClassName, hashId, cssVarCls, rootCls);
	const mergedClassName = (0, import_classnames$90.default)(className, hashId, contextClassName);
	const [zIndex] = useZIndex("ImagePreview", typeof preview === "object" ? preview.zIndex : void 0);
	const mergedPreview = import_react.useMemo(() => {
		if (preview === false) return preview;
		const _preview = typeof preview === "object" ? preview : {};
		const { getContainer: getContainer$1, closeIcon, rootClassName: rootClassName$1, destroyOnClose, destroyOnHidden } = _preview, restPreviewProps = __rest$40(_preview, [
			"getContainer",
			"closeIcon",
			"rootClassName",
			"destroyOnClose",
			"destroyOnHidden"
		]);
		return Object.assign(Object.assign({
			mask: /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-mask-info` }, /* @__PURE__ */ import_react.createElement(EyeOutlined_default, null), imageLocale === null || imageLocale === void 0 ? void 0 : imageLocale.preview),
			icons
		}, restPreviewProps), {
			destroyOnClose: destroyOnHidden !== null && destroyOnHidden !== void 0 ? destroyOnHidden : destroyOnClose,
			rootClassName: (0, import_classnames$90.default)(mergedRootClassName, rootClassName$1),
			getContainer: getContainer$1 !== null && getContainer$1 !== void 0 ? getContainer$1 : getContextPopupContainer,
			transitionName: getTransitionName(rootPrefixCls, "zoom", _preview.transitionName),
			maskTransitionName: getTransitionName(rootPrefixCls, "fade", _preview.maskTransitionName),
			zIndex,
			closeIcon: closeIcon !== null && closeIcon !== void 0 ? closeIcon : contextPreview === null || contextPreview === void 0 ? void 0 : contextPreview.closeIcon
		});
	}, [
		preview,
		imageLocale,
		contextPreview === null || contextPreview === void 0 ? void 0 : contextPreview.closeIcon
	]);
	const mergedStyle = Object.assign(Object.assign({}, contextStyle), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$15, Object.assign({
		prefixCls,
		preview: mergedPreview,
		rootClassName: mergedRootClassName,
		className: mergedClassName,
		style: mergedStyle
	}, otherProps)));
};
Image$1.PreviewGroup = PreviewGroup_default;
Image$1.displayName = "Image";
var image_default = Image$1;

//#endregion
//#region node_modules/antd/es/input/Group.js
var import_classnames$89 = /* @__PURE__ */ __toESM(require_classnames());
/** @deprecated Please use `Space.Compact` */
var Group = (props) => {
	const { getPrefixCls, direction } = (0, import_react.useContext)(ConfigContext);
	const { prefixCls: customizePrefixCls, className } = props;
	const prefixCls = getPrefixCls("input-group", customizePrefixCls);
	const inputPrefixCls = getPrefixCls("input");
	const [wrapCSSVar, hashId, cssVarCls] = style_default$24(inputPrefixCls);
	const cls$12 = (0, import_classnames$89.default)(prefixCls, cssVarCls, {
		[`${prefixCls}-lg`]: props.size === "large",
		[`${prefixCls}-sm`]: props.size === "small",
		[`${prefixCls}-compact`]: props.compact,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, hashId, className);
	const formItemContext = (0, import_react.useContext)(FormItemInputContext);
	const groupFormItemContext = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, formItemContext), { isFormItemInput: false }), [formItemContext]);
	devUseWarning("Input.Group").deprecated(false, "Input.Group", "Space.Compact");
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("span", {
		className: cls$12,
		style: props.style,
		onMouseEnter: props.onMouseEnter,
		onMouseLeave: props.onMouseLeave,
		onFocus: props.onFocus,
		onBlur: props.onBlur
	}, /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: groupFormItemContext }, props.children)));
};
var Group_default = Group;

//#endregion
//#region node_modules/antd/es/input/style/otp.js
var genOTPStyle = (token$1) => {
	const { componentCls, paddingXS } = token$1;
	return { [componentCls]: {
		display: "inline-flex",
		alignItems: "center",
		flexWrap: "nowrap",
		columnGap: paddingXS,
		[`${componentCls}-input-wrapper`]: {
			position: "relative",
			[`${componentCls}-mask-icon`]: {
				position: "absolute",
				zIndex: "1",
				top: "50%",
				right: "50%",
				transform: "translate(50%, -50%)",
				pointerEvents: "none"
			},
			[`${componentCls}-mask-input`]: {
				color: "transparent",
				caretColor: token$1.colorText
			},
			[`${componentCls}-mask-input[type=number]::-webkit-inner-spin-button`]: {
				"-webkit-appearance": "none",
				margin: 0
			},
			[`${componentCls}-mask-input[type=number]`]: { "-moz-appearance": "textfield" }
		},
		"&-rtl": { direction: "rtl" },
		[`${componentCls}-input`]: {
			textAlign: "center",
			paddingInline: token$1.paddingXXS
		},
		[`&${componentCls}-sm ${componentCls}-input`]: { paddingInline: token$1.calc(token$1.paddingXXS).div(2).equal() },
		[`&${componentCls}-lg ${componentCls}-input`]: { paddingInline: token$1.paddingXS }
	} };
};
var otp_default = genStyleHooks(["Input", "OTP"], (token$1) => {
	const inputToken = merge(token$1, initInputToken(token$1));
	return genOTPStyle(inputToken);
}, initComponentToken$1);

//#endregion
//#region node_modules/antd/es/input/OTP/OTPInput.js
var import_classnames$88 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$39 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var OTPInput = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { className, value, onChange, onActiveChange, index: index$2, mask } = props, restProps = __rest$39(props, [
		"className",
		"value",
		"onChange",
		"onActiveChange",
		"index",
		"mask"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("otp");
	const maskValue = typeof mask === "string" ? mask : value;
	const inputRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => inputRef.current);
	const onInternalChange = (e$2) => {
		onChange(index$2, e$2.target.value);
	};
	const syncSelection = () => {
		raf_default(() => {
			var _a;
			const inputEle = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input;
			if (document.activeElement === inputEle && inputEle) inputEle.select();
		});
	};
	const onInternalKeyDown = (event) => {
		const { key, ctrlKey, metaKey } = event;
		if (key === "ArrowLeft") onActiveChange(index$2 - 1);
		else if (key === "ArrowRight") onActiveChange(index$2 + 1);
		else if (key === "z" && (ctrlKey || metaKey)) event.preventDefault();
		else if (key === "Backspace" && !value) onActiveChange(index$2 - 1);
		syncSelection();
	};
	return /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-input-wrapper`,
		role: "presentation"
	}, mask && value !== "" && value !== void 0 && /* @__PURE__ */ import_react.createElement("span", {
		className: `${prefixCls}-mask-icon`,
		"aria-hidden": "true"
	}, maskValue), /* @__PURE__ */ import_react.createElement(Input_default, Object.assign({
		"aria-label": `OTP Input ${index$2 + 1}`,
		type: mask === true ? "password" : "text"
	}, restProps, {
		ref: inputRef,
		value,
		onInput: onInternalChange,
		onFocus: syncSelection,
		onKeyDown: onInternalKeyDown,
		onMouseDown: syncSelection,
		onMouseUp: syncSelection,
		className: (0, import_classnames$88.default)(className, { [`${prefixCls}-mask-input`]: mask })
	})));
});
var OTPInput_default = OTPInput;

//#endregion
//#region node_modules/antd/es/input/OTP/index.js
var import_classnames$87 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$38 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function strToArr(str) {
	return (str || "").split("");
}
var Separator = (props) => {
	const { index: index$2, prefixCls, separator } = props;
	const separatorNode = typeof separator === "function" ? separator(index$2) : separator;
	if (!separatorNode) return null;
	return /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-separator` }, separatorNode);
};
var OTP = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, length: length$1 = 6, size: customSize, defaultValue, value, onChange, formatter, separator, variant, disabled, status: customStatus, autoFocus, mask, type: type$2, onInput, inputMode } = props, restProps = __rest$38(props, [
		"prefixCls",
		"length",
		"size",
		"defaultValue",
		"value",
		"onChange",
		"formatter",
		"separator",
		"variant",
		"disabled",
		"status",
		"autoFocus",
		"mask",
		"type",
		"onInput",
		"inputMode"
	]);
	devUseWarning("Input.OTP")(!(typeof mask === "string" && mask.length > 1), "usage", "`mask` prop should be a single character.");
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("otp", customizePrefixCls);
	const domAttrs = pickAttrs(restProps, {
		aria: true,
		data: true,
		attr: true
	});
	const [wrapCSSVar, hashId, cssVarCls] = otp_default(prefixCls);
	const mergedSize = useSize_default((ctx) => customSize !== null && customSize !== void 0 ? customSize : ctx);
	const formContext = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(formContext.status, customStatus);
	const proxyFormContext = import_react.useMemo(() => Object.assign(Object.assign({}, formContext), {
		status: mergedStatus,
		hasFeedback: false,
		feedbackIcon: null
	}), [formContext, mergedStatus]);
	const containerRef = import_react.useRef(null);
	const refs = import_react.useRef({});
	import_react.useImperativeHandle(ref, () => ({
		focus: () => {
			var _a;
			(_a = refs.current[0]) === null || _a === void 0 || _a.focus();
		},
		blur: () => {
			var _a;
			for (let i = 0; i < length$1; i += 1) (_a = refs.current[i]) === null || _a === void 0 || _a.blur();
		},
		nativeElement: containerRef.current
	}));
	const internalFormatter = (txt) => formatter ? formatter(txt) : txt;
	const [valueCells, setValueCells] = import_react.useState(() => strToArr(internalFormatter(defaultValue || "")));
	import_react.useEffect(() => {
		if (value !== void 0) setValueCells(strToArr(value));
	}, [value]);
	const triggerValueCellsChange = useEvent((nextValueCells) => {
		setValueCells(nextValueCells);
		if (onInput) onInput(nextValueCells);
		if (onChange && nextValueCells.length === length$1 && nextValueCells.every((c) => c) && nextValueCells.some((c, index$2) => valueCells[index$2] !== c)) onChange(nextValueCells.join(""));
	});
	const patchValue = useEvent((index$2, txt) => {
		let nextCells = _toConsumableArray(valueCells);
		for (let i = 0; i < index$2; i += 1) if (!nextCells[i]) nextCells[i] = "";
		if (txt.length <= 1) nextCells[index$2] = txt;
		else nextCells = nextCells.slice(0, index$2).concat(strToArr(txt));
		nextCells = nextCells.slice(0, length$1);
		for (let i = nextCells.length - 1; i >= 0; i -= 1) {
			if (nextCells[i]) break;
			nextCells.pop();
		}
		const formattedValue = internalFormatter(nextCells.map((c) => c || " ").join(""));
		nextCells = strToArr(formattedValue).map((c, i) => {
			if (c === " " && !nextCells[i]) return nextCells[i];
			return c;
		});
		return nextCells;
	});
	const onInputChange = (index$2, txt) => {
		var _a;
		const nextCells = patchValue(index$2, txt);
		const nextIndex = Math.min(index$2 + txt.length, length$1 - 1);
		if (nextIndex !== index$2 && nextCells[index$2] !== void 0) (_a = refs.current[nextIndex]) === null || _a === void 0 || _a.focus();
		triggerValueCellsChange(nextCells);
	};
	const onInputActiveChange = (nextIndex) => {
		var _a;
		(_a = refs.current[nextIndex]) === null || _a === void 0 || _a.focus();
	};
	const inputSharedProps = {
		variant,
		disabled,
		status: mergedStatus,
		mask,
		type: type$2,
		inputMode
	};
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({}, domAttrs, {
		ref: containerRef,
		className: (0, import_classnames$87.default)(prefixCls, {
			[`${prefixCls}-sm`]: mergedSize === "small",
			[`${prefixCls}-lg`]: mergedSize === "large",
			[`${prefixCls}-rtl`]: direction === "rtl"
		}, cssVarCls, hashId),
		role: "group"
	}), /* @__PURE__ */ import_react.createElement(FormItemInputContext.Provider, { value: proxyFormContext }, Array.from({ length: length$1 }).map((_, index$2) => {
		const key = `otp-${index$2}`;
		const singleValue = valueCells[index$2] || "";
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, { key }, /* @__PURE__ */ import_react.createElement(OTPInput_default, Object.assign({
			ref: (inputEle) => {
				refs.current[index$2] = inputEle;
			},
			index: index$2,
			size: mergedSize,
			htmlSize: 1,
			className: `${prefixCls}-input`,
			onChange: onInputChange,
			value: singleValue,
			onActiveChange: onInputActiveChange,
			autoFocus: index$2 === 0 && autoFocus
		}, inputSharedProps)), index$2 < length$1 - 1 && /* @__PURE__ */ import_react.createElement(Separator, {
			separator,
			index: index$2,
			prefixCls
		}));
	}))));
});
var OTP_default = OTP;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/EyeInvisibleOutlined.js
var EyeInvisibleOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" }
		}]
	},
	"name": "eye-invisible",
	"theme": "outlined"
};
var EyeInvisibleOutlined_default$1 = EyeInvisibleOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/EyeInvisibleOutlined.js
/**![eye-invisible](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk0Mi4yIDQ4Ni4yUTg4OS40NyAzNzUuMTEgODE2LjcgMzA1bC01MC44OCA1MC44OEM4MDcuMzEgMzk1LjUzIDg0My40NSA0NDcuNCA4NzQuNyA1MTIgNzkxLjUgNjg0LjIgNjczLjQgNzY2IDUxMiA3NjZxLTcyLjY3IDAtMTMzLjg3LTIyLjM4TDMyMyA3OTguNzVRNDA4IDgzOCA1MTIgODM4cTI4OC4zIDAgNDMwLjItMzAwLjNhNjAuMjkgNjAuMjkgMCAwMDAtNTEuNXptLTYzLjU3LTMyMC42NEw4MzYgMTIyLjg4YTggOCAwIDAwLTExLjMyIDBMNzE1LjMxIDIzMi4yUTYyNC44NiAxODYgNTEyIDE4NnEtMjg4LjMgMC00MzAuMiAzMDAuM2E2MC4zIDYwLjMgMCAwMDAgNTEuNXE1Ni42OSAxMTkuNCAxMzYuNSAxOTEuNDFMMTEyLjQ4IDgzNWE4IDggMCAwMDAgMTEuMzFMMTU1LjE3IDg4OWE4IDggMCAwMDExLjMxIDBsNzEyLjE1LTcxMi4xMmE4IDggMCAwMDAtMTEuMzJ6TTE0OS4zIDUxMkMyMzIuNiAzMzkuOCAzNTAuNyAyNTggNTEyIDI1OGM1NC41NCAwIDEwNC4xMyA5LjM2IDE0OS4xMiAyOC4zOWwtNzAuMyA3MC4zYTE3NiAxNzYgMCAwMC0yMzguMTMgMjM4LjEzbC04My40MiA4My40MkMyMjMuMSA2MzcuNDkgMTgzLjMgNTgyLjI4IDE0OS4zIDUxMnptMjQ2LjcgMGExMTIuMTEgMTEyLjExIDAgMDExNDYuMi0xMDYuNjlMNDAxLjMxIDU0Ni4yQTExMiAxMTIgMCAwMTM5NiA1MTJ6IiAvPjxwYXRoIGQ9Ik01MDggNjI0Yy0zLjQ2IDAtNi44Ny0uMTYtMTAuMjUtLjQ3bC01Mi44MiA1Mi44MmExNzYuMDkgMTc2LjA5IDAgMDAyMjcuNDItMjI3LjQybC01Mi44MiA1Mi44MmMuMzEgMy4zOC40NyA2Ljc5LjQ3IDEwLjI1YTExMS45NCAxMTEuOTQgMCAwMS0xMTIgMTEyeiIgLz48L3N2Zz4=) */
var RefIcon$23 = /* @__PURE__ */ import_react.forwardRef(function EyeInvisibleOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: EyeInvisibleOutlined_default$1
	}));
});
RefIcon$23.displayName = "EyeInvisibleOutlined";
var EyeInvisibleOutlined_default = RefIcon$23;

//#endregion
//#region node_modules/antd/es/input/Password.js
var import_classnames$86 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$37 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var defaultIconRender = (visible) => visible ? /* @__PURE__ */ import_react.createElement(EyeOutlined_default, null) : /* @__PURE__ */ import_react.createElement(EyeInvisibleOutlined_default, null);
var actionMap = {
	click: "onClick",
	hover: "onMouseOver"
};
var Password = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { disabled: customDisabled, action = "click", visibilityToggle = true, iconRender = defaultIconRender, suffix } = props;
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
	const [visible, setVisible] = (0, import_react.useState)(() => visibilityControlled ? visibilityToggle.visible : false);
	const inputRef = (0, import_react.useRef)(null);
	import_react.useEffect(() => {
		if (visibilityControlled) setVisible(visibilityToggle.visible);
	}, [visibilityControlled, visibilityToggle]);
	const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
	const onVisibleChange = () => {
		var _a;
		if (mergedDisabled) return;
		if (visible) removePasswordTimeout();
		const nextVisible = !visible;
		setVisible(nextVisible);
		if (typeof visibilityToggle === "object") (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 || _a.call(visibilityToggle, nextVisible);
	};
	const getIcon$1 = (prefixCls$1) => {
		const iconTrigger = actionMap[action] || "";
		const icon = iconRender(visible);
		const iconProps = {
			[iconTrigger]: onVisibleChange,
			className: `${prefixCls$1}-icon`,
			key: "passwordIcon",
			onMouseDown: (e$2) => {
				e$2.preventDefault();
			},
			onMouseUp: (e$2) => {
				e$2.preventDefault();
			}
		};
		return /* @__PURE__ */ import_react.cloneElement(/* @__PURE__ */ import_react.isValidElement(icon) ? icon : /* @__PURE__ */ import_react.createElement("span", null, icon), iconProps);
	};
	const { className, prefixCls: customizePrefixCls, inputPrefixCls: customizeInputPrefixCls, size } = props, restProps = __rest$37(props, [
		"className",
		"prefixCls",
		"inputPrefixCls",
		"size"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
	const prefixCls = getPrefixCls("input-password", customizePrefixCls);
	const suffixIcon = visibilityToggle && getIcon$1(prefixCls);
	const inputClassName = (0, import_classnames$86.default)(prefixCls, className, { [`${prefixCls}-${size}`]: !!size });
	const omittedProps = Object.assign(Object.assign({}, omit(restProps, [
		"suffix",
		"iconRender",
		"visibilityToggle"
	])), {
		type: visible ? "text" : "password",
		className: inputClassName,
		prefixCls: inputPrefixCls,
		suffix: /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, suffixIcon, suffix)
	});
	if (size) omittedProps.size = size;
	return /* @__PURE__ */ import_react.createElement(Input_default, Object.assign({ ref: composeRef(ref, inputRef) }, omittedProps));
});
Password.displayName = "Input.Password";
var Password_default = Password;

//#endregion
//#region node_modules/antd/es/input/Search.js
var import_classnames$85 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$36 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Search$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, inputPrefixCls: customizeInputPrefixCls, className, size: customizeSize, suffix, enterButton = false, addonAfter, loading, disabled, onSearch: customOnSearch, onChange: customOnChange, onCompositionStart, onCompositionEnd, variant, onPressEnter: customOnPressEnter } = props, restProps = __rest$36(props, [
		"prefixCls",
		"inputPrefixCls",
		"className",
		"size",
		"suffix",
		"enterButton",
		"addonAfter",
		"loading",
		"disabled",
		"onSearch",
		"onChange",
		"onCompositionStart",
		"onCompositionEnd",
		"variant",
		"onPressEnter"
	]);
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const composedRef = import_react.useRef(false);
	const prefixCls = getPrefixCls("input-search", customizePrefixCls);
	const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
	const { compactSize } = useCompactItemContext(prefixCls, direction);
	const size = useSize_default((ctx) => {
		var _a;
		return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
	});
	const inputRef = import_react.useRef(null);
	const onChange = (e$2) => {
		if ((e$2 === null || e$2 === void 0 ? void 0 : e$2.target) && e$2.type === "click" && customOnSearch) customOnSearch(e$2.target.value, e$2, { source: "clear" });
		customOnChange === null || customOnChange === void 0 || customOnChange(e$2);
	};
	const onMouseDown = (e$2) => {
		var _a;
		if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) e$2.preventDefault();
	};
	const onSearch = (e$2) => {
		var _a, _b;
		if (customOnSearch) customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e$2, { source: "input" });
	};
	const onPressEnter = (e$2) => {
		if (composedRef.current || loading) return;
		customOnPressEnter === null || customOnPressEnter === void 0 || customOnPressEnter(e$2);
		onSearch(e$2);
	};
	const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ import_react.createElement(SearchOutlined_default, null) : null;
	const btnClassName = `${prefixCls}-button`;
	let button;
	const enterButtonAsElement = enterButton || {};
	const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
	if (isAntdButton || enterButtonAsElement.type === "button") button = cloneElement(enterButtonAsElement, Object.assign({
		onMouseDown,
		onClick: (e$2) => {
			var _a, _b;
			(_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 || _b.call(_a, e$2);
			onSearch(e$2);
		},
		key: "enterButton"
	}, isAntdButton ? {
		className: btnClassName,
		size
	} : {}));
	else button = /* @__PURE__ */ import_react.createElement(button_default, {
		className: btnClassName,
		color: enterButton ? "primary" : "default",
		size,
		disabled,
		key: "enterButton",
		onMouseDown,
		onClick: onSearch,
		loading,
		icon: searchIcon,
		variant: variant === "borderless" || variant === "filled" || variant === "underlined" ? "text" : enterButton ? "solid" : void 0
	}, enterButton);
	if (addonAfter) button = [button, cloneElement(addonAfter, { key: "addonAfter" })];
	const cls$12 = (0, import_classnames$85.default)(prefixCls, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${size}`]: !!size,
		[`${prefixCls}-with-button`]: !!enterButton
	}, className);
	const handleOnCompositionStart = (e$2) => {
		composedRef.current = true;
		onCompositionStart === null || onCompositionStart === void 0 || onCompositionStart(e$2);
	};
	const handleOnCompositionEnd = (e$2) => {
		composedRef.current = false;
		onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e$2);
	};
	const inputProps = Object.assign(Object.assign({}, restProps), {
		className: cls$12,
		prefixCls: inputPrefixCls,
		type: "search",
		size,
		variant,
		onPressEnter,
		onCompositionStart: handleOnCompositionStart,
		onCompositionEnd: handleOnCompositionEnd,
		addonAfter: button,
		suffix,
		onChange,
		disabled
	});
	return /* @__PURE__ */ import_react.createElement(Input_default, Object.assign({ ref: composeRef(inputRef, ref) }, inputProps));
});
Search$1.displayName = "Search";
var Search_default = Search$1;

//#endregion
//#region node_modules/rc-textarea/es/calculateNodeHeight.js
/**
* calculateNodeHeight(uiTextNode, useCache = false)
*/
var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
var SIZING_STYLE = [
	"letter-spacing",
	"line-height",
	"padding-top",
	"padding-bottom",
	"font-family",
	"font-weight",
	"font-size",
	"font-variant",
	"text-rendering",
	"text-transform",
	"width",
	"text-indent",
	"padding-left",
	"padding-right",
	"border-width",
	"box-sizing",
	"word-break",
	"white-space"
];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node$1) {
	var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	var nodeRef = node$1.getAttribute("id") || node$1.getAttribute("data-reactid") || node$1.getAttribute("name");
	if (useCache && computedStyleCache[nodeRef]) return computedStyleCache[nodeRef];
	var style$1 = window.getComputedStyle(node$1);
	var boxSizing = style$1.getPropertyValue("box-sizing") || style$1.getPropertyValue("-moz-box-sizing") || style$1.getPropertyValue("-webkit-box-sizing");
	var paddingSize = parseFloat(style$1.getPropertyValue("padding-bottom")) + parseFloat(style$1.getPropertyValue("padding-top"));
	var borderSize = parseFloat(style$1.getPropertyValue("border-bottom-width")) + parseFloat(style$1.getPropertyValue("border-top-width"));
	var nodeInfo = {
		sizingStyle: SIZING_STYLE.map(function(name) {
			return "".concat(name, ":").concat(style$1.getPropertyValue(name));
		}).join(";"),
		paddingSize,
		borderSize,
		boxSizing
	};
	if (useCache && nodeRef) computedStyleCache[nodeRef] = nodeInfo;
	return nodeInfo;
}
function calculateAutoSizeStyle(uiTextNode) {
	var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
	var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
	if (!hiddenTextarea) {
		hiddenTextarea = document.createElement("textarea");
		hiddenTextarea.setAttribute("tab-index", "-1");
		hiddenTextarea.setAttribute("aria-hidden", "true");
		hiddenTextarea.setAttribute("name", "hiddenTextarea");
		document.body.appendChild(hiddenTextarea);
	}
	if (uiTextNode.getAttribute("wrap")) hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
	else hiddenTextarea.removeAttribute("wrap");
	var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
	hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
	hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
	var minHeight = void 0;
	var maxHeight = void 0;
	var overflowY;
	var height = hiddenTextarea.scrollHeight;
	if (boxSizing === "border-box") height += borderSize;
	else if (boxSizing === "content-box") height -= paddingSize;
	if (minRows !== null || maxRows !== null) {
		hiddenTextarea.value = " ";
		var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
		if (minRows !== null) {
			minHeight = singleRowHeight * minRows;
			if (boxSizing === "border-box") minHeight = minHeight + paddingSize + borderSize;
			height = Math.max(minHeight, height);
		}
		if (maxRows !== null) {
			maxHeight = singleRowHeight * maxRows;
			if (boxSizing === "border-box") maxHeight = maxHeight + paddingSize + borderSize;
			overflowY = height > maxHeight ? "" : "hidden";
			height = Math.min(maxHeight, height);
		}
	}
	var style$1 = {
		height,
		overflowY,
		resize: "none"
	};
	if (minHeight) style$1.minHeight = minHeight;
	if (maxHeight) style$1.maxHeight = maxHeight;
	return style$1;
}

//#endregion
//#region node_modules/rc-textarea/es/ResizableTextArea.js
var import_classnames$84 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$23 = [
	"prefixCls",
	"defaultValue",
	"value",
	"autoSize",
	"onResize",
	"className",
	"style",
	"disabled",
	"onChange",
	"onInternalAutoSize"
];
var RESIZE_START = 0;
var RESIZE_MEASURING = 1;
var RESIZE_STABLE = 2;
var ResizableTextArea = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var _ref = props, prefixCls = _ref.prefixCls, defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize$1 = _ref.onResize, className = _ref.className, style$1 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange;
	_ref.onInternalAutoSize;
	var restProps = _objectWithoutProperties(_ref, _excluded$23);
	var _useMergedState = useMergedState(defaultValue, {
		value,
		postState: function postState(val) {
			return val !== null && val !== void 0 ? val : "";
		}
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
	var onInternalChange = function onInternalChange$1(event) {
		setMergedValue(event.target.value);
		onChange === null || onChange === void 0 || onChange(event);
	};
	var textareaRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		return { textArea: textareaRef.current };
	});
	var _React$useMemo = import_react.useMemo(function() {
		if (autoSize && _typeof(autoSize) === "object") return [autoSize.minRows, autoSize.maxRows];
		return [];
	}, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
	var needAutoSize = !!autoSize;
	var _React$useState = import_react.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
	var _React$useState3 = import_react.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
	var startResize = function startResize$1() {
		setResizeState(RESIZE_START);
	};
	useLayoutEffect_default(function() {
		if (needAutoSize) startResize();
	}, [
		value,
		minRows,
		maxRows,
		needAutoSize
	]);
	useLayoutEffect_default(function() {
		if (resizeState === RESIZE_START) setResizeState(RESIZE_MEASURING);
		else if (resizeState === RESIZE_MEASURING) {
			var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
			setResizeState(RESIZE_STABLE);
			setAutoSizeStyle(textareaStyles);
		}
	}, [resizeState]);
	var resizeRafRef = import_react.useRef();
	var cleanRaf = function cleanRaf$1() {
		raf_default.cancel(resizeRafRef.current);
	};
	var onInternalResize = function onInternalResize$1(size) {
		if (resizeState === RESIZE_STABLE) {
			onResize$1 === null || onResize$1 === void 0 || onResize$1(size);
			if (autoSize) {
				cleanRaf();
				resizeRafRef.current = raf_default(function() {
					startResize();
				});
			}
		}
	};
	import_react.useEffect(function() {
		return cleanRaf;
	}, []);
	var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
	var mergedStyle = _objectSpread2(_objectSpread2({}, style$1), mergedAutoSizeStyle);
	if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
		mergedStyle.overflowY = "hidden";
		mergedStyle.overflowX = "hidden";
	}
	return /* @__PURE__ */ import_react.createElement(es_default, {
		onResize: onInternalResize,
		disabled: !(autoSize || onResize$1)
	}, /* @__PURE__ */ import_react.createElement("textarea", _extends({}, restProps, {
		ref: textareaRef,
		style: mergedStyle,
		className: (0, import_classnames$84.default)(prefixCls, className, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled)),
		disabled,
		value: mergedValue,
		onChange: onInternalChange
	})));
});
var ResizableTextArea_default = ResizableTextArea;

//#endregion
//#region node_modules/rc-textarea/es/TextArea.js
var import_classnames$83 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$22 = [
	"defaultValue",
	"value",
	"onFocus",
	"onBlur",
	"onChange",
	"allowClear",
	"maxLength",
	"onCompositionStart",
	"onCompositionEnd",
	"suffix",
	"prefixCls",
	"showCount",
	"count",
	"className",
	"style",
	"disabled",
	"hidden",
	"classNames",
	"styles",
	"onResize",
	"onClear",
	"onPressEnter",
	"readOnly",
	"autoSize",
	"onKeyDown"
];
var TextArea$1 = /* @__PURE__ */ import_react.forwardRef(function(_ref, ref) {
	var _countConfig$max;
	var defaultValue = _ref.defaultValue, customValue = _ref.value, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, showCount = _ref.showCount, count = _ref.count, className = _ref.className, style$1 = _ref.style, disabled = _ref.disabled, hidden = _ref.hidden, classNames$252 = _ref.classNames, styles = _ref.styles, onResize$1 = _ref.onResize, onClear = _ref.onClear, onPressEnter = _ref.onPressEnter, readOnly = _ref.readOnly, autoSize = _ref.autoSize, onKeyDown$1 = _ref.onKeyDown, rest = _objectWithoutProperties(_ref, _excluded$22);
	var _useMergedState = useMergedState(defaultValue, {
		value: customValue,
		defaultValue
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
	var formatValue$1 = value === void 0 || value === null ? "" : String(value);
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
	var compositionRef = import_react.useRef(false);
	var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), textareaResized = _React$useState4[0], setTextareaResized = _React$useState4[1];
	var holderRef = (0, import_react.useRef)(null);
	var resizableTextAreaRef = (0, import_react.useRef)(null);
	var getTextArea = function getTextArea$1() {
		var _resizableTextAreaRef;
		return (_resizableTextAreaRef = resizableTextAreaRef.current) === null || _resizableTextAreaRef === void 0 ? void 0 : _resizableTextAreaRef.textArea;
	};
	var focus = function focus$1() {
		getTextArea().focus();
	};
	(0, import_react.useImperativeHandle)(ref, function() {
		var _holderRef$current;
		return {
			resizableTextArea: resizableTextAreaRef.current,
			focus,
			blur: function blur() {
				getTextArea().blur();
			},
			nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || getTextArea()
		};
	});
	(0, import_react.useEffect)(function() {
		setFocused(function(prev$1) {
			return !disabled && prev$1;
		});
	}, [disabled]);
	var _React$useState5 = import_react.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), selection = _React$useState6[0], setSelection = _React$useState6[1];
	import_react.useEffect(function() {
		if (selection) {
			var _getTextArea;
			(_getTextArea = getTextArea()).setSelectionRange.apply(_getTextArea, _toConsumableArray(selection));
		}
	}, [selection]);
	var countConfig = useCount(count, showCount);
	var mergedMax = (_countConfig$max = countConfig.max) !== null && _countConfig$max !== void 0 ? _countConfig$max : maxLength;
	var hasMaxLength = Number(mergedMax) > 0;
	var valueLength = countConfig.strategy(formatValue$1);
	var isOutOfRange = !!mergedMax && valueLength > mergedMax;
	var triggerChange = function triggerChange$1(e$2, currentValue) {
		var cutValue = currentValue;
		if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
			cutValue = countConfig.exceedFormatter(currentValue, { max: countConfig.max });
			if (currentValue !== cutValue) setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
		}
		setValue(cutValue);
		resolveOnChange(e$2.currentTarget, e$2, onChange, cutValue);
	};
	var onInternalCompositionStart = function onInternalCompositionStart$1(e$2) {
		compositionRef.current = true;
		onCompositionStart === null || onCompositionStart === void 0 || onCompositionStart(e$2);
	};
	var onInternalCompositionEnd = function onInternalCompositionEnd$1(e$2) {
		compositionRef.current = false;
		triggerChange(e$2, e$2.currentTarget.value);
		onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e$2);
	};
	var onInternalChange = function onInternalChange$1(e$2) {
		triggerChange(e$2, e$2.target.value);
	};
	var handleKeyDown = function handleKeyDown$1(e$2) {
		if (e$2.key === "Enter" && onPressEnter) onPressEnter(e$2);
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(e$2);
	};
	var handleFocus = function handleFocus$1(e$2) {
		setFocused(true);
		onFocus === null || onFocus === void 0 || onFocus(e$2);
	};
	var handleBlur = function handleBlur$1(e$2) {
		setFocused(false);
		onBlur === null || onBlur === void 0 || onBlur(e$2);
	};
	var handleReset = function handleReset$1(e$2) {
		setValue("");
		focus();
		resolveOnChange(getTextArea(), e$2, onChange);
	};
	var suffixNode = suffix;
	var dataCount;
	if (countConfig.show) {
		if (countConfig.showFormatter) dataCount = countConfig.showFormatter({
			value: formatValue$1,
			count: valueLength,
			maxLength: mergedMax
		});
		else dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
		suffixNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, suffixNode, /* @__PURE__ */ import_react.createElement("span", {
			className: (0, import_classnames$83.default)("".concat(prefixCls, "-data-count"), classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.count),
			style: styles === null || styles === void 0 ? void 0 : styles.count
		}, dataCount));
	}
	var handleResize = function handleResize$1(size) {
		var _getTextArea2;
		onResize$1 === null || onResize$1 === void 0 || onResize$1(size);
		if ((_getTextArea2 = getTextArea()) !== null && _getTextArea2 !== void 0 && _getTextArea2.style.height) setTextareaResized(true);
	};
	var isPureTextArea = !autoSize && !showCount && !allowClear;
	return /* @__PURE__ */ import_react.createElement(BaseInput_default, {
		ref: holderRef,
		value: formatValue$1,
		allowClear,
		handleReset,
		suffix: suffixNode,
		prefixCls,
		classNames: _objectSpread2(_objectSpread2({}, classNames$252), {}, { affixWrapper: (0, import_classnames$83.default)(classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.affixWrapper, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-show-count"), showCount), "".concat(prefixCls, "-textarea-allow-clear"), allowClear)) }),
		disabled,
		focused,
		className: (0, import_classnames$83.default)(className, isOutOfRange && "".concat(prefixCls, "-out-of-range")),
		style: _objectSpread2(_objectSpread2({}, style$1), textareaResized && !isPureTextArea ? { height: "auto" } : {}),
		dataAttrs: { affixWrapper: { "data-count": typeof dataCount === "string" ? dataCount : void 0 } },
		hidden,
		readOnly,
		onClear
	}, /* @__PURE__ */ import_react.createElement(ResizableTextArea_default, _extends({}, rest, {
		autoSize,
		maxLength,
		onKeyDown: handleKeyDown,
		onChange: onInternalChange,
		onFocus: handleFocus,
		onBlur: handleBlur,
		onCompositionStart: onInternalCompositionStart,
		onCompositionEnd: onInternalCompositionEnd,
		className: (0, import_classnames$83.default)(classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.textarea),
		style: _objectSpread2(_objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.textarea), {}, { resize: style$1 === null || style$1 === void 0 ? void 0 : style$1.resize }),
		disabled,
		prefixCls,
		onResize: handleResize,
		ref: resizableTextAreaRef,
		readOnly
	})));
});
var TextArea_default$1 = TextArea$1;

//#endregion
//#region node_modules/rc-textarea/es/index.js
var es_default$13 = TextArea_default$1;

//#endregion
//#region node_modules/antd/es/input/style/textarea.js
var genTextAreaStyle = (token$1) => {
	const { componentCls, paddingLG } = token$1;
	const textareaPrefixCls = `${componentCls}-textarea`;
	return {
		[`textarea${componentCls}`]: {
			maxWidth: "100%",
			height: "auto",
			minHeight: token$1.controlHeight,
			lineHeight: token$1.lineHeight,
			verticalAlign: "bottom",
			transition: `all ${token$1.motionDurationSlow}`,
			resize: "vertical",
			[`&${componentCls}-mouse-active`]: { transition: `all ${token$1.motionDurationSlow}, height 0s, width 0s` }
		},
		[`${componentCls}-textarea-affix-wrapper-resize-dirty`]: { width: "auto" },
		[textareaPrefixCls]: {
			position: "relative",
			"&-show-count": { [`${componentCls}-data-count`]: {
				position: "absolute",
				bottom: token$1.calc(token$1.fontSize).mul(token$1.lineHeight).mul(-1).equal(),
				insetInlineEnd: 0,
				color: token$1.colorTextDescription,
				whiteSpace: "nowrap",
				pointerEvents: "none"
			} },
			[`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: { paddingInlineEnd: paddingLG },
			[`&-affix-wrapper${componentCls}-affix-wrapper`]: {
				padding: 0,
				[`> textarea${componentCls}`]: {
					fontSize: "inherit",
					border: "none",
					outline: "none",
					background: "transparent",
					minHeight: token$1.calc(token$1.controlHeight).sub(token$1.calc(token$1.lineWidth).mul(2)).equal(),
					"&:focus": { boxShadow: "none !important" }
				},
				[`${componentCls}-suffix`]: {
					margin: 0,
					"> *:not(:last-child)": { marginInline: 0 },
					[`${componentCls}-clear-icon`]: {
						position: "absolute",
						insetInlineEnd: token$1.paddingInline,
						insetBlockStart: token$1.paddingXS
					},
					[`${textareaPrefixCls}-suffix`]: {
						position: "absolute",
						top: 0,
						insetInlineEnd: token$1.paddingInline,
						bottom: 0,
						zIndex: 1,
						display: "inline-flex",
						alignItems: "center",
						margin: "auto",
						pointerEvents: "none"
					}
				}
			},
			[`&-affix-wrapper${componentCls}-affix-wrapper-rtl`]: { [`${componentCls}-suffix`]: { [`${componentCls}-data-count`]: {
				direction: "ltr",
				insetInlineStart: 0
			} } },
			[`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: { [`${componentCls}-suffix`]: { [`${componentCls}-clear-icon`]: { insetInlineEnd: token$1.paddingInlineSM } } }
		}
	};
};
var textarea_default = genStyleHooks(["Input", "TextArea"], (token$1) => {
	const inputToken = merge(token$1, initInputToken(token$1));
	return genTextAreaStyle(inputToken);
}, initComponentToken$1, { resetFont: false });

//#endregion
//#region node_modules/antd/es/input/TextArea.js
var import_classnames$82 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$35 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var TextArea = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var _a;
	const { prefixCls: customizePrefixCls, bordered = true, size: customizeSize, disabled: customDisabled, status: customStatus, allowClear, classNames: classes, rootClassName, className, style: style$1, styles, variant: customVariant, showCount, onMouseDown, onResize: onResize$1 } = props, rest = __rest$35(props, [
		"prefixCls",
		"bordered",
		"size",
		"disabled",
		"status",
		"allowClear",
		"classNames",
		"rootClassName",
		"className",
		"style",
		"styles",
		"variant",
		"showCount",
		"onMouseDown",
		"onResize"
	]);
	{
		const { deprecated } = devUseWarning("TextArea");
		deprecated(!("bordered" in props), "bordered", "variant");
	}
	const { getPrefixCls, direction, allowClear: contextAllowClear, autoComplete: contextAutoComplete, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("textArea");
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const { status: contextStatus, hasFeedback, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const innerRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => {
		var _a$1;
		return {
			resizableTextArea: (_a$1 = innerRef.current) === null || _a$1 === void 0 ? void 0 : _a$1.resizableTextArea,
			focus: (option) => {
				var _a$2, _b;
				triggerFocus((_b = (_a$2 = innerRef.current) === null || _a$2 === void 0 ? void 0 : _a$2.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
			},
			blur: () => {
				var _a$2;
				return (_a$2 = innerRef.current) === null || _a$2 === void 0 ? void 0 : _a$2.blur();
			}
		};
	});
	const prefixCls = getPrefixCls("input", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapSharedCSSVar, hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
	const [wrapCSSVar] = textarea_default(prefixCls, rootCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const mergedSize = useSize_default((ctx) => {
		var _a$1;
		return (_a$1 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a$1 !== void 0 ? _a$1 : ctx;
	});
	const [variant, enableVariantCls] = useVariants_default("textArea", customVariant, bordered);
	const mergedAllowClear = getAllowClear_default(allowClear !== null && allowClear !== void 0 ? allowClear : contextAllowClear);
	const [isMouseDown, setIsMouseDown] = import_react.useState(false);
	const [resizeDirty, setResizeDirty] = import_react.useState(false);
	const onInternalMouseDown = (e$2) => {
		setIsMouseDown(true);
		onMouseDown === null || onMouseDown === void 0 || onMouseDown(e$2);
		const onMouseUp = () => {
			setIsMouseDown(false);
			document.removeEventListener("mouseup", onMouseUp);
		};
		document.addEventListener("mouseup", onMouseUp);
	};
	const onInternalResize = (size) => {
		var _a$1, _b;
		onResize$1 === null || onResize$1 === void 0 || onResize$1(size);
		if (isMouseDown && typeof getComputedStyle === "function") {
			const ele = (_b = (_a$1 = innerRef.current) === null || _a$1 === void 0 ? void 0 : _a$1.nativeElement) === null || _b === void 0 ? void 0 : _b.querySelector("textarea");
			if (ele && getComputedStyle(ele).resize === "both") setResizeDirty(true);
		}
	};
	return wrapSharedCSSVar(wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$13, Object.assign({ autoComplete: contextAutoComplete }, rest, {
		style: Object.assign(Object.assign({}, contextStyle), style$1),
		styles: Object.assign(Object.assign({}, contextStyles), styles),
		disabled: mergedDisabled,
		allowClear: mergedAllowClear,
		className: (0, import_classnames$82.default)(cssVarCls, rootCls, className, rootClassName, compactItemClassnames, contextClassName, resizeDirty && `${prefixCls}-textarea-affix-wrapper-resize-dirty`),
		classNames: Object.assign(Object.assign(Object.assign({}, classes), contextClassNames), {
			textarea: (0, import_classnames$82.default)({
				[`${prefixCls}-sm`]: mergedSize === "small",
				[`${prefixCls}-lg`]: mergedSize === "large"
			}, hashId, classes === null || classes === void 0 ? void 0 : classes.textarea, contextClassNames.textarea, isMouseDown && `${prefixCls}-mouse-active`),
			variant: (0, import_classnames$82.default)({ [`${prefixCls}-${variant}`]: enableVariantCls }, getStatusClassNames(prefixCls, mergedStatus)),
			affixWrapper: (0, import_classnames$82.default)(`${prefixCls}-textarea-affix-wrapper`, {
				[`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
				[`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
				[`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
				[`${prefixCls}-textarea-show-count`]: showCount || ((_a = props.count) === null || _a === void 0 ? void 0 : _a.show)
			}, hashId)
		}),
		prefixCls,
		suffix: hasFeedback && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-textarea-suffix` }, feedbackIcon),
		showCount,
		ref: innerRef,
		onResize: onInternalResize,
		onMouseDown: onInternalMouseDown
	}))));
});
var TextArea_default = TextArea;

//#endregion
//#region node_modules/antd/es/input/index.js
var Input = Input_default;
Input.Group = Group_default;
Input.Search = Search_default;
Input.TextArea = TextArea_default;
Input.Password = Password_default;
Input.OTP = OTP_default;
var input_default = Input;

//#endregion
//#region node_modules/antd/es/layout/hooks/useHasSider.js
function useHasSider(siders, children, hasSider) {
	if (typeof hasSider === "boolean") return hasSider;
	if (siders.length) return true;
	return toArray(children).some((node$1) => node$1.type === Sider_default);
}

//#endregion
//#region node_modules/antd/es/layout/layout.js
var import_classnames$81 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$34 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function generator({ suffixCls, tagName, displayName }) {
	return (BasicComponent) => {
		const Adapter = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ import_react.createElement(BasicComponent, Object.assign({
			ref,
			suffixCls,
			tagName
		}, props)));
		Adapter.displayName = displayName;
		return Adapter;
	};
}
var Basic = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, suffixCls, className, tagName: TagName } = props, others = __rest$34(props, [
		"prefixCls",
		"suffixCls",
		"className",
		"tagName"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("layout", customizePrefixCls);
	const [wrapSSR, hashId, cssVarCls] = style_default$23(prefixCls);
	const prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
	return wrapSSR(/* @__PURE__ */ import_react.createElement(TagName, Object.assign({
		className: (0, import_classnames$81.default)(customizePrefixCls || prefixWithSuffixCls, className, hashId, cssVarCls),
		ref
	}, others)));
});
var BasicLayout = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { direction } = import_react.useContext(ConfigContext);
	const [siders, setSiders] = import_react.useState([]);
	const { prefixCls: customizePrefixCls, className, rootClassName, children, hasSider, tagName: Tag$1, style: style$1 } = props, others = __rest$34(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"children",
		"hasSider",
		"tagName",
		"style"
	]);
	const passedProps = omit(others, ["suffixCls"]);
	const { getPrefixCls, className: contextClassName, style: contextStyle } = useComponentConfig("layout");
	const prefixCls = getPrefixCls("layout", customizePrefixCls);
	const mergedHasSider = useHasSider(siders, children, hasSider);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$23(prefixCls);
	const classString = (0, import_classnames$81.default)(prefixCls, {
		[`${prefixCls}-has-sider`]: mergedHasSider,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, contextClassName, className, rootClassName, hashId, cssVarCls);
	const contextValue = import_react.useMemo(() => ({ siderHook: {
		addSider: (id) => {
			setSiders((prev$1) => [].concat(_toConsumableArray(prev$1), [id]));
		},
		removeSider: (id) => {
			setSiders((prev$1) => prev$1.filter((currentId) => currentId !== id));
		}
	} }), []);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(LayoutContext.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement(Tag$1, Object.assign({
		ref,
		className: classString,
		style: Object.assign(Object.assign({}, contextStyle), style$1)
	}, passedProps), children)));
});
var Layout$1 = generator({
	tagName: "div",
	displayName: "Layout"
})(BasicLayout);
var Header$1 = generator({
	suffixCls: "header",
	tagName: "header",
	displayName: "Header"
})(Basic);
var Footer$2 = generator({
	suffixCls: "footer",
	tagName: "footer",
	displayName: "Footer"
})(Basic);
var Content = generator({
	suffixCls: "content",
	tagName: "main",
	displayName: "Content"
})(Basic);
var layout_default$1 = Layout$1;

//#endregion
//#region node_modules/antd/es/layout/index.js
var Layout = layout_default$1;
Layout.Header = Header$1;
Layout.Footer = Footer$2;
Layout.Content = Content;
Layout.Sider = Sider_default;
Layout._InternalSiderContext = SiderContext;
var layout_default = Layout;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/DoubleLeftOutlined.js
var DoubleLeftOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" }
		}]
	},
	"name": "double-left",
	"theme": "outlined"
};
var DoubleLeftOutlined_default$1 = DoubleLeftOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/DoubleLeftOutlined.js
/**![double-left](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTI3Mi45IDUxMmwyNjUuNC0zMzkuMWM0LjEtNS4yLjQtMTIuOS02LjMtMTIuOWgtNzcuM2MtNC45IDAtOS42IDIuMy0xMi42IDYuMUwxODYuOCA0OTIuM2EzMS45OSAzMS45OSAwIDAwMCAzOS41bDI1NS4zIDMyNi4xYzMgMy45IDcuNyA2LjEgMTIuNiA2LjFINTMyYzYuNyAwIDEwLjQtNy43IDYuMy0xMi45TDI3Mi45IDUxMnptMzA0IDBsMjY1LjQtMzM5LjFjNC4xLTUuMi40LTEyLjktNi4zLTEyLjloLTc3LjNjLTQuOSAwLTkuNiAyLjMtMTIuNiA2LjFMNDkwLjggNDkyLjNhMzEuOTkgMzEuOTkgMCAwMDAgMzkuNWwyNTUuMyAzMjYuMWMzIDMuOSA3LjcgNi4xIDEyLjYgNi4xSDgzNmM2LjcgMCAxMC40LTcuNyA2LjMtMTIuOUw1NzYuOSA1MTJ6IiAvPjwvc3ZnPg==) */
var RefIcon$22 = /* @__PURE__ */ import_react.forwardRef(function DoubleLeftOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: DoubleLeftOutlined_default$1
	}));
});
RefIcon$22.displayName = "DoubleLeftOutlined";
var DoubleLeftOutlined_default = RefIcon$22;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/DoubleRightOutlined.js
var DoubleRightOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" }
		}]
	},
	"name": "double-right",
	"theme": "outlined"
};
var DoubleRightOutlined_default$1 = DoubleRightOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/DoubleRightOutlined.js
/**![double-right](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUzMy4yIDQ5Mi4zTDI3Ny45IDE2Ni4xYy0zLTMuOS03LjctNi4xLTEyLjYtNi4xSDE4OGMtNi43IDAtMTAuNCA3LjctNi4zIDEyLjlMNDQ3LjEgNTEyIDE4MS43IDg1MS4xQTcuOTggNy45OCAwIDAwMTg4IDg2NGg3Ny4zYzQuOSAwIDkuNi0yLjMgMTIuNi02LjFsMjU1LjMtMzI2LjFjOS4xLTExLjcgOS4xLTI3LjkgMC0zOS41em0zMDQgMEw1ODEuOSAxNjYuMWMtMy0zLjktNy43LTYuMS0xMi42LTYuMUg0OTJjLTYuNyAwLTEwLjQgNy43LTYuMyAxMi45TDc1MS4xIDUxMiA0ODUuNyA4NTEuMUE3Ljk4IDcuOTggMCAwMDQ5MiA4NjRoNzcuM2M0LjkgMCA5LjYtMi4zIDEyLjYtNi4xbDI1NS4zLTMyNi4xYzkuMS0xMS43IDkuMS0yNy45IDAtMzkuNXoiIC8+PC9zdmc+) */
var RefIcon$21 = /* @__PURE__ */ import_react.forwardRef(function DoubleRightOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: DoubleRightOutlined_default$1
	}));
});
RefIcon$21.displayName = "DoubleRightOutlined";
var DoubleRightOutlined_default = RefIcon$21;

//#endregion
//#region node_modules/rc-pagination/es/locale/zh_CN.js
var locale = {
	items_per_page: "/",
	jump_to: "",
	jump_to_confirm: "",
	page: "",
	prev_page: "",
	next_page: "",
	prev_5: " 5 ",
	next_5: " 5 ",
	prev_3: " 3 ",
	next_3: " 3 ",
	page_size: ""
};
var zh_CN_default = locale;

//#endregion
//#region node_modules/rc-pagination/es/Options.js
var defaultPageSizeOptions = [
	10,
	20,
	50,
	100
];
var Options = function Options$1(props) {
	var _props$pageSizeOption = props.pageSizeOptions, pageSizeOptions = _props$pageSizeOption === void 0 ? defaultPageSizeOptions : _props$pageSizeOption, locale$5 = props.locale, changeSize = props.changeSize, pageSize = props.pageSize, goButton = props.goButton, quickGo = props.quickGo, rootPrefixCls = props.rootPrefixCls, disabled = props.disabled, buildOptionText = props.buildOptionText, showSizeChanger = props.showSizeChanger, sizeChangerRender = props.sizeChangerRender;
	var _React$useState = import_react.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), goInputText = _React$useState2[0], setGoInputText = _React$useState2[1];
	var getValidValue = function getValidValue$1() {
		return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
	};
	var mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : function(value) {
		return "".concat(value, " ").concat(locale$5.items_per_page);
	};
	var handleChange = function handleChange$1(e$2) {
		setGoInputText(e$2.target.value);
	};
	var handleBlur = function handleBlur$1(e$2) {
		if (goButton || goInputText === "") return;
		setGoInputText("");
		if (e$2.relatedTarget && (e$2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e$2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) return;
		quickGo === null || quickGo === void 0 || quickGo(getValidValue());
	};
	var go = function go$1(e$2) {
		if (goInputText === "") return;
		if (e$2.keyCode === KeyCode_default.ENTER || e$2.type === "click") {
			setGoInputText("");
			quickGo === null || quickGo === void 0 || quickGo(getValidValue());
		}
	};
	var getPageSizeOptions = function getPageSizeOptions$1() {
		if (pageSizeOptions.some(function(option) {
			return option.toString() === pageSize.toString();
		})) return pageSizeOptions;
		return pageSizeOptions.concat([pageSize]).sort(function(a, b) {
			return (Number.isNaN(Number(a)) ? 0 : Number(a)) - (Number.isNaN(Number(b)) ? 0 : Number(b));
		});
	};
	var prefixCls = "".concat(rootPrefixCls, "-options");
	if (!showSizeChanger && !quickGo) return null;
	var changeSelect = null;
	var goInput = null;
	var gotoButton = null;
	if (showSizeChanger && sizeChangerRender) changeSelect = sizeChangerRender({
		disabled,
		size: pageSize,
		onSizeChange: function onSizeChange(nextValue) {
			changeSize === null || changeSize === void 0 || changeSize(Number(nextValue));
		},
		"aria-label": locale$5.page_size,
		className: "".concat(prefixCls, "-size-changer"),
		options: getPageSizeOptions().map(function(opt) {
			return {
				label: mergeBuildOptionText(opt),
				value: opt
			};
		})
	});
	if (quickGo) {
		if (goButton) gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			onClick: go,
			onKeyUp: go,
			disabled,
			className: "".concat(prefixCls, "-quick-jumper-button")
		}, locale$5.jump_to_confirm) : /* @__PURE__ */ import_react.createElement("span", {
			onClick: go,
			onKeyUp: go
		}, goButton);
		goInput = /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-quick-jumper") }, locale$5.jump_to, /* @__PURE__ */ import_react.createElement("input", {
			disabled,
			type: "text",
			value: goInputText,
			onChange: handleChange,
			onKeyUp: go,
			onBlur: handleBlur,
			"aria-label": locale$5.page
		}), locale$5.page, gotoButton);
	}
	return /* @__PURE__ */ import_react.createElement("li", { className: prefixCls }, changeSelect, goInput);
};
Options.displayName = "Options";
var Options_default = Options;

//#endregion
//#region node_modules/rc-pagination/es/Pager.js
var import_classnames$80 = /* @__PURE__ */ __toESM(require_classnames());
var Pager = function Pager$1(props) {
	var rootPrefixCls = props.rootPrefixCls, page = props.page, active = props.active, className = props.className, showTitle = props.showTitle, onClick = props.onClick, onKeyPress = props.onKeyPress, itemRender = props.itemRender;
	var prefixCls = "".concat(rootPrefixCls, "-item");
	var cls$12 = (0, import_classnames$80.default)(prefixCls, "".concat(prefixCls, "-").concat(page), _defineProperty(_defineProperty({}, "".concat(prefixCls, "-active"), active), "".concat(prefixCls, "-disabled"), !page), className);
	var handleClick = function handleClick$1() {
		onClick(page);
	};
	var handleKeyPress = function handleKeyPress$1(e$2) {
		onKeyPress(e$2, onClick, page);
	};
	var pager = itemRender(page, "page", /* @__PURE__ */ import_react.createElement("a", { rel: "nofollow" }, page));
	return pager ? /* @__PURE__ */ import_react.createElement("li", {
		title: showTitle ? String(page) : null,
		className: cls$12,
		onClick: handleClick,
		onKeyDown: handleKeyPress,
		tabIndex: 0
	}, pager) : null;
};
Pager.displayName = "Pager";
var Pager_default = Pager;

//#endregion
//#region node_modules/rc-pagination/es/Pagination.js
var import_classnames$79 = /* @__PURE__ */ __toESM(require_classnames());
var defaultItemRender = function defaultItemRender$1(page, type$2, element) {
	return element;
};
function noop$1() {}
function isInteger(v) {
	var value = Number(v);
	return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
}
function calculatePage(p, pageSize, total) {
	var _pageSize = typeof p === "undefined" ? pageSize : p;
	return Math.floor((total - 1) / _pageSize) + 1;
}
var Pagination$1 = function Pagination$2(props) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-pagination" : _props$prefixCls, _props$selectPrefixCl = props.selectPrefixCls, selectPrefixCls = _props$selectPrefixCl === void 0 ? "rc-select" : _props$selectPrefixCl, className = props.className, currentProp = props.current, _props$defaultCurrent = props.defaultCurrent, defaultCurrent = _props$defaultCurrent === void 0 ? 1 : _props$defaultCurrent, _props$total = props.total, total = _props$total === void 0 ? 0 : _props$total, pageSizeProp = props.pageSize, _props$defaultPageSiz = props.defaultPageSize, defaultPageSize = _props$defaultPageSiz === void 0 ? 10 : _props$defaultPageSiz, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? noop$1 : _props$onChange, hideOnSinglePage = props.hideOnSinglePage, align = props.align, _props$showPrevNextJu = props.showPrevNextJumpers, showPrevNextJumpers = _props$showPrevNextJu === void 0 ? true : _props$showPrevNextJu, showQuickJumper = props.showQuickJumper, showLessItems = props.showLessItems, _props$showTitle = props.showTitle, showTitle = _props$showTitle === void 0 ? true : _props$showTitle, _props$onShowSizeChan = props.onShowSizeChange, onShowSizeChange = _props$onShowSizeChan === void 0 ? noop$1 : _props$onShowSizeChan, _props$locale = props.locale, locale$5 = _props$locale === void 0 ? zh_CN_default : _props$locale, style$1 = props.style, _props$totalBoundaryS = props.totalBoundaryShowSizeChanger, totalBoundaryShowSizeChanger = _props$totalBoundaryS === void 0 ? 50 : _props$totalBoundaryS, disabled = props.disabled, simple = props.simple, showTotal = props.showTotal, _props$showSizeChange = props.showSizeChanger, showSizeChanger = _props$showSizeChange === void 0 ? total > totalBoundaryShowSizeChanger : _props$showSizeChange, sizeChangerRender = props.sizeChangerRender, pageSizeOptions = props.pageSizeOptions, _props$itemRender = props.itemRender, itemRender = _props$itemRender === void 0 ? defaultItemRender : _props$itemRender, jumpPrevIcon = props.jumpPrevIcon, jumpNextIcon = props.jumpNextIcon, prevIcon = props.prevIcon, nextIcon = props.nextIcon;
	var paginationRef = import_react.useRef(null);
	var _useMergedState = useMergedState(10, {
		value: pageSizeProp,
		defaultValue: defaultPageSize
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), pageSize = _useMergedState2[0], setPageSize = _useMergedState2[1];
	var _useMergedState3 = useMergedState(1, {
		value: currentProp,
		defaultValue: defaultCurrent,
		postState: function postState(c) {
			return Math.max(1, Math.min(c, calculatePage(void 0, pageSize, total)));
		}
	}), _useMergedState4 = _slicedToArray(_useMergedState3, 2), current = _useMergedState4[0], setCurrent = _useMergedState4[1];
	var _React$useState = import_react.useState(current), _React$useState2 = _slicedToArray(_React$useState, 2), internalInputVal = _React$useState2[0], setInternalInputVal = _React$useState2[1];
	(0, import_react.useEffect)(function() {
		setInternalInputVal(current);
	}, [current]);
	var hasOnChange = onChange !== noop$1;
	var hasCurrent = "current" in props;
	warning_default(hasCurrent ? hasOnChange : true, "You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
	var jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
	var jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
	function getItemIcon(icon, label) {
		var iconNode = icon || /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			"aria-label": label,
			className: "".concat(prefixCls, "-item-link")
		});
		if (typeof icon === "function") iconNode = /* @__PURE__ */ import_react.createElement(icon, _objectSpread2({}, props));
		return iconNode;
	}
	function getValidValue(e$2) {
		var inputValue = e$2.target.value;
		var allPages$1 = calculatePage(void 0, pageSize, total);
		var value;
		if (inputValue === "") value = inputValue;
		else if (Number.isNaN(Number(inputValue))) value = internalInputVal;
		else if (inputValue >= allPages$1) value = allPages$1;
		else value = Number(inputValue);
		return value;
	}
	function isValid(page) {
		return isInteger(page) && page !== current && isInteger(total) && total > 0;
	}
	var shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
	/**
	* prevent "up arrow" key reseting cursor position within textbox
	* @see https://stackoverflow.com/a/1081114
	*/
	function handleKeyDown(event) {
		if (event.keyCode === KeyCode_default.UP || event.keyCode === KeyCode_default.DOWN) event.preventDefault();
	}
	function handleKeyUp(event) {
		var value = getValidValue(event);
		if (value !== internalInputVal) setInternalInputVal(value);
		switch (event.keyCode) {
			case KeyCode_default.ENTER:
				handleChange(value);
				break;
			case KeyCode_default.UP:
				handleChange(value - 1);
				break;
			case KeyCode_default.DOWN:
				handleChange(value + 1);
				break;
			default: break;
		}
	}
	function handleBlur(event) {
		handleChange(getValidValue(event));
	}
	function changePageSize(size) {
		var newCurrent = calculatePage(size, pageSize, total);
		var nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
		setPageSize(size);
		setInternalInputVal(nextCurrent);
		onShowSizeChange === null || onShowSizeChange === void 0 || onShowSizeChange(current, size);
		setCurrent(nextCurrent);
		onChange === null || onChange === void 0 || onChange(nextCurrent, size);
	}
	function handleChange(page) {
		if (isValid(page) && !disabled) {
			var currentPage = calculatePage(void 0, pageSize, total);
			var newPage = page;
			if (page > currentPage) newPage = currentPage;
			else if (page < 1) newPage = 1;
			if (newPage !== internalInputVal) setInternalInputVal(newPage);
			setCurrent(newPage);
			onChange === null || onChange === void 0 || onChange(newPage, pageSize);
			return newPage;
		}
		return current;
	}
	var hasPrev = current > 1;
	var hasNext = current < calculatePage(void 0, pageSize, total);
	function prevHandle() {
		if (hasPrev) handleChange(current - 1);
	}
	function nextHandle() {
		if (hasNext) handleChange(current + 1);
	}
	function jumpPrevHandle() {
		handleChange(jumpPrevPage);
	}
	function jumpNextHandle() {
		handleChange(jumpNextPage);
	}
	function runIfEnter(event, callback) {
		if (event.key === "Enter" || event.charCode === KeyCode_default.ENTER || event.keyCode === KeyCode_default.ENTER) {
			for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) restParams[_key - 2] = arguments[_key];
			callback.apply(void 0, restParams);
		}
	}
	function runIfEnterPrev(event) {
		runIfEnter(event, prevHandle);
	}
	function runIfEnterNext(event) {
		runIfEnter(event, nextHandle);
	}
	function runIfEnterJumpPrev(event) {
		runIfEnter(event, jumpPrevHandle);
	}
	function runIfEnterJumpNext(event) {
		runIfEnter(event, jumpNextHandle);
	}
	function renderPrev(prevPage$1) {
		var prevButton = itemRender(prevPage$1, "prev", getItemIcon(prevIcon, "prev page"));
		return /* @__PURE__ */ import_react.isValidElement(prevButton) ? /* @__PURE__ */ import_react.cloneElement(prevButton, { disabled: !hasPrev }) : prevButton;
	}
	function renderNext(nextPage$1) {
		var nextButton = itemRender(nextPage$1, "next", getItemIcon(nextIcon, "next page"));
		return /* @__PURE__ */ import_react.isValidElement(nextButton) ? /* @__PURE__ */ import_react.cloneElement(nextButton, { disabled: !hasNext }) : nextButton;
	}
	function handleGoTO(event) {
		if (event.type === "click" || event.keyCode === KeyCode_default.ENTER) handleChange(internalInputVal);
	}
	var jumpPrev = null;
	var dataOrAriaAttributeProps = pickAttrs(props, {
		aria: true,
		data: true
	});
	var totalText = showTotal && /* @__PURE__ */ import_react.createElement("li", { className: "".concat(prefixCls, "-total-text") }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
	var jumpNext = null;
	var allPages = calculatePage(void 0, pageSize, total);
	if (hideOnSinglePage && total <= pageSize) return null;
	var pagerList = [];
	var pagerProps = {
		rootPrefixCls: prefixCls,
		onClick: handleChange,
		onKeyPress: runIfEnter,
		showTitle,
		itemRender,
		page: -1
	};
	var prevPage = current - 1 > 0 ? current - 1 : 0;
	var nextPage = current + 1 < allPages ? current + 1 : allPages;
	var goButton = showQuickJumper && showQuickJumper.goButton;
	var isReadOnly = _typeof(simple) === "object" ? simple.readOnly : !simple;
	var gotoButton = goButton;
	var simplePager = null;
	if (simple) {
		if (goButton) {
			if (typeof goButton === "boolean") gotoButton = /* @__PURE__ */ import_react.createElement("button", {
				type: "button",
				onClick: handleGoTO,
				onKeyUp: handleGoTO
			}, locale$5.jump_to_confirm);
			else gotoButton = /* @__PURE__ */ import_react.createElement("span", {
				onClick: handleGoTO,
				onKeyUp: handleGoTO
			}, goButton);
			gotoButton = /* @__PURE__ */ import_react.createElement("li", {
				title: showTitle ? "".concat(locale$5.jump_to).concat(current, "/").concat(allPages) : null,
				className: "".concat(prefixCls, "-simple-pager")
			}, gotoButton);
		}
		simplePager = /* @__PURE__ */ import_react.createElement("li", {
			title: showTitle ? "".concat(current, "/").concat(allPages) : null,
			className: "".concat(prefixCls, "-simple-pager")
		}, isReadOnly ? internalInputVal : /* @__PURE__ */ import_react.createElement("input", {
			type: "text",
			"aria-label": locale$5.jump_to,
			value: internalInputVal,
			disabled,
			onKeyDown: handleKeyDown,
			onKeyUp: handleKeyUp,
			onChange: handleKeyUp,
			onBlur: handleBlur,
			size: 3
		}), /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-slash") }, "/"), allPages);
	}
	var pageBufferSize = showLessItems ? 1 : 2;
	if (allPages <= 3 + pageBufferSize * 2) {
		if (!allPages) pagerList.push(/* @__PURE__ */ import_react.createElement(Pager_default, _extends({}, pagerProps, {
			key: "noPager",
			page: 1,
			className: "".concat(prefixCls, "-item-disabled")
		})));
		for (var i = 1; i <= allPages; i += 1) pagerList.push(/* @__PURE__ */ import_react.createElement(Pager_default, _extends({}, pagerProps, {
			key: i,
			page: i,
			active: current === i
		})));
	} else {
		var prevItemTitle = showLessItems ? locale$5.prev_3 : locale$5.prev_5;
		var nextItemTitle = showLessItems ? locale$5.next_3 : locale$5.next_5;
		var jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page"));
		var jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
		if (showPrevNextJumpers) {
			jumpPrev = jumpPrevContent ? /* @__PURE__ */ import_react.createElement("li", {
				title: showTitle ? prevItemTitle : null,
				key: "prev",
				onClick: jumpPrevHandle,
				tabIndex: 0,
				onKeyDown: runIfEnterJumpPrev,
				className: (0, import_classnames$79.default)("".concat(prefixCls, "-jump-prev"), _defineProperty({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
			}, jumpPrevContent) : null;
			jumpNext = jumpNextContent ? /* @__PURE__ */ import_react.createElement("li", {
				title: showTitle ? nextItemTitle : null,
				key: "next",
				onClick: jumpNextHandle,
				tabIndex: 0,
				onKeyDown: runIfEnterJumpNext,
				className: (0, import_classnames$79.default)("".concat(prefixCls, "-jump-next"), _defineProperty({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
			}, jumpNextContent) : null;
		}
		var left = Math.max(1, current - pageBufferSize);
		var right = Math.min(current + pageBufferSize, allPages);
		if (current - 1 <= pageBufferSize) right = 1 + pageBufferSize * 2;
		if (allPages - current <= pageBufferSize) left = allPages - pageBufferSize * 2;
		for (var _i = left; _i <= right; _i += 1) pagerList.push(/* @__PURE__ */ import_react.createElement(Pager_default, _extends({}, pagerProps, {
			key: _i,
			page: _i,
			active: current === _i
		})));
		if (current - 1 >= pageBufferSize * 2 && current !== 3) {
			pagerList[0] = /* @__PURE__ */ import_react.cloneElement(pagerList[0], { className: (0, import_classnames$79.default)("".concat(prefixCls, "-item-after-jump-prev"), pagerList[0].props.className) });
			pagerList.unshift(jumpPrev);
		}
		if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
			var lastOne = pagerList[pagerList.length - 1];
			pagerList[pagerList.length - 1] = /* @__PURE__ */ import_react.cloneElement(lastOne, { className: (0, import_classnames$79.default)("".concat(prefixCls, "-item-before-jump-next"), lastOne.props.className) });
			pagerList.push(jumpNext);
		}
		if (left !== 1) pagerList.unshift(/* @__PURE__ */ import_react.createElement(Pager_default, _extends({}, pagerProps, {
			key: 1,
			page: 1
		})));
		if (right !== allPages) pagerList.push(/* @__PURE__ */ import_react.createElement(Pager_default, _extends({}, pagerProps, {
			key: allPages,
			page: allPages
		})));
	}
	var prev$1 = renderPrev(prevPage);
	if (prev$1) {
		var prevDisabled = !hasPrev || !allPages;
		prev$1 = /* @__PURE__ */ import_react.createElement("li", {
			title: showTitle ? locale$5.prev_page : null,
			onClick: prevHandle,
			tabIndex: prevDisabled ? null : 0,
			onKeyDown: runIfEnterPrev,
			className: (0, import_classnames$79.default)("".concat(prefixCls, "-prev"), _defineProperty({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
			"aria-disabled": prevDisabled
		}, prev$1);
	}
	var next$1 = renderNext(nextPage);
	if (next$1) {
		var nextDisabled, nextTabIndex;
		if (simple) {
			nextDisabled = !hasNext;
			nextTabIndex = hasPrev ? 0 : null;
		} else {
			nextDisabled = !hasNext || !allPages;
			nextTabIndex = nextDisabled ? null : 0;
		}
		next$1 = /* @__PURE__ */ import_react.createElement("li", {
			title: showTitle ? locale$5.next_page : null,
			onClick: nextHandle,
			tabIndex: nextTabIndex,
			onKeyDown: runIfEnterNext,
			className: (0, import_classnames$79.default)("".concat(prefixCls, "-next"), _defineProperty({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
			"aria-disabled": nextDisabled
		}, next$1);
	}
	var cls$12 = (0, import_classnames$79.default)(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-start"), align === "start"), "".concat(prefixCls, "-center"), align === "center"), "".concat(prefixCls, "-end"), align === "end"), "".concat(prefixCls, "-simple"), simple), "".concat(prefixCls, "-disabled"), disabled));
	return /* @__PURE__ */ import_react.createElement("ul", _extends({
		className: cls$12,
		style: style$1,
		ref: paginationRef
	}, dataOrAriaAttributeProps), totalText, prev$1, simple ? simplePager : pagerList, next$1, /* @__PURE__ */ import_react.createElement(Options_default, {
		locale: locale$5,
		rootPrefixCls: prefixCls,
		disabled,
		selectPrefixCls,
		changeSize: changePageSize,
		pageSize,
		pageSizeOptions,
		quickGo: shouldDisplayQuickJumper ? handleChange : null,
		goButton: gotoButton,
		showSizeChanger,
		sizeChangerRender
	}));
};
Pagination$1.displayName = "Pagination";
var Pagination_default$1 = Pagination$1;

//#endregion
//#region node_modules/antd/es/pagination/style/index.js
var genPaginationDisabledStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}-disabled`]: {
			"&, &:hover": {
				cursor: "not-allowed",
				[`${componentCls}-item-link`]: {
					color: token$1.colorTextDisabled,
					cursor: "not-allowed"
				}
			},
			"&:focus-visible": {
				cursor: "not-allowed",
				[`${componentCls}-item-link`]: {
					color: token$1.colorTextDisabled,
					cursor: "not-allowed"
				}
			}
		},
		[`&${componentCls}-disabled`]: {
			cursor: "not-allowed",
			[`${componentCls}-item`]: {
				cursor: "not-allowed",
				backgroundColor: "transparent",
				"&:hover, &:active": { backgroundColor: "transparent" },
				a: {
					color: token$1.colorTextDisabled,
					backgroundColor: "transparent",
					border: "none",
					cursor: "not-allowed"
				},
				"&-active": {
					borderColor: token$1.colorBorder,
					backgroundColor: token$1.itemActiveBgDisabled,
					"&:hover, &:active": { backgroundColor: token$1.itemActiveBgDisabled },
					a: { color: token$1.itemActiveColorDisabled }
				}
			},
			[`${componentCls}-item-link`]: {
				color: token$1.colorTextDisabled,
				cursor: "not-allowed",
				"&:hover, &:active": { backgroundColor: "transparent" },
				[`${componentCls}-simple&`]: {
					backgroundColor: "transparent",
					"&:hover, &:active": { backgroundColor: "transparent" }
				}
			},
			[`${componentCls}-simple-pager`]: { color: token$1.colorTextDisabled },
			[`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
				[`${componentCls}-item-link-icon`]: { opacity: 0 },
				[`${componentCls}-item-ellipsis`]: { opacity: 1 }
			}
		}
	};
};
var genPaginationMiniStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
			height: token$1.itemSizeSM,
			lineHeight: unit(token$1.itemSizeSM)
		},
		[`&${componentCls}-mini ${componentCls}-item`]: {
			minWidth: token$1.itemSizeSM,
			height: token$1.itemSizeSM,
			margin: 0,
			lineHeight: unit(token$1.calc(token$1.itemSizeSM).sub(2).equal())
		},
		[`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
			minWidth: token$1.itemSizeSM,
			height: token$1.itemSizeSM,
			margin: 0,
			lineHeight: unit(token$1.itemSizeSM)
		},
		[`&${componentCls}-mini:not(${componentCls}-disabled)`]: { [`${componentCls}-prev, ${componentCls}-next`]: {
			[`&:hover ${componentCls}-item-link`]: { backgroundColor: token$1.colorBgTextHover },
			[`&:active ${componentCls}-item-link`]: { backgroundColor: token$1.colorBgTextActive },
			[`&${componentCls}-disabled:hover ${componentCls}-item-link`]: { backgroundColor: "transparent" }
		} },
		[`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
			backgroundColor: "transparent",
			borderColor: "transparent",
			"&::after": {
				height: token$1.itemSizeSM,
				lineHeight: unit(token$1.itemSizeSM)
			}
		},
		[`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
			height: token$1.itemSizeSM,
			marginInlineEnd: 0,
			lineHeight: unit(token$1.itemSizeSM)
		},
		[`&${componentCls}-mini ${componentCls}-options`]: {
			marginInlineStart: token$1.paginationMiniOptionsMarginInlineStart,
			"&-size-changer": { top: token$1.miniOptionsSizeChangerTop },
			"&-quick-jumper": {
				height: token$1.itemSizeSM,
				lineHeight: unit(token$1.itemSizeSM),
				input: Object.assign(Object.assign({}, genInputSmallStyle(token$1)), {
					width: token$1.paginationMiniQuickJumperInputWidth,
					height: token$1.controlHeightSM
				})
			}
		}
	};
};
var genPaginationSimpleStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`&${componentCls}-simple`]: {
		[`${componentCls}-prev, ${componentCls}-next`]: {
			height: token$1.itemSize,
			lineHeight: unit(token$1.itemSize),
			verticalAlign: "top",
			[`${componentCls}-item-link`]: {
				height: token$1.itemSize,
				backgroundColor: "transparent",
				border: 0,
				"&:hover": { backgroundColor: token$1.colorBgTextHover },
				"&:active": { backgroundColor: token$1.colorBgTextActive },
				"&::after": {
					height: token$1.itemSize,
					lineHeight: unit(token$1.itemSize)
				}
			}
		},
		[`${componentCls}-simple-pager`]: {
			display: "inline-flex",
			alignItems: "center",
			height: token$1.itemSize,
			marginInlineEnd: token$1.marginXS,
			input: {
				boxSizing: "border-box",
				height: "100%",
				width: token$1.quickJumperInputWidth,
				padding: `0 ${unit(token$1.paginationItemPaddingInline)}`,
				textAlign: "center",
				backgroundColor: token$1.itemInputBg,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
				borderRadius: token$1.borderRadius,
				outline: "none",
				transition: `border-color ${token$1.motionDurationMid}`,
				color: "inherit",
				"&:hover": { borderColor: token$1.colorPrimary },
				"&:focus": {
					borderColor: token$1.colorPrimaryHover,
					boxShadow: `${unit(token$1.inputOutlineOffset)} 0 ${unit(token$1.controlOutlineWidth)} ${token$1.controlOutline}`
				},
				"&[disabled]": {
					color: token$1.colorTextDisabled,
					backgroundColor: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder,
					cursor: "not-allowed"
				}
			}
		},
		[`&${componentCls}-disabled`]: { [`${componentCls}-prev, ${componentCls}-next`]: { [`${componentCls}-item-link`]: { "&:hover, &:active": { backgroundColor: "transparent" } } } },
		[`&${componentCls}-mini`]: {
			[`${componentCls}-prev, ${componentCls}-next`]: {
				height: token$1.itemSizeSM,
				lineHeight: unit(token$1.itemSizeSM),
				[`${componentCls}-item-link`]: {
					height: token$1.itemSizeSM,
					"&::after": {
						height: token$1.itemSizeSM,
						lineHeight: unit(token$1.itemSizeSM)
					}
				}
			},
			[`${componentCls}-simple-pager`]: {
				height: token$1.itemSizeSM,
				input: { width: token$1.paginationMiniQuickJumperInputWidth }
			}
		}
	} };
};
var genPaginationJumpStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
			outline: 0,
			[`${componentCls}-item-container`]: {
				position: "relative",
				[`${componentCls}-item-link-icon`]: {
					color: token$1.colorPrimary,
					fontSize: token$1.fontSizeSM,
					opacity: 0,
					transition: `all ${token$1.motionDurationMid}`,
					"&-svg": {
						top: 0,
						insetInlineEnd: 0,
						bottom: 0,
						insetInlineStart: 0,
						margin: "auto"
					}
				},
				[`${componentCls}-item-ellipsis`]: {
					position: "absolute",
					top: 0,
					insetInlineEnd: 0,
					bottom: 0,
					insetInlineStart: 0,
					display: "block",
					margin: "auto",
					color: token$1.colorTextDisabled,
					letterSpacing: token$1.paginationEllipsisLetterSpacing,
					textAlign: "center",
					textIndent: token$1.paginationEllipsisTextIndent,
					opacity: 1,
					transition: `all ${token$1.motionDurationMid}`
				}
			},
			"&:hover": {
				[`${componentCls}-item-link-icon`]: { opacity: 1 },
				[`${componentCls}-item-ellipsis`]: { opacity: 0 }
			}
		},
		[`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: { marginInlineEnd: token$1.marginXS },
		[`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
			display: "inline-block",
			minWidth: token$1.itemSize,
			height: token$1.itemSize,
			color: token$1.colorText,
			fontFamily: token$1.fontFamily,
			lineHeight: unit(token$1.itemSize),
			textAlign: "center",
			verticalAlign: "middle",
			listStyle: "none",
			borderRadius: token$1.borderRadius,
			cursor: "pointer",
			transition: `all ${token$1.motionDurationMid}`
		},
		[`${componentCls}-prev, ${componentCls}-next`]: {
			outline: 0,
			button: {
				color: token$1.colorText,
				cursor: "pointer",
				userSelect: "none"
			},
			[`${componentCls}-item-link`]: {
				display: "block",
				width: "100%",
				height: "100%",
				padding: 0,
				fontSize: token$1.fontSizeSM,
				textAlign: "center",
				backgroundColor: "transparent",
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
				borderRadius: token$1.borderRadius,
				outline: "none",
				transition: `all ${token$1.motionDurationMid}`
			},
			[`&:hover ${componentCls}-item-link`]: { backgroundColor: token$1.colorBgTextHover },
			[`&:active ${componentCls}-item-link`]: { backgroundColor: token$1.colorBgTextActive },
			[`&${componentCls}-disabled:hover`]: { [`${componentCls}-item-link`]: { backgroundColor: "transparent" } }
		},
		[`${componentCls}-slash`]: {
			marginInlineEnd: token$1.paginationSlashMarginInlineEnd,
			marginInlineStart: token$1.paginationSlashMarginInlineStart
		},
		[`${componentCls}-options`]: {
			display: "inline-block",
			marginInlineStart: token$1.margin,
			verticalAlign: "middle",
			"&-size-changer": {
				display: "inline-block",
				width: "auto"
			},
			"&-quick-jumper": {
				display: "inline-block",
				height: token$1.controlHeight,
				marginInlineStart: token$1.marginXS,
				lineHeight: unit(token$1.controlHeight),
				verticalAlign: "top",
				input: Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token$1)), genBaseOutlinedStyle(token$1, {
					borderColor: token$1.colorBorder,
					hoverBorderColor: token$1.colorPrimaryHover,
					activeBorderColor: token$1.colorPrimary,
					activeShadow: token$1.activeShadow
				})), {
					"&[disabled]": Object.assign({}, genDisabledStyle(token$1)),
					width: token$1.quickJumperInputWidth,
					height: token$1.controlHeight,
					boxSizing: "border-box",
					margin: 0,
					marginInlineStart: token$1.marginXS,
					marginInlineEnd: token$1.marginXS
				})
			}
		}
	};
};
var genPaginationItemStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-item`]: {
		display: "inline-block",
		minWidth: token$1.itemSize,
		height: token$1.itemSize,
		marginInlineEnd: token$1.marginXS,
		fontFamily: token$1.fontFamily,
		lineHeight: unit(token$1.calc(token$1.itemSize).sub(2).equal()),
		textAlign: "center",
		verticalAlign: "middle",
		listStyle: "none",
		backgroundColor: token$1.itemBg,
		border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
		borderRadius: token$1.borderRadius,
		outline: 0,
		cursor: "pointer",
		userSelect: "none",
		a: {
			display: "block",
			padding: `0 ${unit(token$1.paginationItemPaddingInline)}`,
			color: token$1.colorText,
			"&:hover": { textDecoration: "none" }
		},
		[`&:not(${componentCls}-item-active)`]: {
			"&:hover": {
				transition: `all ${token$1.motionDurationMid}`,
				backgroundColor: token$1.colorBgTextHover
			},
			"&:active": { backgroundColor: token$1.colorBgTextActive }
		},
		"&-active": {
			fontWeight: token$1.fontWeightStrong,
			backgroundColor: token$1.itemActiveBg,
			borderColor: token$1.colorPrimary,
			a: { color: token$1.colorPrimary },
			"&:hover": { borderColor: token$1.colorPrimaryHover },
			"&:hover a": { color: token$1.colorPrimaryHover }
		}
	} };
};
var genPaginationStyle$1 = (token$1) => {
	const { componentCls } = token$1;
	return {
		[componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
			display: "flex",
			"&-start": { justifyContent: "start" },
			"&-center": { justifyContent: "center" },
			"&-end": { justifyContent: "end" },
			"ul, ol": {
				margin: 0,
				padding: 0,
				listStyle: "none"
			},
			"&::after": {
				display: "block",
				clear: "both",
				height: 0,
				overflow: "hidden",
				visibility: "hidden",
				content: "\"\""
			},
			[`${componentCls}-total-text`]: {
				display: "inline-block",
				height: token$1.itemSize,
				marginInlineEnd: token$1.marginXS,
				lineHeight: unit(token$1.calc(token$1.itemSize).sub(2).equal()),
				verticalAlign: "middle"
			}
		}), genPaginationItemStyle(token$1)), genPaginationJumpStyle(token$1)), genPaginationSimpleStyle(token$1)), genPaginationMiniStyle(token$1)), genPaginationDisabledStyle(token$1)), {
			[`@media only screen and (max-width: ${token$1.screenLG}px)`]: { [`${componentCls}-item`]: { "&-after-jump-prev, &-before-jump-next": { display: "none" } } },
			[`@media only screen and (max-width: ${token$1.screenSM}px)`]: { [`${componentCls}-options`]: { display: "none" } }
		}),
		[`&${token$1.componentCls}-rtl`]: { direction: "rtl" }
	};
};
var genPaginationFocusStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}:not(${componentCls}-disabled)`]: {
		[`${componentCls}-item`]: Object.assign({}, genFocusStyle(token$1)),
		[`${componentCls}-jump-prev, ${componentCls}-jump-next`]: { "&:focus-visible": Object.assign({
			[`${componentCls}-item-link-icon`]: { opacity: 1 },
			[`${componentCls}-item-ellipsis`]: { opacity: 0 }
		}, genFocusOutline(token$1)) },
		[`${componentCls}-prev, ${componentCls}-next`]: { [`&:focus-visible ${componentCls}-item-link`]: genFocusOutline(token$1) }
	} };
};
const prepareComponentToken$20 = (token$1) => Object.assign({
	itemBg: token$1.colorBgContainer,
	itemSize: token$1.controlHeight,
	itemSizeSM: token$1.controlHeightSM,
	itemActiveBg: token$1.colorBgContainer,
	itemLinkBg: token$1.colorBgContainer,
	itemActiveColorDisabled: token$1.colorTextDisabled,
	itemActiveBgDisabled: token$1.controlItemBgActiveDisabled,
	itemInputBg: token$1.colorBgContainer,
	miniOptionsSizeChangerTop: 0
}, initComponentToken$1(token$1));
const prepareToken$1 = (token$1) => merge(token$1, {
	inputOutlineOffset: 0,
	quickJumperInputWidth: token$1.calc(token$1.controlHeightLG).mul(1.25).equal(),
	paginationMiniOptionsMarginInlineStart: token$1.calc(token$1.marginXXS).div(2).equal(),
	paginationMiniQuickJumperInputWidth: token$1.calc(token$1.controlHeightLG).mul(1.1).equal(),
	paginationItemPaddingInline: token$1.calc(token$1.marginXXS).mul(1.5).equal(),
	paginationEllipsisLetterSpacing: token$1.calc(token$1.marginXXS).div(2).equal(),
	paginationSlashMarginInlineStart: token$1.marginSM,
	paginationSlashMarginInlineEnd: token$1.marginSM,
	paginationEllipsisTextIndent: "0.13em"
}, initInputToken(token$1));
var style_default$22 = genStyleHooks("Pagination", (token$1) => {
	const paginationToken = prepareToken$1(token$1);
	return [genPaginationStyle$1(paginationToken), genPaginationFocusStyle(paginationToken)];
}, prepareComponentToken$20);

//#endregion
//#region node_modules/antd/es/pagination/style/bordered.js
var genBorderedStyle$2 = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
			"&, &:hover": { [`${componentCls}-item-link`]: { borderColor: token$1.colorBorder } },
			"&:focus-visible": { [`${componentCls}-item-link`]: { borderColor: token$1.colorBorder } },
			[`${componentCls}-item, ${componentCls}-item-link`]: {
				backgroundColor: token$1.colorBgContainerDisabled,
				borderColor: token$1.colorBorder,
				[`&:hover:not(${componentCls}-item-active)`]: {
					backgroundColor: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder,
					a: { color: token$1.colorTextDisabled }
				},
				[`&${componentCls}-item-active`]: { backgroundColor: token$1.itemActiveBgDisabled }
			},
			[`${componentCls}-prev, ${componentCls}-next`]: {
				"&:hover button": {
					backgroundColor: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder,
					color: token$1.colorTextDisabled
				},
				[`${componentCls}-item-link`]: {
					backgroundColor: token$1.colorBgContainerDisabled,
					borderColor: token$1.colorBorder
				}
			}
		},
		[`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
			[`${componentCls}-prev, ${componentCls}-next`]: {
				"&:hover button": {
					borderColor: token$1.colorPrimaryHover,
					backgroundColor: token$1.itemBg
				},
				[`${componentCls}-item-link`]: {
					backgroundColor: token$1.itemLinkBg,
					borderColor: token$1.colorBorder
				},
				[`&:hover ${componentCls}-item-link`]: {
					borderColor: token$1.colorPrimary,
					backgroundColor: token$1.itemBg,
					color: token$1.colorPrimary
				},
				[`&${componentCls}-disabled`]: { [`${componentCls}-item-link`]: {
					borderColor: token$1.colorBorder,
					color: token$1.colorTextDisabled
				} }
			},
			[`${componentCls}-item`]: {
				backgroundColor: token$1.itemBg,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
				[`&:hover:not(${componentCls}-item-active)`]: {
					borderColor: token$1.colorPrimary,
					backgroundColor: token$1.itemBg,
					a: { color: token$1.colorPrimary }
				},
				"&-active": { borderColor: token$1.colorPrimary }
			}
		}
	};
};
var bordered_default$1 = genSubStyleComponent(["Pagination", "bordered"], (token$1) => {
	const paginationToken = prepareToken$1(token$1);
	return genBorderedStyle$2(paginationToken);
}, prepareComponentToken$20);

//#endregion
//#region node_modules/antd/es/pagination/useShowSizeChanger.js
function useShowSizeChanger(showSizeChanger) {
	return (0, import_react.useMemo)(() => {
		if (typeof showSizeChanger === "boolean") return [showSizeChanger, {}];
		if (showSizeChanger && typeof showSizeChanger === "object") return [true, showSizeChanger];
		return [void 0, void 0];
	}, [showSizeChanger]);
}

//#endregion
//#region node_modules/antd/es/pagination/Pagination.js
var import_classnames$78 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$33 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Pagination = (props) => {
	const { align, prefixCls: customizePrefixCls, selectPrefixCls: customizeSelectPrefixCls, className, rootClassName, style: style$1, size: customizeSize, locale: customLocale, responsive, showSizeChanger, selectComponentClass, pageSizeOptions } = props, restProps = __rest$33(props, [
		"align",
		"prefixCls",
		"selectPrefixCls",
		"className",
		"rootClassName",
		"style",
		"size",
		"locale",
		"responsive",
		"showSizeChanger",
		"selectComponentClass",
		"pageSizeOptions"
	]);
	const { xs } = useBreakpoint_default(responsive);
	const [, token$1] = useToken();
	const { getPrefixCls, direction, showSizeChanger: contextShowSizeChangerConfig, className: contextClassName, style: contextStyle } = useComponentConfig("pagination");
	const prefixCls = getPrefixCls("pagination", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$22(prefixCls);
	const mergedSize = useSize_default(customizeSize);
	const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
	const [contextLocale] = useLocale_default("Pagination", en_US_default$1);
	const locale$5 = Object.assign(Object.assign({}, contextLocale), customLocale);
	const [propShowSizeChanger, propSizeChangerSelectProps] = useShowSizeChanger(showSizeChanger);
	const [contextShowSizeChanger, contextSizeChangerSelectProps] = useShowSizeChanger(contextShowSizeChangerConfig);
	const mergedShowSizeChanger = propShowSizeChanger !== null && propShowSizeChanger !== void 0 ? propShowSizeChanger : contextShowSizeChanger;
	const mergedShowSizeChangerSelectProps = propSizeChangerSelectProps !== null && propSizeChangerSelectProps !== void 0 ? propSizeChangerSelectProps : contextSizeChangerSelectProps;
	const SizeChanger = selectComponentClass || select_default;
	const mergedPageSizeOptions = import_react.useMemo(() => {
		return pageSizeOptions ? pageSizeOptions.map((option) => Number(option)) : void 0;
	}, [pageSizeOptions]);
	const sizeChangerRender = (info) => {
		var _a;
		const { disabled, size: pageSize, onSizeChange, "aria-label": ariaLabel, className: sizeChangerClassName, options } = info;
		const { className: propSizeChangerClassName, onChange: propSizeChangerOnChange } = mergedShowSizeChangerSelectProps || {};
		const selectedValue = (_a = options.find((option) => String(option.value) === String(pageSize))) === null || _a === void 0 ? void 0 : _a.value;
		return /* @__PURE__ */ import_react.createElement(SizeChanger, Object.assign({
			disabled,
			showSearch: true,
			popupMatchSelectWidth: false,
			getPopupContainer: (triggerNode) => triggerNode.parentNode,
			"aria-label": ariaLabel,
			options
		}, mergedShowSizeChangerSelectProps, {
			value: selectedValue,
			onChange: (nextSize, option) => {
				onSizeChange === null || onSizeChange === void 0 || onSizeChange(nextSize);
				propSizeChangerOnChange === null || propSizeChangerOnChange === void 0 || propSizeChangerOnChange(nextSize, option);
			},
			size: isSmall ? "small" : "middle",
			className: (0, import_classnames$78.default)(sizeChangerClassName, propSizeChangerClassName)
		}));
	};
	devUseWarning("Pagination")(!selectComponentClass, "usage", "`selectComponentClass` is not official api which will be removed.");
	const iconsProps = import_react.useMemo(() => {
		const ellipsis = /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-item-ellipsis` }, "");
		const prevIcon = /* @__PURE__ */ import_react.createElement("button", {
			className: `${prefixCls}-item-link`,
			type: "button",
			tabIndex: -1
		}, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(RightOutlined_default, null) : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null));
		const nextIcon = /* @__PURE__ */ import_react.createElement("button", {
			className: `${prefixCls}-item-link`,
			type: "button",
			tabIndex: -1
		}, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null));
		const jumpPrevIcon = /* @__PURE__ */ import_react.createElement("a", { className: `${prefixCls}-item-link` }, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-container` }, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(DoubleRightOutlined_default, { className: `${prefixCls}-item-link-icon` }) : /* @__PURE__ */ import_react.createElement(DoubleLeftOutlined_default, { className: `${prefixCls}-item-link-icon` }), ellipsis));
		const jumpNextIcon = /* @__PURE__ */ import_react.createElement("a", { className: `${prefixCls}-item-link` }, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-container` }, direction === "rtl" ? /* @__PURE__ */ import_react.createElement(DoubleLeftOutlined_default, { className: `${prefixCls}-item-link-icon` }) : /* @__PURE__ */ import_react.createElement(DoubleRightOutlined_default, { className: `${prefixCls}-item-link-icon` }), ellipsis));
		return {
			prevIcon,
			nextIcon,
			jumpPrevIcon,
			jumpNextIcon
		};
	}, [direction, prefixCls]);
	const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
	const extendedClassName = (0, import_classnames$78.default)({
		[`${prefixCls}-${align}`]: !!align,
		[`${prefixCls}-mini`]: isSmall,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-bordered`]: token$1.wireframe
	}, contextClassName, className, rootClassName, hashId, cssVarCls);
	const mergedStyle = Object.assign(Object.assign({}, contextStyle), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(import_react.Fragment, null, token$1.wireframe && /* @__PURE__ */ import_react.createElement(bordered_default$1, { prefixCls }), /* @__PURE__ */ import_react.createElement(Pagination_default$1, Object.assign({}, iconsProps, restProps, {
		style: mergedStyle,
		prefixCls,
		selectPrefixCls,
		className: extendedClassName,
		locale: locale$5,
		pageSizeOptions: mergedPageSizeOptions,
		showSizeChanger: mergedShowSizeChanger,
		sizeChangerRender
	}))));
};
Pagination.displayName = "Pagination";
var Pagination_default = Pagination;

//#endregion
//#region node_modules/antd/es/pagination/index.js
var pagination_default = Pagination_default;

//#endregion
//#region node_modules/antd/es/spin/Indicator/Progress.js
var import_classnames$77 = /* @__PURE__ */ __toESM(require_classnames());
var viewSize = 100;
var borderWidth = viewSize / 5;
var radius = viewSize / 2 - borderWidth / 2;
var circumference = radius * 2 * Math.PI;
var position = 50;
var CustomCircle = (props) => {
	const { dotClassName, style: style$1, hasCircleCls } = props;
	return /* @__PURE__ */ import_react.createElement("circle", {
		className: (0, import_classnames$77.default)(`${dotClassName}-circle`, { [`${dotClassName}-circle-bg`]: hasCircleCls }),
		r: radius,
		cx: position,
		cy: position,
		strokeWidth: borderWidth,
		style: style$1
	});
};
var Progress$1 = ({ percent, prefixCls }) => {
	const dotClassName = `${prefixCls}-dot`;
	const holderClassName = `${dotClassName}-holder`;
	const hideClassName = `${holderClassName}-hidden`;
	const [render$1, setRender] = import_react.useState(false);
	useLayoutEffect_default(() => {
		if (percent !== 0) setRender(true);
	}, [percent !== 0]);
	const safePtg = Math.max(Math.min(percent, 100), 0);
	if (!render$1) return null;
	const circleStyle = {
		strokeDashoffset: `${circumference / 4}`,
		strokeDasharray: `${circumference * safePtg / 100} ${circumference * (100 - safePtg) / 100}`
	};
	return /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$77.default)(holderClassName, `${dotClassName}-progress`, safePtg <= 0 && hideClassName) }, /* @__PURE__ */ import_react.createElement("svg", {
		viewBox: `0 0 ${viewSize} ${viewSize}`,
		role: "progressbar",
		"aria-valuemin": 0,
		"aria-valuemax": 100,
		"aria-valuenow": safePtg
	}, /* @__PURE__ */ import_react.createElement(CustomCircle, {
		dotClassName,
		hasCircleCls: true
	}), /* @__PURE__ */ import_react.createElement(CustomCircle, {
		dotClassName,
		style: circleStyle
	})));
};
var Progress_default = Progress$1;

//#endregion
//#region node_modules/antd/es/spin/Indicator/Looper.js
var import_classnames$76 = /* @__PURE__ */ __toESM(require_classnames());
function Looper(props) {
	const { prefixCls, percent = 0 } = props;
	const dotClassName = `${prefixCls}-dot`;
	const holderClassName = `${dotClassName}-holder`;
	const hideClassName = `${holderClassName}-hidden`;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$76.default)(holderClassName, percent > 0 && hideClassName) }, /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$76.default)(dotClassName, `${prefixCls}-dot-spin`) }, [
		1,
		2,
		3,
		4
	].map((i) => /* @__PURE__ */ import_react.createElement("i", {
		className: `${prefixCls}-dot-item`,
		key: i
	})))), /* @__PURE__ */ import_react.createElement(Progress_default, {
		prefixCls,
		percent
	}));
}

//#endregion
//#region node_modules/antd/es/spin/Indicator/index.js
var import_classnames$75 = /* @__PURE__ */ __toESM(require_classnames());
function Indicator(props) {
	var _a;
	const { prefixCls, indicator, percent } = props;
	const dotClassName = `${prefixCls}-dot`;
	if (indicator && /* @__PURE__ */ import_react.isValidElement(indicator)) return cloneElement(indicator, {
		className: (0, import_classnames$75.default)((_a = indicator.props) === null || _a === void 0 ? void 0 : _a.className, dotClassName),
		percent
	});
	return /* @__PURE__ */ import_react.createElement(Looper, {
		prefixCls,
		percent
	});
}

//#endregion
//#region node_modules/antd/es/spin/style/index.js
var antSpinMove = new Keyframes_default("antSpinMove", { to: { opacity: 1 } });
var antRotate = new Keyframes_default("antRotate", { to: { transform: "rotate(405deg)" } });
var genSpinStyle = (token$1) => {
	const { componentCls, calc } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "absolute",
		display: "none",
		color: token$1.colorPrimary,
		fontSize: 0,
		textAlign: "center",
		verticalAlign: "middle",
		opacity: 0,
		transition: `transform ${token$1.motionDurationSlow} ${token$1.motionEaseInOutCirc}`,
		"&-spinning": {
			position: "relative",
			display: "inline-block",
			opacity: 1
		},
		[`${componentCls}-text`]: {
			fontSize: token$1.fontSize,
			paddingTop: calc(calc(token$1.dotSize).sub(token$1.fontSize)).div(2).add(2).equal()
		},
		"&-fullscreen": {
			position: "fixed",
			width: "100vw",
			height: "100vh",
			backgroundColor: token$1.colorBgMask,
			zIndex: token$1.zIndexPopupBase,
			inset: 0,
			display: "flex",
			alignItems: "center",
			flexDirection: "column",
			justifyContent: "center",
			opacity: 0,
			visibility: "hidden",
			transition: `all ${token$1.motionDurationMid}`,
			"&-show": {
				opacity: 1,
				visibility: "visible"
			},
			[componentCls]: {
				[`${componentCls}-dot-holder`]: { color: token$1.colorWhite },
				[`${componentCls}-text`]: { color: token$1.colorTextLightSolid }
			}
		},
		"&-nested-loading": {
			position: "relative",
			[`> div > ${componentCls}`]: {
				position: "absolute",
				top: 0,
				insetInlineStart: 0,
				zIndex: 4,
				display: "block",
				width: "100%",
				height: "100%",
				maxHeight: token$1.contentHeight,
				[`${componentCls}-dot`]: {
					position: "absolute",
					top: "50%",
					insetInlineStart: "50%",
					margin: calc(token$1.dotSize).mul(-1).div(2).equal()
				},
				[`${componentCls}-text`]: {
					position: "absolute",
					top: "50%",
					width: "100%",
					textShadow: `0 1px 2px ${token$1.colorBgContainer}`
				},
				[`&${componentCls}-show-text ${componentCls}-dot`]: { marginTop: calc(token$1.dotSize).div(2).mul(-1).sub(10).equal() },
				"&-sm": {
					[`${componentCls}-dot`]: { margin: calc(token$1.dotSizeSM).mul(-1).div(2).equal() },
					[`${componentCls}-text`]: { paddingTop: calc(calc(token$1.dotSizeSM).sub(token$1.fontSize)).div(2).add(2).equal() },
					[`&${componentCls}-show-text ${componentCls}-dot`]: { marginTop: calc(token$1.dotSizeSM).div(2).mul(-1).sub(10).equal() }
				},
				"&-lg": {
					[`${componentCls}-dot`]: { margin: calc(token$1.dotSizeLG).mul(-1).div(2).equal() },
					[`${componentCls}-text`]: { paddingTop: calc(calc(token$1.dotSizeLG).sub(token$1.fontSize)).div(2).add(2).equal() },
					[`&${componentCls}-show-text ${componentCls}-dot`]: { marginTop: calc(token$1.dotSizeLG).div(2).mul(-1).sub(10).equal() }
				}
			},
			[`${componentCls}-container`]: {
				position: "relative",
				transition: `opacity ${token$1.motionDurationSlow}`,
				"&::after": {
					position: "absolute",
					top: 0,
					insetInlineEnd: 0,
					bottom: 0,
					insetInlineStart: 0,
					zIndex: 10,
					width: "100%",
					height: "100%",
					background: token$1.colorBgContainer,
					opacity: 0,
					transition: `all ${token$1.motionDurationSlow}`,
					content: "\"\"",
					pointerEvents: "none"
				}
			},
			[`${componentCls}-blur`]: {
				clear: "both",
				opacity: .5,
				userSelect: "none",
				pointerEvents: "none",
				"&::after": {
					opacity: .4,
					pointerEvents: "auto"
				}
			}
		},
		"&-tip": { color: token$1.spinDotDefault },
		[`${componentCls}-dot-holder`]: {
			width: "1em",
			height: "1em",
			fontSize: token$1.dotSize,
			display: "inline-block",
			transition: `transform ${token$1.motionDurationSlow} ease, opacity ${token$1.motionDurationSlow} ease`,
			transformOrigin: "50% 50%",
			lineHeight: 1,
			color: token$1.colorPrimary,
			"&-hidden": {
				transform: "scale(0.3)",
				opacity: 0
			}
		},
		[`${componentCls}-dot-progress`]: {
			position: "absolute",
			inset: 0
		},
		[`${componentCls}-dot`]: {
			position: "relative",
			display: "inline-block",
			fontSize: token$1.dotSize,
			width: "1em",
			height: "1em",
			"&-item": {
				position: "absolute",
				display: "block",
				width: calc(token$1.dotSize).sub(calc(token$1.marginXXS).div(2)).div(2).equal(),
				height: calc(token$1.dotSize).sub(calc(token$1.marginXXS).div(2)).div(2).equal(),
				background: "currentColor",
				borderRadius: "100%",
				transform: "scale(0.75)",
				transformOrigin: "50% 50%",
				opacity: .3,
				animationName: antSpinMove,
				animationDuration: "1s",
				animationIterationCount: "infinite",
				animationTimingFunction: "linear",
				animationDirection: "alternate",
				"&:nth-child(1)": {
					top: 0,
					insetInlineStart: 0,
					animationDelay: "0s"
				},
				"&:nth-child(2)": {
					top: 0,
					insetInlineEnd: 0,
					animationDelay: "0.4s"
				},
				"&:nth-child(3)": {
					insetInlineEnd: 0,
					bottom: 0,
					animationDelay: "0.8s"
				},
				"&:nth-child(4)": {
					bottom: 0,
					insetInlineStart: 0,
					animationDelay: "1.2s"
				}
			},
			"&-spin": {
				transform: "rotate(45deg)",
				animationName: antRotate,
				animationDuration: "1.2s",
				animationIterationCount: "infinite",
				animationTimingFunction: "linear"
			},
			"&-circle": {
				strokeLinecap: "round",
				transition: [
					"stroke-dashoffset",
					"stroke-dasharray",
					"stroke",
					"stroke-width",
					"opacity"
				].map((item) => `${item} ${token$1.motionDurationSlow} ease`).join(","),
				fillOpacity: 0,
				stroke: "currentcolor"
			},
			"&-circle-bg": { stroke: token$1.colorFillSecondary }
		},
		[`&-sm ${componentCls}-dot`]: { "&, &-holder": { fontSize: token$1.dotSizeSM } },
		[`&-sm ${componentCls}-dot-holder`]: { i: {
			width: calc(calc(token$1.dotSizeSM).sub(calc(token$1.marginXXS).div(2))).div(2).equal(),
			height: calc(calc(token$1.dotSizeSM).sub(calc(token$1.marginXXS).div(2))).div(2).equal()
		} },
		[`&-lg ${componentCls}-dot`]: { "&, &-holder": { fontSize: token$1.dotSizeLG } },
		[`&-lg ${componentCls}-dot-holder`]: { i: {
			width: calc(calc(token$1.dotSizeLG).sub(token$1.marginXXS)).div(2).equal(),
			height: calc(calc(token$1.dotSizeLG).sub(token$1.marginXXS)).div(2).equal()
		} },
		[`&${componentCls}-show-text ${componentCls}-text`]: { display: "block" }
	}) };
};
const prepareComponentToken$19 = (token$1) => {
	const { controlHeightLG, controlHeight } = token$1;
	return {
		contentHeight: 400,
		dotSize: controlHeightLG / 2,
		dotSizeSM: controlHeightLG * .35,
		dotSizeLG: controlHeight
	};
};
var style_default$21 = genStyleHooks("Spin", (token$1) => {
	const spinToken = merge(token$1, { spinDotDefault: token$1.colorTextDescription });
	return genSpinStyle(spinToken);
}, prepareComponentToken$19);

//#endregion
//#region node_modules/antd/es/spin/usePercent.js
var AUTO_INTERVAL = 200;
var STEP_BUCKETS = [
	[30, .05],
	[70, .03],
	[96, .01]
];
function usePercent(spinning, percent) {
	const [mockPercent, setMockPercent] = import_react.useState(0);
	const mockIntervalRef = import_react.useRef(null);
	const isAuto = percent === "auto";
	import_react.useEffect(() => {
		if (isAuto && spinning) {
			setMockPercent(0);
			mockIntervalRef.current = setInterval(() => {
				setMockPercent((prev$1) => {
					const restPTG = 100 - prev$1;
					for (let i = 0; i < STEP_BUCKETS.length; i += 1) {
						const [limit, stepPtg] = STEP_BUCKETS[i];
						if (prev$1 <= limit) return prev$1 + restPTG * stepPtg;
					}
					return prev$1;
				});
			}, AUTO_INTERVAL);
		}
		return () => {
			clearInterval(mockIntervalRef.current);
		};
	}, [isAuto, spinning]);
	return isAuto ? mockPercent : percent;
}

//#endregion
//#region node_modules/antd/es/spin/index.js
var import_classnames$74 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$32 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var defaultIndicator;
function shouldDelay(spinning, delay) {
	return !!spinning && !!delay && !Number.isNaN(Number(delay));
}
var Spin = (props) => {
	var _a;
	const { prefixCls: customizePrefixCls, spinning: customSpinning = true, delay = 0, className, rootClassName, size = "default", tip, wrapperClassName, style: style$1, children, fullscreen = false, indicator, percent } = props, restProps = __rest$32(props, [
		"prefixCls",
		"spinning",
		"delay",
		"className",
		"rootClassName",
		"size",
		"tip",
		"wrapperClassName",
		"style",
		"children",
		"fullscreen",
		"indicator",
		"percent"
	]);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle, indicator: contextIndicator } = useComponentConfig("spin");
	const prefixCls = getPrefixCls("spin", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$21(prefixCls);
	const [spinning, setSpinning] = import_react.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
	const mergedPercent = usePercent(spinning, percent);
	import_react.useEffect(() => {
		if (customSpinning) {
			const showSpinning = debounce(delay, () => {
				setSpinning(true);
			});
			showSpinning();
			return () => {
				var _a$1;
				(_a$1 = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a$1 === void 0 || _a$1.call(showSpinning);
			};
		}
		setSpinning(false);
	}, [delay, customSpinning]);
	const isNestedPattern = import_react.useMemo(() => typeof children !== "undefined" && !fullscreen, [children, fullscreen]);
	devUseWarning("Spin")(!tip || isNestedPattern || fullscreen, "usage", "`tip` only work in nest or fullscreen pattern.");
	const spinClassName = (0, import_classnames$74.default)(prefixCls, contextClassName, {
		[`${prefixCls}-sm`]: size === "small",
		[`${prefixCls}-lg`]: size === "large",
		[`${prefixCls}-spinning`]: spinning,
		[`${prefixCls}-show-text`]: !!tip,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, !fullscreen && rootClassName, hashId, cssVarCls);
	const containerClassName = (0, import_classnames$74.default)(`${prefixCls}-container`, { [`${prefixCls}-blur`]: spinning });
	const mergedIndicator = (_a = indicator !== null && indicator !== void 0 ? indicator : contextIndicator) !== null && _a !== void 0 ? _a : defaultIndicator;
	const mergedStyle = Object.assign(Object.assign({}, contextStyle), style$1);
	const spinElement = /* @__PURE__ */ import_react.createElement("div", Object.assign({}, restProps, {
		style: mergedStyle,
		className: spinClassName,
		"aria-live": "polite",
		"aria-busy": spinning
	}), /* @__PURE__ */ import_react.createElement(Indicator, {
		prefixCls,
		indicator: mergedIndicator,
		percent: mergedPercent
	}), tip && (isNestedPattern || fullscreen) ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-text` }, tip) : null);
	if (isNestedPattern) return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({}, restProps, { className: (0, import_classnames$74.default)(`${prefixCls}-nested-loading`, wrapperClassName, hashId, cssVarCls) }), spinning && /* @__PURE__ */ import_react.createElement("div", { key: "loading" }, spinElement), /* @__PURE__ */ import_react.createElement("div", {
		className: containerClassName,
		key: "container"
	}, children)));
	if (fullscreen) return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$74.default)(`${prefixCls}-fullscreen`, { [`${prefixCls}-fullscreen-show`]: spinning }, rootClassName, hashId, cssVarCls) }, spinElement));
	return wrapCSSVar(spinElement);
};
Spin.setDefaultIndicator = (indicator) => {
	defaultIndicator = indicator;
};
Spin.displayName = "Spin";
var spin_default = Spin;

//#endregion
//#region node_modules/antd/es/list/context.js
const ListContext = /* @__PURE__ */ import_react.createContext({});
const ListConsumer = ListContext.Consumer;

//#endregion
//#region node_modules/antd/es/list/Item.js
var import_classnames$73 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$31 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const Meta = (_a) => {
	var { prefixCls: customizePrefixCls, className, avatar, title, description } = _a, others = __rest$31(_a, [
		"prefixCls",
		"className",
		"avatar",
		"title",
		"description"
	]);
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("list", customizePrefixCls);
	const classString = (0, import_classnames$73.default)(`${prefixCls}-item-meta`, className);
	const content = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-meta-content` }, title && /* @__PURE__ */ import_react.createElement("h4", { className: `${prefixCls}-item-meta-title` }, title), description && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-meta-description` }, description));
	return /* @__PURE__ */ import_react.createElement("div", Object.assign({}, others, { className: classString }), avatar && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-meta-avatar` }, avatar), (title || description) && content);
};
var Item = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, children, actions, extra, styles, className, classNames: customizeClassNames, colStyle } = props, others = __rest$31(props, [
		"prefixCls",
		"children",
		"actions",
		"extra",
		"styles",
		"className",
		"classNames",
		"colStyle"
	]);
	const { grid, itemLayout } = (0, import_react.useContext)(ListContext);
	const { getPrefixCls, list } = (0, import_react.useContext)(ConfigContext);
	const moduleClass = (moduleName) => {
		var _a, _b;
		return (0, import_classnames$73.default)((_b = (_a = list === null || list === void 0 ? void 0 : list.item) === null || _a === void 0 ? void 0 : _a.classNames) === null || _b === void 0 ? void 0 : _b[moduleName], customizeClassNames === null || customizeClassNames === void 0 ? void 0 : customizeClassNames[moduleName]);
	};
	const moduleStyle = (moduleName) => {
		var _a, _b;
		return Object.assign(Object.assign({}, (_b = (_a = list === null || list === void 0 ? void 0 : list.item) === null || _a === void 0 ? void 0 : _a.styles) === null || _b === void 0 ? void 0 : _b[moduleName]), styles === null || styles === void 0 ? void 0 : styles[moduleName]);
	};
	const isItemContainsTextNodeAndNotSingular = () => {
		let result = false;
		import_react.Children.forEach(children, (element) => {
			if (typeof element === "string") result = true;
		});
		return result && import_react.Children.count(children) > 1;
	};
	const isFlexMode = () => {
		if (itemLayout === "vertical") return !!extra;
		return !isItemContainsTextNodeAndNotSingular();
	};
	const prefixCls = getPrefixCls("list", customizePrefixCls);
	const actionsContent = actions && actions.length > 0 && /* @__PURE__ */ import_react.createElement("ul", {
		className: (0, import_classnames$73.default)(`${prefixCls}-item-action`, moduleClass("actions")),
		key: "actions",
		style: moduleStyle("actions")
	}, actions.map((action, i) => /* @__PURE__ */ import_react.createElement("li", { key: `${prefixCls}-item-action-${i}` }, action, i !== actions.length - 1 && /* @__PURE__ */ import_react.createElement("em", { className: `${prefixCls}-item-action-split` }))));
	const Element$2 = grid ? "div" : "li";
	const itemChildren = /* @__PURE__ */ import_react.createElement(Element$2, Object.assign({}, others, !grid ? { ref } : {}, { className: (0, import_classnames$73.default)(`${prefixCls}-item`, { [`${prefixCls}-item-no-flex`]: !isFlexMode() }, className) }), itemLayout === "vertical" && extra ? [/* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-item-main`,
		key: "content"
	}, children, actionsContent), /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$73.default)(`${prefixCls}-item-extra`, moduleClass("extra")),
		key: "extra",
		style: moduleStyle("extra")
	}, extra)] : [
		children,
		actionsContent,
		cloneElement(extra, { key: "extra" })
	]);
	return grid ? /* @__PURE__ */ import_react.createElement(col_default$1, {
		ref,
		flex: 1,
		style: colStyle
	}, itemChildren) : itemChildren;
});
Item.Meta = Meta;
var Item_default = Item;

//#endregion
//#region node_modules/antd/es/list/style/index.js
var genBorderedStyle$1 = (token$1) => {
	const { listBorderedCls, componentCls, paddingLG, margin, itemPaddingSM, itemPaddingLG, marginLG, borderRadiusLG } = token$1;
	return {
		[listBorderedCls]: {
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
			borderRadius: borderRadiusLG,
			[`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: { paddingInline: paddingLG },
			[`${componentCls}-pagination`]: { margin: `${unit(margin)} ${unit(marginLG)}` }
		},
		[`${listBorderedCls}${componentCls}-sm`]: { [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: { padding: itemPaddingSM } },
		[`${listBorderedCls}${componentCls}-lg`]: { [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: { padding: itemPaddingLG } }
	};
};
var genResponsiveStyle = (token$1) => {
	const { componentCls, screenSM, screenMD, marginLG, marginSM, margin } = token$1;
	return {
		[`@media screen and (max-width:${screenMD}px)`]: {
			[componentCls]: { [`${componentCls}-item`]: { [`${componentCls}-item-action`]: { marginInlineStart: marginLG } } },
			[`${componentCls}-vertical`]: { [`${componentCls}-item`]: { [`${componentCls}-item-extra`]: { marginInlineStart: marginLG } } }
		},
		[`@media screen and (max-width: ${screenSM}px)`]: {
			[componentCls]: { [`${componentCls}-item`]: {
				flexWrap: "wrap",
				[`${componentCls}-action`]: { marginInlineStart: marginSM }
			} },
			[`${componentCls}-vertical`]: { [`${componentCls}-item`]: {
				flexWrap: "wrap-reverse",
				[`${componentCls}-item-main`]: { minWidth: token$1.contentWidth },
				[`${componentCls}-item-extra`]: { margin: `auto auto ${unit(margin)}` }
			} }
		}
	};
};
var genBaseStyle$8 = (token$1) => {
	const { componentCls, antCls, controlHeight, minHeight, paddingSM, marginLG, padding, itemPadding, colorPrimary, itemPaddingSM, itemPaddingLG, paddingXS, margin, colorText, colorTextDescription, motionDurationSlow, lineWidth, headerBg, footerBg, emptyTextPadding, metaMarginBottom, avatarMarginRight, titleMarginBottom, descriptionFontSize } = token$1;
	return {
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "relative",
			["--rc-virtual-list-scrollbar-bg"]: token$1.colorSplit,
			"*": { outline: "none" },
			[`${componentCls}-header`]: { background: headerBg },
			[`${componentCls}-footer`]: { background: footerBg },
			[`${componentCls}-header, ${componentCls}-footer`]: { paddingBlock: paddingSM },
			[`${componentCls}-pagination`]: {
				marginBlockStart: marginLG,
				[`${antCls}-pagination-options`]: { textAlign: "start" }
			},
			[`${componentCls}-spin`]: {
				minHeight,
				textAlign: "center"
			},
			[`${componentCls}-items`]: {
				margin: 0,
				padding: 0,
				listStyle: "none"
			},
			[`${componentCls}-item`]: {
				display: "flex",
				alignItems: "center",
				justifyContent: "space-between",
				padding: itemPadding,
				color: colorText,
				[`${componentCls}-item-meta`]: {
					display: "flex",
					flex: 1,
					alignItems: "flex-start",
					maxWidth: "100%",
					[`${componentCls}-item-meta-avatar`]: { marginInlineEnd: avatarMarginRight },
					[`${componentCls}-item-meta-content`]: {
						flex: "1 0",
						width: 0,
						color: colorText
					},
					[`${componentCls}-item-meta-title`]: {
						margin: `0 0 ${unit(token$1.marginXXS)} 0`,
						color: colorText,
						fontSize: token$1.fontSize,
						lineHeight: token$1.lineHeight,
						"> a": {
							color: colorText,
							transition: `all ${motionDurationSlow}`,
							"&:hover": { color: colorPrimary }
						}
					},
					[`${componentCls}-item-meta-description`]: {
						color: colorTextDescription,
						fontSize: descriptionFontSize,
						lineHeight: token$1.lineHeight
					}
				},
				[`${componentCls}-item-action`]: {
					flex: "0 0 auto",
					marginInlineStart: token$1.marginXXL,
					padding: 0,
					fontSize: 0,
					listStyle: "none",
					"& > li": {
						position: "relative",
						display: "inline-block",
						padding: `0 ${unit(paddingXS)}`,
						color: colorTextDescription,
						fontSize: token$1.fontSize,
						lineHeight: token$1.lineHeight,
						textAlign: "center",
						"&:first-child": { paddingInlineStart: 0 }
					},
					[`${componentCls}-item-action-split`]: {
						position: "absolute",
						insetBlockStart: "50%",
						insetInlineEnd: 0,
						width: lineWidth,
						height: token$1.calc(token$1.fontHeight).sub(token$1.calc(token$1.marginXXS).mul(2)).equal(),
						transform: "translateY(-50%)",
						backgroundColor: token$1.colorSplit
					}
				}
			},
			[`${componentCls}-empty`]: {
				padding: `${unit(padding)} 0`,
				color: colorTextDescription,
				fontSize: token$1.fontSizeSM,
				textAlign: "center"
			},
			[`${componentCls}-empty-text`]: {
				padding: emptyTextPadding,
				color: token$1.colorTextDisabled,
				fontSize: token$1.fontSize,
				textAlign: "center"
			},
			[`${componentCls}-item-no-flex`]: { display: "block" }
		}),
		[`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
			display: "block",
			maxWidth: "100%",
			marginBlockEnd: margin,
			paddingBlock: 0,
			borderBlockEnd: "none"
		},
		[`${componentCls}-vertical ${componentCls}-item`]: {
			alignItems: "initial",
			[`${componentCls}-item-main`]: {
				display: "block",
				flex: 1
			},
			[`${componentCls}-item-extra`]: { marginInlineStart: marginLG },
			[`${componentCls}-item-meta`]: {
				marginBlockEnd: metaMarginBottom,
				[`${componentCls}-item-meta-title`]: {
					marginBlockStart: 0,
					marginBlockEnd: titleMarginBottom,
					color: colorText,
					fontSize: token$1.fontSizeLG,
					lineHeight: token$1.lineHeightLG
				}
			},
			[`${componentCls}-item-action`]: {
				marginBlockStart: padding,
				marginInlineStart: "auto",
				"> li": {
					padding: `0 ${unit(padding)}`,
					"&:first-child": { paddingInlineStart: 0 }
				}
			}
		},
		[`${componentCls}-split ${componentCls}-item`]: {
			borderBlockEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}`,
			"&:last-child": { borderBlockEnd: "none" }
		},
		[`${componentCls}-split ${componentCls}-header`]: { borderBlockEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
		[`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: { borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
		[`${componentCls}-loading ${componentCls}-spin-nested-loading`]: { minHeight: controlHeight },
		[`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: { borderBlockEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorSplit}` },
		[`${componentCls}-lg ${componentCls}-item`]: { padding: itemPaddingLG },
		[`${componentCls}-sm ${componentCls}-item`]: { padding: itemPaddingSM },
		[`${componentCls}:not(${componentCls}-vertical)`]: { [`${componentCls}-item-no-flex`]: { [`${componentCls}-item-action`]: { float: "right" } } }
	};
};
const prepareComponentToken$18 = (token$1) => ({
	contentWidth: 220,
	itemPadding: `${unit(token$1.paddingContentVertical)} 0`,
	itemPaddingSM: `${unit(token$1.paddingContentVerticalSM)} ${unit(token$1.paddingContentHorizontal)}`,
	itemPaddingLG: `${unit(token$1.paddingContentVerticalLG)} ${unit(token$1.paddingContentHorizontalLG)}`,
	headerBg: "transparent",
	footerBg: "transparent",
	emptyTextPadding: token$1.padding,
	metaMarginBottom: token$1.padding,
	avatarMarginRight: token$1.padding,
	titleMarginBottom: token$1.paddingSM,
	descriptionFontSize: token$1.fontSize
});
var style_default$20 = genStyleHooks("List", (token$1) => {
	const listToken = merge(token$1, {
		listBorderedCls: `${token$1.componentCls}-bordered`,
		minHeight: token$1.controlHeightLG
	});
	return [
		genBaseStyle$8(listToken),
		genBorderedStyle$1(listToken),
		genResponsiveStyle(listToken)
	];
}, prepareComponentToken$18);

//#endregion
//#region node_modules/antd/es/list/index.js
var import_classnames$72 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$30 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function InternalList(props, ref) {
	const { pagination = false, prefixCls: customizePrefixCls, bordered = false, split = true, className, rootClassName, style: style$1, children, itemLayout, loadMore, grid, dataSource = [], size: customizeSize, header, footer, loading = false, rowKey, renderItem: renderItem$1, locale: locale$5 } = props, rest = __rest$30(props, [
		"pagination",
		"prefixCls",
		"bordered",
		"split",
		"className",
		"rootClassName",
		"style",
		"children",
		"itemLayout",
		"loadMore",
		"grid",
		"dataSource",
		"size",
		"header",
		"footer",
		"loading",
		"rowKey",
		"renderItem",
		"locale"
	]);
	const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
	const [paginationCurrent, setPaginationCurrent] = import_react.useState(paginationObj.defaultCurrent || 1);
	const [paginationSize, setPaginationSize] = import_react.useState(paginationObj.defaultPageSize || 10);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("list");
	const { renderEmpty } = import_react.useContext(ConfigContext);
	const defaultPaginationProps = {
		current: 1,
		total: 0,
		position: "bottom"
	};
	const triggerPaginationEvent = (eventName) => (page, pageSize) => {
		var _a;
		setPaginationCurrent(page);
		setPaginationSize(pageSize);
		if (pagination) (_a = pagination === null || pagination === void 0 ? void 0 : pagination[eventName]) === null || _a === void 0 || _a.call(pagination, page, pageSize);
	};
	const onPaginationChange = triggerPaginationEvent("onChange");
	const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
	const renderInternalItem = (item, index$2) => {
		if (!renderItem$1) return null;
		let key;
		if (typeof rowKey === "function") key = rowKey(item);
		else if (rowKey) key = item[rowKey];
		else key = item.key;
		if (!key) key = `list-item-${index$2}`;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, { key }, renderItem$1(item, index$2));
	};
	const isSomethingAfterLastItem = !!(loadMore || pagination || footer);
	const prefixCls = getPrefixCls("list", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$20(prefixCls);
	let loadingProp = loading;
	if (typeof loadingProp === "boolean") loadingProp = { spinning: loadingProp };
	const isLoading = !!(loadingProp === null || loadingProp === void 0 ? void 0 : loadingProp.spinning);
	const mergedSize = useSize_default(customizeSize);
	let sizeCls = "";
	switch (mergedSize) {
		case "large":
			sizeCls = "lg";
			break;
		case "small":
			sizeCls = "sm";
			break;
		default: break;
	}
	const classString = (0, import_classnames$72.default)(prefixCls, {
		[`${prefixCls}-vertical`]: itemLayout === "vertical",
		[`${prefixCls}-${sizeCls}`]: sizeCls,
		[`${prefixCls}-split`]: split,
		[`${prefixCls}-bordered`]: bordered,
		[`${prefixCls}-loading`]: isLoading,
		[`${prefixCls}-grid`]: !!grid,
		[`${prefixCls}-something-after-last-item`]: isSomethingAfterLastItem,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, contextClassName, className, rootClassName, hashId, cssVarCls);
	const paginationProps = extendsObject_default(defaultPaginationProps, {
		total: dataSource.length,
		current: paginationCurrent,
		pageSize: paginationSize
	}, pagination || {});
	const largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
	paginationProps.current = Math.min(paginationProps.current, largestPage);
	const paginationContent = pagination && /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$72.default)(`${prefixCls}-pagination`) }, /* @__PURE__ */ import_react.createElement(pagination_default, Object.assign({ align: "end" }, paginationProps, {
		onChange: onPaginationChange,
		onShowSizeChange: onPaginationShowSizeChange
	})));
	let splitDataSource = _toConsumableArray(dataSource);
	if (pagination) {
		if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) splitDataSource = _toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
	}
	const needResponsive = Object.keys(grid || {}).some((key) => [
		"xs",
		"sm",
		"md",
		"lg",
		"xl",
		"xxl"
	].includes(key));
	const screens = useBreakpoint_default(needResponsive);
	const currentBreakpoint = import_react.useMemo(() => {
		for (let i = 0; i < responsiveArray.length; i += 1) {
			const breakpoint = responsiveArray[i];
			if (screens[breakpoint]) return breakpoint;
		}
	}, [screens]);
	const colStyle = import_react.useMemo(() => {
		if (!grid) return;
		const columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
		if (columnCount) return {
			width: `${100 / columnCount}%`,
			maxWidth: `${100 / columnCount}%`
		};
	}, [JSON.stringify(grid), currentBreakpoint]);
	let childrenContent = isLoading && /* @__PURE__ */ import_react.createElement("div", { style: { minHeight: 53 } });
	if (splitDataSource.length > 0) {
		const items = splitDataSource.map(renderInternalItem);
		childrenContent = grid ? /* @__PURE__ */ import_react.createElement(row_default$1, { gutter: grid.gutter }, import_react.Children.map(items, (child) => /* @__PURE__ */ import_react.createElement("div", {
			key: child === null || child === void 0 ? void 0 : child.key,
			style: colStyle
		}, child))) : /* @__PURE__ */ import_react.createElement("ul", { className: `${prefixCls}-items` }, items);
	} else if (!children && !isLoading) childrenContent = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-empty-text` }, (locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.emptyText) || (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("List")) || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "List" }));
	const paginationPosition = paginationProps.position;
	const contextValue = import_react.useMemo(() => ({
		grid,
		itemLayout
	}), [JSON.stringify(grid), itemLayout]);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(ListContext.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement("div", Object.assign({
		ref,
		style: Object.assign(Object.assign({}, contextStyle), style$1),
		className: classString
	}, rest), (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-header` }, header), /* @__PURE__ */ import_react.createElement(spin_default, Object.assign({}, loadingProp), childrenContent, children), footer && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-footer` }, footer), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent)));
}
var ListWithForwardRef = /* @__PURE__ */ import_react.forwardRef(InternalList);
ListWithForwardRef.displayName = "List";
var List = ListWithForwardRef;
List.Item = Item_default;
var list_default = List;

//#endregion
//#region node_modules/rc-mentions/es/hooks/useEffectState.js
/**
* Trigger a callback on state change
*/
function useEffectState() {
	var _useState = (0, import_react.useState)({
		id: 0,
		callback: null
	}), _useState2 = _slicedToArray(_useState, 2), effectId = _useState2[0], setEffectId = _useState2[1];
	var update = (0, import_react.useCallback)(function(callback) {
		setEffectId(function(_ref) {
			return {
				id: _ref.id + 1,
				callback
			};
		});
	}, []);
	(0, import_react.useEffect)(function() {
		var _effectId$callback;
		(_effectId$callback = effectId.callback) === null || _effectId$callback === void 0 || _effectId$callback.call(effectId);
	}, [effectId]);
	return update;
}

//#endregion
//#region node_modules/rc-mentions/es/MentionsContext.js
var MentionsContext = /* @__PURE__ */ import_react.createContext(null);
var MentionsContext_default = MentionsContext;

//#endregion
//#region node_modules/rc-mentions/es/DropdownMenu.js
/**
* We only use Menu to display the candidate.
* The focus is controlled by textarea to make accessibility easy.
*/
function DropdownMenu(props) {
	var _React$useContext = import_react.useContext(MentionsContext_default), notFoundContent = _React$useContext.notFoundContent, activeIndex = _React$useContext.activeIndex, setActiveIndex = _React$useContext.setActiveIndex, selectOption = _React$useContext.selectOption, onFocus = _React$useContext.onFocus, onBlur = _React$useContext.onBlur, onScroll = _React$useContext.onScroll;
	var prefixCls = props.prefixCls, options = props.options;
	var activeOption = options[activeIndex] || {};
	return /* @__PURE__ */ import_react.createElement(es_default$14, {
		prefixCls: "".concat(prefixCls, "-menu"),
		activeKey: activeOption.key,
		onSelect: function onSelect(_ref) {
			var key = _ref.key;
			var option = options.find(function(_ref2) {
				return _ref2.key === key;
			});
			selectOption(option);
		},
		onFocus,
		onBlur,
		onScroll
	}, options.map(function(option, index$2) {
		var key = option.key, disabled = option.disabled, className = option.className, style$1 = option.style, label = option.label;
		return /* @__PURE__ */ import_react.createElement(MenuItem_default, {
			key,
			disabled,
			className,
			style: style$1,
			onMouseEnter: function onMouseEnter() {
				setActiveIndex(index$2);
			}
		}, label);
	}), !options.length && /* @__PURE__ */ import_react.createElement(MenuItem_default, { disabled: true }, notFoundContent));
}
var DropdownMenu_default = DropdownMenu;

//#endregion
//#region node_modules/rc-mentions/es/KeywordTrigger.js
var BUILT_IN_PLACEMENTS = {
	bottomRight: {
		points: ["tl", "br"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	bottomLeft: {
		points: ["tr", "bl"],
		offset: [0, 4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	topRight: {
		points: ["bl", "tr"],
		offset: [0, -4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	},
	topLeft: {
		points: ["br", "tl"],
		offset: [0, -4],
		overflow: {
			adjustX: 1,
			adjustY: 1
		}
	}
};
var KeywordTrigger = function KeywordTrigger$1(props) {
	var prefixCls = props.prefixCls, options = props.options, children = props.children, visible = props.visible, transitionName = props.transitionName, getPopupContainer = props.getPopupContainer, dropdownClassName = props.dropdownClassName, direction = props.direction, placement = props.placement;
	var dropdownPrefix = "".concat(prefixCls, "-dropdown");
	var dropdownElement = /* @__PURE__ */ import_react.createElement(DropdownMenu_default, {
		prefixCls: dropdownPrefix,
		options
	});
	var dropdownPlacement = (0, import_react.useMemo)(function() {
		var popupPlacement;
		if (direction === "rtl") popupPlacement = placement === "top" ? "topLeft" : "bottomLeft";
		else popupPlacement = placement === "top" ? "topRight" : "bottomRight";
		return popupPlacement;
	}, [direction, placement]);
	return /* @__PURE__ */ import_react.createElement(es_default$7, {
		prefixCls: dropdownPrefix,
		popupVisible: visible,
		popup: dropdownElement,
		popupPlacement: dropdownPlacement,
		popupTransitionName: transitionName,
		builtinPlacements: BUILT_IN_PLACEMENTS,
		getPopupContainer,
		popupClassName: dropdownClassName
	}, children);
};
var KeywordTrigger_default = KeywordTrigger;

//#endregion
//#region node_modules/rc-mentions/es/Option.js
var Option$1 = function Option$5() {
	return null;
};
var Option_default = Option$1;

//#endregion
//#region node_modules/rc-mentions/es/util.js
/**
* Cut input selection into 2 part and return text before selection start
*/
function getBeforeSelectionText(input) {
	var selectionStart = input.selectionStart;
	return input.value.slice(0, selectionStart);
}
/**
* Find the last match prefix index
*/
function getLastMeasureIndex(text, prefix) {
	return prefix.reduce(function(lastMatch, prefixStr) {
		var lastIndex = text.lastIndexOf(prefixStr);
		if (lastIndex > lastMatch.location) return {
			location: lastIndex,
			prefix: prefixStr
		};
		return lastMatch;
	}, {
		location: -1,
		prefix: ""
	});
}
function lower(char$1) {
	return (char$1 || "").toLowerCase();
}
function reduceText(text, targetText, split) {
	var firstChar = text[0];
	if (!firstChar || firstChar === split) return text;
	var restText = text;
	var targetTextLen = targetText.length;
	for (var i = 0; i < targetTextLen; i += 1) if (lower(restText[i]) !== lower(targetText[i])) {
		restText = restText.slice(i);
		break;
	} else if (i === targetTextLen - 1) restText = restText.slice(targetTextLen);
	return restText;
}
/**
* Paint targetText into current text:
*  text: little@litest
*  targetText: light
*  => little @light test
*/
function replaceWithMeasure(text, measureConfig) {
	var measureLocation = measureConfig.measureLocation, prefix = measureConfig.prefix, targetText = measureConfig.targetText, selectionStart = measureConfig.selectionStart, split = measureConfig.split;
	var beforeMeasureText = text.slice(0, measureLocation);
	if (beforeMeasureText[beforeMeasureText.length - split.length] === split) beforeMeasureText = beforeMeasureText.slice(0, beforeMeasureText.length - split.length);
	if (beforeMeasureText) beforeMeasureText = "".concat(beforeMeasureText).concat(split);
	var restText = reduceText(text.slice(selectionStart), targetText.slice(selectionStart - measureLocation - prefix.length), split);
	if (restText.slice(0, split.length) === split) restText = restText.slice(split.length);
	var connectedStartText = "".concat(beforeMeasureText).concat(prefix).concat(targetText).concat(split);
	return {
		text: "".concat(connectedStartText).concat(restText),
		selectionLocation: connectedStartText.length
	};
}
function setInputSelection(input, location) {
	input.setSelectionRange(location, location);
	/**
	* Reset caret into view.
	* Since this function always called by user control, it's safe to focus element.
	*/
	input.blur();
	input.focus();
}
function validateSearch(text, split) {
	return !split || text.indexOf(split) === -1;
}
function filterOption(input, _ref) {
	var _ref$value = _ref.value, value = _ref$value === void 0 ? "" : _ref$value;
	var lowerCase = input.toLowerCase();
	return value.toLowerCase().indexOf(lowerCase) !== -1;
}

//#endregion
//#region node_modules/rc-mentions/es/Mentions.js
var import_classnames$71 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$21 = [
	"prefixCls",
	"className",
	"style",
	"prefix",
	"split",
	"notFoundContent",
	"value",
	"defaultValue",
	"children",
	"options",
	"open",
	"allowClear",
	"silent",
	"validateSearch",
	"filterOption",
	"onChange",
	"onKeyDown",
	"onKeyUp",
	"onPressEnter",
	"onSearch",
	"onSelect",
	"onFocus",
	"onBlur",
	"transitionName",
	"placement",
	"direction",
	"getPopupContainer",
	"dropdownClassName",
	"rows",
	"visible",
	"onPopupScroll"
], _excluded2$1 = [
	"suffix",
	"prefixCls",
	"defaultValue",
	"value",
	"allowClear",
	"onChange",
	"classNames",
	"className",
	"disabled",
	"onClear"
];
var InternalMentions = /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
	var prefixCls = props.prefixCls, className = props.className, style$1 = props.style, _props$prefix = props.prefix, prefix = _props$prefix === void 0 ? "@" : _props$prefix, _props$split = props.split, split = _props$split === void 0 ? " " : _props$split, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, value = props.value, defaultValue = props.defaultValue, children = props.children, options = props.options, open$2 = props.open;
	props.allowClear;
	var silent = props.silent, _props$validateSearch = props.validateSearch, validateSearch$1 = _props$validateSearch === void 0 ? validateSearch : _props$validateSearch, _props$filterOption = props.filterOption, filterOption$1 = _props$filterOption === void 0 ? filterOption : _props$filterOption, onChange = props.onChange, onKeyDown$1 = props.onKeyDown, onKeyUp = props.onKeyUp, onPressEnter = props.onPressEnter, onSearch = props.onSearch, onSelect = props.onSelect, onFocus = props.onFocus, onBlur = props.onBlur, transitionName = props.transitionName, placement = props.placement, direction = props.direction, getPopupContainer = props.getPopupContainer, dropdownClassName = props.dropdownClassName, _props$rows = props.rows, rows = _props$rows === void 0 ? 1 : _props$rows;
	props.visible;
	var onPopupScroll = props.onPopupScroll, restProps = _objectWithoutProperties(props, _excluded$21);
	var mergedPrefix = (0, import_react.useMemo)(function() {
		return Array.isArray(prefix) ? prefix : [prefix];
	}, [prefix]);
	var containerRef = (0, import_react.useRef)(null);
	var textareaRef = (0, import_react.useRef)(null);
	var measureRef = (0, import_react.useRef)(null);
	var getTextArea = function getTextArea$1() {
		var _textareaRef$current;
		return (_textareaRef$current = textareaRef.current) === null || _textareaRef$current === void 0 || (_textareaRef$current = _textareaRef$current.resizableTextArea) === null || _textareaRef$current === void 0 ? void 0 : _textareaRef$current.textArea;
	};
	import_react.useImperativeHandle(ref, function() {
		var _textareaRef$current4;
		return {
			focus: function focus() {
				var _textareaRef$current2;
				return (_textareaRef$current2 = textareaRef.current) === null || _textareaRef$current2 === void 0 ? void 0 : _textareaRef$current2.focus();
			},
			blur: function blur() {
				var _textareaRef$current3;
				return (_textareaRef$current3 = textareaRef.current) === null || _textareaRef$current3 === void 0 ? void 0 : _textareaRef$current3.blur();
			},
			textarea: (_textareaRef$current4 = textareaRef.current) === null || _textareaRef$current4 === void 0 || (_textareaRef$current4 = _textareaRef$current4.resizableTextArea) === null || _textareaRef$current4 === void 0 ? void 0 : _textareaRef$current4.textArea,
			nativeElement: containerRef.current
		};
	});
	var _useState = (0, import_react.useState)(false), _useState2 = _slicedToArray(_useState, 2), measuring = _useState2[0], setMeasuring = _useState2[1];
	var _useState3 = (0, import_react.useState)(""), _useState4 = _slicedToArray(_useState3, 2), measureText = _useState4[0], setMeasureText = _useState4[1];
	var _useState5 = (0, import_react.useState)(""), _useState6 = _slicedToArray(_useState5, 2), measurePrefix = _useState6[0], setMeasurePrefix = _useState6[1];
	var _useState7 = (0, import_react.useState)(0), _useState8 = _slicedToArray(_useState7, 2), measureLocation = _useState8[0], setMeasureLocation = _useState8[1];
	var _useState9 = (0, import_react.useState)(0), _useState10 = _slicedToArray(_useState9, 2), activeIndex = _useState10[0], setActiveIndex = _useState10[1];
	var _useState11 = (0, import_react.useState)(false), _useState12 = _slicedToArray(_useState11, 2), isFocus = _useState12[0], setIsFocus = _useState12[1];
	var _useMergedState = useMergedState("", {
		defaultValue,
		value
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
	(0, import_react.useEffect)(function() {
		if (measuring && measureRef.current) measureRef.current.scrollTop = getTextArea().scrollTop;
	}, [measuring]);
	var _React$useMemo = import_react.useMemo(function() {
		if (open$2) {
			warning_default(false, "`open` of Mentions is only used for debug usage. Do not use in you production.");
			for (var i = 0; i < mergedPrefix.length; i += 1) {
				var curPrefix = mergedPrefix[i];
				var index$2 = mergedValue.lastIndexOf(curPrefix);
				if (index$2 >= 0) return [
					true,
					"",
					curPrefix,
					index$2
				];
			}
		}
		return [
			measuring,
			measureText,
			measurePrefix,
			measureLocation
		];
	}, [
		open$2,
		measuring,
		mergedPrefix,
		mergedValue,
		measureText,
		measurePrefix,
		measureLocation
	]), _React$useMemo2 = _slicedToArray(_React$useMemo, 4), mergedMeasuring = _React$useMemo2[0], mergedMeasureText = _React$useMemo2[1], mergedMeasurePrefix = _React$useMemo2[2], mergedMeasureLocation = _React$useMemo2[3];
	var getOptions = import_react.useCallback(function(targetMeasureText) {
		var list;
		if (options && options.length > 0) list = options.map(function(item) {
			var _item$key;
			return _objectSpread2(_objectSpread2({}, item), {}, { key: (_item$key = item === null || item === void 0 ? void 0 : item.key) !== null && _item$key !== void 0 ? _item$key : item.value });
		});
		else list = toArray(children).map(function(_ref) {
			var optionProps = _ref.props, key = _ref.key;
			return _objectSpread2(_objectSpread2({}, optionProps), {}, {
				label: optionProps.children,
				key: key || optionProps.value
			});
		});
		return list.filter(function(option) {
			/** Return all result if `filterOption` is false. */
			if (filterOption$1 === false) return true;
			return filterOption$1(targetMeasureText, option);
		});
	}, [
		children,
		options,
		filterOption$1
	]);
	var mergedOptions = import_react.useMemo(function() {
		return getOptions(mergedMeasureText);
	}, [getOptions, mergedMeasureText]);
	var onSelectionEffect = useEffectState();
	var startMeasure = function startMeasure$1(nextMeasureText, nextMeasurePrefix, nextMeasureLocation) {
		setMeasuring(true);
		setMeasureText(nextMeasureText);
		setMeasurePrefix(nextMeasurePrefix);
		setMeasureLocation(nextMeasureLocation);
		setActiveIndex(0);
	};
	var stopMeasure = function stopMeasure$1(callback) {
		setMeasuring(false);
		setMeasureLocation(0);
		setMeasureText("");
		onSelectionEffect(callback);
	};
	var triggerChange = function triggerChange$1(nextValue) {
		setMergedValue(nextValue);
		onChange === null || onChange === void 0 || onChange(nextValue);
	};
	var onInternalChange = function onInternalChange$1(_ref2) {
		var nextValue = _ref2.target.value;
		triggerChange(nextValue);
	};
	var selectOption = function selectOption$1(option) {
		var _getTextArea;
		var _option$value = option.value;
		var _replaceWithMeasure = replaceWithMeasure(mergedValue, {
			measureLocation: mergedMeasureLocation,
			targetText: _option$value === void 0 ? "" : _option$value,
			prefix: mergedMeasurePrefix,
			selectionStart: (_getTextArea = getTextArea()) === null || _getTextArea === void 0 ? void 0 : _getTextArea.selectionStart,
			split
		}), text = _replaceWithMeasure.text, selectionLocation = _replaceWithMeasure.selectionLocation;
		triggerChange(text);
		stopMeasure(function() {
			setInputSelection(getTextArea(), selectionLocation);
		});
		onSelect === null || onSelect === void 0 || onSelect(option, mergedMeasurePrefix);
	};
	var onInternalKeyDown = function onInternalKeyDown$1(event) {
		var which = event.which;
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event);
		if (!mergedMeasuring) return;
		if (which === KeyCode_default.UP || which === KeyCode_default.DOWN) {
			var optionLen = mergedOptions.length;
			var offset$2 = which === KeyCode_default.UP ? -1 : 1;
			var newActiveIndex = (activeIndex + offset$2 + optionLen) % optionLen;
			setActiveIndex(newActiveIndex);
			event.preventDefault();
		} else if (which === KeyCode_default.ESC) stopMeasure();
		else if (which === KeyCode_default.ENTER) {
			event.preventDefault();
			if (silent) return;
			if (!mergedOptions.length) {
				stopMeasure();
				return;
			}
			var _option = mergedOptions[activeIndex];
			selectOption(_option);
		}
	};
	/**
	* When to start measure:
	* 1. When user press `prefix`
	* 2. When measureText !== prevMeasureText
	*  - If measure hit
	*  - If measuring
	*
	* When to stop measure:
	* 1. Selection is out of range
	* 2. Contains `space`
	* 3. ESC or select one
	*/
	var onInternalKeyUp = function onInternalKeyUp$1(event) {
		var key = event.key, which = event.which;
		var target = event.target;
		var selectionStartText = getBeforeSelectionText(target);
		var _getLastMeasureIndex = getLastMeasureIndex(selectionStartText, mergedPrefix), measureIndex = _getLastMeasureIndex.location, nextMeasurePrefix = _getLastMeasureIndex.prefix;
		onKeyUp === null || onKeyUp === void 0 || onKeyUp(event);
		if ([
			KeyCode_default.ESC,
			KeyCode_default.UP,
			KeyCode_default.DOWN,
			KeyCode_default.ENTER
		].indexOf(which) !== -1) return;
		if (measureIndex !== -1) {
			var nextMeasureText = selectionStartText.slice(measureIndex + nextMeasurePrefix.length);
			var validateMeasure = validateSearch$1(nextMeasureText, split);
			var matchOption = !!getOptions(nextMeasureText).length;
			if (validateMeasure) {
				if (key === nextMeasurePrefix || key === "Shift" || which === KeyCode_default.ALT || key === "AltGraph" || mergedMeasuring || nextMeasureText !== mergedMeasureText && matchOption) startMeasure(nextMeasureText, nextMeasurePrefix, measureIndex);
			} else if (mergedMeasuring) stopMeasure();
			/**
			* We will trigger `onSearch` to developer since they may use for async update.
			* If met `space` means user finished searching.
			*/
			if (onSearch && validateMeasure) onSearch(nextMeasureText, nextMeasurePrefix);
		} else if (mergedMeasuring) stopMeasure();
	};
	var onInternalPressEnter = function onInternalPressEnter$1(event) {
		if (!mergedMeasuring && onPressEnter) onPressEnter(event);
	};
	var focusRef = (0, import_react.useRef)();
	var onInternalFocus = function onInternalFocus$1(event) {
		window.clearTimeout(focusRef.current);
		if (!isFocus && event && onFocus) onFocus(event);
		setIsFocus(true);
	};
	var onInternalBlur = function onInternalBlur$1(event) {
		focusRef.current = window.setTimeout(function() {
			setIsFocus(false);
			stopMeasure();
			onBlur === null || onBlur === void 0 || onBlur(event);
		}, 0);
	};
	return /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$71.default)(prefixCls, className),
		style: style$1,
		ref: containerRef
	}, /* @__PURE__ */ import_react.createElement(es_default$13, _extends({
		ref: textareaRef,
		value: mergedValue
	}, restProps, {
		rows,
		onChange: onInternalChange,
		onKeyDown: onInternalKeyDown,
		onKeyUp: onInternalKeyUp,
		onPressEnter: onInternalPressEnter,
		onFocus: onInternalFocus,
		onBlur: onInternalBlur
	})), mergedMeasuring && /* @__PURE__ */ import_react.createElement("div", {
		ref: measureRef,
		className: "".concat(prefixCls, "-measure")
	}, mergedValue.slice(0, mergedMeasureLocation), /* @__PURE__ */ import_react.createElement(MentionsContext_default.Provider, { value: {
		notFoundContent,
		activeIndex,
		setActiveIndex,
		selectOption,
		onFocus: function onDropdownFocus() {
			onInternalFocus();
		},
		onBlur: function onDropdownBlur() {
			onInternalBlur();
		},
		onScroll: function onInternalPopupScroll(event) {
			onPopupScroll === null || onPopupScroll === void 0 || onPopupScroll(event);
		}
	} }, /* @__PURE__ */ import_react.createElement(KeywordTrigger_default, {
		prefixCls,
		transitionName,
		placement,
		direction,
		options: mergedOptions,
		visible: true,
		getPopupContainer,
		dropdownClassName
	}, /* @__PURE__ */ import_react.createElement("span", null, mergedMeasurePrefix))), mergedValue.slice(mergedMeasureLocation + mergedMeasurePrefix.length)));
});
var Mentions$1 = /* @__PURE__ */ (0, import_react.forwardRef)(function(_ref3, ref) {
	var suffix = _ref3.suffix, _ref3$prefixCls = _ref3.prefixCls, prefixCls = _ref3$prefixCls === void 0 ? "rc-mentions" : _ref3$prefixCls, defaultValue = _ref3.defaultValue, customValue = _ref3.value, allowClear = _ref3.allowClear, onChange = _ref3.onChange, classes = _ref3.classNames, className = _ref3.className, disabled = _ref3.disabled, onClear = _ref3.onClear, rest = _objectWithoutProperties(_ref3, _excluded2$1);
	var holderRef = (0, import_react.useRef)(null);
	var mentionRef = (0, import_react.useRef)(null);
	(0, import_react.useImperativeHandle)(ref, function() {
		var _holderRef$current, _mentionRef$current;
		return _objectSpread2(_objectSpread2({}, mentionRef.current), {}, { nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || ((_mentionRef$current = mentionRef.current) === null || _mentionRef$current === void 0 ? void 0 : _mentionRef$current.nativeElement) });
	});
	var _useMergedState3 = useMergedState("", {
		defaultValue,
		value: customValue
	}), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedValue = _useMergedState4[0], setMergedValue = _useMergedState4[1];
	var triggerChange = function triggerChange$1(currentValue) {
		setMergedValue(currentValue);
		onChange === null || onChange === void 0 || onChange(currentValue);
	};
	return /* @__PURE__ */ import_react.createElement(BaseInput_default, {
		suffix,
		prefixCls,
		value: mergedValue,
		allowClear,
		handleReset: function handleReset() {
			triggerChange("");
		},
		className,
		classNames: classes,
		disabled,
		ref: holderRef,
		onClear
	}, /* @__PURE__ */ import_react.createElement(InternalMentions, _extends({
		className: classes === null || classes === void 0 ? void 0 : classes.mentions,
		prefixCls,
		ref: mentionRef,
		onChange: triggerChange,
		disabled
	}, rest)));
});
Mentions$1.Option = Option_default;
var Mentions_default = Mentions$1;

//#endregion
//#region node_modules/rc-mentions/es/index.js
var es_default$12 = Mentions_default;

//#endregion
//#region node_modules/antd/es/_util/toList.js
var toList$1 = (candidate, skipEmpty = false) => {
	if (skipEmpty && (candidate === void 0 || candidate === null)) return [];
	return Array.isArray(candidate) ? candidate : [candidate];
};
var toList_default = toList$1;

//#endregion
//#region node_modules/antd/es/mentions/style/index.js
var genMentionsStyle = (token$1) => {
	const { componentCls, antCls, colorTextDisabled, controlItemBgHover, controlPaddingHorizontal, colorText, motionDurationSlow, lineHeight, controlHeight, paddingInline, paddingBlock, fontSize, fontSizeIcon, colorIcon, colorTextQuaternary, colorBgElevated, paddingXXS, borderRadius, borderRadiusLG, boxShadowSecondary, itemPaddingVertical, calc } = token$1;
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), genBasicInputStyle(token$1)), {
		position: "relative",
		display: "inline-block",
		height: "auto",
		padding: `0 ${unit(token$1.paddingInline)}`,
		overflow: "hidden",
		lineHeight,
		whiteSpace: "pre-wrap",
		verticalAlign: "bottom"
	}), genOutlinedStyle(token$1)), genFilledStyle(token$1)), genBorderlessStyle(token$1)), { "&-affix-wrapper": Object.assign(Object.assign({}, genBasicInputStyle(token$1)), {
		display: "inline-flex",
		paddingBlock: 0,
		paddingInlineStart: 0,
		paddingInlineEnd: token$1.paddingInline,
		"&::before": {
			display: "inline-block",
			width: 0,
			visibility: "hidden",
			content: "\"\\a0\""
		},
		[`${componentCls}-suffix`]: {
			display: "inline-flex",
			alignItems: "center",
			[`&:has(${antCls}-form-item-feedback-icon) ${componentCls}-clear-icon`]: { marginInlineEnd: token$1.marginXS },
			[`${antCls}-form-item-feedback-icon`]: {
				display: "inline-flex",
				alignItems: "center",
				justifyContent: "center"
			}
		},
		[`${componentCls}-clear-icon`]: {
			insetInlineEnd: 0,
			insetBlockStart: calc(fontSize).mul(lineHeight).mul(.5).add(paddingBlock).equal(),
			padding: 0,
			lineHeight: 0,
			color: colorTextQuaternary,
			fontSize: fontSizeIcon,
			verticalAlign: -1,
			cursor: "pointer",
			transition: `color ${motionDurationSlow}`,
			border: "none",
			outline: "none",
			backgroundColor: "transparent",
			"&:hover": { color: colorIcon },
			"&:active": { color: colorText },
			"&-hidden": { visibility: "hidden" }
		}
	}) }), genUnderlinedStyle(token$1)), {
		"&-disabled": { "> textarea": Object.assign({}, genDisabledStyle(token$1)) },
		[`&, &-affix-wrapper > ${componentCls}`]: {
			[`> textarea, ${componentCls}-measure`]: {
				color: colorText,
				boxSizing: "border-box",
				minHeight: token$1.calc(controlHeight).sub(2).equal(),
				margin: 0,
				padding: `${unit(paddingBlock)} ${unit(paddingInline)}`,
				overflow: "inherit",
				overflowX: "hidden",
				overflowY: "auto",
				fontWeight: "inherit",
				fontSize: "inherit",
				fontFamily: "inherit",
				fontStyle: "inherit",
				fontVariant: "inherit",
				fontSizeAdjust: "inherit",
				fontStretch: "inherit",
				lineHeight: "inherit",
				direction: "inherit",
				letterSpacing: "inherit",
				whiteSpace: "inherit",
				textAlign: "inherit",
				verticalAlign: "top",
				wordWrap: "break-word",
				wordBreak: "inherit",
				tabSize: "inherit"
			},
			"> textarea": Object.assign(Object.assign({
				width: "100%",
				border: "none",
				outline: "none",
				resize: "none",
				backgroundColor: "transparent"
			}, genPlaceholderStyle(token$1.colorTextPlaceholder)), { padding: `${unit(token$1.paddingBlock)} 0` }),
			[`${componentCls}-measure`]: {
				position: "absolute",
				top: 0,
				insetInlineEnd: 0,
				bottom: 0,
				insetInlineStart: 0,
				zIndex: -1,
				color: "transparent",
				pointerEvents: "none",
				"> span": {
					display: "inline-block",
					minHeight: "1em"
				}
			}
		},
		"&-dropdown": Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "absolute",
			top: -9999,
			insetInlineStart: -9999,
			zIndex: token$1.zIndexPopup,
			boxSizing: "border-box",
			fontSize,
			fontVariant: "initial",
			padding: paddingXXS,
			backgroundColor: colorBgElevated,
			borderRadius: borderRadiusLG,
			outline: "none",
			boxShadow: boxShadowSecondary,
			"&-hidden": { display: "none" },
			[`${componentCls}-dropdown-menu`]: {
				maxHeight: token$1.dropdownHeight,
				margin: 0,
				paddingInlineStart: 0,
				overflow: "auto",
				listStyle: "none",
				outline: "none",
				"&-item": Object.assign(Object.assign({}, textEllipsis), {
					position: "relative",
					display: "block",
					minWidth: token$1.controlItemWidth,
					padding: `${unit(itemPaddingVertical)} ${unit(controlPaddingHorizontal)}`,
					color: colorText,
					borderRadius,
					fontWeight: "normal",
					lineHeight,
					cursor: "pointer",
					transition: `background ${motionDurationSlow} ease`,
					"&:hover": { backgroundColor: controlItemBgHover },
					"&-disabled": {
						color: colorTextDisabled,
						cursor: "not-allowed",
						"&:hover": {
							color: colorTextDisabled,
							backgroundColor: controlItemBgHover,
							cursor: "not-allowed"
						}
					},
					"&-selected": {
						color: colorText,
						fontWeight: token$1.fontWeightStrong,
						backgroundColor: controlItemBgHover
					},
					"&-active": { backgroundColor: controlItemBgHover }
				})
			}
		})
	}) };
};
const prepareComponentToken$17 = (token$1) => Object.assign(Object.assign({}, initComponentToken$1(token$1)), {
	dropdownHeight: 250,
	controlItemWidth: 100,
	zIndexPopup: token$1.zIndexPopupBase + 50,
	itemPaddingVertical: (token$1.controlHeight - token$1.fontHeight) / 2
});
var style_default$19 = genStyleHooks("Mentions", (token$1) => {
	const mentionsToken = merge(token$1, initInputToken(token$1));
	return genMentionsStyle(mentionsToken);
}, prepareComponentToken$17);

//#endregion
//#region node_modules/antd/es/mentions/index.js
var import_classnames$70 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$29 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const { Option } = es_default$12;
function loadingFilterOption() {
	return true;
}
var Mentions = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, disabled, loading, filterOption: filterOption$1, children, notFoundContent, options, status: customStatus, allowClear = false, popupClassName, style: style$1, variant: customVariant } = props, restProps = __rest$29(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"disabled",
		"loading",
		"filterOption",
		"children",
		"notFoundContent",
		"options",
		"status",
		"allowClear",
		"popupClassName",
		"style",
		"variant"
	]);
	const [focused, setFocused] = import_react.useState(false);
	const innerRef = import_react.useRef(null);
	const mergedRef = composeRef(ref, innerRef);
	devUseWarning("Mentions").deprecated(!children, "Mentions.Option", "options");
	const { getPrefixCls, renderEmpty, direction, mentions: contextMentions } = import_react.useContext(ConfigContext);
	const { status: contextStatus, hasFeedback, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const onFocus = (...args) => {
		if (restProps.onFocus) restProps.onFocus.apply(restProps, args);
		setFocused(true);
	};
	const onBlur = (...args) => {
		if (restProps.onBlur) restProps.onBlur.apply(restProps, args);
		setFocused(false);
	};
	const notFoundContentEle = import_react.useMemo(() => {
		if (notFoundContent !== void 0) return notFoundContent;
		return (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Select" });
	}, [notFoundContent, renderEmpty]);
	const mentionOptions = import_react.useMemo(() => {
		if (loading) return /* @__PURE__ */ import_react.createElement(Option, {
			value: "ANTD_SEARCHING",
			disabled: true
		}, /* @__PURE__ */ import_react.createElement(spin_default, { size: "small" }));
		return children;
	}, [loading, children]);
	const mergedOptions = loading ? [{
		value: "ANTD_SEARCHING",
		disabled: true,
		label: /* @__PURE__ */ import_react.createElement(spin_default, { size: "small" })
	}] : options;
	const mentionsfilterOption = loading ? loadingFilterOption : filterOption$1;
	const prefixCls = getPrefixCls("mentions", customizePrefixCls);
	const mergedAllowClear = getAllowClear_default(allowClear);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$19(prefixCls, rootCls);
	const [variant, enableVariantCls] = useVariants_default("mentions", customVariant);
	const suffixNode = hasFeedback && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, feedbackIcon);
	const mergedClassName = (0, import_classnames$70.default)(contextMentions === null || contextMentions === void 0 ? void 0 : contextMentions.className, className, rootClassName, cssVarCls, rootCls);
	const mentions = /* @__PURE__ */ import_react.createElement(es_default$12, Object.assign({
		silent: loading,
		prefixCls,
		notFoundContent: notFoundContentEle,
		className: mergedClassName,
		disabled,
		allowClear: mergedAllowClear,
		direction,
		style: Object.assign(Object.assign({}, contextMentions === null || contextMentions === void 0 ? void 0 : contextMentions.style), style$1)
	}, restProps, {
		filterOption: mentionsfilterOption,
		onFocus,
		onBlur,
		dropdownClassName: (0, import_classnames$70.default)(popupClassName, rootClassName, hashId, cssVarCls, rootCls),
		ref: mergedRef,
		options: mergedOptions,
		suffix: suffixNode,
		classNames: {
			mentions: (0, import_classnames$70.default)({
				[`${prefixCls}-disabled`]: disabled,
				[`${prefixCls}-focused`]: focused,
				[`${prefixCls}-rtl`]: direction === "rtl"
			}, hashId),
			variant: (0, import_classnames$70.default)({ [`${prefixCls}-${variant}`]: enableVariantCls }, getStatusClassNames(prefixCls, mergedStatus)),
			affixWrapper: hashId
		}
	}), mentionOptions);
	return wrapCSSVar(mentions);
});
Mentions.displayName = "Mentions";
Mentions.Option = Option;
Mentions._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default(Mentions, void 0, void 0, "mentions");
Mentions.getMentions = (value = "", config = {}) => {
	const { prefix = "@", split = " " } = config;
	const prefixList = toList_default(prefix);
	return value.split(split).map((str = "") => {
		let hitPrefix = null;
		prefixList.some((prefixStr) => {
			if (str.slice(0, prefixStr.length) === prefixStr) {
				hitPrefix = prefixStr;
				return true;
			}
			return false;
		});
		if (hitPrefix !== null) return {
			prefix: hitPrefix,
			value: str.slice(hitPrefix.length)
		};
		return null;
	}).filter((entity) => !!entity && !!entity.value);
};
var mentions_default = Mentions;

//#endregion
//#region node_modules/antd/es/message/index.js
var message = null;
var act$1 = (callback) => callback();
var taskQueue$1 = [];
var defaultGlobalConfig$1 = {};
function getGlobalContext$1() {
	const { getContainer: getContainer$1, duration, rtl, maxCount, top } = defaultGlobalConfig$1;
	const mergedContainer = (getContainer$1 === null || getContainer$1 === void 0 ? void 0 : getContainer$1()) || document.body;
	return {
		getContainer: () => mergedContainer,
		duration,
		rtl,
		maxCount,
		top
	};
}
var GlobalHolder$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { messageConfig, sync } = props;
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = defaultGlobalConfig$1.prefixCls || getPrefixCls("message");
	const appConfig = (0, import_react.useContext)(AppConfigContext);
	const [api, holder] = useInternalMessage(Object.assign(Object.assign(Object.assign({}, messageConfig), { prefixCls }), appConfig.message));
	import_react.useImperativeHandle(ref, () => {
		const instance = Object.assign({}, api);
		Object.keys(instance).forEach((method$1) => {
			instance[method$1] = (...args) => {
				sync();
				return api[method$1].apply(api, args);
			};
		});
		return {
			instance,
			sync
		};
	});
	return holder;
});
var GlobalHolderWrapper$1 = /* @__PURE__ */ import_react.forwardRef((_, ref) => {
	const [messageConfig, setMessageConfig] = import_react.useState(getGlobalContext$1);
	const sync = () => {
		setMessageConfig(getGlobalContext$1);
	};
	import_react.useEffect(sync, []);
	const global$2 = globalConfig();
	const rootPrefixCls = global$2.getRootPrefixCls();
	const rootIconPrefixCls = global$2.getIconPrefixCls();
	const theme = global$2.getTheme();
	const dom = /* @__PURE__ */ import_react.createElement(GlobalHolder$1, {
		ref,
		sync,
		messageConfig
	});
	return /* @__PURE__ */ import_react.createElement(config_provider_default, {
		prefixCls: rootPrefixCls,
		iconPrefixCls: rootIconPrefixCls,
		theme
	}, global$2.holderRender ? global$2.holderRender(dom) : dom);
});
var flushMessageQueue = () => {
	if (!message) {
		const holderFragment = document.createDocumentFragment();
		const newMessage = { fragment: holderFragment };
		message = newMessage;
		act$1(() => {
			unstableSetRender()(/* @__PURE__ */ import_react.createElement(GlobalHolderWrapper$1, { ref: (node$1) => {
				const { instance, sync } = node$1 || {};
				Promise.resolve().then(() => {
					if (!newMessage.instance && instance) {
						newMessage.instance = instance;
						newMessage.sync = sync;
						flushMessageQueue();
					}
				});
			} }), holderFragment);
		});
		return;
	}
	if (!message.instance) return;
	taskQueue$1.forEach((task) => {
		const { type: type$2, skipped } = task;
		if (!skipped) switch (type$2) {
			case "open":
				act$1(() => {
					const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig$1), task.config));
					closeFn === null || closeFn === void 0 || closeFn.then(task.resolve);
					task.setCloseFn(closeFn);
				});
				break;
			case "destroy":
				act$1(() => {
					message === null || message === void 0 || message.instance.destroy(task.key);
				});
				break;
			default: act$1(() => {
				var _message$instance;
				const closeFn = (_message$instance = message.instance)[type$2].apply(_message$instance, _toConsumableArray(task.args));
				closeFn === null || closeFn === void 0 || closeFn.then(task.resolve);
				task.setCloseFn(closeFn);
			});
		}
	});
	taskQueue$1 = [];
};
function setMessageGlobalConfig(config) {
	defaultGlobalConfig$1 = Object.assign(Object.assign({}, defaultGlobalConfig$1), config);
	act$1(() => {
		var _a;
		(_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 || _a.call(message);
	});
}
function open$1(config) {
	const result = wrapPromiseFn((resolve) => {
		let closeFn;
		const task = {
			type: "open",
			config,
			resolve,
			setCloseFn: (fn) => {
				closeFn = fn;
			}
		};
		taskQueue$1.push(task);
		return () => {
			if (closeFn) act$1(() => {
				closeFn();
			});
			else task.skipped = true;
		};
	});
	flushMessageQueue();
	return result;
}
function typeOpen(type$2, args) {
	if (!globalConfig().holderRender) warnContext("message");
	const result = wrapPromiseFn((resolve) => {
		let closeFn;
		const task = {
			type: type$2,
			args,
			resolve,
			setCloseFn: (fn) => {
				closeFn = fn;
			}
		};
		taskQueue$1.push(task);
		return () => {
			if (closeFn) act$1(() => {
				closeFn();
			});
			else task.skipped = true;
		};
	});
	flushMessageQueue();
	return result;
}
var destroy$1 = (key) => {
	taskQueue$1.push({
		type: "destroy",
		key
	});
	flushMessageQueue();
};
var methods$1 = [
	"success",
	"info",
	"warning",
	"error",
	"loading"
];
var staticMethods$1 = {
	open: open$1,
	destroy: destroy$1,
	config: setMessageGlobalConfig,
	useMessage,
	_InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default$6
};
methods$1.forEach((type$2) => {
	staticMethods$1[type$2] = (...args) => typeOpen(type$2, args);
});
var message_default = staticMethods$1;

//#endregion
//#region node_modules/antd/es/modal/PurePanel.js
var import_classnames$69 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$28 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var PurePanel$4 = (props) => {
	const { prefixCls: customizePrefixCls, className, closeIcon, closable, type: type$2, title, children, footer } = props, restProps = __rest$28(props, [
		"prefixCls",
		"className",
		"closeIcon",
		"closable",
		"type",
		"title",
		"children",
		"footer"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const rootPrefixCls = getPrefixCls();
	const prefixCls = customizePrefixCls || getPrefixCls("modal");
	const rootCls = useCSSVarCls_default(rootPrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$18(prefixCls, rootCls);
	const confirmPrefixCls = `${prefixCls}-confirm`;
	let additionalProps = {};
	if (type$2) additionalProps = {
		closable: closable !== null && closable !== void 0 ? closable : false,
		title: "",
		footer: "",
		children: /* @__PURE__ */ import_react.createElement(ConfirmContent, Object.assign({}, props, {
			prefixCls,
			confirmPrefixCls,
			rootPrefixCls,
			content: children
		}))
	};
	else additionalProps = {
		closable: closable !== null && closable !== void 0 ? closable : true,
		title,
		footer: footer !== null && /* @__PURE__ */ import_react.createElement(Footer$1, Object.assign({}, props)),
		children
	};
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(Panel_default$2, Object.assign({
		prefixCls,
		className: (0, import_classnames$69.default)(hashId, `${prefixCls}-pure-panel`, type$2 && confirmPrefixCls, type$2 && `${confirmPrefixCls}-${type$2}`, className, cssVarCls, rootCls)
	}, restProps, {
		closeIcon: renderCloseIcon(prefixCls, closeIcon),
		closable
	}, additionalProps)));
};
var PurePanel_default$5 = withPureRenderTheme(PurePanel$4);

//#endregion
//#region node_modules/antd/es/modal/index.js
function modalWarn(props) {
	return confirm(withWarn(props));
}
var Modal = Modal_default;
Modal.useModal = useModal_default;
Modal.info = function infoFn(props) {
	return confirm(withInfo(props));
};
Modal.success = function successFn(props) {
	return confirm(withSuccess(props));
};
Modal.error = function errorFn(props) {
	return confirm(withError(props));
};
Modal.warning = modalWarn;
Modal.warn = modalWarn;
Modal.confirm = function confirmFn(props) {
	return confirm(withConfirm(props));
};
Modal.destroyAll = function destroyAllFn() {
	while (destroyFns_default.length) {
		const close = destroyFns_default.pop();
		if (close) close();
	}
};
Modal.config = modalGlobalConfig;
Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$5;
Modal.displayName = "Modal";
var modal_default = Modal;

//#endregion
//#region node_modules/antd/es/notification/index.js
var notification = null;
var act = (callback) => callback();
var taskQueue = [];
var defaultGlobalConfig = {};
function getGlobalContext() {
	const { getContainer: getContainer$1, rtl, maxCount, top, bottom, showProgress, pauseOnHover } = defaultGlobalConfig;
	const mergedContainer = (getContainer$1 === null || getContainer$1 === void 0 ? void 0 : getContainer$1()) || document.body;
	return {
		getContainer: () => mergedContainer,
		rtl,
		maxCount,
		top,
		bottom,
		showProgress,
		pauseOnHover
	};
}
var GlobalHolder = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { notificationConfig, sync } = props;
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("notification");
	const appConfig = (0, import_react.useContext)(AppConfigContext);
	const [api, holder] = useInternalNotification(Object.assign(Object.assign(Object.assign({}, notificationConfig), { prefixCls }), appConfig.notification));
	import_react.useEffect(sync, []);
	import_react.useImperativeHandle(ref, () => {
		const instance = Object.assign({}, api);
		Object.keys(instance).forEach((method$1) => {
			instance[method$1] = (...args) => {
				sync();
				return api[method$1].apply(api, args);
			};
		});
		return {
			instance,
			sync
		};
	});
	return holder;
});
var GlobalHolderWrapper = /* @__PURE__ */ import_react.forwardRef((_, ref) => {
	const [notificationConfig, setNotificationConfig] = import_react.useState(getGlobalContext);
	const sync = () => {
		setNotificationConfig(getGlobalContext);
	};
	import_react.useEffect(sync, []);
	const global$2 = globalConfig();
	const rootPrefixCls = global$2.getRootPrefixCls();
	const rootIconPrefixCls = global$2.getIconPrefixCls();
	const theme = global$2.getTheme();
	const dom = /* @__PURE__ */ import_react.createElement(GlobalHolder, {
		ref,
		sync,
		notificationConfig
	});
	return /* @__PURE__ */ import_react.createElement(config_provider_default, {
		prefixCls: rootPrefixCls,
		iconPrefixCls: rootIconPrefixCls,
		theme
	}, global$2.holderRender ? global$2.holderRender(dom) : dom);
});
var flushNotificationQueue = () => {
	if (!notification) {
		const holderFragment = document.createDocumentFragment();
		const newNotification = { fragment: holderFragment };
		notification = newNotification;
		act(() => {
			unstableSetRender()(/* @__PURE__ */ import_react.createElement(GlobalHolderWrapper, { ref: (node$1) => {
				const { instance, sync } = node$1 || {};
				Promise.resolve().then(() => {
					if (!newNotification.instance && instance) {
						newNotification.instance = instance;
						newNotification.sync = sync;
						flushNotificationQueue();
					}
				});
			} }), holderFragment);
		});
		return;
	}
	if (!notification.instance) return;
	taskQueue.forEach((task) => {
		switch (task.type) {
			case "open":
				act(() => {
					notification.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));
				});
				break;
			case "destroy":
				act(() => {
					var _a;
					(_a = notification === null || notification === void 0 ? void 0 : notification.instance) === null || _a === void 0 || _a.destroy(task.key);
				});
				break;
		}
	});
	taskQueue = [];
};
function setNotificationGlobalConfig(config) {
	defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);
	act(() => {
		var _a;
		(_a = notification === null || notification === void 0 ? void 0 : notification.sync) === null || _a === void 0 || _a.call(notification);
	});
}
function open(config) {
	if (!globalConfig().holderRender) warnContext("notification");
	taskQueue.push({
		type: "open",
		config
	});
	flushNotificationQueue();
}
var destroy = (key) => {
	taskQueue.push({
		type: "destroy",
		key
	});
	flushNotificationQueue();
};
var methods = [
	"success",
	"info",
	"warning",
	"error"
];
var staticMethods = {
	open,
	destroy,
	config: setNotificationGlobalConfig,
	useNotification,
	_InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default$4
};
methods.forEach((type$2) => {
	staticMethods[type$2] = (config) => open(Object.assign(Object.assign({}, config), { type: type$2 }));
});
var notification_default = staticMethods;

//#endregion
//#region node_modules/antd/es/popconfirm/style/index.js
var genBaseStyle$7 = (token$1) => {
	const { componentCls, iconCls, antCls, zIndexPopup, colorText, colorWarning, marginXXS, marginXS, fontSize, fontWeightStrong, colorTextHeading } = token$1;
	return { [componentCls]: {
		zIndex: zIndexPopup,
		[`&${antCls}-popover`]: { fontSize },
		[`${componentCls}-message`]: {
			marginBottom: marginXS,
			display: "flex",
			flexWrap: "nowrap",
			alignItems: "start",
			[`> ${componentCls}-message-icon ${iconCls}`]: {
				color: colorWarning,
				fontSize,
				lineHeight: 1,
				marginInlineEnd: marginXS
			},
			[`${componentCls}-title`]: {
				fontWeight: fontWeightStrong,
				color: colorTextHeading,
				"&:only-child": { fontWeight: "normal" }
			},
			[`${componentCls}-description`]: {
				marginTop: marginXXS,
				color: colorText
			}
		},
		[`${componentCls}-buttons`]: {
			textAlign: "end",
			whiteSpace: "nowrap",
			button: { marginInlineStart: marginXS }
		}
	} };
};
const prepareComponentToken$16 = (token$1) => {
	const { zIndexPopupBase } = token$1;
	return { zIndexPopup: zIndexPopupBase + 60 };
};
var style_default$17 = genStyleHooks("Popconfirm", (token$1) => genBaseStyle$7(token$1), prepareComponentToken$16, { resetStyle: false });

//#endregion
//#region node_modules/antd/es/popconfirm/PurePanel.js
var import_classnames$68 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$27 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const Overlay = (props) => {
	const { prefixCls, okButtonProps, cancelButtonProps, title, description, cancelText, okText, okType = "primary", icon = /* @__PURE__ */ import_react.createElement(ExclamationCircleFilled_default, null), showCancel = true, close, onConfirm, onCancel, onPopupClick } = props;
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const [contextLocale] = useLocale_default("Popconfirm", en_US_default.Popconfirm);
	const titleNode = getRenderPropValue(title);
	const descriptionNode = getRenderPropValue(description);
	return /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-inner-content`,
		onClick: onPopupClick
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-message` }, icon && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-message-icon` }, icon), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-message-text` }, titleNode && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-title` }, titleNode), descriptionNode && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-description` }, descriptionNode))), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-buttons` }, showCancel && /* @__PURE__ */ import_react.createElement(button_default, Object.assign({
		onClick: onCancel,
		size: "small"
	}, cancelButtonProps), cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)), /* @__PURE__ */ import_react.createElement(ActionButton_default, {
		buttonProps: Object.assign(Object.assign({ size: "small" }, convertLegacyProps(okType)), okButtonProps),
		actionFn: onConfirm,
		close,
		prefixCls: getPrefixCls("btn"),
		quitOnNullishReturnValue: true,
		emitEvent: true
	}, okText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText))));
};
var PurePanel$3 = (props) => {
	const { prefixCls: customizePrefixCls, placement, className, style: style$1 } = props, restProps = __rest$27(props, [
		"prefixCls",
		"placement",
		"className",
		"style"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
	const [wrapCSSVar] = style_default$17(prefixCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(PurePanel_default$3, {
		placement,
		className: (0, import_classnames$68.default)(prefixCls, className),
		style: style$1,
		content: /* @__PURE__ */ import_react.createElement(Overlay, Object.assign({ prefixCls }, restProps))
	}));
};
var PurePanel_default$2 = PurePanel$3;

//#endregion
//#region node_modules/antd/es/popconfirm/index.js
var import_classnames$67 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$26 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Popconfirm = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a, _b;
	const { prefixCls: customizePrefixCls, placement = "top", trigger = "click", okType = "primary", icon = /* @__PURE__ */ import_react.createElement(ExclamationCircleFilled_default, null), children, overlayClassName, onOpenChange, onVisibleChange, overlayStyle, styles, classNames: popconfirmClassNames } = props, restProps = __rest$26(props, [
		"prefixCls",
		"placement",
		"trigger",
		"okType",
		"icon",
		"children",
		"overlayClassName",
		"onOpenChange",
		"onVisibleChange",
		"overlayStyle",
		"styles",
		"classNames"
	]);
	const { getPrefixCls, className: contextClassName, style: contextStyle, classNames: contextClassNames, styles: contextStyles } = useComponentConfig("popconfirm");
	const [open$2, setOpen] = useMergedState(false, {
		value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
		defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
	});
	const settingOpen = (value, e$2) => {
		setOpen(value, true);
		onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(value);
		onOpenChange === null || onOpenChange === void 0 || onOpenChange(value, e$2);
	};
	const close = (e$2) => {
		settingOpen(false, e$2);
	};
	const onConfirm = (e$2) => {
		var _a$1;
		return (_a$1 = props.onConfirm) === null || _a$1 === void 0 ? void 0 : _a$1.call(void 0, e$2);
	};
	const onCancel = (e$2) => {
		var _a$1;
		settingOpen(false, e$2);
		(_a$1 = props.onCancel) === null || _a$1 === void 0 || _a$1.call(void 0, e$2);
	};
	const onInternalOpenChange = (value, e$2) => {
		const { disabled = false } = props;
		if (disabled) return;
		settingOpen(value, e$2);
	};
	const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
	const rootClassNames = (0, import_classnames$67.default)(prefixCls, contextClassName, overlayClassName, contextClassNames.root, popconfirmClassNames === null || popconfirmClassNames === void 0 ? void 0 : popconfirmClassNames.root);
	const bodyClassNames = (0, import_classnames$67.default)(contextClassNames.body, popconfirmClassNames === null || popconfirmClassNames === void 0 ? void 0 : popconfirmClassNames.body);
	const [wrapCSSVar] = style_default$17(prefixCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(popover_default, Object.assign({}, omit(restProps, ["title"]), {
		trigger,
		placement,
		onOpenChange: onInternalOpenChange,
		open: open$2,
		ref,
		classNames: {
			root: rootClassNames,
			body: bodyClassNames
		},
		styles: {
			root: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), contextStyle), overlayStyle), styles === null || styles === void 0 ? void 0 : styles.root),
			body: Object.assign(Object.assign({}, contextStyles.body), styles === null || styles === void 0 ? void 0 : styles.body)
		},
		content: /* @__PURE__ */ import_react.createElement(Overlay, Object.assign({
			okType,
			icon
		}, props, {
			prefixCls,
			close,
			onConfirm,
			onCancel
		})),
		"data-popover-inject": true
	}), children));
});
/* istanbul ignore next */
Popconfirm._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$2;
Popconfirm.displayName = "Popconfirm";
var popconfirm_default = Popconfirm;

//#endregion
//#region node_modules/rc-progress/es/common.js
var defaultProps = {
	percent: 0,
	prefixCls: "rc-progress",
	strokeColor: "#2db7f5",
	strokeLinecap: "round",
	strokeWidth: 1,
	trailColor: "#D9D9D9",
	trailWidth: 1,
	gapPosition: "bottom"
};
var useTransitionDuration = function useTransitionDuration$1() {
	var pathsRef = (0, import_react.useRef)([]);
	var prevTimeStamp = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(function() {
		var now$1 = Date.now();
		var updated = false;
		pathsRef.current.forEach(function(path$1) {
			if (!path$1) return;
			updated = true;
			var pathStyle = path$1.style;
			pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
			if (prevTimeStamp.current && now$1 - prevTimeStamp.current < 100) pathStyle.transitionDuration = "0s, 0s";
		});
		if (updated) prevTimeStamp.current = Date.now();
	});
	return pathsRef.current;
};

//#endregion
//#region node_modules/rc-progress/es/Line.js
var import_classnames$66 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$20 = [
	"className",
	"percent",
	"prefixCls",
	"strokeColor",
	"strokeLinecap",
	"strokeWidth",
	"style",
	"trailColor",
	"trailWidth",
	"transition"
];
var Line$1 = function Line$2(props) {
	var _defaultProps$props = _objectSpread2(_objectSpread2({}, defaultProps), props), className = _defaultProps$props.className, percent = _defaultProps$props.percent, prefixCls = _defaultProps$props.prefixCls, strokeColor = _defaultProps$props.strokeColor, strokeLinecap = _defaultProps$props.strokeLinecap, strokeWidth = _defaultProps$props.strokeWidth, style$1 = _defaultProps$props.style, trailColor = _defaultProps$props.trailColor, trailWidth = _defaultProps$props.trailWidth, transition = _defaultProps$props.transition, restProps = _objectWithoutProperties(_defaultProps$props, _excluded$20);
	delete restProps.gapPosition;
	var percentList = Array.isArray(percent) ? percent : [percent];
	var strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
	var paths = useTransitionDuration();
	var center = strokeWidth / 2;
	var right = 100 - strokeWidth / 2;
	var pathString = "M ".concat(strokeLinecap === "round" ? center : 0, ",").concat(center, "\n         L ").concat(strokeLinecap === "round" ? right : 100, ",").concat(center);
	var viewBoxString = "0 0 100 ".concat(strokeWidth);
	var stackPtg = 0;
	return /* @__PURE__ */ import_react.createElement("svg", _extends({
		className: (0, import_classnames$66.default)("".concat(prefixCls, "-line"), className),
		viewBox: viewBoxString,
		preserveAspectRatio: "none",
		style: style$1
	}, restProps), /* @__PURE__ */ import_react.createElement("path", {
		className: "".concat(prefixCls, "-line-trail"),
		d: pathString,
		strokeLinecap,
		stroke: trailColor,
		strokeWidth: trailWidth || strokeWidth,
		fillOpacity: "0"
	}), percentList.map(function(ptg, index$2) {
		var dashPercent = 1;
		switch (strokeLinecap) {
			case "round":
				dashPercent = 1 - strokeWidth / 100;
				break;
			case "square":
				dashPercent = 1 - strokeWidth / 2 / 100;
				break;
			default:
				dashPercent = 1;
				break;
		}
		var pathStyle = {
			strokeDasharray: "".concat(ptg * dashPercent, "px, 100px"),
			strokeDashoffset: "-".concat(stackPtg, "px"),
			transition: transition || "stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear"
		};
		var color = strokeColorList[index$2] || strokeColorList[strokeColorList.length - 1];
		stackPtg += ptg;
		return /* @__PURE__ */ import_react.createElement("path", {
			key: index$2,
			className: "".concat(prefixCls, "-line-path"),
			d: pathString,
			strokeLinecap,
			stroke: color,
			strokeWidth,
			fillOpacity: "0",
			ref: function ref(elem) {
				paths[index$2] = elem;
			},
			style: pathStyle
		});
	}));
};
Line$1.displayName = "Line";

//#endregion
//#region node_modules/rc-progress/es/hooks/useId.js
var uuid = 0;
/** Is client side and not jsdom */
var isBrowserClient = canUseDom();
/** Get unique id for accessibility usage */
function getUUID() {
	var retId;
	/* istanbul ignore if */
	if (isBrowserClient) {
		retId = uuid;
		uuid += 1;
	} else retId = "TEST_OR_SSR";
	return retId;
}
var useId_default$1 = (function(id) {
	var _React$useState = import_react.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
	import_react.useEffect(function() {
		setInnerId("rc_progress_".concat(getUUID()));
	}, []);
	return id || innerId;
});

//#endregion
//#region node_modules/rc-progress/es/Circle/PtgCircle.js
var Block = function Block$1(_ref) {
	var bg = _ref.bg, children = _ref.children;
	return /* @__PURE__ */ import_react.createElement("div", { style: {
		width: "100%",
		height: "100%",
		background: bg
	} }, children);
};
function getPtgColors(color, scale) {
	return Object.keys(color).map(function(key) {
		var parsedKey = parseFloat(key);
		var ptgKey = "".concat(Math.floor(parsedKey * scale), "%");
		return "".concat(color[key], " ").concat(ptgKey);
	});
}
var PtgCircle = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, color = props.color, gradientId = props.gradientId, radius$1 = props.radius, circleStyleForStack = props.style, ptg = props.ptg, strokeLinecap = props.strokeLinecap, strokeWidth = props.strokeWidth, size = props.size, gapDegree = props.gapDegree;
	var isGradient = color && _typeof(color) === "object";
	var stroke = isGradient ? "#FFF" : void 0;
	var halfSize = size / 2;
	var circleNode = /* @__PURE__ */ import_react.createElement("circle", {
		className: "".concat(prefixCls, "-circle-path"),
		r: radius$1,
		cx: halfSize,
		cy: halfSize,
		stroke,
		strokeLinecap,
		strokeWidth,
		opacity: ptg === 0 ? 0 : 1,
		style: circleStyleForStack,
		ref
	});
	if (!isGradient) return circleNode;
	var maskId = "".concat(gradientId, "-conic");
	var fromDeg = gapDegree ? "".concat(180 + gapDegree / 2, "deg") : "0deg";
	var conicColors = getPtgColors(color, (360 - gapDegree) / 360);
	var linearColors = getPtgColors(color, 1);
	var conicColorBg = "conic-gradient(from ".concat(fromDeg, ", ").concat(conicColors.join(", "), ")");
	var linearColorBg = "linear-gradient(to ".concat(gapDegree ? "bottom" : "top", ", ").concat(linearColors.join(", "), ")");
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("mask", { id: maskId }, circleNode), /* @__PURE__ */ import_react.createElement("foreignObject", {
		x: 0,
		y: 0,
		width: size,
		height: size,
		mask: "url(#".concat(maskId, ")")
	}, /* @__PURE__ */ import_react.createElement(Block, { bg: linearColorBg }, /* @__PURE__ */ import_react.createElement(Block, { bg: conicColorBg }))));
});
PtgCircle.displayName = "PtgCircle";
var PtgCircle_default = PtgCircle;

//#endregion
//#region node_modules/rc-progress/es/Circle/util.js
var VIEW_BOX_SIZE = 100;
var getCircleStyle = function getCircleStyle$1(perimeter, perimeterWithoutGap, offset$2, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth) {
	var stepSpace = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 0;
	var offsetDeg = offset$2 / 100 * 360 * ((360 - gapDegree) / 360);
	var positionDeg = gapDegree === 0 ? 0 : {
		bottom: 0,
		top: 180,
		left: 90,
		right: -90
	}[gapPosition];
	var strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
	if (strokeLinecap === "round" && percent !== 100) {
		strokeDashoffset += strokeWidth / 2;
		if (strokeDashoffset >= perimeterWithoutGap) strokeDashoffset = perimeterWithoutGap - .01;
	}
	var halfSize = VIEW_BOX_SIZE / 2;
	return {
		stroke: typeof strokeColor === "string" ? strokeColor : void 0,
		strokeDasharray: "".concat(perimeterWithoutGap, "px ").concat(perimeter),
		strokeDashoffset: strokeDashoffset + stepSpace,
		transform: "rotate(".concat(rotateDeg + offsetDeg + positionDeg, "deg)"),
		transformOrigin: "".concat(halfSize, "px ").concat(halfSize, "px"),
		transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
		fillOpacity: 0
	};
};

//#endregion
//#region node_modules/rc-progress/es/Circle/index.js
var import_classnames$65 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$19 = [
	"id",
	"prefixCls",
	"steps",
	"strokeWidth",
	"trailWidth",
	"gapDegree",
	"gapPosition",
	"trailColor",
	"strokeLinecap",
	"style",
	"className",
	"strokeColor",
	"percent"
];
function toArray$3(value) {
	var mergedValue = value !== null && value !== void 0 ? value : [];
	return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
}
var Circle$1 = function Circle$2(props) {
	var _defaultProps$props = _objectSpread2(_objectSpread2({}, defaultProps), props), id = _defaultProps$props.id, prefixCls = _defaultProps$props.prefixCls, steps = _defaultProps$props.steps, strokeWidth = _defaultProps$props.strokeWidth, trailWidth = _defaultProps$props.trailWidth, _defaultProps$props$g = _defaultProps$props.gapDegree, gapDegree = _defaultProps$props$g === void 0 ? 0 : _defaultProps$props$g, gapPosition = _defaultProps$props.gapPosition, trailColor = _defaultProps$props.trailColor, strokeLinecap = _defaultProps$props.strokeLinecap, style$1 = _defaultProps$props.style, className = _defaultProps$props.className, strokeColor = _defaultProps$props.strokeColor, percent = _defaultProps$props.percent, restProps = _objectWithoutProperties(_defaultProps$props, _excluded$19);
	var halfSize = VIEW_BOX_SIZE / 2;
	var mergedId = useId_default$1(id);
	var gradientId = "".concat(mergedId, "-gradient");
	var radius$1 = halfSize - strokeWidth / 2;
	var perimeter = Math.PI * 2 * radius$1;
	var rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
	var perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
	var _ref = _typeof(steps) === "object" ? steps : {
		count: steps,
		gap: 2
	}, stepCount = _ref.count, stepGap = _ref.gap;
	var percentList = toArray$3(percent);
	var strokeColorList = toArray$3(strokeColor);
	var gradient = strokeColorList.find(function(color) {
		return color && _typeof(color) === "object";
	});
	var mergedStrokeLinecap = gradient && _typeof(gradient) === "object" ? "butt" : strokeLinecap;
	var circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, trailColor, mergedStrokeLinecap, strokeWidth);
	var paths = useTransitionDuration();
	return /* @__PURE__ */ import_react.createElement("svg", _extends({
		className: (0, import_classnames$65.default)("".concat(prefixCls, "-circle"), className),
		viewBox: "0 0 ".concat(VIEW_BOX_SIZE, " ").concat(VIEW_BOX_SIZE),
		style: style$1,
		id,
		role: "presentation"
	}, restProps), !stepCount && /* @__PURE__ */ import_react.createElement("circle", {
		className: "".concat(prefixCls, "-circle-trail"),
		r: radius$1,
		cx: halfSize,
		cy: halfSize,
		stroke: trailColor,
		strokeLinecap: mergedStrokeLinecap,
		strokeWidth: trailWidth || strokeWidth,
		style: circleStyle
	}), stepCount ? function getStepStokeList() {
		var current = Math.round(stepCount * (percentList[0] / 100));
		var stepPtg = 100 / stepCount;
		var stackPtg = 0;
		return new Array(stepCount).fill(null).map(function(_, index$2) {
			var color = index$2 <= current - 1 ? strokeColorList[0] : trailColor;
			var stroke = color && _typeof(color) === "object" ? "url(#".concat(gradientId, ")") : void 0;
			var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, "butt", strokeWidth, stepGap);
			stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepGap) * 100 / perimeterWithoutGap;
			return /* @__PURE__ */ import_react.createElement("circle", {
				key: index$2,
				className: "".concat(prefixCls, "-circle-path"),
				r: radius$1,
				cx: halfSize,
				cy: halfSize,
				stroke,
				strokeWidth,
				opacity: 1,
				style: circleStyleForStack,
				ref: function ref(elem) {
					paths[index$2] = elem;
				}
			});
		});
	}() : function getStokeList() {
		var stackPtg = 0;
		return percentList.map(function(ptg, index$2) {
			var color = strokeColorList[index$2] || strokeColorList[strokeColorList.length - 1];
			var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, mergedStrokeLinecap, strokeWidth);
			stackPtg += ptg;
			return /* @__PURE__ */ import_react.createElement(PtgCircle_default, {
				key: index$2,
				color,
				ptg,
				radius: radius$1,
				prefixCls,
				gradientId,
				style: circleStyleForStack,
				strokeLinecap: mergedStrokeLinecap,
				strokeWidth,
				gapDegree,
				ref: function ref(elem) {
					paths[index$2] = elem;
				},
				size: VIEW_BOX_SIZE
			});
		}).reverse();
	}());
};
Circle$1.displayName = "Circle";
var Circle_default$1 = Circle$1;

//#endregion
//#region node_modules/antd/es/progress/utils.js
function validProgress(progress) {
	if (!progress || progress < 0) return 0;
	if (progress > 100) return 100;
	return progress;
}
function getSuccessPercent({ success, successPercent }) {
	let percent = successPercent;
	/** @deprecated Use `percent` instead */
	if (success && "progress" in success) percent = success.progress;
	if (success && "percent" in success) percent = success.percent;
	return percent;
}
const getPercentage = ({ percent, success, successPercent }) => {
	const realSuccessPercent = validProgress(getSuccessPercent({
		success,
		successPercent
	}));
	return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
};
const getStrokeColor = ({ success = {}, strokeColor }) => {
	const { strokeColor: successColor } = success;
	return [successColor || presetPrimaryColors.green, strokeColor || null];
};
const getSize = (size, type$2, extra) => {
	var _a, _b, _c, _d;
	let width = -1;
	let height = -1;
	if (type$2 === "step") {
		const steps = extra.steps;
		const strokeWidth = extra.strokeWidth;
		if (typeof size === "string" || typeof size === "undefined") {
			width = size === "small" ? 2 : 14;
			height = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 8;
		} else if (typeof size === "number") [width, height] = [size, size];
		else [width = 14, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
		width *= steps;
	} else if (type$2 === "line") {
		const strokeWidth = extra === null || extra === void 0 ? void 0 : extra.strokeWidth;
		if (typeof size === "string" || typeof size === "undefined") height = strokeWidth || (size === "small" ? 6 : 8);
		else if (typeof size === "number") [width, height] = [size, size];
		else [width = -1, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
	} else if (type$2 === "circle" || type$2 === "dashboard") {
		if (typeof size === "string" || typeof size === "undefined") [width, height] = size === "small" ? [60, 60] : [120, 120];
		else if (typeof size === "number") [width, height] = [size, size];
		else if (Array.isArray(size)) {
			width = (_b = (_a = size[0]) !== null && _a !== void 0 ? _a : size[1]) !== null && _b !== void 0 ? _b : 120;
			height = (_d = (_c = size[0]) !== null && _c !== void 0 ? _c : size[1]) !== null && _d !== void 0 ? _d : 120;
		}
	}
	return [width, height];
};

//#endregion
//#region node_modules/antd/es/progress/Circle.js
var import_classnames$64 = /* @__PURE__ */ __toESM(require_classnames());
var CIRCLE_MIN_STROKE_WIDTH = 3;
var getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
var Circle = (props) => {
	const { prefixCls, trailColor = null, strokeLinecap = "round", gapPosition, gapDegree, width: originWidth = 120, type: type$2, children, success, size = originWidth, steps } = props;
	const [width, height] = getSize(size, "circle");
	let { strokeWidth } = props;
	if (strokeWidth === void 0) strokeWidth = Math.max(getMinPercent(width), 6);
	const circleStyle = {
		width,
		height,
		fontSize: width * .15 + 6
	};
	const realGapDegree = import_react.useMemo(() => {
		if (gapDegree || gapDegree === 0) return gapDegree;
		if (type$2 === "dashboard") return 75;
	}, [gapDegree, type$2]);
	const percentArray = getPercentage(props);
	const gapPos = gapPosition || type$2 === "dashboard" && "bottom" || void 0;
	const isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]";
	const strokeColor = getStrokeColor({
		success,
		strokeColor: props.strokeColor
	});
	const wrapperClassName = (0, import_classnames$64.default)(`${prefixCls}-inner`, { [`${prefixCls}-circle-gradient`]: isGradient });
	const circleContent = /* @__PURE__ */ import_react.createElement(Circle_default$1, {
		steps,
		percent: steps ? percentArray[1] : percentArray,
		strokeWidth,
		trailWidth: strokeWidth,
		strokeColor: steps ? strokeColor[1] : strokeColor,
		strokeLinecap,
		trailColor,
		prefixCls,
		gapDegree: realGapDegree,
		gapPosition: gapPos
	});
	const smallCircle = width <= 20;
	const node$1 = /* @__PURE__ */ import_react.createElement("div", {
		className: wrapperClassName,
		style: circleStyle
	}, circleContent, !smallCircle && children);
	if (smallCircle) return /* @__PURE__ */ import_react.createElement(tooltip_default, { title: children }, node$1);
	return node$1;
};
var Circle_default = Circle;

//#endregion
//#region node_modules/antd/es/progress/style/index.js
const LineStrokeColorVar = "--progress-line-stroke-color";
const Percent = "--progress-percent";
var genAntProgressActive = (isRtl) => {
	const direction = isRtl ? "100%" : "-100%";
	return new Keyframes_default(`antProgress${isRtl ? "RTL" : "LTR"}Active`, {
		"0%": {
			transform: `translateX(${direction}) scaleX(0)`,
			opacity: .1
		},
		"20%": {
			transform: `translateX(${direction}) scaleX(0)`,
			opacity: .5
		},
		to: {
			transform: "translateX(0) scaleX(1)",
			opacity: 0
		}
	});
};
var genBaseStyle$6 = (token$1) => {
	const { componentCls: progressCls, iconCls: iconPrefixCls } = token$1;
	return { [progressCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		display: "inline-block",
		"&-rtl": { direction: "rtl" },
		"&-line": {
			position: "relative",
			width: "100%",
			fontSize: token$1.fontSize
		},
		[`${progressCls}-outer`]: {
			display: "inline-flex",
			alignItems: "center",
			width: "100%"
		},
		[`${progressCls}-inner`]: {
			position: "relative",
			display: "inline-block",
			width: "100%",
			flex: 1,
			overflow: "hidden",
			verticalAlign: "middle",
			backgroundColor: token$1.remainingColor,
			borderRadius: token$1.lineBorderRadius
		},
		[`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: { [`${progressCls}-circle-path`]: { stroke: token$1.defaultColor } },
		[`${progressCls}-success-bg, ${progressCls}-bg`]: {
			position: "relative",
			background: token$1.defaultColor,
			borderRadius: token$1.lineBorderRadius,
			transition: `all ${token$1.motionDurationSlow} ${token$1.motionEaseInOutCirc}`
		},
		[`${progressCls}-layout-bottom`]: {
			display: "flex",
			flexDirection: "column",
			alignItems: "center",
			justifyContent: "center",
			[`${progressCls}-text`]: {
				width: "max-content",
				marginInlineStart: 0,
				marginTop: token$1.marginXXS
			}
		},
		[`${progressCls}-bg`]: {
			overflow: "hidden",
			"&::after": {
				content: "\"\"",
				background: {
					_multi_value_: true,
					value: ["inherit", `var(${LineStrokeColorVar})`]
				},
				height: "100%",
				width: `calc(1 / var(${Percent}) * 100%)`,
				display: "block"
			},
			[`&${progressCls}-bg-inner`]: {
				minWidth: "max-content",
				"&::after": { content: "none" },
				[`${progressCls}-text-inner`]: {
					color: token$1.colorWhite,
					[`&${progressCls}-text-bright`]: { color: "rgba(0, 0, 0, 0.45)" }
				}
			}
		},
		[`${progressCls}-success-bg`]: {
			position: "absolute",
			insetBlockStart: 0,
			insetInlineStart: 0,
			backgroundColor: token$1.colorSuccess
		},
		[`${progressCls}-text`]: {
			display: "inline-block",
			marginInlineStart: token$1.marginXS,
			color: token$1.colorText,
			lineHeight: 1,
			width: "2em",
			whiteSpace: "nowrap",
			textAlign: "start",
			verticalAlign: "middle",
			wordBreak: "normal",
			[iconPrefixCls]: { fontSize: token$1.fontSize },
			[`&${progressCls}-text-outer`]: { width: "max-content" },
			[`&${progressCls}-text-outer${progressCls}-text-start`]: {
				width: "max-content",
				marginInlineStart: 0,
				marginInlineEnd: token$1.marginXS
			}
		},
		[`${progressCls}-text-inner`]: {
			display: "flex",
			justifyContent: "center",
			alignItems: "center",
			width: "100%",
			height: "100%",
			marginInlineStart: 0,
			padding: `0 ${unit(token$1.paddingXXS)}`,
			[`&${progressCls}-text-start`]: { justifyContent: "start" },
			[`&${progressCls}-text-end`]: { justifyContent: "end" }
		},
		[`&${progressCls}-status-active`]: { [`${progressCls}-bg::before`]: {
			position: "absolute",
			inset: 0,
			backgroundColor: token$1.colorBgContainer,
			borderRadius: token$1.lineBorderRadius,
			opacity: 0,
			animationName: genAntProgressActive(),
			animationDuration: token$1.progressActiveMotionDuration,
			animationTimingFunction: token$1.motionEaseOutQuint,
			animationIterationCount: "infinite",
			content: "\"\""
		} },
		[`&${progressCls}-rtl${progressCls}-status-active`]: { [`${progressCls}-bg::before`]: { animationName: genAntProgressActive(true) } },
		[`&${progressCls}-status-exception`]: {
			[`${progressCls}-bg`]: { backgroundColor: token$1.colorError },
			[`${progressCls}-text`]: { color: token$1.colorError }
		},
		[`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: { [`${progressCls}-circle-path`]: { stroke: token$1.colorError } },
		[`&${progressCls}-status-success`]: {
			[`${progressCls}-bg`]: { backgroundColor: token$1.colorSuccess },
			[`${progressCls}-text`]: { color: token$1.colorSuccess }
		},
		[`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: { [`${progressCls}-circle-path`]: { stroke: token$1.colorSuccess } }
	}) };
};
var genCircleStyle = (token$1) => {
	const { componentCls: progressCls, iconCls: iconPrefixCls } = token$1;
	return {
		[progressCls]: {
			[`${progressCls}-circle-trail`]: { stroke: token$1.remainingColor },
			[`&${progressCls}-circle ${progressCls}-inner`]: {
				position: "relative",
				lineHeight: 1,
				backgroundColor: "transparent"
			},
			[`&${progressCls}-circle ${progressCls}-text`]: {
				position: "absolute",
				insetBlockStart: "50%",
				insetInlineStart: 0,
				width: "100%",
				margin: 0,
				padding: 0,
				color: token$1.circleTextColor,
				fontSize: token$1.circleTextFontSize,
				lineHeight: 1,
				whiteSpace: "normal",
				textAlign: "center",
				transform: "translateY(-50%)",
				[iconPrefixCls]: { fontSize: token$1.circleIconFontSize }
			},
			[`${progressCls}-circle&-status-exception`]: { [`${progressCls}-text`]: { color: token$1.colorError } },
			[`${progressCls}-circle&-status-success`]: { [`${progressCls}-text`]: { color: token$1.colorSuccess } }
		},
		[`${progressCls}-inline-circle`]: {
			lineHeight: 1,
			[`${progressCls}-inner`]: { verticalAlign: "bottom" }
		}
	};
};
var genStepStyle = (token$1) => {
	const { componentCls: progressCls } = token$1;
	return { [progressCls]: { [`${progressCls}-steps`]: {
		display: "inline-block",
		"&-outer": {
			display: "flex",
			flexDirection: "row",
			alignItems: "center"
		},
		"&-item": {
			flexShrink: 0,
			minWidth: token$1.progressStepMinWidth,
			marginInlineEnd: token$1.progressStepMarginInlineEnd,
			backgroundColor: token$1.remainingColor,
			transition: `all ${token$1.motionDurationSlow}`,
			"&-active": { backgroundColor: token$1.defaultColor }
		}
	} } };
};
var genSmallLine = (token$1) => {
	const { componentCls: progressCls, iconCls: iconPrefixCls } = token$1;
	return { [progressCls]: { [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: { fontSize: token$1.fontSizeSM } } };
};
const prepareComponentToken$15 = (token$1) => ({
	circleTextColor: token$1.colorText,
	defaultColor: token$1.colorInfo,
	remainingColor: token$1.colorFillSecondary,
	lineBorderRadius: 100,
	circleTextFontSize: "1em",
	circleIconFontSize: `${token$1.fontSize / token$1.fontSizeSM}em`
});
var style_default$16 = genStyleHooks("Progress", (token$1) => {
	const progressStepMarginInlineEnd = token$1.calc(token$1.marginXXS).div(2).equal();
	const progressToken = merge(token$1, {
		progressStepMarginInlineEnd,
		progressStepMinWidth: progressStepMarginInlineEnd,
		progressActiveMotionDuration: "2.4s"
	});
	return [
		genBaseStyle$6(progressToken),
		genCircleStyle(progressToken),
		genStepStyle(progressToken),
		genSmallLine(progressToken)
	];
}, prepareComponentToken$15);

//#endregion
//#region node_modules/antd/es/progress/Line.js
var import_classnames$63 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$25 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
/**
* @example
*   {
*     "0%": "#afc163",
*     "75%": "#009900",
*     "50%": "green", // ====> '#afc163 0%, #66FF00 25%, #00CC00 50%, #009900 75%, #ffffff 100%'
*     "25%": "#66FF00",
*     "100%": "#ffffff"
*   }
*/
const sortGradient = (gradients) => {
	let tempArr = [];
	Object.keys(gradients).forEach((key) => {
		const formattedKey = parseFloat(key.replace(/%/g, ""));
		if (!Number.isNaN(formattedKey)) tempArr.push({
			key: formattedKey,
			value: gradients[key]
		});
	});
	tempArr = tempArr.sort((a, b) => a.key - b.key);
	return tempArr.map(({ key, value }) => `${value} ${key}%`).join(", ");
};
/**
* Then this man came to realize the truth: Besides six pence, there is the moon. Besides bread and
* butter, there is the bug. And... Besides women, there is the code.
*
* @example
*   {
*     "0%": "#afc163",
*     "25%": "#66FF00",
*     "50%": "#00CC00", // ====>  linear-gradient(to right, #afc163 0%, #66FF00 25%,
*     "75%": "#009900", //        #00CC00 50%, #009900 75%, #ffffff 100%)
*     "100%": "#ffffff"
*   }
*/
const handleGradient = (strokeColor, directionConfig) => {
	const { from: from$1 = presetPrimaryColors.blue, to = presetPrimaryColors.blue, direction = directionConfig === "rtl" ? "to left" : "to right" } = strokeColor, rest = __rest$25(strokeColor, [
		"from",
		"to",
		"direction"
	]);
	if (Object.keys(rest).length !== 0) {
		const sortedGradients = sortGradient(rest);
		const background$1 = `linear-gradient(${direction}, ${sortedGradients})`;
		return {
			background: background$1,
			[LineStrokeColorVar]: background$1
		};
	}
	const background = `linear-gradient(${direction}, ${from$1}, ${to})`;
	return {
		background,
		[LineStrokeColorVar]: background
	};
};
var Line = (props) => {
	const { prefixCls, direction: directionConfig, percent, size, strokeWidth, strokeColor, strokeLinecap = "round", children, trailColor = null, percentPosition, success } = props;
	const { align: infoAlign, type: infoPosition } = percentPosition;
	const backgroundProps = strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, directionConfig) : {
		[LineStrokeColorVar]: strokeColor,
		background: strokeColor
	};
	const borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0;
	const [width, height] = getSize(size !== null && size !== void 0 ? size : [-1, strokeWidth || (size === "small" ? 6 : 8)], "line", { strokeWidth });
	devUseWarning("Progress").deprecated(!("strokeWidth" in props), "strokeWidth", "size");
	const trailStyle = {
		backgroundColor: trailColor || void 0,
		borderRadius
	};
	const percentStyle = Object.assign(Object.assign({
		width: `${validProgress(percent)}%`,
		height,
		borderRadius
	}, backgroundProps), { [Percent]: validProgress(percent) / 100 });
	const successPercent = getSuccessPercent(props);
	const successPercentStyle = {
		width: `${validProgress(successPercent)}%`,
		height,
		borderRadius,
		backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
	};
	const outerStyle = { width: width < 0 ? "100%" : width };
	const lineInner = /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-inner`,
		style: trailStyle
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$63.default)(`${prefixCls}-bg`, `${prefixCls}-bg-${infoPosition}`),
		style: percentStyle
	}, infoPosition === "inner" && children), successPercent !== void 0 && /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-success-bg`,
		style: successPercentStyle
	}));
	const isOuterStart = infoPosition === "outer" && infoAlign === "start";
	const isOuterEnd = infoPosition === "outer" && infoAlign === "end";
	return infoPosition === "outer" && infoAlign === "center" ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-layout-bottom` }, lineInner, children) : /* @__PURE__ */ import_react.createElement("div", {
		className: `${prefixCls}-outer`,
		style: outerStyle
	}, isOuterStart && children, lineInner, isOuterEnd && children);
};
var Line_default = Line;

//#endregion
//#region node_modules/antd/es/progress/Steps.js
var import_classnames$62 = /* @__PURE__ */ __toESM(require_classnames());
var Steps$2 = (props) => {
	const { size, steps, rounding: customRounding = Math.round, percent = 0, strokeWidth = 8, strokeColor, trailColor = null, prefixCls, children } = props;
	const current = customRounding(steps * (percent / 100));
	const [width, height] = getSize(size !== null && size !== void 0 ? size : [size === "small" ? 2 : 14, strokeWidth], "step", {
		steps,
		strokeWidth
	});
	const unitWidth = width / steps;
	const styledSteps = Array.from({ length: steps });
	for (let i = 0; i < steps; i++) {
		const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
		styledSteps[i] = /* @__PURE__ */ import_react.createElement("div", {
			key: i,
			className: (0, import_classnames$62.default)(`${prefixCls}-steps-item`, { [`${prefixCls}-steps-item-active`]: i <= current - 1 }),
			style: {
				backgroundColor: i <= current - 1 ? color : trailColor,
				width: unitWidth,
				height
			}
		});
	}
	return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-steps-outer` }, styledSteps, children);
};
var Steps_default$1 = Steps$2;

//#endregion
//#region node_modules/antd/es/progress/progress.js
var import_classnames$61 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$24 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var ProgressStatuses = [
	"normal",
	"exception",
	"active",
	"success"
];
var Progress = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, steps, strokeColor, percent = 0, size = "default", showInfo = true, type: type$2 = "line", status, format: format$2, style: style$1, percentPosition = {} } = props, restProps = __rest$24(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"steps",
		"strokeColor",
		"percent",
		"size",
		"showInfo",
		"type",
		"status",
		"format",
		"style",
		"percentPosition"
	]);
	const { align: infoAlign = "end", type: infoPosition = "outer" } = percentPosition;
	const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
	const strokeColorNotGradient = typeof strokeColor === "string" || Array.isArray(strokeColor) ? strokeColor : void 0;
	const strokeColorIsBright = import_react.useMemo(() => {
		if (strokeColorNotArray) {
			const color = typeof strokeColorNotArray === "string" ? strokeColorNotArray : Object.values(strokeColorNotArray)[0];
			return new FastColor(color).isLight();
		}
		return false;
	}, [strokeColor]);
	const percentNumber = import_react.useMemo(() => {
		var _a, _b;
		const successPercent = getSuccessPercent(props);
		return parseInt(successPercent !== void 0 ? (_a = successPercent !== null && successPercent !== void 0 ? successPercent : 0) === null || _a === void 0 ? void 0 : _a.toString() : (_b = percent !== null && percent !== void 0 ? percent : 0) === null || _b === void 0 ? void 0 : _b.toString(), 10);
	}, [
		percent,
		props.success,
		props.successPercent
	]);
	const progressStatus = import_react.useMemo(() => {
		if (!ProgressStatuses.includes(status) && percentNumber >= 100) return "success";
		return status || "normal";
	}, [status, percentNumber]);
	const { getPrefixCls, direction, progress: progressStyle } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("progress", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$16(prefixCls);
	const isLineType = type$2 === "line";
	const isPureLineType = isLineType && !steps;
	const progressInfo = import_react.useMemo(() => {
		if (!showInfo) return null;
		const successPercent = getSuccessPercent(props);
		let text;
		const textFormatter = format$2 || ((number$1) => `${number$1}%`);
		const isBrightInnerColor = isLineType && strokeColorIsBright && infoPosition === "inner";
		if (infoPosition === "inner" || format$2 || progressStatus !== "exception" && progressStatus !== "success") text = textFormatter(validProgress(percent), validProgress(successPercent));
		else if (progressStatus === "exception") text = isLineType ? /* @__PURE__ */ import_react.createElement(CloseCircleFilled_default, null) : /* @__PURE__ */ import_react.createElement(CloseOutlined_default, null);
		else if (progressStatus === "success") text = isLineType ? /* @__PURE__ */ import_react.createElement(CheckCircleFilled_default, null) : /* @__PURE__ */ import_react.createElement(CheckOutlined_default, null);
		return /* @__PURE__ */ import_react.createElement("span", {
			className: (0, import_classnames$61.default)(`${prefixCls}-text`, {
				[`${prefixCls}-text-bright`]: isBrightInnerColor,
				[`${prefixCls}-text-${infoAlign}`]: isPureLineType,
				[`${prefixCls}-text-${infoPosition}`]: isPureLineType
			}),
			title: typeof text === "string" ? text : void 0
		}, text);
	}, [
		showInfo,
		percent,
		percentNumber,
		progressStatus,
		type$2,
		prefixCls,
		format$2
	]);
	{
		const warning$4 = devUseWarning("Progress");
		warning$4.deprecated(!("successPercent" in props), "successPercent", "success.percent");
		warning$4.deprecated(!("width" in props), "width", "size");
		if (type$2 === "circle" || type$2 === "dashboard") {
			if (Array.isArray(size)) warning$4(false, "usage", "Type \"circle\" and \"dashboard\" do not accept array as `size`, please use number or preset size instead.");
			else if (typeof size === "object") warning$4(false, "usage", "Type \"circle\" and \"dashboard\" do not accept object as `size`, please use number or preset size instead.");
		}
		if (props.success && "progress" in props.success) warning$4.deprecated(false, "success.progress", "success.percent");
	}
	let progress;
	if (type$2 === "line") progress = steps ? /* @__PURE__ */ import_react.createElement(Steps_default$1, Object.assign({}, props, {
		strokeColor: strokeColorNotGradient,
		prefixCls,
		steps: typeof steps === "object" ? steps.count : steps
	}), progressInfo) : /* @__PURE__ */ import_react.createElement(Line_default, Object.assign({}, props, {
		strokeColor: strokeColorNotArray,
		prefixCls,
		direction,
		percentPosition: {
			align: infoAlign,
			type: infoPosition
		}
	}), progressInfo);
	else if (type$2 === "circle" || type$2 === "dashboard") progress = /* @__PURE__ */ import_react.createElement(Circle_default, Object.assign({}, props, {
		strokeColor: strokeColorNotArray,
		prefixCls,
		progressStatus
	}), progressInfo);
	const classString = (0, import_classnames$61.default)(prefixCls, `${prefixCls}-status-${progressStatus}`, {
		[`${prefixCls}-${type$2 === "dashboard" && "circle" || type$2}`]: type$2 !== "line",
		[`${prefixCls}-inline-circle`]: type$2 === "circle" && getSize(size, "circle")[0] <= 20,
		[`${prefixCls}-line`]: isPureLineType,
		[`${prefixCls}-line-align-${infoAlign}`]: isPureLineType,
		[`${prefixCls}-line-position-${infoPosition}`]: isPureLineType,
		[`${prefixCls}-steps`]: steps,
		[`${prefixCls}-show-info`]: showInfo,
		[`${prefixCls}-${size}`]: typeof size === "string",
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, progressStyle === null || progressStyle === void 0 ? void 0 : progressStyle.className, className, rootClassName, hashId, cssVarCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({
		ref,
		style: Object.assign(Object.assign({}, progressStyle === null || progressStyle === void 0 ? void 0 : progressStyle.style), style$1),
		className: classString,
		role: "progressbar",
		"aria-valuenow": percentNumber,
		"aria-valuemin": 0,
		"aria-valuemax": 100
	}, omit(restProps, [
		"trailColor",
		"strokeWidth",
		"width",
		"gapDegree",
		"gapPosition",
		"strokeLinecap",
		"success",
		"successPercent"
	])), progress));
});
Progress.displayName = "Progress";
var progress_default$2 = Progress;

//#endregion
//#region node_modules/antd/es/progress/index.js
var progress_default = progress_default$2;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
function _createForOfIteratorHelper(r$1, e$2) {
	var t$1 = "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (!t$1) {
		if (Array.isArray(r$1) || (t$1 = _unsupportedIterableToArray(r$1)) || e$2 && r$1 && "number" == typeof r$1.length) {
			t$1 && (r$1 = t$1);
			var _n = 0, F = function F$1() {};
			return {
				s: F,
				n: function n$1() {
					return _n >= r$1.length ? { done: !0 } : {
						done: !1,
						value: r$1[_n++]
					};
				},
				e: function e$3(r$2) {
					throw r$2;
				},
				f: F
			};
		}
		throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	var o$2, a = !0, u = !1;
	return {
		s: function s() {
			t$1 = t$1.call(r$1);
		},
		n: function n$1() {
			var r$2 = t$1.next();
			return a = r$2.done, r$2;
		},
		e: function e$3(r$2) {
			u = !0, o$2 = r$2;
		},
		f: function f() {
			try {
				a || null == t$1["return"] || t$1["return"]();
			} finally {
				if (u) throw o$2;
			}
		}
	};
}

//#endregion
//#region node_modules/@rc-component/qrcode/es/libs/qrcodegen.js
var _class, _class2;
function appendBits(val, len, bb) {
	if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError("Value out of range");
	for (var i = len - 1; i >= 0; i--) bb.push(val >>> i & 1);
}
function getBit(x, i) {
	return (x >>> i & 1) != 0;
}
function assert(cond) {
	if (!cond) throw new Error("Assertion error");
}
var Mode = /* @__PURE__ */ function() {
	function Mode$1(modeBits, numBitsCharCount) {
		_classCallCheck(this, Mode$1);
		_defineProperty(this, "modeBits", void 0);
		_defineProperty(this, "numBitsCharCount", void 0);
		this.modeBits = modeBits;
		this.numBitsCharCount = numBitsCharCount;
	}
	_createClass(Mode$1, [{
		key: "numCharCountBits",
		value: function numCharCountBits(ver) {
			return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
		}
	}]);
	return Mode$1;
}();
_class = Mode;
_defineProperty(Mode, "NUMERIC", new _class(1, [
	10,
	12,
	14
]));
_defineProperty(Mode, "ALPHANUMERIC", new _class(2, [
	9,
	11,
	13
]));
_defineProperty(Mode, "BYTE", new _class(4, [
	8,
	16,
	16
]));
_defineProperty(Mode, "KANJI", new _class(8, [
	8,
	10,
	12
]));
_defineProperty(Mode, "ECI", new _class(7, [
	0,
	0,
	0
]));
var Ecc = /* @__PURE__ */ _createClass(function Ecc$1(ordinal, formatBits) {
	_classCallCheck(this, Ecc$1);
	_defineProperty(this, "ordinal", void 0);
	_defineProperty(this, "formatBits", void 0);
	this.ordinal = ordinal;
	this.formatBits = formatBits;
});
_class2 = Ecc;
_defineProperty(Ecc, "LOW", new _class2(0, 1));
_defineProperty(Ecc, "MEDIUM", new _class2(1, 0));
_defineProperty(Ecc, "QUARTILE", new _class2(2, 3));
_defineProperty(Ecc, "HIGH", new _class2(3, 2));
var QrSegment = /* @__PURE__ */ function() {
	function QrSegment$1(mode, numChars, bitData) {
		_classCallCheck(this, QrSegment$1);
		_defineProperty(this, "mode", void 0);
		_defineProperty(this, "numChars", void 0);
		_defineProperty(this, "bitData", void 0);
		this.mode = mode;
		this.numChars = numChars;
		this.bitData = bitData;
		if (numChars < 0) throw new RangeError("Invalid argument");
		this.bitData = bitData.slice();
	}
	_createClass(QrSegment$1, [{
		key: "getData",
		value: function getData() {
			return this.bitData.slice();
		}
	}], [
		{
			key: "makeBytes",
			value: function makeBytes(data) {
				var bb = [];
				var _iterator = _createForOfIteratorHelper(data), _step;
				try {
					for (_iterator.s(); !(_step = _iterator.n()).done;) {
						var b = _step.value;
						appendBits(b, 8, bb);
					}
				} catch (err) {
					_iterator.e(err);
				} finally {
					_iterator.f();
				}
				return new QrSegment$1(Mode.BYTE, data.length, bb);
			}
		},
		{
			key: "makeNumeric",
			value: function makeNumeric(digits) {
				if (!QrSegment$1.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");
				var bb = [];
				for (var i = 0; i < digits.length;) {
					var n$1 = Math.min(digits.length - i, 3);
					appendBits(parseInt(digits.substring(i, i + n$1), 10), n$1 * 3 + 1, bb);
					i += n$1;
				}
				return new QrSegment$1(Mode.NUMERIC, digits.length, bb);
			}
		},
		{
			key: "makeAlphanumeric",
			value: function makeAlphanumeric(text) {
				if (!QrSegment$1.isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
				var bb = [];
				var i;
				for (i = 0; i + 2 <= text.length; i += 2) {
					var temp = QrSegment$1.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
					temp += QrSegment$1.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
					appendBits(temp, 11, bb);
				}
				if (i < text.length) appendBits(QrSegment$1.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
				return new QrSegment$1(Mode.ALPHANUMERIC, text.length, bb);
			}
		},
		{
			key: "makeSegments",
			value: function makeSegments(text) {
				if (text == "") return [];
				else if (QrSegment$1.isNumeric(text)) return [QrSegment$1.makeNumeric(text)];
				else if (QrSegment$1.isAlphanumeric(text)) return [QrSegment$1.makeAlphanumeric(text)];
				else return [QrSegment$1.makeBytes(QrSegment$1.toUtf8ByteArray(text))];
			}
		},
		{
			key: "makeEci",
			value: function makeEci(assignVal) {
				var bb = [];
				if (assignVal < 0) throw new RangeError("ECI assignment value out of range");
				else if (assignVal < 128) appendBits(assignVal, 8, bb);
				else if (assignVal < 16384) {
					appendBits(2, 2, bb);
					appendBits(assignVal, 14, bb);
				} else if (assignVal < 1e6) {
					appendBits(6, 3, bb);
					appendBits(assignVal, 21, bb);
				} else throw new RangeError("ECI assignment value out of range");
				return new QrSegment$1(Mode.ECI, 0, bb);
			}
		},
		{
			key: "isNumeric",
			value: function isNumeric$1(text) {
				return QrSegment$1.NUMERIC_REGEX.test(text);
			}
		},
		{
			key: "isAlphanumeric",
			value: function isAlphanumeric(text) {
				return QrSegment$1.ALPHANUMERIC_REGEX.test(text);
			}
		},
		{
			key: "getTotalBits",
			value: function getTotalBits(segs, version$2) {
				var result = 0;
				var _iterator2 = _createForOfIteratorHelper(segs), _step2;
				try {
					for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
						var seg = _step2.value;
						var ccbits = seg.mode.numCharCountBits(version$2);
						if (seg.numChars >= 1 << ccbits) return Infinity;
						result += 4 + ccbits + seg.bitData.length;
					}
				} catch (err) {
					_iterator2.e(err);
				} finally {
					_iterator2.f();
				}
				return result;
			}
		},
		{
			key: "toUtf8ByteArray",
			value: function toUtf8ByteArray(input) {
				var str = encodeURI(input);
				var result = [];
				for (var i = 0; i < str.length; i++) if (str.charAt(i) != "%") result.push(str.charCodeAt(i));
				else {
					result.push(parseInt(str.substring(i + 1, i + 3), 16));
					i += 2;
				}
				return result;
			}
		}
	]);
	return QrSegment$1;
}();
_defineProperty(QrSegment, "NUMERIC_REGEX", /^[0-9]*$/);
_defineProperty(QrSegment, "ALPHANUMERIC_REGEX", /^[A-Z0-9 $%*+.\/:-]*$/);
_defineProperty(QrSegment, "ALPHANUMERIC_CHARSET", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
var QrCode = /* @__PURE__ */ function() {
	function QrCode$1(version$2, errorCorrectionLevel, dataCodewords, oriMsk) {
		_classCallCheck(this, QrCode$1);
		_defineProperty(this, "size", void 0);
		_defineProperty(this, "mask", void 0);
		_defineProperty(this, "modules", []);
		_defineProperty(this, "isFunction", []);
		_defineProperty(this, "version", void 0);
		_defineProperty(this, "errorCorrectionLevel", void 0);
		var msk = oriMsk;
		this.version = version$2;
		this.errorCorrectionLevel = errorCorrectionLevel;
		if (version$2 < QrCode$1.MIN_VERSION || version$2 > QrCode$1.MAX_VERSION) throw new RangeError("Version value out of range");
		if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");
		this.size = version$2 * 4 + 17;
		var row = [];
		for (var i = 0; i < this.size; i++) row.push(false);
		for (var _i = 0; _i < this.size; _i++) {
			this.modules.push(row.slice());
			this.isFunction.push(row.slice());
		}
		this.drawFunctionPatterns();
		var allCodewords = this.addEccAndInterleave(dataCodewords);
		this.drawCodewords(allCodewords);
		if (msk == -1) {
			var minPenalty = 1e9;
			for (var _i2 = 0; _i2 < 8; _i2++) {
				this.applyMask(_i2);
				this.drawFormatBits(_i2);
				var penalty = this.getPenaltyScore();
				if (penalty < minPenalty) {
					msk = _i2;
					minPenalty = penalty;
				}
				this.applyMask(_i2);
			}
		}
		assert(0 <= msk && msk <= 7);
		this.mask = msk;
		this.applyMask(msk);
		this.drawFormatBits(msk);
		this.isFunction = [];
	}
	_createClass(QrCode$1, [
		{
			key: "getModule",
			value: function getModule(x, y) {
				return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
			}
		},
		{
			key: "getModules",
			value: function getModules() {
				return this.modules;
			}
		},
		{
			key: "drawFunctionPatterns",
			value: function drawFunctionPatterns() {
				for (var i = 0; i < this.size; i++) {
					this.setFunctionModule(6, i, i % 2 == 0);
					this.setFunctionModule(i, 6, i % 2 == 0);
				}
				this.drawFinderPattern(3, 3);
				this.drawFinderPattern(this.size - 4, 3);
				this.drawFinderPattern(3, this.size - 4);
				var alignPatPos = this.getAlignmentPatternPositions();
				var numAlign = alignPatPos.length;
				for (var _i3 = 0; _i3 < numAlign; _i3++) for (var j = 0; j < numAlign; j++) if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);
				this.drawFormatBits(0);
				this.drawVersion();
			}
		},
		{
			key: "drawFormatBits",
			value: function drawFormatBits(mask) {
				var data = this.errorCorrectionLevel.formatBits << 3 | mask;
				var rem = data;
				for (var i = 0; i < 10; i++) rem = rem << 1 ^ (rem >>> 9) * 1335;
				var bits = (data << 10 | rem) ^ 21522;
				assert(bits >>> 15 == 0);
				for (var _i4 = 0; _i4 <= 5; _i4++) this.setFunctionModule(8, _i4, getBit(bits, _i4));
				this.setFunctionModule(8, 7, getBit(bits, 6));
				this.setFunctionModule(8, 8, getBit(bits, 7));
				this.setFunctionModule(7, 8, getBit(bits, 8));
				for (var _i5 = 9; _i5 < 15; _i5++) this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));
				for (var _i6 = 0; _i6 < 8; _i6++) this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));
				for (var _i7 = 8; _i7 < 15; _i7++) this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));
				this.setFunctionModule(8, this.size - 8, true);
			}
		},
		{
			key: "drawVersion",
			value: function drawVersion() {
				if (this.version < 7) return;
				var rem = this.version;
				for (var i = 0; i < 12; i++) rem = rem << 1 ^ (rem >>> 11) * 7973;
				var bits = this.version << 12 | rem;
				assert(bits >>> 18 == 0);
				for (var _i8 = 0; _i8 < 18; _i8++) {
					var color = getBit(bits, _i8);
					var a = this.size - 11 + _i8 % 3;
					var b = Math.floor(_i8 / 3);
					this.setFunctionModule(a, b, color);
					this.setFunctionModule(b, a, color);
				}
			}
		},
		{
			key: "drawFinderPattern",
			value: function drawFinderPattern(x, y) {
				for (var dy = -4; dy <= 4; dy++) for (var dx = -4; dx <= 4; dx++) {
					var dist = Math.max(Math.abs(dx), Math.abs(dy));
					var xx = x + dx;
					var yy = y + dy;
					if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
				}
			}
		},
		{
			key: "drawAlignmentPattern",
			value: function drawAlignmentPattern(x, y) {
				for (var dy = -2; dy <= 2; dy++) for (var dx = -2; dx <= 2; dx++) this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
			}
		},
		{
			key: "setFunctionModule",
			value: function setFunctionModule(x, y, isDark) {
				this.modules[y][x] = isDark;
				this.isFunction[y][x] = true;
			}
		},
		{
			key: "addEccAndInterleave",
			value: function addEccAndInterleave(data) {
				var ver = this.version;
				var ecl = this.errorCorrectionLevel;
				if (data.length != QrCode$1.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");
				var numBlocks = QrCode$1.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
				var blockEccLen = QrCode$1.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
				var rawCodewords = Math.floor(QrCode$1.getNumRawDataModules(ver) / 8);
				var numShortBlocks = numBlocks - rawCodewords % numBlocks;
				var shortBlockLen = Math.floor(rawCodewords / numBlocks);
				var blocks = [];
				var rsDiv = QrCode$1.reedSolomonComputeDivisor(blockEccLen);
				for (var i = 0, k = 0; i < numBlocks; i++) {
					var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
					k += dat.length;
					var ecc = QrCode$1.reedSolomonComputeRemainder(dat, rsDiv);
					if (i < numShortBlocks) dat.push(0);
					blocks.push(dat.concat(ecc));
				}
				var result = [];
				var _loop = function _loop$1(_i9$1) {
					blocks.forEach(function(block, j) {
						if (_i9$1 != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[_i9$1]);
					});
				};
				for (var _i9 = 0; _i9 < blocks[0].length; _i9++) _loop(_i9);
				assert(result.length == rawCodewords);
				return result;
			}
		},
		{
			key: "drawCodewords",
			value: function drawCodewords(data) {
				if (data.length != Math.floor(QrCode$1.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
				var i = 0;
				for (var right = this.size - 1; right >= 1; right -= 2) {
					if (right == 6) right = 5;
					for (var vert = 0; vert < this.size; vert++) for (var j = 0; j < 2; j++) {
						var x = right - j;
						var y = (right + 1 & 2) == 0 ? this.size - 1 - vert : vert;
						if (!this.isFunction[y][x] && i < data.length * 8) {
							this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
							i++;
						}
					}
				}
				assert(i == data.length * 8);
			}
		},
		{
			key: "applyMask",
			value: function applyMask(mask) {
				if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");
				for (var y = 0; y < this.size; y++) for (var x = 0; x < this.size; x++) {
					var invert = void 0;
					switch (mask) {
						case 0:
							invert = (x + y) % 2 == 0;
							break;
						case 1:
							invert = y % 2 == 0;
							break;
						case 2:
							invert = x % 3 == 0;
							break;
						case 3:
							invert = (x + y) % 3 == 0;
							break;
						case 4:
							invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
							break;
						case 5:
							invert = x * y % 2 + x * y % 3 == 0;
							break;
						case 6:
							invert = (x * y % 2 + x * y % 3) % 2 == 0;
							break;
						case 7:
							invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
							break;
						default: throw new Error("Unreachable");
					}
					if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];
				}
			}
		},
		{
			key: "getPenaltyScore",
			value: function getPenaltyScore() {
				var result = 0;
				for (var y = 0; y < this.size; y++) {
					var runColor = false;
					var runX = 0;
					var runHistory = [
						0,
						0,
						0,
						0,
						0,
						0,
						0
					];
					for (var x = 0; x < this.size; x++) if (this.modules[y][x] == runColor) {
						runX++;
						if (runX == 5) result += QrCode$1.PENALTY_N1;
						else if (runX > 5) result++;
					} else {
						this.finderPenaltyAddHistory(runX, runHistory);
						if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * QrCode$1.PENALTY_N3;
						runColor = this.modules[y][x];
						runX = 1;
					}
					result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode$1.PENALTY_N3;
				}
				for (var _x = 0; _x < this.size; _x++) {
					var _runColor = false;
					var runY = 0;
					var _runHistory = [
						0,
						0,
						0,
						0,
						0,
						0,
						0
					];
					for (var _y = 0; _y < this.size; _y++) if (this.modules[_y][_x] == _runColor) {
						runY++;
						if (runY == 5) result += QrCode$1.PENALTY_N1;
						else if (runY > 5) result++;
					} else {
						this.finderPenaltyAddHistory(runY, _runHistory);
						if (!_runColor) result += this.finderPenaltyCountPatterns(_runHistory) * QrCode$1.PENALTY_N3;
						_runColor = this.modules[_y][_x];
						runY = 1;
					}
					result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * QrCode$1.PENALTY_N3;
				}
				for (var _y2 = 0; _y2 < this.size - 1; _y2++) for (var _x2 = 0; _x2 < this.size - 1; _x2++) {
					var color = this.modules[_y2][_x2];
					if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) result += QrCode$1.PENALTY_N2;
				}
				var dark = 0;
				var _iterator3 = _createForOfIteratorHelper(this.modules), _step3;
				try {
					for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) dark = _step3.value.reduce(function(sum, color$1) {
						return sum + (color$1 ? 1 : 0);
					}, dark);
				} catch (err) {
					_iterator3.e(err);
				} finally {
					_iterator3.f();
				}
				var total = this.size * this.size;
				var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
				assert(0 <= k && k <= 9);
				result += k * QrCode$1.PENALTY_N4;
				assert(0 <= result && result <= 2568888);
				return result;
			}
		},
		{
			key: "getAlignmentPatternPositions",
			value: function getAlignmentPatternPositions() {
				if (this.version == 1) return [];
				else {
					var numAlign = Math.floor(this.version / 7) + 2;
					var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
					var result = [6];
					for (var pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);
					return result;
				}
			}
		},
		{
			key: "finderPenaltyCountPatterns",
			value: function finderPenaltyCountPatterns(runHistory) {
				var n$1 = runHistory[1];
				assert(n$1 <= this.size * 3);
				var core = n$1 > 0 && runHistory[2] == n$1 && runHistory[3] == n$1 * 3 && runHistory[4] == n$1 && runHistory[5] == n$1;
				return (core && runHistory[0] >= n$1 * 4 && runHistory[6] >= n$1 ? 1 : 0) + (core && runHistory[6] >= n$1 * 4 && runHistory[0] >= n$1 ? 1 : 0);
			}
		},
		{
			key: "finderPenaltyTerminateAndCount",
			value: function finderPenaltyTerminateAndCount(currentRunColor, oriCurrentRunLength, runHistory) {
				var currentRunLength = oriCurrentRunLength;
				if (currentRunColor) {
					this.finderPenaltyAddHistory(currentRunLength, runHistory);
					currentRunLength = 0;
				}
				currentRunLength += this.size;
				this.finderPenaltyAddHistory(currentRunLength, runHistory);
				return this.finderPenaltyCountPatterns(runHistory);
			}
		},
		{
			key: "finderPenaltyAddHistory",
			value: function finderPenaltyAddHistory(oriCurrentRunLength, runHistory) {
				var currentRunLength = oriCurrentRunLength;
				if (runHistory[0] == 0) currentRunLength += this.size;
				runHistory.pop();
				runHistory.unshift(currentRunLength);
			}
		}
	], [
		{
			key: "encodeText",
			value: function encodeText(text, ecl) {
				var segs = QrSegment.makeSegments(text);
				return QrCode$1.encodeSegments(segs, ecl);
			}
		},
		{
			key: "encodeBinary",
			value: function encodeBinary(data, ecl) {
				var seg = QrSegment.makeBytes(data);
				return QrCode$1.encodeSegments([seg], ecl);
			}
		},
		{
			key: "encodeSegments",
			value: function encodeSegments(segs, oriEcl) {
				var minVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
				var maxVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40;
				var mask = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
				var boostEcl = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
				if (!(QrCode$1.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode$1.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError("Invalid value");
				var version$2;
				var dataUsedBits;
				for (version$2 = minVersion;; version$2++) {
					var _dataCapacityBits = QrCode$1.getNumDataCodewords(version$2, oriEcl) * 8;
					var usedBits = QrSegment.getTotalBits(segs, version$2);
					if (usedBits <= _dataCapacityBits) {
						dataUsedBits = usedBits;
						break;
					}
					if (version$2 >= maxVersion) throw new RangeError("Data too long");
				}
				var ecl = oriEcl;
				for (var _i10 = 0, _arr = [
					Ecc.MEDIUM,
					Ecc.QUARTILE,
					Ecc.HIGH
				]; _i10 < _arr.length; _i10++) {
					var newEcl = _arr[_i10];
					if (boostEcl && dataUsedBits <= QrCode$1.getNumDataCodewords(version$2, newEcl) * 8) ecl = newEcl;
				}
				var bb = [];
				var _iterator4 = _createForOfIteratorHelper(segs), _step4;
				try {
					for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
						var seg = _step4.value;
						appendBits(seg.mode.modeBits, 4, bb);
						appendBits(seg.numChars, seg.mode.numCharCountBits(version$2), bb);
						var _iterator5 = _createForOfIteratorHelper(seg.getData()), _step5;
						try {
							for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
								var b = _step5.value;
								bb.push(b);
							}
						} catch (err) {
							_iterator5.e(err);
						} finally {
							_iterator5.f();
						}
					}
				} catch (err) {
					_iterator4.e(err);
				} finally {
					_iterator4.f();
				}
				assert(bb.length == dataUsedBits);
				var dataCapacityBits = QrCode$1.getNumDataCodewords(version$2, ecl) * 8;
				assert(bb.length <= dataCapacityBits);
				appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
				appendBits(0, (8 - bb.length % 8) % 8, bb);
				assert(bb.length % 8 == 0);
				for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 253) appendBits(padByte, 8, bb);
				var dataCodewords = [];
				while (dataCodewords.length * 8 < bb.length) dataCodewords.push(0);
				bb.forEach(function(b$1, i) {
					dataCodewords[i >>> 3] |= b$1 << 7 - (i & 7);
				});
				return new QrCode$1(version$2, ecl, dataCodewords, mask);
			}
		},
		{
			key: "getNumRawDataModules",
			value: function getNumRawDataModules(ver) {
				if (ver < QrCode$1.MIN_VERSION || ver > QrCode$1.MAX_VERSION) throw new RangeError("Version number out of range");
				var result = (16 * ver + 128) * ver + 64;
				if (ver >= 2) {
					var numAlign = Math.floor(ver / 7) + 2;
					result -= (25 * numAlign - 10) * numAlign - 55;
					if (ver >= 7) result -= 36;
				}
				assert(208 <= result && result <= 29648);
				return result;
			}
		},
		{
			key: "getNumDataCodewords",
			value: function getNumDataCodewords(ver, ecl) {
				return Math.floor(QrCode$1.getNumRawDataModules(ver) / 8) - QrCode$1.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode$1.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
			}
		},
		{
			key: "reedSolomonComputeDivisor",
			value: function reedSolomonComputeDivisor(degree) {
				if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
				var result = [];
				for (var i = 0; i < degree - 1; i++) result.push(0);
				result.push(1);
				var root = 1;
				for (var _i11 = 0; _i11 < degree; _i11++) {
					for (var j = 0; j < result.length; j++) {
						result[j] = QrCode$1.reedSolomonMultiply(result[j], root);
						if (j + 1 < result.length) result[j] ^= result[j + 1];
					}
					root = QrCode$1.reedSolomonMultiply(root, 2);
				}
				return result;
			}
		},
		{
			key: "reedSolomonComputeRemainder",
			value: function reedSolomonComputeRemainder(data, divisor) {
				var result = divisor.map(function() {
					return 0;
				});
				var _iterator6 = _createForOfIteratorHelper(data), _step6;
				try {
					var _loop2 = function _loop2$1() {
						var factor = _step6.value ^ result.shift();
						result.push(0);
						divisor.forEach(function(coef, i) {
							result[i] ^= QrCode$1.reedSolomonMultiply(coef, factor);
						});
					};
					for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) _loop2();
				} catch (err) {
					_iterator6.e(err);
				} finally {
					_iterator6.f();
				}
				return result;
			}
		},
		{
			key: "reedSolomonMultiply",
			value: function reedSolomonMultiply(x, y) {
				if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError("Byte out of range");
				var z = 0;
				for (var i = 7; i >= 0; i--) {
					z = z << 1 ^ (z >>> 7) * 285;
					z ^= (y >>> i & 1) * x;
				}
				assert(z >>> 8 == 0);
				return z;
			}
		}
	]);
	return QrCode$1;
}();
_defineProperty(QrCode, "MIN_VERSION", 1);
_defineProperty(QrCode, "MAX_VERSION", 40);
_defineProperty(QrCode, "PENALTY_N1", 3);
_defineProperty(QrCode, "PENALTY_N2", 3);
_defineProperty(QrCode, "PENALTY_N3", 40);
_defineProperty(QrCode, "PENALTY_N4", 10);
_defineProperty(QrCode, "ECC_CODEWORDS_PER_BLOCK", [
	[
		-1,
		7,
		10,
		15,
		20,
		26,
		18,
		20,
		24,
		30,
		18,
		20,
		24,
		26,
		30,
		22,
		24,
		28,
		30,
		28,
		28,
		28,
		28,
		30,
		30,
		26,
		28,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	],
	[
		-1,
		10,
		16,
		26,
		18,
		24,
		16,
		18,
		22,
		22,
		26,
		30,
		22,
		22,
		24,
		24,
		28,
		28,
		26,
		26,
		26,
		26,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28
	],
	[
		-1,
		13,
		22,
		18,
		26,
		18,
		24,
		18,
		22,
		20,
		24,
		28,
		26,
		24,
		20,
		30,
		24,
		28,
		28,
		26,
		30,
		28,
		30,
		30,
		30,
		30,
		28,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	],
	[
		-1,
		17,
		28,
		22,
		16,
		22,
		28,
		26,
		26,
		24,
		28,
		24,
		28,
		22,
		24,
		24,
		30,
		28,
		28,
		26,
		28,
		30,
		24,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	]
]);
_defineProperty(QrCode, "NUM_ERROR_CORRECTION_BLOCKS", [
	[
		-1,
		1,
		1,
		1,
		1,
		1,
		2,
		2,
		2,
		2,
		4,
		4,
		4,
		4,
		4,
		6,
		6,
		6,
		6,
		7,
		8,
		8,
		9,
		9,
		10,
		12,
		12,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		19,
		20,
		21,
		22,
		24,
		25
	],
	[
		-1,
		1,
		1,
		1,
		2,
		2,
		4,
		4,
		4,
		5,
		5,
		5,
		8,
		9,
		9,
		10,
		10,
		11,
		13,
		14,
		16,
		17,
		17,
		18,
		20,
		21,
		23,
		25,
		26,
		28,
		29,
		31,
		33,
		35,
		37,
		38,
		40,
		43,
		45,
		47,
		49
	],
	[
		-1,
		1,
		1,
		2,
		2,
		4,
		4,
		6,
		6,
		8,
		8,
		8,
		10,
		12,
		16,
		12,
		17,
		16,
		18,
		21,
		20,
		23,
		23,
		25,
		27,
		29,
		34,
		34,
		35,
		38,
		40,
		43,
		45,
		48,
		51,
		53,
		56,
		59,
		62,
		65,
		68
	],
	[
		-1,
		1,
		1,
		2,
		4,
		4,
		4,
		5,
		6,
		8,
		8,
		11,
		11,
		16,
		16,
		18,
		16,
		19,
		21,
		25,
		25,
		25,
		34,
		30,
		32,
		35,
		37,
		40,
		42,
		45,
		48,
		51,
		54,
		57,
		60,
		63,
		66,
		70,
		74,
		77,
		81
	]
]);

//#endregion
//#region node_modules/@rc-component/qrcode/es/utils.js
var ERROR_LEVEL_MAP = {
	L: Ecc.LOW,
	M: Ecc.MEDIUM,
	Q: Ecc.QUARTILE,
	H: Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BACKGROUND_COLOR = "#FFFFFF";
var DEFAULT_FRONT_COLOR = "#000000";
var DEFAULT_NEED_MARGIN = false;
var DEFAULT_MINVERSION = 1;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = .1;
/**
* Generate a path string from modules
* @param modules
* @param margin
* @returns
*/
var generatePath = function generatePath$1(modules) {
	var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var ops = [];
	modules.forEach(function(row, y) {
		var start = null;
		row.forEach(function(cell, x) {
			if (!cell && start !== null) {
				ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
				start = null;
				return;
			}
			if (x === row.length - 1) {
				if (!cell) return;
				if (start === null) ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
				else ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
				return;
			}
			if (cell && start === null) start = x;
		});
	});
	return ops.join("");
};
/**
* Excavate modules
* @param modules
* @param excavation
* @returns
*/
var excavateModules = function excavateModules$1(modules, excavation) {
	return modules.slice().map(function(row, y) {
		if (y < excavation.y || y >= excavation.y + excavation.h) return row;
		return row.map(function(cell, x) {
			if (x < excavation.x || x >= excavation.x + excavation.w) return cell;
			return false;
		});
	});
};
/**
* Get image settings
* @param cells The modules of the QR code
* @param size The size of the QR code
* @param margin
* @param imageSettings
* @returns
*/
var getImageSettings = function getImageSettings$1(cells, size, margin, imageSettings) {
	if (imageSettings == null) return null;
	var numCells = cells.length + margin * 2;
	var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
	var scale = numCells / size;
	var w = (imageSettings.width || defaultSize) * scale;
	var h = (imageSettings.height || defaultSize) * scale;
	var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
	var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
	var opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
	var excavation = null;
	if (imageSettings.excavate) {
		var floorX = Math.floor(x);
		var floorY = Math.floor(y);
		var ceilW = Math.ceil(w + x - floorX);
		var ceilH = Math.ceil(h + y - floorY);
		excavation = {
			x: floorX,
			y: floorY,
			w: ceilW,
			h: ceilH
		};
	}
	var crossOrigin = imageSettings.crossOrigin;
	return {
		x,
		y,
		h,
		w,
		excavation,
		opacity,
		crossOrigin
	};
};
/**
* Get margin size
* @param needMargin Whether need margin
* @param marginSize Custom margin size
* @returns
*/
var getMarginSize = function getMarginSize$1(needMargin, marginSize) {
	if (marginSize != null) return Math.max(Math.floor(marginSize), 0);
	return needMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
};
/**
* Check if Path2D is supported
*/
var isSupportPath2d = function() {
	try {
		new Path2D().addPath(new Path2D());
	} catch (_unused) {
		return false;
	}
	return true;
}();

//#endregion
//#region node_modules/@rc-component/qrcode/es/hooks/useQRCode.js
var useQRCode = function useQRCode$1(opt) {
	var value = opt.value, level = opt.level, minVersion = opt.minVersion, includeMargin = opt.includeMargin, marginSize = opt.marginSize, imageSettings = opt.imageSettings, size = opt.size;
	var memoizedQrcode = import_react.useMemo(function() {
		var segments = QrSegment.makeSegments(value);
		return QrCode.encodeSegments(segments, ERROR_LEVEL_MAP[level], minVersion);
	}, [
		value,
		level,
		minVersion
	]);
	return import_react.useMemo(function() {
		var cs = memoizedQrcode.getModules();
		var mg = getMarginSize(includeMargin, marginSize);
		var ncs = cs.length + mg * 2;
		var cis = getImageSettings(cs, size, mg, imageSettings);
		return {
			cells: cs,
			margin: mg,
			numCells: ncs,
			calculatedImageSettings: cis,
			qrcode: memoizedQrcode
		};
	}, [
		memoizedQrcode,
		size,
		imageSettings,
		includeMargin,
		marginSize
	]);
};

//#endregion
//#region node_modules/@rc-component/qrcode/es/QRCodeCanvas.js
var _excluded$18 = [
	"value",
	"size",
	"level",
	"bgColor",
	"fgColor",
	"includeMargin",
	"minVersion",
	"marginSize",
	"style",
	"imageSettings"
];
var QRCodeCanvas = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, marginSize = props.marginSize, style$1 = props.style, imageSettings = props.imageSettings, otherProps = _objectWithoutProperties(props, _excluded$18);
	var imgSrc = imageSettings === null || imageSettings === void 0 ? void 0 : imageSettings.src;
	var _canvas = import_react.useRef(null);
	var _image = import_react.useRef(null);
	var setCanvasRef = import_react.useCallback(function(node$1) {
		_canvas.current = node$1;
		if (typeof ref === "function") ref(node$1);
		else if (ref) ref.current = node$1;
	}, [ref]);
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), setIsImageLoaded = _React$useState2[1];
	var _useQRCode = useQRCode({
		value,
		level,
		minVersion,
		includeMargin,
		marginSize,
		imageSettings,
		size
	}), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
	import_react.useEffect(function() {
		if (_canvas.current) {
			var canvas = _canvas.current;
			var ctx = canvas.getContext("2d");
			if (!ctx) return;
			var cellsToDraw = cells;
			var image = _image.current;
			var haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
			if (haveImageToRender) {
				if (calculatedImageSettings.excavation != null) cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
			}
			var pixelRatio = window.devicePixelRatio || 1;
			canvas.height = canvas.width = size * pixelRatio;
			var scale = size / numCells * pixelRatio;
			ctx.scale(scale, scale);
			ctx.fillStyle = bgColor;
			ctx.fillRect(0, 0, numCells, numCells);
			ctx.fillStyle = fgColor;
			if (isSupportPath2d) ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
			else cells.forEach(function(row, rdx) {
				row.forEach(function(cell, cdx) {
					if (cell) ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
				});
			});
			if (calculatedImageSettings) ctx.globalAlpha = calculatedImageSettings.opacity;
			if (haveImageToRender) ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
		}
	});
	import_react.useEffect(function() {
		setIsImageLoaded(false);
	}, [imgSrc]);
	var canvasStyle = _objectSpread2({
		height: size,
		width: size
	}, style$1);
	var img = null;
	if (imgSrc != null) img = /* @__PURE__ */ import_react.createElement("img", {
		src: imgSrc,
		key: imgSrc,
		style: { display: "none" },
		onLoad: function onLoad() {
			setIsImageLoaded(true);
		},
		ref: _image,
		crossOrigin: calculatedImageSettings === null || calculatedImageSettings === void 0 ? void 0 : calculatedImageSettings.crossOrigin
	});
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("canvas", _extends({
		style: canvasStyle,
		height: size,
		width: size,
		ref: setCanvasRef,
		role: "img"
	}, otherProps)), img);
});
QRCodeCanvas.displayName = "QRCodeCanvas";

//#endregion
//#region node_modules/@rc-component/qrcode/es/QRCodeSVG.js
var _excluded$17 = [
	"value",
	"size",
	"level",
	"bgColor",
	"fgColor",
	"includeMargin",
	"minVersion",
	"title",
	"marginSize",
	"imageSettings"
];
var QRCodeSVG = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, title = props.title, marginSize = props.marginSize, imageSettings = props.imageSettings, otherProps = _objectWithoutProperties(props, _excluded$17);
	var _useQRCode = useQRCode({
		value,
		level,
		minVersion,
		includeMargin,
		marginSize,
		imageSettings,
		size
	}), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
	var cellsToDraw = cells;
	var image = null;
	if (imageSettings != null && calculatedImageSettings != null) {
		if (calculatedImageSettings.excavation != null) cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
		image = /* @__PURE__ */ import_react.createElement("image", {
			href: imageSettings.src,
			height: calculatedImageSettings.h,
			width: calculatedImageSettings.w,
			x: calculatedImageSettings.x + margin,
			y: calculatedImageSettings.y + margin,
			preserveAspectRatio: "none",
			opacity: calculatedImageSettings.opacity,
			crossOrigin: calculatedImageSettings.crossOrigin
		});
	}
	var fgPath = generatePath(cellsToDraw, margin);
	return /* @__PURE__ */ import_react.createElement("svg", _extends({
		height: size,
		width: size,
		viewBox: "0 0 ".concat(numCells, " ").concat(numCells),
		ref,
		role: "img"
	}, otherProps), !!title && /* @__PURE__ */ import_react.createElement("title", null, title), /* @__PURE__ */ import_react.createElement("path", {
		fill: bgColor,
		d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z"),
		shapeRendering: "crispEdges"
	}), /* @__PURE__ */ import_react.createElement("path", {
		fill: fgColor,
		d: fgPath,
		shapeRendering: "crispEdges"
	}), image);
});
QRCodeSVG.displayName = "QRCodeSVG";

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/ReloadOutlined.js
var ReloadOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z" }
		}]
	},
	"name": "reload",
	"theme": "outlined"
};
var ReloadOutlined_default$1 = ReloadOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/ReloadOutlined.js
/**![reload](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkwOS4xIDIwOS4zbC01Ni40IDQ0LjFDNzc1LjggMTU1LjEgNjU2LjIgOTIgNTIxLjkgOTIgMjkwIDkyIDEwMi4zIDI3OS41IDEwMiA1MTEuNSAxMDEuNyA3NDMuNyAyODkuOCA5MzIgNTIxLjkgOTMyYzE4MS4zIDAgMzM1LjgtMTE1IDM5NC42LTI3Ni4xIDEuNS00LjItLjctOC45LTQuOS0xMC4zbC01Ni43LTE5LjVhOCA4IDAgMDAtMTAuMSA0LjhjLTEuOCA1LTMuOCAxMC01LjkgMTQuOS0xNy4zIDQxLTQyLjEgNzcuOC03My43IDEwOS40QTM0NC43NyAzNDQuNzcgMCAwMTY1NS45IDgyOWMtNDIuMyAxNy45LTg3LjQgMjctMTMzLjggMjctNDYuNSAwLTkxLjUtOS4xLTEzMy44LTI3QTM0MS41IDM0MS41IDAgMDEyNzkgNzU1LjJhMzQyLjE2IDM0Mi4xNiAwIDAxLTczLjctMTA5LjRjLTE3LjktNDIuNC0yNy04Ny40LTI3LTEzMy45czkuMS05MS41IDI3LTEzMy45YzE3LjMtNDEgNDIuMS03Ny44IDczLjctMTA5LjQgMzEuNi0zMS42IDY4LjQtNTYuNCAxMDkuMy03My44IDQyLjMtMTcuOSA4Ny40LTI3IDEzMy44LTI3IDQ2LjUgMCA5MS41IDkuMSAxMzMuOCAyN2EzNDEuNSAzNDEuNSAwIDAxMTA5LjMgNzMuOGM5LjkgOS45IDE5LjIgMjAuNCAyNy44IDMxLjRsLTYwLjIgNDdhOCA4IDAgMDAzIDE0LjFsMTc1LjYgNDNjNSAxLjIgOS45LTIuNiA5LjktNy43bC44LTE4MC45Yy0uMS02LjYtNy44LTEwLjMtMTMtNi4yeiIgLz48L3N2Zz4=) */
var RefIcon$20 = /* @__PURE__ */ import_react.forwardRef(function ReloadOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: ReloadOutlined_default$1
	}));
});
RefIcon$20.displayName = "ReloadOutlined";
var ReloadOutlined_default = RefIcon$20;

//#endregion
//#region node_modules/antd/es/qr-code/QrcodeStatus.js
var defaultSpin = /* @__PURE__ */ import_react.createElement(spin_default, null);
function QRcodeStatus({ prefixCls, locale: locale$5, onRefresh, statusRender, status }) {
	const defaultExpiredNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("p", { className: `${prefixCls}-expired` }, locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.expired), onRefresh && /* @__PURE__ */ import_react.createElement(button_default, {
		type: "link",
		icon: /* @__PURE__ */ import_react.createElement(ReloadOutlined_default, null),
		onClick: onRefresh
	}, locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.refresh));
	const defaultScannedNode = /* @__PURE__ */ import_react.createElement("p", { className: `${prefixCls}-scanned` }, locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.scanned);
	const defaultNodes = {
		expired: defaultExpiredNode,
		loading: defaultSpin,
		scanned: defaultScannedNode
	};
	const defaultStatusRender = (info) => defaultNodes[info.status];
	return (statusRender !== null && statusRender !== void 0 ? statusRender : defaultStatusRender)({
		status,
		locale: locale$5,
		onRefresh
	});
}

//#endregion
//#region node_modules/antd/es/qr-code/style/index.js
var genQRCodeStyle = (token$1) => {
	const { componentCls, lineWidth, lineType, colorSplit } = token$1;
	return {
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			display: "flex",
			justifyContent: "center",
			alignItems: "center",
			padding: token$1.paddingSM,
			backgroundColor: token$1.colorWhite,
			borderRadius: token$1.borderRadiusLG,
			border: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			position: "relative",
			overflow: "hidden",
			[`& > ${componentCls}-mask`]: {
				position: "absolute",
				insetBlockStart: 0,
				insetInlineStart: 0,
				zIndex: 10,
				display: "flex",
				flexDirection: "column",
				justifyContent: "center",
				alignItems: "center",
				width: "100%",
				height: "100%",
				color: token$1.colorText,
				lineHeight: token$1.lineHeight,
				background: token$1.QRCodeMaskBackgroundColor,
				textAlign: "center",
				[`& > ${componentCls}-expired, & > ${componentCls}-scanned`]: { color: token$1.QRCodeTextColor }
			},
			"> canvas": {
				alignSelf: "stretch",
				flex: "auto",
				minWidth: 0
			},
			"&-icon": {
				marginBlockEnd: token$1.marginXS,
				fontSize: token$1.controlHeight
			}
		}),
		[`${componentCls}-borderless`]: {
			borderColor: "transparent",
			padding: 0,
			borderRadius: 0
		}
	};
};
const prepareComponentToken$14 = (token$1) => ({ QRCodeMaskBackgroundColor: new FastColor(token$1.colorBgContainer).setA(.96).toRgbString() });
var style_default$15 = genStyleHooks("QRCode", (token$1) => {
	const mergedToken = merge(token$1, { QRCodeTextColor: token$1.colorText });
	return genQRCodeStyle(mergedToken);
}, prepareComponentToken$14);

//#endregion
//#region node_modules/antd/es/qr-code/index.js
var import_classnames$60 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$23 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var QRCode = (props) => {
	var _a, _b, _c, _d;
	const [, token$1] = useToken();
	const { value, type: type$2 = "canvas", icon = "", size = 160, iconSize, color = token$1.colorText, errorLevel = "M", status = "active", bordered = true, onRefresh, style: style$1, className, rootClassName, prefixCls: customizePrefixCls, bgColor = "transparent", statusRender } = props, rest = __rest$23(props, [
		"value",
		"type",
		"icon",
		"size",
		"iconSize",
		"color",
		"errorLevel",
		"status",
		"bordered",
		"onRefresh",
		"style",
		"className",
		"rootClassName",
		"prefixCls",
		"bgColor",
		"statusRender"
	]);
	const { getPrefixCls } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("qrcode", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$15(prefixCls);
	const imageSettings = {
		src: icon,
		x: void 0,
		y: void 0,
		height: typeof iconSize === "number" ? iconSize : (_a = iconSize === null || iconSize === void 0 ? void 0 : iconSize.height) !== null && _a !== void 0 ? _a : 40,
		width: typeof iconSize === "number" ? iconSize : (_b = iconSize === null || iconSize === void 0 ? void 0 : iconSize.width) !== null && _b !== void 0 ? _b : 40,
		excavate: true,
		crossOrigin: "anonymous"
	};
	const a11yProps = pickAttrs(rest, true);
	const restProps = omit(rest, Object.keys(a11yProps));
	const qrCodeProps = Object.assign({
		value,
		size,
		level: errorLevel,
		bgColor,
		fgColor: color,
		style: {
			width: style$1 === null || style$1 === void 0 ? void 0 : style$1.width,
			height: style$1 === null || style$1 === void 0 ? void 0 : style$1.height
		},
		imageSettings: icon ? imageSettings : void 0
	}, a11yProps);
	const [locale$5] = useLocale_default("QRCode");
	{
		const warning$4 = devUseWarning("QRCode");
		warning$4(!!value, "usage", "need to receive `value` props");
		warning$4(!(icon && errorLevel === "L"), "usage", "ErrorLevel `L` is not recommended to be used with `icon`, for scanning result would be affected by low level.");
	}
	if (!value) return null;
	const mergedCls = (0, import_classnames$60.default)(prefixCls, className, rootClassName, hashId, cssVarCls, { [`${prefixCls}-borderless`]: !bordered });
	const mergedStyle = Object.assign(Object.assign({ backgroundColor: bgColor }, style$1), {
		width: (_c = style$1 === null || style$1 === void 0 ? void 0 : style$1.width) !== null && _c !== void 0 ? _c : size,
		height: (_d = style$1 === null || style$1 === void 0 ? void 0 : style$1.height) !== null && _d !== void 0 ? _d : size
	});
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({}, restProps, {
		className: mergedCls,
		style: mergedStyle
	}), status !== "active" && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-mask` }, /* @__PURE__ */ import_react.createElement(QRcodeStatus, {
		prefixCls,
		locale: locale$5,
		status,
		onRefresh,
		statusRender
	})), type$2 === "canvas" ? /* @__PURE__ */ import_react.createElement(QRCodeCanvas, Object.assign({}, qrCodeProps)) : /* @__PURE__ */ import_react.createElement(QRCodeSVG, Object.assign({}, qrCodeProps))));
};
QRCode.displayName = "QRCode";
var qr_code_default = QRCode;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/StarFilled.js
var StarFilled = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z" }
		}]
	},
	"name": "star",
	"theme": "filled"
};
var StarFilled_default$1 = StarFilled;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/StarFilled.js
/**![star](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkwOC4xIDM1My4xbC0yNTMuOS0zNi45TDU0MC43IDg2LjFjLTMuMS02LjMtOC4yLTExLjQtMTQuNS0xNC41LTE1LjgtNy44LTM1LTEuMy00Mi45IDE0LjVMMzY5LjggMzE2LjJsLTI1My45IDM2LjljLTcgMS0xMy40IDQuMy0xOC4zIDkuM2EzMi4wNSAzMi4wNSAwIDAwLjYgNDUuM2wxODMuNyAxNzkuMS00My40IDI1Mi45YTMxLjk1IDMxLjk1IDAgMDA0Ni40IDMzLjdMNTEyIDc1NGwyMjcuMSAxMTkuNGM2LjIgMy4zIDEzLjQgNC40IDIwLjMgMy4yIDE3LjQtMyAyOS4xLTE5LjUgMjYuMS0zNi45bC00My40LTI1Mi45IDE4My43LTE3OS4xYzUtNC45IDguMy0xMS4zIDkuMy0xOC4zIDIuNy0xNy41LTkuNS0zMy43LTI3LTM2LjN6IiAvPjwvc3ZnPg==) */
var RefIcon$19 = /* @__PURE__ */ import_react.forwardRef(function StarFilled$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: StarFilled_default$1
	}));
});
RefIcon$19.displayName = "StarFilled";
var StarFilled_default = RefIcon$19;

//#endregion
//#region node_modules/rc-rate/es/Star.js
var import_classnames$59 = /* @__PURE__ */ __toESM(require_classnames());
function Star(props, ref) {
	var disabled = props.disabled, prefixCls = props.prefixCls, character$1 = props.character, characterRender = props.characterRender, index$2 = props.index, count = props.count, value = props.value, allowHalf = props.allowHalf, focused = props.focused, onHover = props.onHover, onClick = props.onClick;
	var onInternalHover = function onInternalHover$1(e$2) {
		onHover(e$2, index$2);
	};
	var onInternalClick = function onInternalClick$1(e$2) {
		onClick(e$2, index$2);
	};
	var onInternalKeyDown = function onInternalKeyDown$1(e$2) {
		if (e$2.keyCode === KeyCode_default.ENTER) onClick(e$2, index$2);
	};
	var starValue = index$2 + 1;
	var classNameList = new Set([prefixCls]);
	if (value === 0 && index$2 === 0 && focused) classNameList.add("".concat(prefixCls, "-focused"));
	else if (allowHalf && value + .5 >= starValue && value < starValue) {
		classNameList.add("".concat(prefixCls, "-half"));
		classNameList.add("".concat(prefixCls, "-active"));
		if (focused) classNameList.add("".concat(prefixCls, "-focused"));
	} else {
		if (starValue <= value) classNameList.add("".concat(prefixCls, "-full"));
		else classNameList.add("".concat(prefixCls, "-zero"));
		if (starValue === value && focused) classNameList.add("".concat(prefixCls, "-focused"));
	}
	var characterNode = typeof character$1 === "function" ? character$1(props) : character$1;
	var start = /* @__PURE__ */ import_react.createElement("li", {
		className: (0, import_classnames$59.default)(Array.from(classNameList)),
		ref
	}, /* @__PURE__ */ import_react.createElement("div", {
		onClick: disabled ? null : onInternalClick,
		onKeyDown: disabled ? null : onInternalKeyDown,
		onMouseMove: disabled ? null : onInternalHover,
		role: "radio",
		"aria-checked": value > index$2 ? "true" : "false",
		"aria-posinset": index$2 + 1,
		"aria-setsize": count,
		tabIndex: disabled ? -1 : 0
	}, /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-first") }, characterNode), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-second") }, characterNode)));
	if (characterRender) start = characterRender(start, props);
	return start;
}
var Star_default = /* @__PURE__ */ import_react.forwardRef(Star);

//#endregion
//#region node_modules/rc-rate/es/useRefs.js
function useRefs() {
	var nodeRef = import_react.useRef({});
	function getRef(index$2) {
		return nodeRef.current[index$2];
	}
	function setRef(index$2) {
		return function(node$1) {
			nodeRef.current[index$2] = node$1;
		};
	}
	return [getRef, setRef];
}

//#endregion
//#region node_modules/rc-rate/es/util.js
function getScroll(w) {
	var ret = w.pageXOffset;
	var method$1 = "scrollLeft";
	if (typeof ret !== "number") {
		var d = w.document;
		ret = d.documentElement[method$1];
		if (typeof ret !== "number") ret = d.body[method$1];
	}
	return ret;
}
function getClientPosition(elem) {
	var x;
	var y;
	var doc = elem.ownerDocument;
	var body = doc.body;
	var docElem = doc && doc.documentElement;
	var box$1 = elem.getBoundingClientRect();
	x = box$1.left;
	y = box$1.top;
	x -= docElem.clientLeft || body.clientLeft || 0;
	y -= docElem.clientTop || body.clientTop || 0;
	return {
		left: x,
		top: y
	};
}
function getOffsetLeft(el) {
	var pos = getClientPosition(el);
	var doc = el.ownerDocument;
	var w = doc.defaultView || doc.parentWindow;
	pos.left += getScroll(w);
	return pos.left;
}

//#endregion
//#region node_modules/rc-rate/es/Rate.js
var import_classnames$58 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$16 = [
	"prefixCls",
	"className",
	"defaultValue",
	"value",
	"count",
	"allowHalf",
	"allowClear",
	"keyboard",
	"character",
	"characterRender",
	"disabled",
	"direction",
	"tabIndex",
	"autoFocus",
	"onHoverChange",
	"onChange",
	"onFocus",
	"onBlur",
	"onKeyDown",
	"onMouseLeave"
];
function Rate$1(props, ref) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-rate" : _props$prefixCls, className = props.className, defaultValue = props.defaultValue, propValue = props.value, _props$count = props.count, count = _props$count === void 0 ? 5 : _props$count, _props$allowHalf = props.allowHalf, allowHalf = _props$allowHalf === void 0 ? false : _props$allowHalf, _props$allowClear = props.allowClear, allowClear = _props$allowClear === void 0 ? true : _props$allowClear, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$character = props.character, character$1 = _props$character === void 0 ? "" : _props$character, characterRender = props.characterRender, disabled = props.disabled, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, autoFocus = props.autoFocus, onHoverChange = props.onHoverChange, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown$1 = props.onKeyDown, onMouseLeave = props.onMouseLeave, restProps = _objectWithoutProperties(props, _excluded$16);
	var _useRefs = useRefs(), _useRefs2 = _slicedToArray(_useRefs, 2), getStarRef = _useRefs2[0], setStarRef = _useRefs2[1];
	var rateRef = import_react.useRef(null);
	var triggerFocus$1 = function triggerFocus$2() {
		if (!disabled) {
			var _rateRef$current;
			(_rateRef$current = rateRef.current) === null || _rateRef$current === void 0 || _rateRef$current.focus();
		}
	};
	import_react.useImperativeHandle(ref, function() {
		return {
			focus: triggerFocus$1,
			blur: function blur() {
				if (!disabled) {
					var _rateRef$current2;
					(_rateRef$current2 = rateRef.current) === null || _rateRef$current2 === void 0 || _rateRef$current2.blur();
				}
			}
		};
	});
	var _useMergedState = useMergedState(defaultValue || 0, { value: propValue }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
	var _useMergedState3 = useMergedState(null), _useMergedState4 = _slicedToArray(_useMergedState3, 2), cleanedValue = _useMergedState4[0], setCleanedValue = _useMergedState4[1];
	var getStarValue = function getStarValue$1(index$2, x) {
		var reverse = direction === "rtl";
		var starValue = index$2 + 1;
		if (allowHalf) {
			var starEle = getStarRef(index$2);
			var leftDis = getOffsetLeft(starEle);
			var width = starEle.clientWidth;
			if (reverse && x - leftDis > width / 2) starValue -= .5;
			else if (!reverse && x - leftDis < width / 2) starValue -= .5;
		}
		return starValue;
	};
	var changeValue = function changeValue$1(nextValue) {
		setValue(nextValue);
		onChange === null || onChange === void 0 || onChange(nextValue);
	};
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
	var onInternalFocus = function onInternalFocus$1() {
		setFocused(true);
		onFocus === null || onFocus === void 0 || onFocus();
	};
	var onInternalBlur = function onInternalBlur$1() {
		setFocused(false);
		onBlur === null || onBlur === void 0 || onBlur();
	};
	var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), hoverValue = _React$useState4[0], setHoverValue = _React$useState4[1];
	var onHover = function onHover$1(event, index$2) {
		var nextHoverValue = getStarValue(index$2, event.pageX);
		if (nextHoverValue !== cleanedValue) {
			setHoverValue(nextHoverValue);
			setCleanedValue(null);
		}
		onHoverChange === null || onHoverChange === void 0 || onHoverChange(nextHoverValue);
	};
	var onMouseLeaveCallback = function onMouseLeaveCallback$1(event) {
		if (!disabled) {
			setHoverValue(null);
			setCleanedValue(null);
			onHoverChange === null || onHoverChange === void 0 || onHoverChange(void 0);
		}
		if (event) onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave(event);
	};
	var onClick = function onClick$1(event, index$2) {
		var newValue = getStarValue(index$2, event.pageX);
		var isReset = false;
		if (allowClear) isReset = newValue === value;
		onMouseLeaveCallback();
		changeValue(isReset ? 0 : newValue);
		setCleanedValue(isReset ? newValue : null);
	};
	var onInternalKeyDown = function onInternalKeyDown$1(event) {
		var keyCode = event.keyCode;
		var reverse = direction === "rtl";
		var step = allowHalf ? .5 : 1;
		if (keyboard) {
			if (keyCode === KeyCode_default.RIGHT && value < count && !reverse) {
				changeValue(value + step);
				event.preventDefault();
			} else if (keyCode === KeyCode_default.LEFT && value > 0 && !reverse) {
				changeValue(value - step);
				event.preventDefault();
			} else if (keyCode === KeyCode_default.RIGHT && value > 0 && reverse) {
				changeValue(value - step);
				event.preventDefault();
			} else if (keyCode === KeyCode_default.LEFT && value < count && reverse) {
				changeValue(value + step);
				event.preventDefault();
			}
		}
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event);
	};
	import_react.useEffect(function() {
		if (autoFocus && !disabled) triggerFocus$1();
	}, []);
	var starNodes = new Array(count).fill(0).map(function(item, index$2) {
		return /* @__PURE__ */ import_react.createElement(Star_default, {
			ref: setStarRef(index$2),
			index: index$2,
			count,
			disabled,
			prefixCls: "".concat(prefixCls, "-star"),
			allowHalf,
			value: hoverValue === null ? value : hoverValue,
			onClick,
			onHover,
			key: item || index$2,
			character: character$1,
			characterRender,
			focused
		});
	});
	var classString = (0, import_classnames$58.default)(prefixCls, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-rtl"), direction === "rtl"));
	return /* @__PURE__ */ import_react.createElement("ul", _extends({
		className: classString,
		onMouseLeave: onMouseLeaveCallback,
		tabIndex: disabled ? -1 : tabIndex,
		onFocus: disabled ? null : onInternalFocus,
		onBlur: disabled ? null : onInternalBlur,
		onKeyDown: disabled ? null : onInternalKeyDown,
		ref: rateRef
	}, pickAttrs(restProps, {
		aria: true,
		data: true,
		attr: true
	})), starNodes);
}
var Rate_default = /* @__PURE__ */ import_react.forwardRef(Rate$1);

//#endregion
//#region node_modules/rc-rate/es/index.js
var es_default$11 = Rate_default;

//#endregion
//#region node_modules/antd/es/rate/style/index.js
var genRateStarStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-star`]: {
		position: "relative",
		display: "inline-block",
		color: "inherit",
		cursor: "pointer",
		"&:not(:last-child)": { marginInlineEnd: token$1.marginXS },
		"> div": {
			transition: `all ${token$1.motionDurationMid}, outline 0s`,
			"&:hover": { transform: token$1.starHoverScale },
			"&:focus": { outline: 0 },
			"&:focus-visible": {
				outline: `${unit(token$1.lineWidth)} dashed ${token$1.starColor}`,
				transform: token$1.starHoverScale
			}
		},
		"&-first, &-second": {
			color: token$1.starBg,
			transition: `all ${token$1.motionDurationMid}`,
			userSelect: "none"
		},
		"&-first": {
			position: "absolute",
			top: 0,
			insetInlineStart: 0,
			width: "50%",
			height: "100%",
			overflow: "hidden",
			opacity: 0
		},
		[`&-half ${componentCls}-star-first, &-half ${componentCls}-star-second`]: { opacity: 1 },
		[`&-half ${componentCls}-star-first, &-full ${componentCls}-star-second`]: { color: "inherit" }
	} };
};
var genRateRtlStyle = (token$1) => ({ [`&-rtl${token$1.componentCls}`]: { direction: "rtl" } });
var genRateStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
		display: "inline-block",
		margin: 0,
		padding: 0,
		color: token$1.starColor,
		fontSize: token$1.starSize,
		lineHeight: 1,
		listStyle: "none",
		outline: "none",
		[`&-disabled${componentCls} ${componentCls}-star`]: {
			cursor: "default",
			"> div:hover": { transform: "scale(1)" }
		}
	}), genRateStarStyle(token$1)), genRateRtlStyle(token$1)) };
};
const prepareComponentToken$13 = (token$1) => ({
	starColor: token$1.yellow6,
	starSize: token$1.controlHeightLG * .5,
	starHoverScale: "scale(1.1)",
	starBg: token$1.colorFillContent
});
var style_default$14 = genStyleHooks("Rate", (token$1) => {
	const rateToken = merge(token$1, {});
	return genRateStyle(rateToken);
}, prepareComponentToken$13);

//#endregion
//#region node_modules/antd/es/rate/index.js
var import_classnames$57 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$22 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Rate = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls, className, rootClassName, style: style$1, tooltips, character: character$1 = /* @__PURE__ */ import_react.createElement(StarFilled_default, null), disabled: customDisabled } = props, rest = __rest$22(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"style",
		"tooltips",
		"character",
		"disabled"
	]);
	const characterRender = (node$1, { index: index$2 }) => {
		if (!tooltips) return node$1;
		return /* @__PURE__ */ import_react.createElement(tooltip_default, { title: tooltips[index$2] }, node$1);
	};
	const { getPrefixCls, direction, rate } = import_react.useContext(ConfigContext);
	const ratePrefixCls = getPrefixCls("rate", prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$14(ratePrefixCls);
	const mergedStyle = Object.assign(Object.assign({}, rate === null || rate === void 0 ? void 0 : rate.style), style$1);
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$11, Object.assign({
		ref,
		character: character$1,
		characterRender,
		disabled: mergedDisabled
	}, rest, {
		className: (0, import_classnames$57.default)(className, rootClassName, hashId, cssVarCls, rate === null || rate === void 0 ? void 0 : rate.className),
		style: mergedStyle,
		prefixCls: ratePrefixCls,
		direction
	})));
});
Rate.displayName = "Rate";
var rate_default = Rate;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/WarningFilled.js
var WarningFilled = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" }
		}]
	},
	"name": "warning",
	"theme": "filled"
};
var WarningFilled_default$1 = WarningFilled;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/WarningFilled.js
/**![warning](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk1NS43IDg1NmwtNDE2LTcyMGMtNi4yLTEwLjctMTYuOS0xNi0yNy43LTE2cy0yMS42IDUuMy0yNy43IDE2bC00MTYgNzIwQzU2IDg3Ny40IDcxLjQgOTA0IDk2IDkwNGg4MzJjMjQuNiAwIDQwLTI2LjYgMjcuNy00OHpNNDgwIDQxNmMwLTQuNCAzLjYtOCA4LThoNDhjNC40IDAgOCAzLjYgOCA4djE4NGMwIDQuNC0zLjYgOC04IDhoLTQ4Yy00LjQgMC04LTMuNi04LThWNDE2em0zMiAzNTJhNDguMDEgNDguMDEgMCAwMTAtOTYgNDguMDEgNDguMDEgMCAwMTAgOTZ6IiAvPjwvc3ZnPg==) */
var RefIcon$18 = /* @__PURE__ */ import_react.forwardRef(function WarningFilled$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: WarningFilled_default$1
	}));
});
RefIcon$18.displayName = "WarningFilled";
var WarningFilled_default = RefIcon$18;

//#endregion
//#region node_modules/antd/es/result/noFound.js
var NoFound = () => /* @__PURE__ */ import_react.createElement("svg", {
	width: "252",
	height: "294"
}, /* @__PURE__ */ import_react.createElement("title", null, "No Found"), /* @__PURE__ */ import_react.createElement("g", {
	fill: "none",
	fillRule: "evenodd"
}, /* @__PURE__ */ import_react.createElement("circle", {
	cx: "126.75",
	cy: "128.1",
	r: "126",
	fill: "#E4EBF7"
}), /* @__PURE__ */ import_react.createElement("circle", {
	cx: "31.55",
	cy: "130.8",
	r: "8.3",
	fill: "#FFF"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m37 134.3 10.5 6m.9 6.2-12.7 10.8",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M39.9 159.4a5.7 5.7 0 1 1-11.3-1.2 5.7 5.7 0 0 1 11.3 1.2m17.7-16.2a5.7 5.7 0 1 1-11.4-1.1 5.7 5.7 0 0 1 11.4 1.1M99 27h29.8a4.6 4.6 0 1 0 0-9.2H99a4.6 4.6 0 1 0 0 9.2m11.4 18.3h29.8a4.6 4.6 0 0 0 0-9.2h-29.8a4.6 4.6 0 1 0 0 9.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M112.8 26.9h15.8a4.6 4.6 0 1 0 0 9.1h-15.8a4.6 4.6 0 0 0 0-9.1m71.7 108.8a10 10 0 1 1-19.8-2 10 10 0 0 1 19.8 2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m179.3 141.8 12.6 7.1m1.1 7.6-15.2 13",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M184.7 170a6.8 6.8 0 1 1-13.6-1.3 6.8 6.8 0 0 1 13.6 1.4m18.6-16.8a6.9 6.9 0 1 1-13.7-1.4 6.9 6.9 0 0 1 13.7 1.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "M152 192.3a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.4 0zm73.3-76.2a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0zm-9 35a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.5 0zM177 107.6a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm18.4-15.4a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0zm6.8 88.5a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0z",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m214.4 153.3-2 20.2-10.8 6m-28-4.7-6.3 9.8H156l-4.5 6.5m23.5-66v-15.7m46 7.8-13 8-15.2-8V94.4",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M166.6 66h-4a4.8 4.8 0 0 1-4.7-4.8 4.8 4.8 0 0 1 4.7-4.7h4a4.8 4.8 0 0 1 4.7 4.7 4.8 4.8 0 0 1-4.7 4.7"
}), /* @__PURE__ */ import_react.createElement("circle", {
	cx: "204.3",
	cy: "30",
	r: "29.5",
	fill: "#1677ff"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M206 38.4c.5.5.7 1.1.7 2s-.2 1.4-.7 1.9a3 3 0 0 1-2 .7c-.8 0-1.5-.3-2-.8s-.8-1.1-.8-1.9.3-1.4.8-2c.5-.4 1.2-.7 2-.7.7 0 1.4.3 2 .8m4.2-19.5c1.5 1.3 2.2 3 2.2 5.2a7.2 7.2 0 0 1-1.5 4.5l-3 2.7a5 5 0 0 0-1.3 1.7 5.2 5.2 0 0 0-.6 2.4v.5h-4v-.5c0-1.4.1-2.5.6-3.5s1.9-2.5 4.2-4.5l.4-.5a4 4 0 0 0 1-2.6c0-1.2-.4-2-1-2.8-.7-.6-1.6-1-2.9-1-1.5 0-2.6.5-3.3 1.5-.4.5-.6 1-.8 1.9a2 2 0 0 1-2 1.6 2 2 0 0 1-2-2.4c.4-1.6 1-2.8 2.1-3.8a8.5 8.5 0 0 1 6.3-2.3c2.3 0 4.2.6 5.6 2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "M52 76.1s21.8 5.4 27.3 16c5.6 10.7-6.3 9.2-15.7 5C52.8 92 39 85 52 76"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m90.5 67.5-.5 2.9c-.7.5-4.7-2.7-4.7-2.7l-1.7.8-1.3-5.7s6.8-4.6 9-5c2.4-.5 9.8 1 10.6 2.3 0 0 1.3.4-2.2.6-3.6.3-5 .5-6.8 3.2l-2.4 3.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M128 111.4a36.7 36.7 0 0 0-8.9-15.5c-3.5-3-9.3-2.2-11.3-4.2-1.3-1.2-3.2-1.2-3.2-1.2L87.7 87c-2.3-.4-2.1-.7-6-1.4-1.6-1.9-3-1.1-3-1.1l-7-1.4c-1-1.5-2.5-1-2.5-1l-2.4-.9C65 91.2 59 95 59 95c1.8 1.1 15.7 8.3 15.7 8.3l5.1 37.1s-3.3 5.7 1.4 9.1c0 0 19.9-3.7 34.9-.3 0 0 3-2.6 1-8.8.5-3 1.4-8.3 1.7-11.6.4.7 2 1.9 3.1 3.4 0 0 9.4-7.3 11-14a17 17 0 0 1-2.2-2.4c-.5-.8-.3-2-.7-2.8-.7-1-1.8-1.3-2-1.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M101 290s4.4 2 7.4 1c2.9-1 4.6.7 7.1 1.2 2.6.5 6.9 1.1 11.7-1.3 0-5.5-6.9-4-12-6.7-2.5-1.4-3.7-4.7-3.5-8.8h-9.5s-1.2 10.6-1 14.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M101 289.8s2.5 1.3 6.8.7c3-.5 3.7.5 7.4 1 3.8.6 10.8 0 11.9-.9.4 1.1-.4 2-.4 2s-1.5.7-4.8.9c-2 .1-5.8.3-7.6-.5-1.8-1.4-5.2-1.9-5.7-.2-4 1-7.4-.3-7.4-.3l-.1-2.7z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M108.3 276h3.1s0 6.7 4.6 8.6c-4.7.6-8.6-2.3-7.7-8.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M57.5 272.4s-2 7.4-4.4 12.3c-1.8 3.7-4.3 7.5 5.4 7.5 6.7 0 9-.5 7.4-6.6-1.5-6.1.3-13.2.3-13.2h-8.7z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M51.5 289.8s2 1.2 6.6 1.2c6 0 8.3-1.7 8.3-1.7s.6 1.1-.7 2.2c-1 .8-3.6 1.6-7.4 1.5-4.1 0-5.8-.5-6.7-1.1-.8-.6-.7-1.6-.1-2.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M58.4 274.3s0 1.5-.3 3c-.3 1.4-1 3-1.1 4 0 1.2 4.5 1.7 5.1.1.6-1.5 1.3-6.4 2-7.2.6-.9-5-2.2-5.7.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#7BB2F9",
	d: "m99.7 278.5 13.3.1s1.3-54.5 1.9-64.4c.5-9.9 3.8-43.4 1-63.1l-12.6-.7-22.8.8-1.2 10c0 .5-.7.8-.7 1.4-.1.5.4 1.3.3 2-2.4 14-6.4 33-8.8 46.6 0 .7-1.2 1-1.4 2.7 0 .3.2 1.5 0 1.8-6.8 18.7-10.9 47.8-14.2 61.9h14.6s2.2-8.6 4-17c2.9-12.9 23.2-85 23.2-85l3-.5 1 46.3s-.2 1.2.4 2c.5.8-.6 1.1-.4 2.3l.4 1.8-1 11.8c-.4 4.8 0 39.2 0 39.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M76 221.6c1.2.1 4.1-2 7-5m23.4 8.5s2.7-1 6-3.8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M107.3 222.1s2.7-1.1 6-3.9",
	strokeLinecap: "round",
	strokeLinejoin: "round"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M74.7 224.8s2.7-.6 6.5-3.4m4.8-69.8c-.2 3.1.3 8.6-4.3 9.2m22-11s0 14-1.4 15.1a15 15 0 0 1-3 2m.5-16.5s0 13-1.2 24.4m-5 1.1s7.3-1.7 9.5-1.7M74.3 206a212 212 0 0 1-1 4.5s-1.4 1.9-1 3.8c.5 2-1 2-5 15.4A353 353 0 0 0 61 257l-.2 1.2m14.9-60.5a321 321 0 0 1-.9 4.8m7.8-50.4-1.2 10.5s-1.1.1-.5 2.2c.1 1.4-2.7 15.8-5.2 30.5m-19.6 79h13.3",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M116.2 148.2s-17-3-35.9.2c.2 2.5 0 4.2 0 4.2s14.7-2.8 35.7-.3c.3-2.4.2-4 .2-4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M106.3 151.2v-5a.8.8 0 0 0-.8-.8h-7.8a.8.8 0 0 0-.8.8v5a.8.8 0 0 0 .8.8h7.8a.8.8 0 0 0 .8-.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M105.2 150.2v-3a.6.6 0 0 0-.6-.7 94.3 94.3 0 0 0-5.9 0 .7.7 0 0 0-.6.6v3.1a.6.6 0 0 0 .6.7 121.1 121.1 0 0 1 5.8 0c.4 0 .7-.3.7-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M100.3 275.4h12.3m-11.2-4.9.1 6.5m0-12.5a915.8 915.8 0 0 0 0 4.4m-.5-94 .9 44.7s.7 1.6-.2 2.7c-1 1.1 2.4.7.9 2.2-1.6 1.6.9 1.2 0 3.4-.6 1.5-1 21.1-1.1 35.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M46.9 83.4s-.5 6 7.2 5.6c11.2-.7 9.2-9.4 31.5-21.7-.7-2.7-2.4-4.7-2.4-4.7s-11 3-22.6 8c-6.8 3-13.4 6.4-13.7 12.8m57.6 7.7.9-5.4-8.9-11.4-5 5.3-1.8 7.9a.3.3 0 0 0 .1.3c1 .8 6.5 5 14.4 3.5a.3.3 0 0 0 .3-.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M94 79.4s-4.6-2.9-2.5-6.9c1.6-3 4.5 1.2 4.5 1.2s.5-3.7 3.1-3.7c.6-1 1.6-4.1 1.6-4.1l13.5 3c0 5.3-2.3 19.5-7.8 20-8.9.6-12.5-9.5-12.5-9.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#520038",
	d: "M113.9 73.4c2.6-2 3.4-9.7 3.4-9.7s-2.4-.5-6.6-2c-4.7-2.1-12.8-4.8-17.5 1-9.6 3.2-2 19.8-2 19.8l2.7-3s-4-3.3-2-6.3c2-3.5 3.8 1 3.8 1s.7-2.3 3.6-3.3c.4-.7 1-2.6 1.4-3.8a1 1 0 0 1 1.3-.7l11.4 2.6c.5.2.8.7.8 1.2l-.3 3.2z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#552950",
	d: "M105 76c-.1.7-.6 1.1-1 1-.6 0-.9-.6-.8-1.2.1-.6.6-1 1-1 .6 0 .9.7.8 1.3m7.1 1.6c0 .6-.5 1-1 1-.5-.1-.8-.7-.7-1.3 0-.6.5-1 1-1 .5.1.8.7.7 1.3"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "m110.1 74.8-.9 1.7-.3 4.3h-2.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M110.8 74.5s1.8-.7 2.6.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M92.4 74.3s.5-1.1 1.1-.7c.6.4 1.3 1.4.6 2-.8.5.1 1.6.1 1.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M103.3 73s1.8 1 4.1.9",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M103.7 81.8s2.2 1.2 4.4 1.2m-3.5 1.3s1 .4 1.6.3m-11.5-3.4s2.3 7.4 10.4 7.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M81.5 89.4s.4 5.6-5 12.8M69 82.7s-.7 9.2-8.2 14.2m68.6 26s-5.3 7.4-9.4 10.7m-.7-26.3s.5 4.4-2.1 32",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M150 151.2h-49.8a1 1 0 0 1-1-1v-31.7c0-.5.4-1 1-1H150c.6 0 1 .5 1 1v31.7a1 1 0 0 1-1 1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F4D19D",
	d: "M150.3 151.2h-19.9v-33.7h20.8v32.8a1 1 0 0 1-1 1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M123.6 127.9H92.9a.5.5 0 0 1-.4-.8l6.4-9.1c.2-.3.5-.5.8-.5h31.1l-7.2 10.4z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CC9B6E",
	d: "M123.7 128.4H99.2v-.5h24.2l7.2-10.2.4.3z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F4D19D",
	d: "M158.3 127.9h-18.7a2 2 0 0 1-1.6-.8l-7.2-9.6h20c.5 0 1 .3 1.2.6l6.7 9a.5.5 0 0 1-.4.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CC9B6E",
	d: "M157.8 128.5h-19.3l-7.9-10.5.4-.3 7.7 10.3h19.1zm-27.2 22.2v-8.2h.4v8.2zm-.1-10.9v-21.4h.4l.1 21.4zm-18.6 1.1-.5-.1 1.5-5.2.5.2zm-3.5.2-2.6-3 2.6-3.4.4.3-2.4 3.1 2.4 2.6zm8.2 0-.4-.4 2.4-2.6-2.4-3 .4-.4 2.7 3.4z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m154.3 131.9-3.1-2v3.5l-1 .1a85 85 0 0 1-4.8.3c-1.9 0-2.7 2.2 2.2 2.6l-2.6-.6s-2.2 1.3.5 2.3c0 0-1.6 1.2.6 2.6-.6 3.5 5.2 4 7 3.6a6.1 6.1 0 0 0 4.6-5.2 8 8 0 0 0-3.4-7.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M153.7 133.6s-6.5.4-8.4.3c-1.8 0-1.9 2.2 2.4 2.3 3.7.2 5.4 0 5.4 0",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M145.2 135.9c-1.9 1.3.5 2.3.5 2.3s3.5 1 6.8.6m-.6 2.9s-6.3.1-6.7-2.1c-.3-1.4.4-1.4.4-1.4m.5 2.7s-1 3.1 5.5 3.5m-.4-14.5v3.5M52.8 89.3a18 18 0 0 0 13.6-7.8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#5BA02E",
	d: "M168.6 248.3a6.6 6.6 0 0 1-6.7-6.6v-66.5a6.6 6.6 0 1 1 13.3 0v66.5a6.6 6.6 0 0 1-6.6 6.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#92C110",
	d: "M176.5 247.7a6.6 6.6 0 0 1-6.6-6.7v-33.2a6.6 6.6 0 1 1 13.3 0V241a6.6 6.6 0 0 1-6.7 6.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M186.4 293.6H159a3.2 3.2 0 0 1-3.2-3.2v-46.1a3.2 3.2 0 0 1 3.2-3.2h27.5a3.2 3.2 0 0 1 3.2 3.2v46.1a3.2 3.2 0 0 1-3.2 3.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M89 89.5s7.8 5.4 16.6 2.8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
})));
var noFound_default = NoFound;

//#endregion
//#region node_modules/antd/es/result/serverError.js
var ServerError = () => /* @__PURE__ */ import_react.createElement("svg", {
	width: "254",
	height: "294"
}, /* @__PURE__ */ import_react.createElement("title", null, "Server Error"), /* @__PURE__ */ import_react.createElement("g", {
	fill: "none",
	fillRule: "evenodd"
}, /* @__PURE__ */ import_react.createElement("path", {
	fill: "#E4EBF7",
	d: "M0 128.1v-2C0 56.5 56.3.2 125.7.2h2.1C197.2.3 253.5 56.6 253.5 126v2.1c0 69.5-56.3 125.7-125.7 125.7h-2.1A125.7 125.7 0 0 1 0 128.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M40 132.1a8.3 8.3 0 1 1-16.6-1.7 8.3 8.3 0 0 1 16.6 1.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m37.2 135.6 10.5 6m1 6.3-12.8 10.8",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M40.1 160.8a5.7 5.7 0 1 1-11.3-1.1 5.7 5.7 0 0 1 11.3 1.1M58 144.6a5.7 5.7 0 1 1-11.4-1.2 5.7 5.7 0 0 1 11.4 1.2M99.7 27.4h30a4.6 4.6 0 1 0 0-9.2h-30a4.6 4.6 0 0 0 0 9.2M111 46h30a4.6 4.6 0 1 0 0-9.3h-30a4.6 4.6 0 1 0 0 9.3m2.5-18.6h16a4.6 4.6 0 1 0 0 9.3h-16a4.6 4.6 0 0 0 0-9.3m36.7 42.7h-4a4.8 4.8 0 0 1-4.8-4.8 4.8 4.8 0 0 1 4.8-4.8h4a4.8 4.8 0 0 1 4.7 4.8 4.8 4.8 0 0 1-4.7 4.8"
}), /* @__PURE__ */ import_react.createElement("circle", {
	cx: "201.35",
	cy: "30.2",
	r: "29.7",
	fill: "#FF603B"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "m203.6 19.4-.7 15a1.5 1.5 0 0 1-3 0l-.7-15a2.2 2.2 0 1 1 4.4 0m-.3 19.4c.5.5.8 1.1.8 1.9s-.3 1.4-.8 1.9a3 3 0 0 1-2 .7 2.5 2.5 0 0 1-1.8-.7c-.6-.6-.8-1.2-.8-2 0-.7.2-1.3.8-1.8.5-.5 1.1-.7 1.8-.7.8 0 1.5.2 2 .7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "M119.3 133.3c4.4-.6 3.6-1.2 4-4.8.8-5.2-3-17-8.2-25.1-1-10.7-12.6-11.3-12.6-11.3s4.3 5 4.2 16.2c1.4 5.3.8 14.5.8 14.5s5.3 11.4 11.8 10.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M101 91.6s1.4-.6 3.2.6c8 1.4 10.3 6.7 11.3 11.4 1.8 1.2 1.8 2.3 1.8 3.5l1.5 3s-7.2 1.7-11 6.7c-1.3-6.4-6.9-25.2-6.9-25.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "m94 90.5 1-5.8-9.2-11.9-5.2 5.6-2.6 9.9s8.4 5 16 2.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M83 78.2s-4.6-2.9-2.5-6.9c1.6-3 4.5 1.2 4.5 1.2s.5-3.7 3.2-3.7c.5-1 1.5-4.2 1.5-4.2l13.6 3.2c0 5.2-2.3 19.5-7.9 20-8.9.6-12.5-9.6-12.5-9.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#520038",
	d: "M103 72.2c2.6-2 3.5-9.7 3.5-9.7s-2.5-.5-6.7-2c-4.7-2.2-12.9-4.9-17.6.9-9.5 4.4-2 20-2 20l2.7-3.1s-4-3.3-2.1-6.3c2.2-3.5 4 1 4 1s.6-2.3 3.5-3.3c.4-.7 1-2.7 1.5-3.8A1 1 0 0 1 91 65l11.5 2.7c.5.1.8.6.8 1.2l-.3 3.2z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#552950",
	d: "M101.2 76.5c0 .6-.6 1-1 1-.5-.1-.9-.7-.8-1.3.1-.6.6-1 1.1-1 .5.1.8.7.7 1.3m-7-1.4c0 .6-.5 1-1 1-.5-.1-.8-.7-.7-1.3 0-.6.6-1 1-1 .5.1.9.7.8 1.3"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "m99.2 73.6-.9 1.7-.3 4.3h-2.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M100 73.3s1.7-.7 2.4.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M81.4 73s.4-1 1-.6c.7.4 1.4 1.4.6 2s.2 1.6.2 1.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M92.3 71.7s1.9 1.1 4.2 1",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M92.7 80.6s2.3 1.2 4.4 1.2m-3.4 1.4s1 .4 1.5.3M83.7 80s1.8 6.6 9.2 8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M95.5 91.7s-1 2.8-8.2 2c-7.3-.6-10.3-5-10.3-5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M78.1 87.5s6.6 5 16.5 2.5c0 0 9.6 1 11.5 5.3 5.4 11.8.6 36.8 0 40 3.5 4-.4 8.4-.4 8.4-15.7-3.5-35.8-.6-35.8-.6-4.9-3.5-1.3-9-1.3-9l-6.2-23.8c-2.5-15.2.8-19.8 3.5-20.7 3-1 8-1.3 8-1.3.6 0 1.1 0 1.4-.2 2.4-1.3 2.8-.6 2.8-.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M65.8 89.8s-6.8.5-7.6 8.2c-.4 8.8 3 11 3 11s6.1 22 16.9 22.9c8.4-2.2 4.7-6.7 4.6-11.4-.2-11.3-7-17-7-17s-4.3-13.7-9.9-13.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M71.7 124.2s.9 11.3 9.8 6.5c4.8-2.5 7.6-13.8 9.8-22.6A201 201 0 0 0 94 96l-5-1.7s-2.4 5.6-7.7 12.3c-4.4 5.5-9.2 11.1-9.5 17.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M108.5 105.2s1.7 2.7-2.4 30.5c2.4 2.2 1 6-.2 7.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M123.3 131.5s-.5 2.8-11.8 2c-15.2-1-25.3-3.2-25.3-3.2l.9-5.8s.7.2 9.7-.1c11.9-.4 18.7-6 25-1 4 3.2 1.5 8.1 1.5 8.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M70.2 91s-5.6-4.8-11 2.7c-3.3 7.2.5 15.2 2.6 19.5-.3 3.8 2.4 4.3 2.4 4.3s0 1 1.5 2.7c4-7 6.7-9.1 13.7-12.5-.3-.7-1.9-3.3-1.8-3.8.2-1.7-1.3-2.6-1.3-2.6s-.3-.2-1.2-2.8c-.8-2.3-2-5.1-4.9-7.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M90.2 288s4.9 2.3 8.3 1.2c3.2-1 5.2.7 8 1.3a20 20 0 0 0 13.3-1.4c-.2-6.2-7.8-4.5-13.6-7.6-2.9-1.6-4.2-5.3-4-10H91.5s-1.5 12-1.3 16.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M90.2 287.8s2.8 1.5 7.6.8c3.5-.5 3.3.6 7.5 1.3 4.2.6 13-.2 14.3-1.2.5 1.3-.4 2.4-.4 2.4s-1.7.6-5.4.9c-2.3.1-8.1.3-10.2-.6-2-1.6-4.9-1.5-6-.3-4.5 1.1-7.2-.3-7.2-.3l-.2-3z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M98.4 272.3h3.5s0 7.5 5.2 9.6c-5.3.7-9.7-2.6-8.7-9.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M44.4 272s-2.2 7.8-4.7 13c-1.9 3.8-4.4 7.8 5.8 7.8 7 0 9.3-.5 7.7-7-1.6-6.3.3-13.8.3-13.8h-9z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M38 290.3s2.3 1.2 7 1.2c6.4 0 8.7-1.7 8.7-1.7s.6 1.1-.7 2.2c-1 1-3.8 1.7-7.7 1.7-4.4 0-6.1-.6-7-1.3-1-.5-.8-1.6-.2-2.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M45.3 274s0 1.6-.3 3.1-1.1 3.3-1.2 4.4c0 1.2 4.8 1.6 5.4 0 .7-1.6 1.4-6.8 2-7.6.7-.9-5.1-2.2-5.9.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#7BB2F9",
	d: "M89.5 277.6h13.9s1.3-56.6 1.9-66.8c.6-10.3 4-45.1 1-65.6l-13-.7-23.7.8-1.3 10.4c0 .5-.7.9-.8 1.4 0 .6.5 1.4.4 2L59.6 206c-.1.7-1.3 1-1.5 2.8 0 .3.2 1.6.1 1.8-7.1 19.5-12.2 52.6-15.6 67.2h15.1L62 259c3-13.3 24-88.3 24-88.3l3.2-1-.2 48.6s-.2 1.3.4 2.1c.5.8-.6 1.2-.4 2.4l.4 1.8-1 12.4c-.4 4.9 1.2 40.7 1.2 40.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M64.6 218.9c1.2 0 4.2-2.1 7.2-5.1m24.2 8.7s3-1.1 6.4-4",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M97 219.4s2.9-1.2 6.3-4",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M63.2 222.1s2.7-.6 6.7-3.5m5-72.4c-.3 3.2.3 8.8-4.5 9.4m22.8-11.3s.1 14.6-1.4 15.7c-2.3 1.7-3 2-3 2m.4-17s.3 13-1 25m-4.7.7s6.8-1 9.1-1M46 270l-.9 4.6m1.8-11.3-.8 4.1m16.6-64.9c-.3 1.6 0 2-.4 3.4 0 0-2.8 2-2.3 4s-.3 3.4-4.5 17.2c-1.8 5.8-4.3 19-6.2 28.3l-1.1 5.8m16-67-1 4.9m8.1-52.3-1.2 10.9s-1.2.1-.5 2.3c0 1.4-2.8 16.4-5.4 31.6m-20 82.1h13.9",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M106.2 142.1c-3-.5-18.8-2.7-36.2.2a.6.6 0 0 0-.6.7v3a.6.6 0 0 0 .8.6c3.3-.5 17-2.4 35.6-.3.4 0 .7-.2.7-.5.2-1.4.2-2.5.2-3a.6.6 0 0 0-.5-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M96.4 145.3v-5.1a.8.8 0 0 0-.8-.9 114.1 114.1 0 0 0-8.1 0 .8.8 0 0 0-.9.8v5.1c0 .5.4.9.9.9h8a.8.8 0 0 0 .9-.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M95.2 144.3v-3.2a.7.7 0 0 0-.6-.7h-6.1a.7.7 0 0 0-.6.7v3.2c0 .4.3.7.6.7h6c.4 0 .7-.3.7-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M90.1 273.5h12.8m-11.7-3.7v6.3m-.3-12.6v4.5m-.5-97.6 1 46.4s.7 1.6-.3 2.8c-.9 1.1 2.6.7 1 2.3-1.7 1.6.9 1.2 0 3.5-.6 1.6-1 22-1.2 36.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M73.7 98.7 76 103s2 .8 1.8 2.7l.8 2.2m-14.3 8.7c.2-1 2.2-7.1 12.6-10.5m.7-16s7.7 6 16.5 2.7",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M92 87s5.5-.9 7.5-4.6c1.3-.3.8 2.2-.3 3.7l-1 1.5s.2.3.2.9c0 .6-.2.6-.3 1v1l-.4 1c-.1.2 0 .6-.2.9-.2.4-1.6 1.8-2.6 2.8-3.8 3.6-5 1.7-6-.4-1-1.8-.7-5.1-.9-6.9-.3-2.9-2.6-3-2-4.4.4-.7 3 .7 3.4 1.8.7 2 2.9 1.8 2.6 1.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M99.8 82.4c-.5.1-.3.3-1 1.3-.6 1-4.8 2.9-6.4 3.2-2.5.5-2.2-1.6-4.2-2.9-1.7-1-3.6-.6-1.4 1.4 1 1 1 1.1 1.4 3.2.3 1.5-.7 3.7.7 5.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E59788",
	d: "M79.5 108.7c-2 2.9-4.2 6.1-5.5 8.7",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M87.7 124.8s-2-2-5.1-2.8c-3-.7-3.6-.1-5.5.1-2 .3-4-.9-3.7.7.3 1.7 5 1 5.2 2.1.2 1.1-6.3 2.8-8.3 2.2-.8.8.5 1.9 2 2.2.3 1.5 2.3 1.5 2.3 1.5s.7 1 2.6 1.1c2.5 1.3 9-.7 11-1.5 2-.9-.5-5.6-.5-5.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E59788",
	d: "M73.4 122.8s.7 1.2 3.2 1.4c2.3.3 2.6.6 2.6.6s-2.6 3-9.1 2.3m2.3 2.2s3.8 0 5-.7m-2.4 2.2s2 0 3.3-.6m-1 1.7s1.7 0 2.8-.5m-6.8-9s-.6-1.1 1.3-.5c1.7.5 2.8 0 5.1.1 1.4.1 3-.2 4 .2 1.6.8 3.6 2.2 3.6 2.2s10.6 1.2 19-1.1M79 108s-8.4 2.8-13.2 12.1",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M109.3 112.5s3.4-3.6 7.6-4.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E59788",
	d: "M107.4 123s9.7-2.7 11.4-.9",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#BFCDDD",
	d: "m194.6 83.7 4-4M187.2 91l3.7-3.6m.9-3-4.5-4.7m11.2 11.5-4.2-4.3m-65 76.3 3.7-3.7M122.3 170l3.5-3.5m.8-2.9-4.3-4.2M133 170l-4-4",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A3B4C6",
	d: "M190.2 211.8h-1.6a4 4 0 0 1-4-4v-32.1a4 4 0 0 1 4-4h1.6a4 4 0 0 1 4 4v32a4 4 0 0 1-4 4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A3B4C6",
	d: "M237.8 213a4.8 4.8 0 0 1-4.8 4.8h-86.6a4.8 4.8 0 0 1 0-9.6H233a4.8 4.8 0 0 1 4.8 4.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A3B4C6",
	d: "M154.1 190.1h70.5v-84.6h-70.5z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#BFCDDD",
	d: "M225 190.1h-71.2a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.2v19a3.2 3.2 0 0 1-3.2 3.2m0-59.3h-71.1a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.3v19a3.2 3.2 0 0 1-3.2 3.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M159.6 120.5a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8v-3.2c0-.4.3-.8.8-.8h22.4c.5 0 .8.4.8.8v3.2c0 .5-.3.8-.8.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#BFCDDD",
	d: "M225 160.5h-71.2a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.2v19a3.2 3.2 0 0 1-3.2 3.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#7C90A5",
	d: "M173.5 130.8h49.3m-57.8 0h6m-15 0h6.7m11.1 29.8h49.3m-57.7 0h6m-15.8 0h6.7",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M159.6 151a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8V147c0-.4.3-.8.8-.8h22.4c.5 0 .8.4.8.8v3.2c0 .5-.3.8-.8.8m-63 29a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.5 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8V176c0-.5.3-.8.8-.8h22.4c.5 0 .8.3.8.8v3.2c0 .4-.3.8-.8.8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#BFCDDD",
	d: "M203 221.1h-27.3a2.4 2.4 0 0 1-2.4-2.4v-11.4a2.4 2.4 0 0 1 2.4-2.5H203a2.4 2.4 0 0 1 2.4 2.5v11.4a2.4 2.4 0 0 1-2.4 2.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#A3B4C6",
	d: "M177.3 207.2v11.5m23.8-11.5v11.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#5BA02E",
	d: "M162.9 267.9a9.4 9.4 0 0 1-9.4-9.4v-14.8a9.4 9.4 0 0 1 18.8 0v14.8a9.4 9.4 0 0 1-9.4 9.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#92C110",
	d: "M171.2 267.8a9.4 9.4 0 0 1-9.4-9.4V255a9.4 9.4 0 0 1 18.8 0v3.4a9.4 9.4 0 0 1-9.4 9.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M181.3 293.7h-27.7a3.2 3.2 0 0 1-3.2-3.2v-20.7a3.2 3.2 0 0 1 3.2-3.2h27.7a3.2 3.2 0 0 1 3.2 3.2v20.7a3.2 3.2 0 0 1-3.2 3.2"
})));
var serverError_default = ServerError;

//#endregion
//#region node_modules/antd/es/result/style/index.js
var genBaseStyle$5 = (token$1) => {
	const { componentCls, lineHeightHeading3, iconCls, padding, paddingXL, paddingXS, paddingLG, marginXS, lineHeight } = token$1;
	return {
		[componentCls]: {
			padding: `${unit(token$1.calc(paddingLG).mul(2).equal())} ${unit(paddingXL)}`,
			"&-rtl": { direction: "rtl" }
		},
		[`${componentCls} ${componentCls}-image`]: {
			width: token$1.imageWidth,
			height: token$1.imageHeight,
			margin: "auto"
		},
		[`${componentCls} ${componentCls}-icon`]: {
			marginBottom: paddingLG,
			textAlign: "center",
			[`& > ${iconCls}`]: { fontSize: token$1.iconFontSize }
		},
		[`${componentCls} ${componentCls}-title`]: {
			color: token$1.colorTextHeading,
			fontSize: token$1.titleFontSize,
			lineHeight: lineHeightHeading3,
			marginBlock: marginXS,
			textAlign: "center"
		},
		[`${componentCls} ${componentCls}-subtitle`]: {
			color: token$1.colorTextDescription,
			fontSize: token$1.subtitleFontSize,
			lineHeight,
			textAlign: "center"
		},
		[`${componentCls} ${componentCls}-content`]: {
			marginTop: paddingLG,
			padding: `${unit(paddingLG)} ${unit(token$1.calc(padding).mul(2.5).equal())}`,
			backgroundColor: token$1.colorFillAlter
		},
		[`${componentCls} ${componentCls}-extra`]: {
			margin: token$1.extraMargin,
			textAlign: "center",
			"& > *": {
				marginInlineEnd: paddingXS,
				"&:last-child": { marginInlineEnd: 0 }
			}
		}
	};
};
var genStatusIconStyle = (token$1) => {
	const { componentCls, iconCls } = token$1;
	return {
		[`${componentCls}-success ${componentCls}-icon > ${iconCls}`]: { color: token$1.resultSuccessIconColor },
		[`${componentCls}-error ${componentCls}-icon > ${iconCls}`]: { color: token$1.resultErrorIconColor },
		[`${componentCls}-info ${componentCls}-icon > ${iconCls}`]: { color: token$1.resultInfoIconColor },
		[`${componentCls}-warning ${componentCls}-icon > ${iconCls}`]: { color: token$1.resultWarningIconColor }
	};
};
var genResultStyle = (token$1) => [genBaseStyle$5(token$1), genStatusIconStyle(token$1)];
var getStyle$1 = (token$1) => genResultStyle(token$1);
const prepareComponentToken$12 = (token$1) => ({
	titleFontSize: token$1.fontSizeHeading3,
	subtitleFontSize: token$1.fontSize,
	iconFontSize: token$1.fontSizeHeading3 * 3,
	extraMargin: `${token$1.paddingLG}px 0 0 0`
});
var style_default$13 = genStyleHooks("Result", (token$1) => {
	const resultInfoIconColor = token$1.colorInfo;
	const resultErrorIconColor = token$1.colorError;
	const resultSuccessIconColor = token$1.colorSuccess;
	const resultWarningIconColor = token$1.colorWarning;
	const resultToken = merge(token$1, {
		resultInfoIconColor,
		resultErrorIconColor,
		resultSuccessIconColor,
		resultWarningIconColor,
		imageWidth: 250,
		imageHeight: 295
	});
	return [getStyle$1(resultToken)];
}, prepareComponentToken$12);

//#endregion
//#region node_modules/antd/es/result/unauthorized.js
var Unauthorized = () => /* @__PURE__ */ import_react.createElement("svg", {
	width: "251",
	height: "294"
}, /* @__PURE__ */ import_react.createElement("title", null, "Unauthorized"), /* @__PURE__ */ import_react.createElement("g", {
	fill: "none",
	fillRule: "evenodd"
}, /* @__PURE__ */ import_react.createElement("path", {
	fill: "#E4EBF7",
	d: "M0 129v-2C0 58.3 55.6 2.7 124.2 2.7h2c68.6 0 124.2 55.6 124.2 124.1v2.1c0 68.6-55.6 124.2-124.1 124.2h-2.1A124.2 124.2 0 0 1 0 129"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M41.4 133a8.2 8.2 0 1 1-16.4-1.7 8.2 8.2 0 0 1 16.4 1.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m38.7 136.4 10.4 5.9m.9 6.2-12.6 10.7",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M41.5 161.3a5.6 5.6 0 1 1-11.2-1.2 5.6 5.6 0 0 1 11.2 1.2m17.7-16a5.7 5.7 0 1 1-11.3-1.2 5.7 5.7 0 0 1 11.3 1.2m41.2-115.8H130a4.6 4.6 0 1 0 0-9.1h-29.6a4.6 4.6 0 0 0 0 9.1m11.3 18.3h29.7a4.6 4.6 0 1 0 0-9.2h-29.7a4.6 4.6 0 1 0 0 9.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M114 29.5h15.8a4.6 4.6 0 1 0 0 9.1H114a4.6 4.6 0 0 0 0-9.1m71.3 108.2a10 10 0 1 1-19.8-2 10 10 0 0 1 19.8 2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m180.2 143.8 12.5 7.1m1.1 7.5-15.1 13",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M185.6 172a6.8 6.8 0 1 1-13.6-1.4 6.8 6.8 0 0 1 13.5 1.3m18.6-16.6a6.8 6.8 0 1 1-13.6-1.4 6.8 6.8 0 0 1 13.6 1.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "M153 194a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm73-75.8a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.4 0zm-9 34.9a2.2 2.2 0 1 1-4.3 0 2.2 2.2 0 0 1 4.4 0zm-39.2-43.3a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm18.3-15.3a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm6.7 88a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0z",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#FFF",
	d: "m215.1 155.3-1.9 20-10.8 6m-27.8-4.7-6.3 9.8H157l-4.5 6.4m23.4-65.5v-15.7m45.6 7.8-12.8 7.9-15.2-7.9V96.7",
	strokeWidth: "2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A26EF4",
	d: "M180.7 29.3a29.3 29.3 0 1 1 58.6 0 29.3 29.3 0 0 1-58.6 0"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "m221.4 41.7-21.5-.1a1.7 1.7 0 0 1-1.7-1.8V27.6a1.7 1.7 0 0 1 1.8-1.7h21.5c1 0 1.8.9 1.8 1.8l-.1 12.3a1.7 1.7 0 0 1-1.7 1.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M215.1 29.2c0 2.6-2 4.6-4.5 4.6a4.6 4.6 0 0 1-4.5-4.7v-6.9c0-2.6 2-4.6 4.6-4.6 2.5 0 4.5 2 4.4 4.7v6.9zm-4.5-14a6.9 6.9 0 0 0-7 6.8v7.3a6.9 6.9 0 0 0 13.8.1V22a6.9 6.9 0 0 0-6.8-6.9zm-43 53.2h-4a4.7 4.7 0 0 1-4.7-4.8 4.7 4.7 0 0 1 4.7-4.7h4a4.7 4.7 0 0 1 4.7 4.8 4.7 4.7 0 0 1-4.7 4.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#5BA02E",
	d: "M168.2 248.8a6.6 6.6 0 0 1-6.6-6.6v-66a6.6 6.6 0 0 1 13.2 0v66a6.6 6.6 0 0 1-6.6 6.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#92C110",
	d: "M176.1 248.2a6.6 6.6 0 0 1-6.6-6.6v-33a6.6 6.6 0 1 1 13.3 0v33a6.6 6.6 0 0 1-6.7 6.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#F2D7AD",
	d: "M186 293.9h-27.4a3.2 3.2 0 0 1-3.2-3.2v-45.9a3.2 3.2 0 0 1 3.2-3.1H186a3.2 3.2 0 0 1 3.2 3.1v46a3.2 3.2 0 0 1-3.2 3"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M82 147.7s6.3-1 17.5-1.3c11.8-.4 17.6 1 17.6 1s3.7-3.8 1-8.3c1.3-12.1 6-32.9.3-48.3-1.1-1.4-3.7-1.5-7.5-.6-1.4.3-7.2-.2-8-.1l-15.3-.4-8-.5c-1.6-.1-4.3-1.7-5.5-.3-.4.4-2.4 5.6-2 16l8.7 35.7s-3.2 3.6 1.2 7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m75.8 73.3-1-6.4 12-6.5s7.4-.1 8 1.2c.8 1.3-5.5 1-5.5 1s-1.9 1.4-2.6 2.5c-1.7 2.4-1 6.5-8.4 6-1.7.3-2.5 2.2-2.5 2.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "M52.4 77.7S66.7 87 77.4 92c1 .5-2 16.2-11.9 11.8-7.4-3.3-20.1-8.4-21.5-14.5-.7-3.2 2.6-7.6 8.4-11.7M142 80s-6.7 3-13.9 6.9c-3.9 2.1-10.1 4.7-12.3 8-6.2 9.3 3.5 11.2 13 7.5 6.6-2.7 29-12.1 13.2-22.4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m76.2 66.4 3 3.8S76.4 73 73 76c-7 6.2-12.8 14.3-16 16.4-4 2.7-9.7 3.3-12.2 0-3.5-5.1.5-14.7 31.5-26"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M64.7 85.1s-2.4 8.4-9 14.5c.7.5 18.6 10.5 22.2 10 5.2-.6 6.4-19 1.2-20.5-.8-.2-6-1.3-8.9-2.2-.9-.2-1.6-1.7-3.5-1l-2-.8zm63.7.7s5.3 2 7.3 13.8c-.6.2-17.6 12.3-21.8 7.8-6.6-7-.8-17.4 4.2-18.6 4.7-1.2 5-1.4 10.3-3"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M78.2 94.7s.9 7.4-5 13",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M87.4 94.7s3.1 2.6 10.3 2.6c7.1 0 9-3.5 9-3.5",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".9"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m117.2 68.6-6.8-6.1s-5.4-4.4-9.2-1c-3.9 3.5 4.4 2.2 5.6 4.2 1.2 2.1.9 1.2-2 .5-5.7-1.4-2.1.9 3 5.3 2 1.9 7 1 7 1l2.4-3.9z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFB594",
	d: "m105.3 91.3-.3-11H89l-.5 10.5c0 .4.2.8.6 1 2 1.3 9.3 5 15.8.4.2-.2.4-.5.4-.9"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#5C2552",
	d: "M107.6 74.2c.8-1.1 1-9 1-11.9a1 1 0 0 0-1-1l-4.6-.4c-7.7-1-17 .6-18.3 6.3-5.4 5.9-.4 13.3-.4 13.3s2 3.5 4.3 6.8c.8 1 .4-3.8 3-6a47.9 47.9 0 0 1 16-7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "M88.4 83.2s2.7 6.2 11.6 6.5c7.8.3 9-7 7.5-17.5l-1-5.5c-6-2.9-15.4.6-15.4.6s-.6 2-.2 5.5c-2.3 2-1.8 5.6-1.8 5.6s-1-2-2-2.3c-.9-.3-2 0-2.3 2-1 4.6 3.6 5.1 3.6 5.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "m100.8 77.1 1.7-1-1-4.3.7-1.4",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#552950",
	d: "M105.5 74c0 .8-.4 1.4-1 1.4-.4 0-.8-.7-.8-1.4s.5-1.2 1-1.2.9.6.8 1.3m-8 .2c0 .8-.4 1.3-.9 1.3s-.9-.6-.9-1.3c0-.7.5-1.3 1-1.3s1 .6.9 1.3"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M91.1 86.8s5.3 5 12.7 2.3",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#DB836E",
	d: "M99.8 81.9s-3.6.2-1.5-2.8c1.6-1.5 5-.4 5-.4s1 3.9-3.5 3.2"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#5C2552",
	d: "M102.9 70.6s2.5.8 3.4.7m-12.4.7s2.5-1.2 4.8-1.1",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.5"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M86.3 77.4s1 .9 1.5 2c-.4.6-1 1.2-.3 1.9m11.8 2.4s2 .2 2.5-.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "m87.8 115.8 15.7-3m-3.3 3 10-2m-43.7-27s-1.6 8.8-6.7 14M128.3 88s3 4 4 11.7",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M64 84.8s-6 10-13.5 10",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFC6A0",
	d: "m112.4 66-.2 5.2 12 9.2c4.5 3.6 8.9 7.5 11 8.7 4.8 2.8 8.9 3.3 11 1.8 4.1-2.9 4.4-9.9-8.1-15.3-4.3-1.8-16.1-6.3-25.7-9.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#DB836E",
	d: "M130.5 85.5s4.6 5.7 11.7 6.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: ".8"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#E4EBF7",
	d: "M121.7 105.7s-.4 8.6-1.3 13.6",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M115.8 161.5s-3.6-1.5-2.7-7.1",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M101.5 290.2s4.3 2.1 7.4 1c2.9-.9 4.6.7 7.2 1.3 2.5.5 6.9 1 11.7-1.3 0-5.6-7-4-12-6.8-2.6-1.4-3.8-4.7-3.6-8.8h-9.5s-1.4 10.6-1.2 14.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M101.5 290s2.4 1.4 6.8.7c3-.4 3.7.5 7.5 1 3.7.6 10.8 0 11.9-.8.4 1-.4 2-.4 2s-1.5.7-4.8.9c-2 .1-5.8.3-7.7-.5-1.8-1.4-5.2-2-5.7-.3-4 1-7.4-.3-7.4-.3l-.2-2.6z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M108.8 276.2h3.1s0 6.7 4.6 8.6c-4.7.6-8.6-2.3-7.7-8.6"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#CBD1D1",
	d: "M57.6 272.5s-2 7.5-4.5 12.4c-1.8 3.7-4.2 7.6 5.5 7.6 6.7 0 9-.5 7.5-6.7-1.5-6.1.3-13.3.3-13.3h-8.8z"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#2B0849",
	d: "M51.5 290s2.2 1.2 6.7 1.2c6.1 0 8.3-1.6 8.3-1.6s.6 1-.6 2.1c-1 .9-3.6 1.6-7.4 1.6-4.2 0-6-.6-6.8-1.2-.9-.5-.7-1.6-.2-2"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#A4AABA",
	d: "M58.5 274.4s0 1.6-.3 3-1 3.1-1.1 4.2c0 1.1 4.5 1.5 5.2 0 .6-1.6 1.3-6.5 1.9-7.3.6-.8-5-2.1-5.7.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#7BB2F9",
	d: "m100.9 277 13.3.1s1.3-54.2 1.8-64c.6-9.9 3.8-43.2 1-62.8l-12.4-.7-22.8.8-1.2 10c0 .4-.6.8-.7 1.3 0 .6.4 1.3.3 2-2.3 14-6.3 32.9-8.7 46.4-.1.6-1.2 1-1.4 2.6 0 .3.2 1.6 0 1.8-6.8 18.7-10.8 47.6-14.1 61.6h14.5s2.2-8.6 4-17a3984 3984 0 0 1 23-84.5l3-.5 1 46.1s-.2 1.2.4 2c.5.8-.6 1.1-.4 2.3l.4 1.7-1 11.9c-.4 4.6 0 39 0 39"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M77.4 220.4c1.2.1 4-2 7-4.9m23.1 8.4s2.8-1 6.1-3.8",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M108.5 221s2.7-1.2 6-4",
	strokeLinecap: "round",
	strokeLinejoin: "round"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M76.1 223.6s2.6-.6 6.5-3.4m4.7-69.4c-.2 3.1.3 8.5-4.3 9m21.8-10.7s.1 14-1.3 15c-2.2 1.6-3 1.9-3 1.9m.5-16.4s0 12.8-1.2 24.3m-4.9 1s7.2-1.6 9.4-1.6m-28.6 31.5-1 4.5s-1.5 1.8-1 3.7c.4 2-1 2-5 15.3-1.7 5.6-4.4 18.5-6.3 27.5l-4 18.4M77 196.7a313.3 313.3 0 0 1-.8 4.8m7.7-50-1.2 10.3s-1 .2-.5 2.3c.1 1.3-2.6 15.6-5.1 30.2M57.6 273h13.2",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M117.4 147.4s-17-3-35.7.2v4.2s14.6-2.9 35.5-.4l.2-4"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#FFF",
	d: "M107.5 150.4v-5a.8.8 0 0 0-.8-.7H99a.8.8 0 0 0-.7.8v4.8c0 .5.3.9.8.8a140.8 140.8 0 0 1 7.7 0 .8.8 0 0 0 .8-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	fill: "#192064",
	d: "M106.4 149.4v-3a.6.6 0 0 0-.6-.7 94.1 94.1 0 0 0-5.8 0 .6.6 0 0 0-.7.7v3c0 .4.3.7.7.7h5.7c.4 0 .7-.3.7-.7"
}), /* @__PURE__ */ import_react.createElement("path", {
	stroke: "#648BD8",
	d: "M101.5 274h12.3m-11.1-5v6.5m0-12.4v4.3m-.5-93.4.9 44.4s.7 1.6-.2 2.7c-1 1.1 2.4.7.9 2.2-1.6 1.6.9 1.1 0 3.4-.6 1.5-1 21-1.1 35",
	strokeLinecap: "round",
	strokeLinejoin: "round",
	strokeWidth: "1.1"
})));
var unauthorized_default = Unauthorized;

//#endregion
//#region node_modules/antd/es/result/index.js
var import_classnames$56 = /* @__PURE__ */ __toESM(require_classnames());
const IconMap = {
	success: CheckCircleFilled_default,
	error: CloseCircleFilled_default,
	info: ExclamationCircleFilled_default,
	warning: WarningFilled_default
};
const ExceptionMap = {
	"404": noFound_default,
	"500": serverError_default,
	"403": unauthorized_default
};
var ExceptionStatus = Object.keys(ExceptionMap);
var Icon = ({ prefixCls, icon, status }) => {
	const className = (0, import_classnames$56.default)(`${prefixCls}-icon`);
	devUseWarning("Result")(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`);
	if (ExceptionStatus.includes(`${status}`)) {
		const SVGComponent = ExceptionMap[status];
		return /* @__PURE__ */ import_react.createElement("div", { className: `${className} ${prefixCls}-image` }, /* @__PURE__ */ import_react.createElement(SVGComponent, null));
	}
	const iconNode = /* @__PURE__ */ import_react.createElement(IconMap[status]);
	if (icon === null || icon === false) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className }, icon || iconNode);
};
var Extra = ({ prefixCls, extra }) => {
	if (!extra) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-extra` }, extra);
};
var Result = ({ prefixCls: customizePrefixCls, className: customizeClassName, rootClassName, subTitle, title, style: style$1, children, status = "info", icon, extra }) => {
	const { getPrefixCls, direction, result } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("result", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$13(prefixCls);
	const className = (0, import_classnames$56.default)(prefixCls, `${prefixCls}-${status}`, customizeClassName, result === null || result === void 0 ? void 0 : result.className, rootClassName, { [`${prefixCls}-rtl`]: direction === "rtl" }, hashId, cssVarCls);
	const mergedStyle = Object.assign(Object.assign({}, result === null || result === void 0 ? void 0 : result.style), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
		className,
		style: mergedStyle
	}, /* @__PURE__ */ import_react.createElement(Icon, {
		prefixCls,
		status,
		icon
	}), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-title` }, title), subTitle && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-subtitle` }, subTitle), /* @__PURE__ */ import_react.createElement(Extra, {
		prefixCls,
		extra
	}), children && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-content` }, children)));
};
Result.PRESENTED_IMAGE_403 = ExceptionMap["403"];
Result.PRESENTED_IMAGE_404 = ExceptionMap["404"];
Result.PRESENTED_IMAGE_500 = ExceptionMap["500"];
Result.displayName = "Result";
var result_default = Result;

//#endregion
//#region node_modules/antd/es/row/index.js
var row_default = row_default$1;

//#endregion
//#region node_modules/antd/es/statistic/Number.js
var StatisticNumber = (props) => {
	const { value, formatter, precision, decimalSeparator, groupSeparator = "", prefixCls } = props;
	let valueNode;
	if (typeof formatter === "function") valueNode = formatter(value);
	else {
		const val = String(value);
		const cells = val.match(/^(-?)(\d*)(\.(\d+))?$/);
		if (!cells || val === "-") valueNode = val;
		else {
			const negative = cells[1];
			let int = cells[2] || "0";
			let decimal = cells[4] || "";
			int = int.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
			if (typeof precision === "number") decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
			if (decimal) decimal = `${decimalSeparator}${decimal}`;
			valueNode = [/* @__PURE__ */ import_react.createElement("span", {
				key: "int",
				className: `${prefixCls}-content-value-int`
			}, negative, int), decimal && /* @__PURE__ */ import_react.createElement("span", {
				key: "decimal",
				className: `${prefixCls}-content-value-decimal`
			}, decimal)];
		}
	}
	return /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-content-value` }, valueNode);
};
var Number_default = StatisticNumber;

//#endregion
//#region node_modules/antd/es/statistic/style/index.js
var genStatisticStyle = (token$1) => {
	const { componentCls, marginXXS, padding, colorTextDescription, titleFontSize, colorTextHeading, contentFontSize, fontFamily } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		[`${componentCls}-title`]: {
			marginBottom: marginXXS,
			color: colorTextDescription,
			fontSize: titleFontSize
		},
		[`${componentCls}-skeleton`]: { paddingTop: padding },
		[`${componentCls}-content`]: {
			color: colorTextHeading,
			fontSize: contentFontSize,
			fontFamily,
			[`${componentCls}-content-value`]: {
				display: "inline-block",
				direction: "ltr"
			},
			[`${componentCls}-content-prefix, ${componentCls}-content-suffix`]: { display: "inline-block" },
			[`${componentCls}-content-prefix`]: { marginInlineEnd: marginXXS },
			[`${componentCls}-content-suffix`]: { marginInlineStart: marginXXS }
		}
	}) };
};
const prepareComponentToken$11 = (token$1) => {
	const { fontSizeHeading3, fontSize } = token$1;
	return {
		titleFontSize: fontSize,
		contentFontSize: fontSizeHeading3
	};
};
var style_default$12 = genStyleHooks("Statistic", (token$1) => {
	const statisticToken$1 = merge(token$1, {});
	return genStatisticStyle(statisticToken$1);
}, prepareComponentToken$11);

//#endregion
//#region node_modules/antd/es/statistic/Statistic.js
var import_classnames$55 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$21 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Statistic = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, valueStyle, value = 0, title, valueRender, prefix, suffix, loading = false, formatter, precision, decimalSeparator = ".", groupSeparator = ",", onMouseEnter, onMouseLeave } = props, rest = __rest$21(props, [
		"prefixCls",
		"className",
		"rootClassName",
		"style",
		"valueStyle",
		"value",
		"title",
		"valueRender",
		"prefix",
		"suffix",
		"loading",
		"formatter",
		"precision",
		"decimalSeparator",
		"groupSeparator",
		"onMouseEnter",
		"onMouseLeave"
	]);
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("statistic");
	const prefixCls = getPrefixCls("statistic", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$12(prefixCls);
	const valueNode = /* @__PURE__ */ import_react.createElement(Number_default, {
		decimalSeparator,
		groupSeparator,
		prefixCls,
		formatter,
		precision,
		value
	});
	const cls$12 = (0, import_classnames$55.default)(prefixCls, { [`${prefixCls}-rtl`]: direction === "rtl" }, contextClassName, className, rootClassName, hashId, cssVarCls);
	const internalRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({ nativeElement: internalRef.current }));
	const restProps = pickAttrs(rest, {
		aria: true,
		data: true
	});
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", Object.assign({}, restProps, {
		ref: internalRef,
		className: cls$12,
		style: Object.assign(Object.assign({}, contextStyle), style$1),
		onMouseEnter,
		onMouseLeave
	}), title && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-title` }, title), /* @__PURE__ */ import_react.createElement(skeleton_default, {
		paragraph: false,
		loading,
		className: `${prefixCls}-skeleton`
	}, /* @__PURE__ */ import_react.createElement("div", {
		style: valueStyle,
		className: `${prefixCls}-content`
	}, prefix && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-content-prefix` }, prefix), valueRender ? valueRender(valueNode) : valueNode, suffix && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-content-suffix` }, suffix)))));
});
Statistic.displayName = "Statistic";
var Statistic_default = Statistic;

//#endregion
//#region node_modules/antd/es/statistic/utils.js
var timeUnits = [
	["Y", 1e3 * 60 * 60 * 24 * 365],
	["M", 1e3 * 60 * 60 * 24 * 30],
	["D", 1e3 * 60 * 60 * 24],
	["H", 1e3 * 60 * 60],
	["m", 1e3 * 60],
	["s", 1e3],
	["S", 1]
];
function formatTimeStr(duration, format$2) {
	let leftDuration = duration;
	const escapeRegex = /\[[^\]]*]/g;
	const keepList = (format$2.match(escapeRegex) || []).map((str) => str.slice(1, -1));
	const templateText = format$2.replace(escapeRegex, "[]");
	const replacedText = timeUnits.reduce((current, [name, unit$2]) => {
		if (current.includes(name)) {
			const value = Math.floor(leftDuration / unit$2);
			leftDuration -= value * unit$2;
			return current.replace(new RegExp(`${name}+`, "g"), (match$1) => {
				const len = match$1.length;
				return value.toString().padStart(len, "0");
			});
		}
		return current;
	}, templateText);
	let index$2 = 0;
	return replacedText.replace(escapeRegex, () => {
		const match$1 = keepList[index$2];
		index$2 += 1;
		return match$1;
	});
}
function formatCounter(value, config, down) {
	const { format: format$2 = "" } = config;
	const target = new Date(value).getTime();
	const current = Date.now();
	const diff = down ? Math.max(target - current, 0) : Math.max(current - target, 0);
	return formatTimeStr(diff, format$2);
}

//#endregion
//#region node_modules/antd/es/statistic/Timer.js
var __rest$20 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function getTime(value) {
	return new Date(value).getTime();
}
var StatisticTimer = (props) => {
	const { value, format: format$2 = "HH:mm:ss", onChange, onFinish, type: type$2 } = props, rest = __rest$20(props, [
		"value",
		"format",
		"onChange",
		"onFinish",
		"type"
	]);
	const down = type$2 === "countdown";
	const [showTime, setShowTime] = import_react.useState(null);
	const update = useEvent(() => {
		const now$1 = Date.now();
		const timestamp = getTime(value);
		setShowTime({});
		const timeDiff = !down ? now$1 - timestamp : timestamp - now$1;
		onChange === null || onChange === void 0 || onChange(timeDiff);
		if (down && timestamp < now$1) {
			onFinish === null || onFinish === void 0 || onFinish();
			return false;
		}
		return true;
	});
	import_react.useEffect(() => {
		let rafId;
		const clear = () => raf_default.cancel(rafId);
		const rafUpdate = () => {
			rafId = raf_default(() => {
				if (update()) rafUpdate();
			});
		};
		rafUpdate();
		return clear;
	}, [value, down]);
	import_react.useEffect(() => {
		setShowTime({});
	}, []);
	const formatter = (formatValue$1, config) => showTime ? formatCounter(formatValue$1, Object.assign(Object.assign({}, config), { format: format$2 }), down) : "-";
	const valueRender = (node$1) => cloneElement(node$1, { title: void 0 });
	return /* @__PURE__ */ import_react.createElement(Statistic_default, Object.assign({}, rest, {
		value,
		valueRender,
		formatter
	}));
};
var Timer_default = StatisticTimer;

//#endregion
//#region node_modules/antd/es/statistic/Countdown.js
var Countdown = (props) => {
	devUseWarning("Countdown").deprecated(false, "<Statistic.Countdown />", "<Statistic.Timer type=\"countdown\" />");
	return /* @__PURE__ */ import_react.createElement(Timer_default, Object.assign({}, props, { type: "countdown" }));
};
var Countdown_default = /* @__PURE__ */ import_react.memo(Countdown);

//#endregion
//#region node_modules/antd/es/statistic/index.js
Statistic_default.Timer = Timer_default;
Statistic_default.Countdown = Countdown_default;
var statistic_default = Statistic_default;

//#endregion
//#region node_modules/rc-steps/es/Step.js
var import_classnames$54 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$15 = [
	"className",
	"prefixCls",
	"style",
	"active",
	"status",
	"iconPrefix",
	"icon",
	"wrapperStyle",
	"stepNumber",
	"disabled",
	"description",
	"title",
	"subTitle",
	"progressDot",
	"stepIcon",
	"tailContent",
	"icons",
	"stepIndex",
	"onStepClick",
	"onClick",
	"render"
];
function isString(str) {
	return typeof str === "string";
}
function Step(props) {
	var _classNames2, className = props.className, prefixCls = props.prefixCls, style$1 = props.style, active = props.active, status = props.status, iconPrefix = props.iconPrefix, icon = props.icon;
	props.wrapperStyle;
	var stepNumber = props.stepNumber, disabled = props.disabled, description = props.description, title = props.title, subTitle = props.subTitle, progressDot = props.progressDot, stepIcon = props.stepIcon, tailContent = props.tailContent, icons$1 = props.icons, stepIndex = props.stepIndex, onStepClick = props.onStepClick, onClick = props.onClick, render$1 = props.render, restProps = _objectWithoutProperties(props, _excluded$15);
	var clickable = !!onStepClick && !disabled;
	var accessibilityProps = {};
	if (clickable) {
		accessibilityProps.role = "button";
		accessibilityProps.tabIndex = 0;
		accessibilityProps.onClick = function(e$2) {
			onClick === null || onClick === void 0 || onClick(e$2);
			onStepClick(stepIndex);
		};
		accessibilityProps.onKeyDown = function(e$2) {
			var which = e$2.which;
			if (which === KeyCode_default.ENTER || which === KeyCode_default.SPACE) onStepClick(stepIndex);
		};
	}
	var renderIconNode = function renderIconNode$1() {
		var _classNames;
		var iconNode;
		var iconClassName = (0, import_classnames$54.default)("".concat(prefixCls, "-icon"), "".concat(iconPrefix, "icon"), (_classNames = {}, _defineProperty(_classNames, "".concat(iconPrefix, "icon-").concat(icon), icon && isString(icon)), _defineProperty(_classNames, "".concat(iconPrefix, "icon-check"), !icon && status === "finish" && (icons$1 && !icons$1.finish || !icons$1)), _defineProperty(_classNames, "".concat(iconPrefix, "icon-cross"), !icon && status === "error" && (icons$1 && !icons$1.error || !icons$1)), _classNames));
		var iconDot = /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-icon-dot") });
		if (progressDot) if (typeof progressDot === "function") iconNode = /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-icon") }, progressDot(iconDot, {
			index: stepNumber - 1,
			status,
			title,
			description
		}));
		else iconNode = /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-icon") }, iconDot);
		else if (icon && !isString(icon)) iconNode = /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-icon") }, icon);
		else if (icons$1 && icons$1.finish && status === "finish") iconNode = /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-icon") }, icons$1.finish);
		else if (icons$1 && icons$1.error && status === "error") iconNode = /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-icon") }, icons$1.error);
		else if (icon || status === "finish" || status === "error") iconNode = /* @__PURE__ */ import_react.createElement("span", { className: iconClassName });
		else iconNode = /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-icon") }, stepNumber);
		if (stepIcon) iconNode = stepIcon({
			index: stepNumber - 1,
			status,
			title,
			description,
			node: iconNode
		});
		return iconNode;
	};
	var mergedStatus = status || "wait";
	var classString = (0, import_classnames$54.default)("".concat(prefixCls, "-item"), "".concat(prefixCls, "-item-").concat(mergedStatus), className, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefixCls, "-item-custom"), icon), _defineProperty(_classNames2, "".concat(prefixCls, "-item-active"), active), _defineProperty(_classNames2, "".concat(prefixCls, "-item-disabled"), disabled === true), _classNames2));
	var stepItemStyle = _objectSpread2({}, style$1);
	var stepNode = /* @__PURE__ */ import_react.createElement("div", _extends({}, restProps, {
		className: classString,
		style: stepItemStyle
	}), /* @__PURE__ */ import_react.createElement("div", _extends({ onClick }, accessibilityProps, { className: "".concat(prefixCls, "-item-container") }), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-item-tail") }, tailContent), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-item-icon") }, renderIconNode()), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-item-content") }, /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-item-title") }, title, subTitle && /* @__PURE__ */ import_react.createElement("div", {
		title: typeof subTitle === "string" ? subTitle : void 0,
		className: "".concat(prefixCls, "-item-subtitle")
	}, subTitle)), description && /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-item-description") }, description))));
	if (render$1) stepNode = render$1(stepNode) || null;
	return stepNode;
}
var Step_default = Step;

//#endregion
//#region node_modules/rc-steps/es/Steps.js
var import_classnames$53 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$14 = [
	"prefixCls",
	"style",
	"className",
	"children",
	"direction",
	"type",
	"labelPlacement",
	"iconPrefix",
	"status",
	"size",
	"current",
	"progressDot",
	"stepIcon",
	"initial",
	"icons",
	"onChange",
	"itemRender",
	"items"
];
function Steps$1(props) {
	var _classNames, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-steps" : _props$prefixCls, _props$style = props.style, style$1 = _props$style === void 0 ? {} : _props$style, className = props.className;
	props.children;
	var _props$direction = props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction, _props$type = props.type, type$2 = _props$type === void 0 ? "default" : _props$type, _props$labelPlacement = props.labelPlacement, labelPlacement = _props$labelPlacement === void 0 ? "horizontal" : _props$labelPlacement, _props$iconPrefix = props.iconPrefix, iconPrefix = _props$iconPrefix === void 0 ? "rc" : _props$iconPrefix, _props$status = props.status, status = _props$status === void 0 ? "process" : _props$status, size = props.size, _props$current = props.current, current = _props$current === void 0 ? 0 : _props$current, _props$progressDot = props.progressDot, progressDot = _props$progressDot === void 0 ? false : _props$progressDot, stepIcon = props.stepIcon, _props$initial = props.initial, initial = _props$initial === void 0 ? 0 : _props$initial, icons$1 = props.icons, onChange = props.onChange, itemRender = props.itemRender, _props$items = props.items, items = _props$items === void 0 ? [] : _props$items, restProps = _objectWithoutProperties(props, _excluded$14);
	var isNav = type$2 === "navigation";
	var isInline = type$2 === "inline";
	var mergedProgressDot = isInline || progressDot;
	var mergedDirection = isInline ? "horizontal" : direction;
	var mergedSize = isInline ? void 0 : size;
	var adjustedLabelPlacement = mergedProgressDot ? "vertical" : labelPlacement;
	var classString = (0, import_classnames$53.default)(prefixCls, "".concat(prefixCls, "-").concat(mergedDirection), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-").concat(mergedSize), mergedSize), _defineProperty(_classNames, "".concat(prefixCls, "-label-").concat(adjustedLabelPlacement), mergedDirection === "horizontal"), _defineProperty(_classNames, "".concat(prefixCls, "-dot"), !!mergedProgressDot), _defineProperty(_classNames, "".concat(prefixCls, "-navigation"), isNav), _defineProperty(_classNames, "".concat(prefixCls, "-inline"), isInline), _classNames));
	var onStepClick = function onStepClick$1(next$1) {
		if (onChange && current !== next$1) onChange(next$1);
	};
	return /* @__PURE__ */ import_react.createElement("div", _extends({
		className: classString,
		style: style$1
	}, restProps), items.filter(function(item) {
		return item;
	}).map(function renderStep(item, index$2) {
		var mergedItem = _objectSpread2({}, item);
		var stepNumber = initial + index$2;
		if (status === "error" && index$2 === current - 1) mergedItem.className = "".concat(prefixCls, "-next-error");
		if (!mergedItem.status) if (stepNumber === current) mergedItem.status = status;
		else if (stepNumber < current) mergedItem.status = "finish";
		else mergedItem.status = "wait";
		if (isInline) {
			mergedItem.icon = void 0;
			mergedItem.subTitle = void 0;
		}
		if (!mergedItem.render && itemRender) mergedItem.render = function(stepItem) {
			return itemRender(mergedItem, stepItem);
		};
		return /* @__PURE__ */ import_react.createElement(Step_default, _extends({}, mergedItem, {
			active: stepNumber === current,
			stepNumber: stepNumber + 1,
			stepIndex: stepNumber,
			key: stepNumber,
			prefixCls,
			iconPrefix,
			wrapperStyle: style$1,
			progressDot: mergedProgressDot,
			stepIcon,
			icons: icons$1,
			onStepClick: onChange && onStepClick
		}));
	}));
}
Steps$1.Step = Step_default;
var Steps_default = Steps$1;

//#endregion
//#region node_modules/rc-steps/es/index.js
var es_default$10 = Steps_default;

//#endregion
//#region node_modules/antd/es/steps/style/custom-icon.js
var genStepsCustomIconStyle = (token$1) => {
	const { componentCls, customIconTop, customIconSize, customIconFontSize } = token$1;
	return {
		[`${componentCls}-item-custom`]: { [`> ${componentCls}-item-container > ${componentCls}-item-icon`]: {
			height: "auto",
			background: "none",
			border: 0,
			[`> ${componentCls}-icon`]: {
				top: customIconTop,
				width: customIconSize,
				height: customIconSize,
				fontSize: customIconFontSize,
				lineHeight: unit(customIconSize)
			}
		} },
		[`&:not(${componentCls}-vertical)`]: { [`${componentCls}-item-custom`]: { [`${componentCls}-item-icon`]: {
			width: "auto",
			background: "none"
		} } }
	};
};
var custom_icon_default = genStepsCustomIconStyle;

//#endregion
//#region node_modules/antd/es/steps/style/horizontal.js
var genHorizontalStyle = (token$1) => {
	const { componentCls } = token$1;
	const stepsItemCls = `${componentCls}-item`;
	return { [`${componentCls}-horizontal`]: { [`${stepsItemCls}-tail`]: { transform: "translateY(-50%)" } } };
};
var horizontal_default = genHorizontalStyle;

//#endregion
//#region node_modules/antd/es/steps/style/inline.js
var genStepsInlineStyle = (token$1) => {
	const { componentCls, inlineDotSize, inlineTitleColor, inlineTailColor } = token$1;
	const containerPaddingTop = token$1.calc(token$1.paddingXS).add(token$1.lineWidth).equal();
	const titleStyle = { [`${componentCls}-item-container ${componentCls}-item-content ${componentCls}-item-title`]: { color: inlineTitleColor } };
	return { [`&${componentCls}-inline`]: {
		width: "auto",
		display: "inline-flex",
		[`${componentCls}-item`]: {
			flex: "none",
			"&-container": {
				padding: `${unit(containerPaddingTop)} ${unit(token$1.paddingXXS)} 0`,
				margin: `0 ${unit(token$1.calc(token$1.marginXXS).div(2).equal())}`,
				borderRadius: token$1.borderRadiusSM,
				cursor: "pointer",
				transition: `background-color ${token$1.motionDurationMid}`,
				"&:hover": { background: token$1.controlItemBgHover },
				"&[role='button']:hover": { opacity: 1 }
			},
			"&-icon": {
				width: inlineDotSize,
				height: inlineDotSize,
				marginInlineStart: `calc(50% - ${unit(token$1.calc(inlineDotSize).div(2).equal())})`,
				[`> ${componentCls}-icon`]: { top: 0 },
				[`${componentCls}-icon-dot`]: {
					borderRadius: token$1.calc(token$1.fontSizeSM).div(4).equal(),
					"&::after": { display: "none" }
				}
			},
			"&-content": {
				width: "auto",
				marginTop: token$1.calc(token$1.marginXS).sub(token$1.lineWidth).equal()
			},
			"&-title": {
				color: inlineTitleColor,
				fontSize: token$1.fontSizeSM,
				lineHeight: token$1.lineHeightSM,
				fontWeight: "normal",
				marginBottom: token$1.calc(token$1.marginXXS).div(2).equal()
			},
			"&-description": { display: "none" },
			"&-tail": {
				marginInlineStart: 0,
				top: token$1.calc(inlineDotSize).div(2).add(containerPaddingTop).equal(),
				transform: `translateY(-50%)`,
				"&:after": {
					width: "100%",
					height: token$1.lineWidth,
					borderRadius: 0,
					marginInlineStart: 0,
					background: inlineTailColor
				}
			},
			[`&:first-child ${componentCls}-item-tail`]: {
				width: "50%",
				marginInlineStart: "50%"
			},
			[`&:last-child ${componentCls}-item-tail`]: {
				display: "block",
				width: "50%"
			},
			"&-wait": Object.assign({ [`${componentCls}-item-icon ${componentCls}-icon ${componentCls}-icon-dot`]: {
				backgroundColor: token$1.colorBorderBg,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${inlineTailColor}`
			} }, titleStyle),
			"&-finish": Object.assign({
				[`${componentCls}-item-tail::after`]: { backgroundColor: inlineTailColor },
				[`${componentCls}-item-icon ${componentCls}-icon ${componentCls}-icon-dot`]: {
					backgroundColor: inlineTailColor,
					border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${inlineTailColor}`
				}
			}, titleStyle),
			"&-error": titleStyle,
			"&-active, &-process": Object.assign({ [`${componentCls}-item-icon`]: {
				width: inlineDotSize,
				height: inlineDotSize,
				marginInlineStart: `calc(50% - ${unit(token$1.calc(inlineDotSize).div(2).equal())})`,
				top: 0
			} }, titleStyle),
			[`&:not(${componentCls}-item-active) > ${componentCls}-item-container[role='button']:hover`]: { [`${componentCls}-item-title`]: { color: inlineTitleColor } }
		}
	} };
};
var inline_default = genStepsInlineStyle;

//#endregion
//#region node_modules/antd/es/steps/style/label-placement.js
var genStepsLabelPlacementStyle = (token$1) => {
	const { componentCls, iconSize, lineHeight, iconSizeSM } = token$1;
	return { [`&${componentCls}-label-vertical`]: {
		[`${componentCls}-item`]: {
			overflow: "visible",
			"&-tail": {
				marginInlineStart: token$1.calc(iconSize).div(2).add(token$1.controlHeightLG).equal(),
				padding: `0 ${unit(token$1.paddingLG)}`
			},
			"&-content": {
				display: "block",
				width: token$1.calc(iconSize).div(2).add(token$1.controlHeightLG).mul(2).equal(),
				marginTop: token$1.marginSM,
				textAlign: "center"
			},
			"&-icon": {
				display: "inline-block",
				marginInlineStart: token$1.controlHeightLG
			},
			"&-title": {
				paddingInlineEnd: 0,
				paddingInlineStart: 0,
				"&::after": { display: "none" }
			},
			"&-subtitle": {
				display: "block",
				marginBottom: token$1.marginXXS,
				marginInlineStart: 0,
				lineHeight
			}
		},
		[`&${componentCls}-small:not(${componentCls}-dot)`]: { [`${componentCls}-item`]: { "&-icon": { marginInlineStart: token$1.calc(iconSize).sub(iconSizeSM).div(2).add(token$1.controlHeightLG).equal() } } }
	} };
};
var label_placement_default = genStepsLabelPlacementStyle;

//#endregion
//#region node_modules/antd/es/steps/style/nav.js
var genStepsNavStyle = (token$1) => {
	const { componentCls, navContentMaxWidth, navArrowColor, stepsNavActiveColor, motionDurationSlow } = token$1;
	return {
		[`&${componentCls}-navigation`]: {
			paddingTop: token$1.paddingSM,
			[`&${componentCls}-small`]: { [`${componentCls}-item`]: { "&-container": { marginInlineStart: token$1.calc(token$1.marginSM).mul(-1).equal() } } },
			[`${componentCls}-item`]: {
				overflow: "visible",
				textAlign: "center",
				"&-container": {
					display: "inline-block",
					height: "100%",
					marginInlineStart: token$1.calc(token$1.margin).mul(-1).equal(),
					paddingBottom: token$1.paddingSM,
					textAlign: "start",
					transition: `opacity ${motionDurationSlow}`,
					[`${componentCls}-item-content`]: { maxWidth: navContentMaxWidth },
					[`${componentCls}-item-title`]: Object.assign(Object.assign({
						maxWidth: "100%",
						paddingInlineEnd: 0
					}, textEllipsis), { "&::after": { display: "none" } })
				},
				[`&:not(${componentCls}-item-active)`]: { [`${componentCls}-item-container[role='button']`]: {
					cursor: "pointer",
					"&:hover": { opacity: .85 }
				} },
				"&:last-child": {
					flex: 1,
					"&::after": { display: "none" }
				},
				"&::after": {
					position: "absolute",
					top: `calc(50% - ${unit(token$1.calc(token$1.paddingSM).div(2).equal())})`,
					insetInlineStart: "100%",
					display: "inline-block",
					width: token$1.fontSizeIcon,
					height: token$1.fontSizeIcon,
					borderTop: `${unit(token$1.lineWidth)} ${token$1.lineType} ${navArrowColor}`,
					borderBottom: "none",
					borderInlineStart: "none",
					borderInlineEnd: `${unit(token$1.lineWidth)} ${token$1.lineType} ${navArrowColor}`,
					transform: "translateY(-50%) translateX(-50%) rotate(45deg)",
					content: "\"\""
				},
				"&::before": {
					position: "absolute",
					bottom: 0,
					insetInlineStart: "50%",
					display: "inline-block",
					width: 0,
					height: token$1.lineWidthBold,
					backgroundColor: stepsNavActiveColor,
					transition: `width ${motionDurationSlow}, inset-inline-start ${motionDurationSlow}`,
					transitionTimingFunction: "ease-out",
					content: "\"\""
				}
			},
			[`${componentCls}-item${componentCls}-item-active::before`]: {
				insetInlineStart: 0,
				width: "100%"
			}
		},
		[`&${componentCls}-navigation${componentCls}-vertical`]: { [`> ${componentCls}-item`]: {
			marginInlineEnd: 0,
			"&::before": { display: "none" },
			[`&${componentCls}-item-active::before`]: {
				top: 0,
				insetInlineEnd: 0,
				insetInlineStart: "unset",
				display: "block",
				width: token$1.calc(token$1.lineWidth).mul(3).equal(),
				height: `calc(100% - ${unit(token$1.marginLG)})`
			},
			"&::after": {
				position: "relative",
				insetInlineStart: "50%",
				display: "block",
				width: token$1.calc(token$1.controlHeight).mul(.25).equal(),
				height: token$1.calc(token$1.controlHeight).mul(.25).equal(),
				marginBottom: token$1.marginXS,
				textAlign: "center",
				transform: "translateY(-50%) translateX(-50%) rotate(135deg)"
			},
			"&:last-child": { "&::after": { display: "none" } },
			[`> ${componentCls}-item-container > ${componentCls}-item-tail`]: { visibility: "hidden" }
		} },
		[`&${componentCls}-navigation${componentCls}-horizontal`]: { [`> ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: { visibility: "hidden" } }
	};
};
var nav_default = genStepsNavStyle;

//#endregion
//#region node_modules/antd/es/steps/style/progress.js
var genStepsProgressStyle = (token$1) => {
	const { antCls, componentCls, iconSize, iconSizeSM, processIconColor, marginXXS, lineWidthBold, lineWidth, paddingXXS } = token$1;
	const progressSize = token$1.calc(iconSize).add(token$1.calc(lineWidthBold).mul(4).equal()).equal();
	const progressSizeSM = token$1.calc(iconSizeSM).add(token$1.calc(token$1.lineWidth).mul(4).equal()).equal();
	return { [`&${componentCls}-with-progress`]: {
		[`${componentCls}-item`]: {
			paddingTop: paddingXXS,
			[`&-process ${componentCls}-item-container ${componentCls}-item-icon ${componentCls}-icon`]: { color: processIconColor }
		},
		[`&${componentCls}-vertical > ${componentCls}-item `]: {
			paddingInlineStart: paddingXXS,
			[`> ${componentCls}-item-container > ${componentCls}-item-tail`]: {
				top: marginXXS,
				insetInlineStart: token$1.calc(iconSize).div(2).sub(lineWidth).add(paddingXXS).equal()
			}
		},
		[`&, &${componentCls}-small`]: { [`&${componentCls}-horizontal ${componentCls}-item:first-child`]: {
			paddingBottom: paddingXXS,
			paddingInlineStart: paddingXXS
		} },
		[`&${componentCls}-small${componentCls}-vertical > ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: { insetInlineStart: token$1.calc(iconSizeSM).div(2).sub(lineWidth).add(paddingXXS).equal() },
		[`&${componentCls}-label-vertical ${componentCls}-item ${componentCls}-item-tail`]: { top: token$1.calc(iconSize).div(2).add(paddingXXS).equal() },
		[`${componentCls}-item-icon`]: {
			position: "relative",
			[`${antCls}-progress`]: {
				position: "absolute",
				insetInlineStart: "50%",
				top: "50%",
				transform: "translate(-50%, -50%)",
				"&-inner": {
					width: `${unit(progressSize)} !important`,
					height: `${unit(progressSize)} !important`
				}
			}
		},
		[`&${componentCls}-small`]: {
			[`&${componentCls}-label-vertical ${componentCls}-item ${componentCls}-item-tail`]: { top: token$1.calc(iconSizeSM).div(2).add(paddingXXS).equal() },
			[`${componentCls}-item-icon ${antCls}-progress-inner`]: {
				width: `${unit(progressSizeSM)} !important`,
				height: `${unit(progressSizeSM)} !important`
			}
		}
	} };
};
var progress_default$1 = genStepsProgressStyle;

//#endregion
//#region node_modules/antd/es/steps/style/progress-dot.js
var genStepsProgressDotStyle = (token$1) => {
	const { componentCls, descriptionMaxWidth, lineHeight, dotCurrentSize, dotSize, motionDurationSlow } = token$1;
	return {
		[`&${componentCls}-dot, &${componentCls}-dot${componentCls}-small`]: { [`${componentCls}-item`]: {
			"&-title": { lineHeight },
			"&-tail": {
				top: token$1.calc(token$1.dotSize).sub(token$1.calc(token$1.lineWidth).mul(3).equal()).div(2).equal(),
				width: "100%",
				marginTop: 0,
				marginBottom: 0,
				marginInline: `${unit(token$1.calc(descriptionMaxWidth).div(2).equal())} 0`,
				padding: 0,
				"&::after": {
					width: `calc(100% - ${unit(token$1.calc(token$1.marginSM).mul(2).equal())})`,
					height: token$1.calc(token$1.lineWidth).mul(3).equal(),
					marginInlineStart: token$1.marginSM
				}
			},
			"&-icon": {
				width: dotSize,
				height: dotSize,
				marginInlineStart: token$1.calc(token$1.descriptionMaxWidth).sub(dotSize).div(2).equal(),
				paddingInlineEnd: 0,
				lineHeight: unit(dotSize),
				background: "transparent",
				border: 0,
				[`${componentCls}-icon-dot`]: {
					position: "relative",
					float: "left",
					width: "100%",
					height: "100%",
					borderRadius: 100,
					transition: `all ${motionDurationSlow}`,
					"&::after": {
						position: "absolute",
						top: token$1.calc(token$1.marginSM).mul(-1).equal(),
						insetInlineStart: token$1.calc(dotSize).sub(token$1.calc(token$1.controlHeightLG).mul(1.5).equal()).div(2).equal(),
						width: token$1.calc(token$1.controlHeightLG).mul(1.5).equal(),
						height: token$1.controlHeight,
						background: "transparent",
						content: "\"\""
					}
				}
			},
			"&-content": { width: descriptionMaxWidth },
			[`&-process ${componentCls}-item-icon`]: {
				position: "relative",
				top: token$1.calc(dotSize).sub(dotCurrentSize).div(2).equal(),
				width: dotCurrentSize,
				height: dotCurrentSize,
				lineHeight: unit(dotCurrentSize),
				background: "none",
				marginInlineStart: token$1.calc(token$1.descriptionMaxWidth).sub(dotCurrentSize).div(2).equal()
			},
			[`&-process ${componentCls}-icon`]: { [`&:first-child ${componentCls}-icon-dot`]: { insetInlineStart: 0 } }
		} },
		[`&${componentCls}-vertical${componentCls}-dot`]: {
			[`${componentCls}-item-icon`]: {
				marginTop: token$1.calc(token$1.controlHeight).sub(dotSize).div(2).equal(),
				marginInlineStart: 0,
				background: "none"
			},
			[`${componentCls}-item-process ${componentCls}-item-icon`]: {
				marginTop: token$1.calc(token$1.controlHeight).sub(dotCurrentSize).div(2).equal(),
				top: 0,
				insetInlineStart: token$1.calc(dotSize).sub(dotCurrentSize).div(2).equal(),
				marginInlineStart: 0
			},
			[`${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
				top: token$1.calc(token$1.controlHeight).sub(dotSize).div(2).equal(),
				insetInlineStart: 0,
				margin: 0,
				padding: `${unit(token$1.calc(dotSize).add(token$1.paddingXS).equal())} 0 ${unit(token$1.paddingXS)}`,
				"&::after": { marginInlineStart: token$1.calc(dotSize).sub(token$1.lineWidth).div(2).equal() }
			},
			[`&${componentCls}-small`]: {
				[`${componentCls}-item-icon`]: { marginTop: token$1.calc(token$1.controlHeightSM).sub(dotSize).div(2).equal() },
				[`${componentCls}-item-process ${componentCls}-item-icon`]: { marginTop: token$1.calc(token$1.controlHeightSM).sub(dotCurrentSize).div(2).equal() },
				[`${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: { top: token$1.calc(token$1.controlHeightSM).sub(dotSize).div(2).equal() }
			},
			[`${componentCls}-item:first-child ${componentCls}-icon-dot`]: { insetInlineStart: 0 },
			[`${componentCls}-item-content`]: { width: "inherit" }
		}
	};
};
var progress_dot_default = genStepsProgressDotStyle;

//#endregion
//#region node_modules/antd/es/steps/style/rtl.js
var genStepsRTLStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`&${componentCls}-rtl`]: {
		direction: "rtl",
		[`${componentCls}-item`]: { "&-subtitle": { float: "left" } },
		[`&${componentCls}-navigation`]: { [`${componentCls}-item::after`]: { transform: "rotate(-45deg)" } },
		[`&${componentCls}-vertical`]: { [`> ${componentCls}-item`]: {
			"&::after": { transform: "rotate(225deg)" },
			[`${componentCls}-item-icon`]: { float: "right" }
		} },
		[`&${componentCls}-dot`]: { [`${componentCls}-item-icon ${componentCls}-icon-dot, &${componentCls}-small ${componentCls}-item-icon ${componentCls}-icon-dot`]: { float: "right" } }
	} };
};
var rtl_default$2 = genStepsRTLStyle;

//#endregion
//#region node_modules/antd/es/steps/style/small.js
var genStepsSmallStyle = (token$1) => {
	const { componentCls, iconSizeSM, fontSizeSM, fontSize, colorTextDescription } = token$1;
	return { [`&${componentCls}-small`]: {
		[`&${componentCls}-horizontal:not(${componentCls}-label-vertical) ${componentCls}-item`]: {
			paddingInlineStart: token$1.paddingSM,
			"&:first-child": { paddingInlineStart: 0 }
		},
		[`${componentCls}-item-icon`]: {
			width: iconSizeSM,
			height: iconSizeSM,
			marginTop: 0,
			marginBottom: 0,
			marginInline: `0 ${unit(token$1.marginXS)}`,
			fontSize: fontSizeSM,
			lineHeight: unit(iconSizeSM),
			textAlign: "center",
			borderRadius: iconSizeSM
		},
		[`${componentCls}-item-title`]: {
			paddingInlineEnd: token$1.paddingSM,
			fontSize,
			lineHeight: unit(iconSizeSM),
			"&::after": { top: token$1.calc(iconSizeSM).div(2).equal() }
		},
		[`${componentCls}-item-description`]: {
			color: colorTextDescription,
			fontSize
		},
		[`${componentCls}-item-tail`]: { top: token$1.calc(iconSizeSM).div(2).sub(token$1.paddingXXS).equal() },
		[`${componentCls}-item-custom ${componentCls}-item-icon`]: {
			width: "inherit",
			height: "inherit",
			lineHeight: "inherit",
			background: "none",
			border: 0,
			borderRadius: 0,
			[`> ${componentCls}-icon`]: {
				fontSize: iconSizeSM,
				lineHeight: unit(iconSizeSM),
				transform: "none"
			}
		}
	} };
};
var small_default = genStepsSmallStyle;

//#endregion
//#region node_modules/antd/es/steps/style/vertical.js
var genStepsVerticalStyle = (token$1) => {
	const { componentCls, iconSizeSM, iconSize } = token$1;
	return { [`&${componentCls}-vertical`]: {
		display: "flex",
		flexDirection: "column",
		[`> ${componentCls}-item`]: {
			display: "block",
			flex: "1 0 auto",
			paddingInlineStart: 0,
			overflow: "visible",
			[`${componentCls}-item-icon`]: {
				float: "left",
				marginInlineEnd: token$1.margin
			},
			[`${componentCls}-item-content`]: {
				display: "block",
				minHeight: token$1.calc(token$1.controlHeight).mul(1.5).equal(),
				overflow: "hidden"
			},
			[`${componentCls}-item-title`]: { lineHeight: unit(iconSize) },
			[`${componentCls}-item-description`]: { paddingBottom: token$1.paddingSM }
		},
		[`> ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
			position: "absolute",
			top: 0,
			insetInlineStart: token$1.calc(iconSize).div(2).sub(token$1.lineWidth).equal(),
			width: token$1.lineWidth,
			height: "100%",
			padding: `${unit(token$1.calc(token$1.marginXXS).mul(1.5).add(iconSize).equal())} 0 ${unit(token$1.calc(token$1.marginXXS).mul(1.5).equal())}`,
			"&::after": {
				width: token$1.lineWidth,
				height: "100%"
			}
		},
		[`> ${componentCls}-item:not(:last-child) > ${componentCls}-item-container > ${componentCls}-item-tail`]: { display: "block" },
		[` > ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-content > ${componentCls}-item-title`]: { "&::after": { display: "none" } },
		[`&${componentCls}-small ${componentCls}-item-container`]: {
			[`${componentCls}-item-tail`]: {
				position: "absolute",
				top: 0,
				insetInlineStart: token$1.calc(iconSizeSM).div(2).sub(token$1.lineWidth).equal(),
				padding: `${unit(token$1.calc(token$1.marginXXS).mul(1.5).add(iconSizeSM).equal())} 0 ${unit(token$1.calc(token$1.marginXXS).mul(1.5).equal())}`
			},
			[`${componentCls}-item-title`]: { lineHeight: unit(iconSizeSM) }
		}
	} };
};
var vertical_default = genStepsVerticalStyle;

//#endregion
//#region node_modules/antd/es/steps/style/index.js
var STEP_ITEM_STATUS_WAIT = "wait";
var STEP_ITEM_STATUS_PROCESS = "process";
var STEP_ITEM_STATUS_FINISH = "finish";
var STEP_ITEM_STATUS_ERROR = "error";
var genStepsItemStatusStyle = (status, token$1) => {
	const prefix = `${token$1.componentCls}-item`;
	const iconColorKey = `${status}IconColor`;
	const titleColorKey = `${status}TitleColor`;
	const descriptionColorKey = `${status}DescriptionColor`;
	const tailColorKey = `${status}TailColor`;
	const iconBgColorKey = `${status}IconBgColor`;
	const iconBorderColorKey = `${status}IconBorderColor`;
	const dotColorKey = `${status}DotColor`;
	return {
		[`${prefix}-${status} ${prefix}-icon`]: {
			backgroundColor: token$1[iconBgColorKey],
			borderColor: token$1[iconBorderColorKey],
			[`> ${token$1.componentCls}-icon`]: {
				color: token$1[iconColorKey],
				[`${token$1.componentCls}-icon-dot`]: { background: token$1[dotColorKey] }
			}
		},
		[`${prefix}-${status}${prefix}-custom ${prefix}-icon`]: { [`> ${token$1.componentCls}-icon`]: { color: token$1[dotColorKey] } },
		[`${prefix}-${status} > ${prefix}-container > ${prefix}-content > ${prefix}-title`]: {
			color: token$1[titleColorKey],
			"&::after": { backgroundColor: token$1[tailColorKey] }
		},
		[`${prefix}-${status} > ${prefix}-container > ${prefix}-content > ${prefix}-description`]: { color: token$1[descriptionColorKey] },
		[`${prefix}-${status} > ${prefix}-container > ${prefix}-tail::after`]: { backgroundColor: token$1[tailColorKey] }
	};
};
var genStepsItemStyle = (token$1) => {
	const { componentCls, motionDurationSlow } = token$1;
	const stepsItemCls = `${componentCls}-item`;
	const stepItemIconCls = `${stepsItemCls}-icon`;
	return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
		[stepsItemCls]: {
			position: "relative",
			display: "inline-block",
			flex: 1,
			overflow: "hidden",
			verticalAlign: "top",
			"&:last-child": {
				flex: "none",
				[`> ${stepsItemCls}-container > ${stepsItemCls}-tail, > ${stepsItemCls}-container >  ${stepsItemCls}-content > ${stepsItemCls}-title::after`]: { display: "none" }
			}
		},
		[`${stepsItemCls}-container`]: {
			outline: "none",
			[`&:focus-visible ${stepItemIconCls}`]: genFocusOutline(token$1)
		},
		[`${stepItemIconCls}, ${stepsItemCls}-content`]: {
			display: "inline-block",
			verticalAlign: "top"
		},
		[stepItemIconCls]: {
			width: token$1.iconSize,
			height: token$1.iconSize,
			marginTop: 0,
			marginBottom: 0,
			marginInlineStart: 0,
			marginInlineEnd: token$1.marginXS,
			fontSize: token$1.iconFontSize,
			fontFamily: token$1.fontFamily,
			lineHeight: unit(token$1.iconSize),
			textAlign: "center",
			borderRadius: token$1.iconSize,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} transparent`,
			transition: `background-color ${motionDurationSlow}, border-color ${motionDurationSlow}`,
			[`${componentCls}-icon`]: {
				position: "relative",
				top: token$1.iconTop,
				color: token$1.colorPrimary,
				lineHeight: 1
			}
		},
		[`${stepsItemCls}-tail`]: {
			position: "absolute",
			top: token$1.calc(token$1.iconSize).div(2).equal(),
			insetInlineStart: 0,
			width: "100%",
			"&::after": {
				display: "inline-block",
				width: "100%",
				height: token$1.lineWidth,
				background: token$1.colorSplit,
				borderRadius: token$1.lineWidth,
				transition: `background ${motionDurationSlow}`,
				content: "\"\""
			}
		},
		[`${stepsItemCls}-title`]: {
			position: "relative",
			display: "inline-block",
			paddingInlineEnd: token$1.padding,
			color: token$1.colorText,
			fontSize: token$1.fontSizeLG,
			lineHeight: unit(token$1.titleLineHeight),
			"&::after": {
				position: "absolute",
				top: token$1.calc(token$1.titleLineHeight).div(2).equal(),
				insetInlineStart: "100%",
				display: "block",
				width: 9999,
				height: token$1.lineWidth,
				background: token$1.processTailColor,
				content: "\"\""
			}
		},
		[`${stepsItemCls}-subtitle`]: {
			display: "inline",
			marginInlineStart: token$1.marginXS,
			color: token$1.colorTextDescription,
			fontWeight: "normal",
			fontSize: token$1.fontSize
		},
		[`${stepsItemCls}-description`]: {
			color: token$1.colorTextDescription,
			fontSize: token$1.fontSize
		}
	}, genStepsItemStatusStyle(STEP_ITEM_STATUS_WAIT, token$1)), genStepsItemStatusStyle(STEP_ITEM_STATUS_PROCESS, token$1)), { [`${stepsItemCls}-process > ${stepsItemCls}-container > ${stepsItemCls}-title`]: { fontWeight: token$1.fontWeightStrong } }), genStepsItemStatusStyle(STEP_ITEM_STATUS_FINISH, token$1)), genStepsItemStatusStyle(STEP_ITEM_STATUS_ERROR, token$1)), {
		[`${stepsItemCls}${componentCls}-next-error > ${componentCls}-item-title::after`]: { background: token$1.colorError },
		[`${stepsItemCls}-disabled`]: { cursor: "not-allowed" }
	});
};
var genStepsClickableStyle = (token$1) => {
	const { componentCls, motionDurationSlow } = token$1;
	return {
		[`& ${componentCls}-item`]: { [`&:not(${componentCls}-item-active)`]: {
			[`& > ${componentCls}-item-container[role='button']`]: {
				cursor: "pointer",
				[`${componentCls}-item`]: { [`&-title, &-subtitle, &-description, &-icon ${componentCls}-icon`]: { transition: `color ${motionDurationSlow}` } },
				"&:hover": { [`${componentCls}-item`]: { "&-title, &-subtitle, &-description": { color: token$1.colorPrimary } } }
			},
			[`&:not(${componentCls}-item-process)`]: { [`& > ${componentCls}-item-container[role='button']:hover`]: { [`${componentCls}-item`]: { "&-icon": {
				borderColor: token$1.colorPrimary,
				[`${componentCls}-icon`]: { color: token$1.colorPrimary }
			} } } }
		} },
		[`&${componentCls}-horizontal:not(${componentCls}-label-vertical)`]: { [`${componentCls}-item`]: {
			paddingInlineStart: token$1.padding,
			whiteSpace: "nowrap",
			"&:first-child": { paddingInlineStart: 0 },
			[`&:last-child ${componentCls}-item-title`]: { paddingInlineEnd: 0 },
			"&-tail": { display: "none" },
			"&-description": {
				maxWidth: token$1.descriptionMaxWidth,
				whiteSpace: "normal"
			}
		} }
	};
};
var genStepsStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
		display: "flex",
		width: "100%",
		fontSize: 0,
		textAlign: "initial"
	}), genStepsItemStyle(token$1)), genStepsClickableStyle(token$1)), custom_icon_default(token$1)), small_default(token$1)), vertical_default(token$1)), horizontal_default(token$1)), label_placement_default(token$1)), progress_dot_default(token$1)), nav_default(token$1)), rtl_default$2(token$1)), progress_default$1(token$1)), inline_default(token$1)) };
};
const prepareComponentToken$10 = (token$1) => ({
	titleLineHeight: token$1.controlHeight,
	customIconSize: token$1.controlHeight,
	customIconTop: 0,
	customIconFontSize: token$1.controlHeightSM,
	iconSize: token$1.controlHeight,
	iconTop: -.5,
	iconFontSize: token$1.fontSize,
	iconSizeSM: token$1.fontSizeHeading3,
	dotSize: token$1.controlHeight / 4,
	dotCurrentSize: token$1.controlHeightLG / 4,
	navArrowColor: token$1.colorTextDisabled,
	navContentMaxWidth: "unset",
	descriptionMaxWidth: 140,
	waitIconColor: token$1.wireframe ? token$1.colorTextDisabled : token$1.colorTextLabel,
	waitIconBgColor: token$1.wireframe ? token$1.colorBgContainer : token$1.colorFillContent,
	waitIconBorderColor: token$1.wireframe ? token$1.colorTextDisabled : "transparent",
	finishIconBgColor: token$1.wireframe ? token$1.colorBgContainer : token$1.controlItemBgActive,
	finishIconBorderColor: token$1.wireframe ? token$1.colorPrimary : token$1.controlItemBgActive
});
var style_default$11 = genStyleHooks("Steps", (token$1) => {
	const { colorTextDisabled, controlHeightLG, colorTextLightSolid, colorText, colorPrimary, colorTextDescription, colorTextQuaternary, colorError, colorBorderSecondary, colorSplit } = token$1;
	const stepsToken = merge(token$1, {
		processIconColor: colorTextLightSolid,
		processTitleColor: colorText,
		processDescriptionColor: colorText,
		processIconBgColor: colorPrimary,
		processIconBorderColor: colorPrimary,
		processDotColor: colorPrimary,
		processTailColor: colorSplit,
		waitTitleColor: colorTextDescription,
		waitDescriptionColor: colorTextDescription,
		waitTailColor: colorSplit,
		waitDotColor: colorTextDisabled,
		finishIconColor: colorPrimary,
		finishTitleColor: colorText,
		finishDescriptionColor: colorTextDescription,
		finishTailColor: colorPrimary,
		finishDotColor: colorPrimary,
		errorIconColor: colorTextLightSolid,
		errorTitleColor: colorError,
		errorDescriptionColor: colorError,
		errorTailColor: colorSplit,
		errorIconBgColor: colorError,
		errorIconBorderColor: colorError,
		errorDotColor: colorError,
		stepsNavActiveColor: colorPrimary,
		stepsProgressSize: controlHeightLG,
		inlineDotSize: 6,
		inlineTitleColor: colorTextQuaternary,
		inlineTailColor: colorBorderSecondary
	});
	return genStepsStyle(stepsToken);
}, prepareComponentToken$10);

//#endregion
//#region node_modules/antd/es/steps/useLegacyItems.js
function filter(items) {
	return items.filter((item) => item);
}
function useLegacyItems(items, children) {
	if (items) return items;
	const childrenItems = toArray(children).map((node$1) => {
		if (/* @__PURE__ */ import_react.isValidElement(node$1)) {
			const { props } = node$1;
			return Object.assign({}, props);
		}
		return null;
	});
	return filter(childrenItems);
}
var useLegacyItems_default = useLegacyItems;

//#endregion
//#region node_modules/antd/es/steps/index.js
var import_classnames$52 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$19 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Steps = (props) => {
	const { percent, size: customizeSize, className, rootClassName, direction, items, responsive = true, current = 0, children, style: style$1 } = props, restProps = __rest$19(props, [
		"percent",
		"size",
		"className",
		"rootClassName",
		"direction",
		"items",
		"responsive",
		"current",
		"children",
		"style"
	]);
	const { xs } = useBreakpoint_default(responsive);
	const { getPrefixCls, direction: rtlDirection, className: contextClassName, style: contextStyle } = useComponentConfig("steps");
	const realDirectionValue = import_react.useMemo(() => responsive && xs ? "vertical" : direction, [xs, direction]);
	const size = useSize_default(customizeSize);
	const prefixCls = getPrefixCls("steps", props.prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$11(prefixCls);
	const isInline = props.type === "inline";
	const iconPrefix = getPrefixCls("", props.iconPrefix);
	const mergedItems = useLegacyItems_default(items, children);
	const mergedPercent = isInline ? void 0 : percent;
	const mergedStyle = Object.assign(Object.assign({}, contextStyle), style$1);
	const stepsClassName = (0, import_classnames$52.default)(contextClassName, {
		[`${prefixCls}-rtl`]: rtlDirection === "rtl",
		[`${prefixCls}-with-progress`]: mergedPercent !== void 0
	}, className, rootClassName, hashId, cssVarCls);
	const icons$1 = {
		finish: /* @__PURE__ */ import_react.createElement(CheckOutlined_default, { className: `${prefixCls}-finish-icon` }),
		error: /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-error-icon` })
	};
	const stepIconRender = ({ node: node$1, status }) => {
		if (status === "process" && mergedPercent !== void 0) {
			const progressWidth = size === "small" ? 32 : 40;
			return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-progress-icon` }, /* @__PURE__ */ import_react.createElement(progress_default, {
				type: "circle",
				percent: mergedPercent,
				size: progressWidth,
				strokeWidth: 4,
				format: () => null
			}), node$1);
		}
		return node$1;
	};
	const itemRender = (item, stepItem) => item.description ? /* @__PURE__ */ import_react.createElement(tooltip_default, { title: item.description }, stepItem) : stepItem;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$10, Object.assign({ icons: icons$1 }, restProps, {
		style: mergedStyle,
		current,
		size,
		items: mergedItems,
		itemRender: isInline ? itemRender : void 0,
		stepIcon: stepIconRender,
		direction: realDirectionValue,
		prefixCls,
		iconPrefix,
		className: stepsClassName
	})));
};
Steps.Step = es_default$10.Step;
Steps.displayName = "Steps";
var steps_default = Steps;

//#endregion
//#region node_modules/rc-switch/es/index.js
var import_classnames$51 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$13 = [
	"prefixCls",
	"className",
	"checked",
	"defaultChecked",
	"disabled",
	"loadingIcon",
	"checkedChildren",
	"unCheckedChildren",
	"onClick",
	"onChange",
	"onKeyDown"
];
var Switch$1 = /* @__PURE__ */ import_react.forwardRef(function(_ref, ref) {
	var _classNames;
	var _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-switch" : _ref$prefixCls, className = _ref.className, checked = _ref.checked, defaultChecked = _ref.defaultChecked, disabled = _ref.disabled, loadingIcon = _ref.loadingIcon, checkedChildren = _ref.checkedChildren, unCheckedChildren = _ref.unCheckedChildren, onClick = _ref.onClick, onChange = _ref.onChange, onKeyDown$1 = _ref.onKeyDown, restProps = _objectWithoutProperties(_ref, _excluded$13);
	var _useMergedState = useMergedState(false, {
		value: checked,
		defaultValue: defaultChecked
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerChecked = _useMergedState2[0], setInnerChecked = _useMergedState2[1];
	function triggerChange(newChecked, event) {
		var mergedChecked = innerChecked;
		if (!disabled) {
			mergedChecked = newChecked;
			setInnerChecked(mergedChecked);
			onChange === null || onChange === void 0 || onChange(mergedChecked, event);
		}
		return mergedChecked;
	}
	function onInternalKeyDown(e$2) {
		if (e$2.which === KeyCode_default.LEFT) triggerChange(false, e$2);
		else if (e$2.which === KeyCode_default.RIGHT) triggerChange(true, e$2);
		onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(e$2);
	}
	function onInternalClick(e$2) {
		var ret = triggerChange(!innerChecked, e$2);
		onClick === null || onClick === void 0 || onClick(ret, e$2);
	}
	var switchClassName = (0, import_classnames$51.default)(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-checked"), innerChecked), _defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
	return /* @__PURE__ */ import_react.createElement("button", _extends({}, restProps, {
		type: "button",
		role: "switch",
		"aria-checked": innerChecked,
		disabled,
		className: switchClassName,
		ref,
		onKeyDown: onInternalKeyDown,
		onClick: onInternalClick
	}), loadingIcon, /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-inner") }, /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-inner-checked") }, checkedChildren), /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-inner-unchecked") }, unCheckedChildren)));
});
Switch$1.displayName = "Switch";
var es_default$9 = Switch$1;

//#endregion
//#region node_modules/antd/es/switch/style/index.js
var genSwitchSmallStyle = (token$1) => {
	const { componentCls, trackHeightSM, trackPadding, trackMinWidthSM, innerMinMarginSM, innerMaxMarginSM, handleSizeSM, calc } = token$1;
	const switchInnerCls = `${componentCls}-inner`;
	const trackPaddingCalc = unit(calc(handleSizeSM).add(calc(trackPadding).mul(2)).equal());
	const innerMaxMarginCalc = unit(calc(innerMaxMarginSM).mul(2).equal());
	return { [componentCls]: { [`&${componentCls}-small`]: {
		minWidth: trackMinWidthSM,
		height: trackHeightSM,
		lineHeight: unit(trackHeightSM),
		[`${componentCls}-inner`]: {
			paddingInlineStart: innerMaxMarginSM,
			paddingInlineEnd: innerMinMarginSM,
			[`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: { minHeight: trackHeightSM },
			[`${switchInnerCls}-checked`]: {
				marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
				marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
			},
			[`${switchInnerCls}-unchecked`]: {
				marginTop: calc(trackHeightSM).mul(-1).equal(),
				marginInlineStart: 0,
				marginInlineEnd: 0
			}
		},
		[`${componentCls}-handle`]: {
			width: handleSizeSM,
			height: handleSizeSM
		},
		[`${componentCls}-loading-icon`]: {
			top: calc(calc(handleSizeSM).sub(token$1.switchLoadingIconSize)).div(2).equal(),
			fontSize: token$1.switchLoadingIconSize
		},
		[`&${componentCls}-checked`]: {
			[`${componentCls}-inner`]: {
				paddingInlineStart: innerMinMarginSM,
				paddingInlineEnd: innerMaxMarginSM,
				[`${switchInnerCls}-checked`]: {
					marginInlineStart: 0,
					marginInlineEnd: 0
				},
				[`${switchInnerCls}-unchecked`]: {
					marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
					marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
				}
			},
			[`${componentCls}-handle`]: { insetInlineStart: `calc(100% - ${unit(calc(handleSizeSM).add(trackPadding).equal())})` }
		},
		[`&:not(${componentCls}-disabled):active`]: {
			[`&:not(${componentCls}-checked) ${switchInnerCls}`]: { [`${switchInnerCls}-unchecked`]: {
				marginInlineStart: calc(token$1.marginXXS).div(2).equal(),
				marginInlineEnd: calc(token$1.marginXXS).mul(-1).div(2).equal()
			} },
			[`&${componentCls}-checked ${switchInnerCls}`]: { [`${switchInnerCls}-checked`]: {
				marginInlineStart: calc(token$1.marginXXS).mul(-1).div(2).equal(),
				marginInlineEnd: calc(token$1.marginXXS).div(2).equal()
			} }
		}
	} } };
};
var genSwitchLoadingStyle = (token$1) => {
	const { componentCls, handleSize, calc } = token$1;
	return { [componentCls]: {
		[`${componentCls}-loading-icon${token$1.iconCls}`]: {
			position: "relative",
			top: calc(calc(handleSize).sub(token$1.fontSize)).div(2).equal(),
			color: token$1.switchLoadingIconColor,
			verticalAlign: "top"
		},
		[`&${componentCls}-checked ${componentCls}-loading-icon`]: { color: token$1.switchColor }
	} };
};
var genSwitchHandleStyle = (token$1) => {
	const { componentCls, trackPadding, handleBg, handleShadow, handleSize, calc } = token$1;
	const switchHandleCls = `${componentCls}-handle`;
	return { [componentCls]: {
		[switchHandleCls]: {
			position: "absolute",
			top: trackPadding,
			insetInlineStart: trackPadding,
			width: handleSize,
			height: handleSize,
			transition: `all ${token$1.switchDuration} ease-in-out`,
			"&::before": {
				position: "absolute",
				top: 0,
				insetInlineEnd: 0,
				bottom: 0,
				insetInlineStart: 0,
				backgroundColor: handleBg,
				borderRadius: calc(handleSize).div(2).equal(),
				boxShadow: handleShadow,
				transition: `all ${token$1.switchDuration} ease-in-out`,
				content: "\"\""
			}
		},
		[`&${componentCls}-checked ${switchHandleCls}`]: { insetInlineStart: `calc(100% - ${unit(calc(handleSize).add(trackPadding).equal())})` },
		[`&:not(${componentCls}-disabled):active`]: {
			[`${switchHandleCls}::before`]: {
				insetInlineEnd: token$1.switchHandleActiveInset,
				insetInlineStart: 0
			},
			[`&${componentCls}-checked ${switchHandleCls}::before`]: {
				insetInlineEnd: 0,
				insetInlineStart: token$1.switchHandleActiveInset
			}
		}
	} };
};
var genSwitchInnerStyle = (token$1) => {
	const { componentCls, trackHeight, trackPadding, innerMinMargin, innerMaxMargin, handleSize, calc } = token$1;
	const switchInnerCls = `${componentCls}-inner`;
	const trackPaddingCalc = unit(calc(handleSize).add(calc(trackPadding).mul(2)).equal());
	const innerMaxMarginCalc = unit(calc(innerMaxMargin).mul(2).equal());
	return { [componentCls]: {
		[switchInnerCls]: {
			display: "block",
			overflow: "hidden",
			borderRadius: 100,
			height: "100%",
			paddingInlineStart: innerMaxMargin,
			paddingInlineEnd: innerMinMargin,
			transition: `padding-inline-start ${token$1.switchDuration} ease-in-out, padding-inline-end ${token$1.switchDuration} ease-in-out`,
			[`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
				display: "block",
				color: token$1.colorTextLightSolid,
				fontSize: token$1.fontSizeSM,
				transition: `margin-inline-start ${token$1.switchDuration} ease-in-out, margin-inline-end ${token$1.switchDuration} ease-in-out`,
				pointerEvents: "none",
				minHeight: trackHeight
			},
			[`${switchInnerCls}-checked`]: {
				marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
				marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
			},
			[`${switchInnerCls}-unchecked`]: {
				marginTop: calc(trackHeight).mul(-1).equal(),
				marginInlineStart: 0,
				marginInlineEnd: 0
			}
		},
		[`&${componentCls}-checked ${switchInnerCls}`]: {
			paddingInlineStart: innerMinMargin,
			paddingInlineEnd: innerMaxMargin,
			[`${switchInnerCls}-checked`]: {
				marginInlineStart: 0,
				marginInlineEnd: 0
			},
			[`${switchInnerCls}-unchecked`]: {
				marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
				marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
			}
		},
		[`&:not(${componentCls}-disabled):active`]: {
			[`&:not(${componentCls}-checked) ${switchInnerCls}`]: { [`${switchInnerCls}-unchecked`]: {
				marginInlineStart: calc(trackPadding).mul(2).equal(),
				marginInlineEnd: calc(trackPadding).mul(-1).mul(2).equal()
			} },
			[`&${componentCls}-checked ${switchInnerCls}`]: { [`${switchInnerCls}-checked`]: {
				marginInlineStart: calc(trackPadding).mul(-1).mul(2).equal(),
				marginInlineEnd: calc(trackPadding).mul(2).equal()
			} }
		}
	} };
};
var genSwitchStyle = (token$1) => {
	const { componentCls, trackHeight, trackMinWidth } = token$1;
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "relative",
		display: "inline-block",
		boxSizing: "border-box",
		minWidth: trackMinWidth,
		height: trackHeight,
		lineHeight: unit(trackHeight),
		verticalAlign: "middle",
		background: token$1.colorTextQuaternary,
		border: "0",
		borderRadius: 100,
		cursor: "pointer",
		transition: `all ${token$1.motionDurationMid}`,
		userSelect: "none",
		[`&:hover:not(${componentCls}-disabled)`]: { background: token$1.colorTextTertiary }
	}), genFocusStyle(token$1)), {
		[`&${componentCls}-checked`]: {
			background: token$1.switchColor,
			[`&:hover:not(${componentCls}-disabled)`]: { background: token$1.colorPrimaryHover }
		},
		[`&${componentCls}-loading, &${componentCls}-disabled`]: {
			cursor: "not-allowed",
			opacity: token$1.switchDisabledOpacity,
			"*": {
				boxShadow: "none",
				cursor: "not-allowed"
			}
		},
		[`&${componentCls}-rtl`]: { direction: "rtl" }
	}) };
};
const prepareComponentToken$9 = (token$1) => {
	const { fontSize, lineHeight, controlHeight, colorWhite } = token$1;
	const height = fontSize * lineHeight;
	const heightSM = controlHeight / 2;
	const padding = 2;
	const handleSize = height - padding * 2;
	const handleSizeSM = heightSM - padding * 2;
	return {
		trackHeight: height,
		trackHeightSM: heightSM,
		trackMinWidth: handleSize * 2 + padding * 4,
		trackMinWidthSM: handleSizeSM * 2 + padding * 2,
		trackPadding: padding,
		handleBg: colorWhite,
		handleSize,
		handleSizeSM,
		handleShadow: `0 2px 4px 0 ${new FastColor("#00230b").setA(.2).toRgbString()}`,
		innerMinMargin: handleSize / 2,
		innerMaxMargin: handleSize + padding + padding * 2,
		innerMinMarginSM: handleSizeSM / 2,
		innerMaxMarginSM: handleSizeSM + padding + padding * 2
	};
};
var style_default$10 = genStyleHooks("Switch", (token$1) => {
	const switchToken = merge(token$1, {
		switchDuration: token$1.motionDurationMid,
		switchColor: token$1.colorPrimary,
		switchDisabledOpacity: token$1.opacityLoading,
		switchLoadingIconSize: token$1.calc(token$1.fontSizeIcon).mul(.75).equal(),
		switchLoadingIconColor: `rgba(0, 0, 0, ${token$1.opacityLoading})`,
		switchHandleActiveInset: "-30%"
	});
	return [
		genSwitchStyle(switchToken),
		genSwitchInnerStyle(switchToken),
		genSwitchHandleStyle(switchToken),
		genSwitchLoadingStyle(switchToken),
		genSwitchSmallStyle(switchToken)
	];
}, prepareComponentToken$9);

//#endregion
//#region node_modules/antd/es/switch/index.js
var import_classnames$50 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$18 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Switch = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, size: customizeSize, disabled: customDisabled, loading, className, rootClassName, style: style$1, checked: checkedProp, value, defaultChecked: defaultCheckedProp, defaultValue, onChange } = props, restProps = __rest$18(props, [
		"prefixCls",
		"size",
		"disabled",
		"loading",
		"className",
		"rootClassName",
		"style",
		"checked",
		"value",
		"defaultChecked",
		"defaultValue",
		"onChange"
	]);
	const [checked, setChecked] = useMergedState(false, {
		value: checkedProp !== null && checkedProp !== void 0 ? checkedProp : value,
		defaultValue: defaultCheckedProp !== null && defaultCheckedProp !== void 0 ? defaultCheckedProp : defaultValue
	});
	const { getPrefixCls, direction, switch: SWITCH } = import_react.useContext(ConfigContext);
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = (customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled) || loading;
	const prefixCls = getPrefixCls("switch", customizePrefixCls);
	const loadingIcon = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-handle` }, loading && /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { className: `${prefixCls}-loading-icon` }));
	const [wrapCSSVar, hashId, cssVarCls] = style_default$10(prefixCls);
	const mergedSize = useSize_default(customizeSize);
	const classes = (0, import_classnames$50.default)(SWITCH === null || SWITCH === void 0 ? void 0 : SWITCH.className, {
		[`${prefixCls}-small`]: mergedSize === "small",
		[`${prefixCls}-loading`]: loading,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, rootClassName, hashId, cssVarCls);
	const mergedStyle = Object.assign(Object.assign({}, SWITCH === null || SWITCH === void 0 ? void 0 : SWITCH.style), style$1);
	const changeHandler = (...args) => {
		setChecked(args[0]);
		onChange === null || onChange === void 0 || onChange.apply(void 0, args);
	};
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(wave_default, {
		component: "Switch",
		disabled: mergedDisabled
	}, /* @__PURE__ */ import_react.createElement(es_default$9, Object.assign({}, restProps, {
		checked,
		onChange: changeHandler,
		prefixCls,
		className: classes,
		style: mergedStyle,
		disabled: mergedDisabled,
		ref,
		loadingIcon
	}))));
});
Switch.__ANT_SWITCH = true;
Switch.displayName = "Switch";
var switch_default = Switch;

//#endregion
//#region node_modules/rc-table/es/constant.js
var EXPAND_COLUMN = {};
var INTERNAL_HOOKS = "rc-table-internal-hook";

//#endregion
//#region node_modules/@rc-component/context/es/context.js
var import_react_dom$1 = /* @__PURE__ */ __toESM(require_react_dom());
function createContext(defaultValue) {
	var Context$2 = /* @__PURE__ */ import_react.createContext(void 0);
	return {
		Context: Context$2,
		Provider: function Provider(_ref) {
			var value = _ref.value, children = _ref.children;
			var valueRef = import_react.useRef(value);
			valueRef.current = value;
			var _React$useState = import_react.useState(function() {
				return {
					getValue: function getValue$2() {
						return valueRef.current;
					},
					listeners: /* @__PURE__ */ new Set()
				};
			}), _React$useState2 = _slicedToArray(_React$useState, 1), context = _React$useState2[0];
			useLayoutEffect_default(function() {
				(0, import_react_dom$1.unstable_batchedUpdates)(function() {
					context.listeners.forEach(function(listener) {
						listener(value);
					});
				});
			}, [value]);
			return /* @__PURE__ */ import_react.createElement(Context$2.Provider, { value: context }, children);
		},
		defaultValue
	};
}
/** e.g. useSelect(userContext) => user */
/** e.g. useSelect(userContext, user => user.name) => user.name */
/** e.g. useSelect(userContext, ['name', 'age']) => user { name, age } */
/** e.g. useSelect(userContext, 'name') => user.name */
function useContext$2(holder, selector) {
	var eventSelector = useEvent(typeof selector === "function" ? selector : function(ctx) {
		if (selector === void 0) return ctx;
		if (!Array.isArray(selector)) return ctx[selector];
		var obj = {};
		selector.forEach(function(key) {
			obj[key] = ctx[key];
		});
		return obj;
	});
	var context = import_react.useContext(holder === null || holder === void 0 ? void 0 : holder.Context);
	var _ref2 = context || {}, listeners = _ref2.listeners, getValue$2 = _ref2.getValue;
	var valueRef = import_react.useRef();
	valueRef.current = eventSelector(context ? getValue$2() : holder === null || holder === void 0 ? void 0 : holder.defaultValue);
	var _React$useState3 = import_react.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), forceUpdate = _React$useState4[1];
	useLayoutEffect_default(function() {
		if (!context) return;
		function trigger(nextValue) {
			var nextSelectorValue = eventSelector(nextValue);
			if (!isEqual_default(valueRef.current, nextSelectorValue, true)) forceUpdate({});
		}
		listeners.add(trigger);
		return function() {
			listeners.delete(trigger);
		};
	}, [context]);
	return valueRef.current;
}

//#endregion
//#region node_modules/@rc-component/context/es/Immutable.js
/**
* Create Immutable pair for `makeImmutable` and `responseImmutable`.
*/
function createImmutable() {
	var ImmutableContext = /* @__PURE__ */ import_react.createContext(null);
	/**
	* Get render update mark by `makeImmutable` root.
	* Do not deps on the return value as render times
	* but only use for `useMemo` or `useCallback` deps.
	*/
	function useImmutableMark$2() {
		return import_react.useContext(ImmutableContext);
	}
	/**
	* Wrapped Component will be marked as Immutable.
	* When Component parent trigger render,
	* it will notice children component (use with `responseImmutable`) node that parent has updated.
	* @param Component Passed Component
	* @param triggerRender Customize trigger `responseImmutable` children re-render logic. Default will always trigger re-render when this component re-render.
	*/
	function makeImmutable$2(Component$2, shouldTriggerRender) {
		var refAble = supportRef(Component$2);
		var ImmutableComponent = function ImmutableComponent$1(props, ref) {
			var refProps = refAble ? { ref } : {};
			var renderTimesRef = import_react.useRef(0);
			var prevProps = import_react.useRef(props);
			if (useImmutableMark$2() !== null) return /* @__PURE__ */ import_react.createElement(Component$2, _extends({}, props, refProps));
			if (!shouldTriggerRender || shouldTriggerRender(prevProps.current, props)) renderTimesRef.current += 1;
			prevProps.current = props;
			return /* @__PURE__ */ import_react.createElement(ImmutableContext.Provider, { value: renderTimesRef.current }, /* @__PURE__ */ import_react.createElement(Component$2, _extends({}, props, refProps)));
		};
		ImmutableComponent.displayName = "ImmutableRoot(".concat(Component$2.displayName || Component$2.name, ")");
		return refAble ? /* @__PURE__ */ import_react.forwardRef(ImmutableComponent) : ImmutableComponent;
	}
	/**
	* Wrapped Component with `React.memo`.
	* But will rerender when parent with `makeImmutable` rerender.
	*/
	function responseImmutable$2(Component$2, propsAreEqual) {
		var refAble = supportRef(Component$2);
		var ImmutableComponent = function ImmutableComponent$1(props, ref) {
			var refProps = refAble ? { ref } : {};
			useImmutableMark$2();
			return /* @__PURE__ */ import_react.createElement(Component$2, _extends({}, props, refProps));
		};
		ImmutableComponent.displayName = "ImmutableResponse(".concat(Component$2.displayName || Component$2.name, ")");
		return refAble ? /* @__PURE__ */ import_react.memo(/* @__PURE__ */ import_react.forwardRef(ImmutableComponent), propsAreEqual) : /* @__PURE__ */ import_react.memo(ImmutableComponent, propsAreEqual);
	}
	return {
		makeImmutable: makeImmutable$2,
		responseImmutable: responseImmutable$2,
		useImmutableMark: useImmutableMark$2
	};
}

//#endregion
//#region node_modules/@rc-component/context/es/index.js
var _createImmutable$1 = createImmutable(), makeImmutable$1 = _createImmutable$1.makeImmutable, responseImmutable$1 = _createImmutable$1.responseImmutable, useImmutableMark$1 = _createImmutable$1.useImmutableMark;

//#endregion
//#region node_modules/rc-table/es/context/TableContext.js
var _createImmutable = createImmutable(), makeImmutable = _createImmutable.makeImmutable, responseImmutable = _createImmutable.responseImmutable, useImmutableMark = _createImmutable.useImmutableMark;
var TableContext = createContext();
var TableContext_default = TableContext;

//#endregion
//#region node_modules/rc-table/es/hooks/useRenderTimes.js
function useRenderTimes(props, debug) {
	var timesRef = import_react.useRef(0);
	timesRef.current += 1;
	var propsRef = import_react.useRef(props);
	var keys$1 = [];
	Object.keys(props || {}).map(function(key) {
		var _propsRef$current;
		if ((props === null || props === void 0 ? void 0 : props[key]) !== ((_propsRef$current = propsRef.current) === null || _propsRef$current === void 0 ? void 0 : _propsRef$current[key])) keys$1.push(key);
	});
	propsRef.current = props;
	var keysRef = import_react.useRef([]);
	if (keys$1.length) keysRef.current = keys$1;
	import_react.useDebugValue(timesRef.current);
	import_react.useDebugValue(keysRef.current.join(", "));
	if (debug) console.log("".concat(debug, ":"), timesRef.current, keysRef.current);
	return timesRef.current;
}
var useRenderTimes_default = useRenderTimes;
var RenderBlock = /* @__PURE__ */ import_react.memo(function() {
	var times = useRenderTimes();
	return /* @__PURE__ */ import_react.createElement("h1", null, "Render Times: ", times);
});
RenderBlock.displayName = "RenderBlock";

//#endregion
//#region node_modules/rc-table/es/context/PerfContext.js
var PerfContext = /* @__PURE__ */ import_react.createContext({ renderWithProps: false });
var PerfContext_default = PerfContext;

//#endregion
//#region node_modules/rc-table/es/utils/valueUtil.js
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray$2(arr) {
	if (arr === void 0 || arr === null) return [];
	return Array.isArray(arr) ? arr : [arr];
}
function getColumnsKey(columns) {
	var columnKeys = [];
	var keys$1 = {};
	columns.forEach(function(column$1) {
		var _ref = column$1 || {}, key = _ref.key, dataIndex = _ref.dataIndex;
		var mergedKey = key || toArray$2(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
		while (keys$1[mergedKey]) mergedKey = "".concat(mergedKey, "_next");
		keys$1[mergedKey] = true;
		columnKeys.push(mergedKey);
	});
	return columnKeys;
}
function validateValue(val) {
	return val !== null && val !== void 0;
}
function validNumberValue(value) {
	return typeof value === "number" && !Number.isNaN(value);
}

//#endregion
//#region node_modules/rc-table/es/Cell/useCellRender.js
function isRenderCell(data) {
	return data && _typeof(data) === "object" && !Array.isArray(data) && !/* @__PURE__ */ import_react.isValidElement(data);
}
function useCellRender(record, dataIndex, renderIndex, children, render$1, shouldCellUpdate) {
	var perfRecord = import_react.useContext(PerfContext_default);
	var mark = useImmutableMark();
	return useMemo$1(function() {
		if (validateValue(children)) return [children];
		var value = get(record, dataIndex === null || dataIndex === void 0 || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex]);
		var returnChildNode = value;
		var returnCellProps = void 0;
		if (render$1) {
			var renderData = render$1(value, record, renderIndex);
			if (isRenderCell(renderData)) {
				warning_default(false, "`columns.render` return cell props is deprecated with perf issue, please use `onCell` instead.");
				returnChildNode = renderData.children;
				returnCellProps = renderData.props;
				perfRecord.renderWithProps = true;
			} else returnChildNode = renderData;
		}
		return [returnChildNode, returnCellProps];
	}, [
		mark,
		record,
		children,
		dataIndex,
		render$1,
		renderIndex
	], function(prev$1, next$1) {
		if (shouldCellUpdate) {
			var _prev = _slicedToArray(prev$1, 2), prevRecord = _prev[1];
			var _next = _slicedToArray(next$1, 2), nextRecord = _next[1];
			return shouldCellUpdate(nextRecord, prevRecord);
		}
		if (perfRecord.renderWithProps) return true;
		return !isEqual_default(prev$1, next$1, true);
	});
}

//#endregion
//#region node_modules/rc-table/es/Cell/useHoverState.js
/** Check if cell is in hover range */
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
	var cellEndRow = cellStartRow + cellRowSpan - 1;
	return cellStartRow <= endRow && cellEndRow >= startRow;
}
function useHoverState(rowIndex, rowSpan) {
	return useContext$2(TableContext_default, function(ctx) {
		return [inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow), ctx.onHover];
	});
}

//#endregion
//#region node_modules/rc-table/es/Cell/index.js
var import_classnames$49 = /* @__PURE__ */ __toESM(require_classnames());
var getTitleFromCellRenderChildren = function getTitleFromCellRenderChildren$1(_ref) {
	var ellipsis = _ref.ellipsis, rowType = _ref.rowType, children = _ref.children;
	var title;
	var ellipsisConfig = ellipsis === true ? { showTitle: true } : ellipsis;
	if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
		if (typeof children === "string" || typeof children === "number") title = children.toString();
		else if (/* @__PURE__ */ import_react.isValidElement(children) && typeof children.props.children === "string") title = children.props.children;
	}
	return title;
};
function Cell(props) {
	var _ref2, _ref3, _legacyCellProps$colS, _ref4, _ref5, _legacyCellProps$rowS, _additionalProps$titl, _classNames;
	useRenderTimes_default(props);
	var Component$2 = props.component, children = props.children, ellipsis = props.ellipsis, scope = props.scope, prefixCls = props.prefixCls, className = props.className, align = props.align, record = props.record, render$1 = props.render, dataIndex = props.dataIndex, renderIndex = props.renderIndex, shouldCellUpdate = props.shouldCellUpdate, index$2 = props.index, rowType = props.rowType, colSpan = props.colSpan, rowSpan = props.rowSpan, fixLeft = props.fixLeft, fixRight = props.fixRight, firstFixLeft = props.firstFixLeft, lastFixLeft = props.lastFixLeft, firstFixRight = props.firstFixRight, lastFixRight = props.lastFixRight, appendNode = props.appendNode, _props$additionalProp = props.additionalProps, additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp, isSticky = props.isSticky;
	var cellPrefixCls = "".concat(prefixCls, "-cell");
	var _useContext = useContext$2(TableContext_default, [
		"supportSticky",
		"allColumnsFixedLeft",
		"rowHoverable"
	]), supportSticky = _useContext.supportSticky, allColumnsFixedLeft = _useContext.allColumnsFixedLeft, rowHoverable = _useContext.rowHoverable;
	var _useCellRender = useCellRender(record, dataIndex, renderIndex, children, render$1, shouldCellUpdate), _useCellRender2 = _slicedToArray(_useCellRender, 2), childNode = _useCellRender2[0], legacyCellProps = _useCellRender2[1];
	var fixedStyle$1 = {};
	var isFixLeft = typeof fixLeft === "number" && supportSticky;
	var isFixRight = typeof fixRight === "number" && supportSticky;
	if (isFixLeft) {
		fixedStyle$1.position = "sticky";
		fixedStyle$1.left = fixLeft;
	}
	if (isFixRight) {
		fixedStyle$1.position = "sticky";
		fixedStyle$1.right = fixRight;
	}
	var mergedColSpan = (_ref2 = (_ref3 = (_legacyCellProps$colS = legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.colSpan) !== null && _legacyCellProps$colS !== void 0 ? _legacyCellProps$colS : additionalProps.colSpan) !== null && _ref3 !== void 0 ? _ref3 : colSpan) !== null && _ref2 !== void 0 ? _ref2 : 1;
	var mergedRowSpan = (_ref4 = (_ref5 = (_legacyCellProps$rowS = legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.rowSpan) !== null && _legacyCellProps$rowS !== void 0 ? _legacyCellProps$rowS : additionalProps.rowSpan) !== null && _ref5 !== void 0 ? _ref5 : rowSpan) !== null && _ref4 !== void 0 ? _ref4 : 1;
	var _useHoverState = useHoverState(index$2, mergedRowSpan), _useHoverState2 = _slicedToArray(_useHoverState, 2), hovering = _useHoverState2[0], onHover = _useHoverState2[1];
	var onMouseEnter = useEvent(function(event) {
		var _additionalProps$onMo;
		if (record) onHover(index$2, index$2 + mergedRowSpan - 1);
		additionalProps === null || additionalProps === void 0 || (_additionalProps$onMo = additionalProps.onMouseEnter) === null || _additionalProps$onMo === void 0 || _additionalProps$onMo.call(additionalProps, event);
	});
	var onMouseLeave = useEvent(function(event) {
		var _additionalProps$onMo2;
		if (record) onHover(-1, -1);
		additionalProps === null || additionalProps === void 0 || (_additionalProps$onMo2 = additionalProps.onMouseLeave) === null || _additionalProps$onMo2 === void 0 || _additionalProps$onMo2.call(additionalProps, event);
	});
	if (mergedColSpan === 0 || mergedRowSpan === 0) return null;
	var title = (_additionalProps$titl = additionalProps.title) !== null && _additionalProps$titl !== void 0 ? _additionalProps$titl : getTitleFromCellRenderChildren({
		rowType,
		ellipsis,
		children: childNode
	});
	var mergedClassName = (0, import_classnames$49.default)(cellPrefixCls, className, (_classNames = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-all"), lastFixLeft && allColumnsFixedLeft && supportSticky), "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky), "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky), "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky), "".concat(cellPrefixCls, "-ellipsis"), ellipsis), "".concat(cellPrefixCls, "-with-append"), appendNode), "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-row-hover"), !legacyCellProps && hovering)), additionalProps.className, legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.className);
	var alignStyle = {};
	if (align) alignStyle.textAlign = align;
	var mergedStyle = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.style), fixedStyle$1), alignStyle), additionalProps.style);
	var mergedChildNode = childNode;
	if (_typeof(mergedChildNode) === "object" && !Array.isArray(mergedChildNode) && !/* @__PURE__ */ import_react.isValidElement(mergedChildNode)) mergedChildNode = null;
	if (ellipsis && (lastFixLeft || firstFixRight)) mergedChildNode = /* @__PURE__ */ import_react.createElement("span", { className: "".concat(cellPrefixCls, "-content") }, mergedChildNode);
	return /* @__PURE__ */ import_react.createElement(Component$2, _extends({}, legacyCellProps, additionalProps, {
		className: mergedClassName,
		style: mergedStyle,
		title,
		scope,
		onMouseEnter: rowHoverable ? onMouseEnter : void 0,
		onMouseLeave: rowHoverable ? onMouseLeave : void 0,
		colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
		rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
	}), appendNode, mergedChildNode);
}
var Cell_default = /* @__PURE__ */ import_react.memo(Cell);

//#endregion
//#region node_modules/rc-table/es/utils/fixUtil.js
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
	var startColumn = columns[colStart] || {};
	var endColumn = columns[colEnd] || {};
	var fixLeft;
	var fixRight;
	if (startColumn.fixed === "left") fixLeft = stickyOffsets.left[direction === "rtl" ? colEnd : colStart];
	else if (endColumn.fixed === "right") fixRight = stickyOffsets.right[direction === "rtl" ? colStart : colEnd];
	var lastFixLeft = false;
	var firstFixRight = false;
	var lastFixRight = false;
	var firstFixLeft = false;
	var nextColumn = columns[colEnd + 1];
	var prevColumn = columns[colStart - 1];
	var canLastFix = nextColumn && !nextColumn.fixed || prevColumn && !prevColumn.fixed || columns.every(function(col) {
		return col.fixed === "left";
	});
	if (direction === "rtl") {
		if (fixLeft !== void 0) firstFixLeft = !(prevColumn && prevColumn.fixed === "left") && canLastFix;
		else if (fixRight !== void 0) lastFixRight = !(nextColumn && nextColumn.fixed === "right") && canLastFix;
	} else if (fixLeft !== void 0) lastFixLeft = !(nextColumn && nextColumn.fixed === "left") && canLastFix;
	else if (fixRight !== void 0) firstFixRight = !(prevColumn && prevColumn.fixed === "right") && canLastFix;
	return {
		fixLeft,
		fixRight,
		lastFixLeft,
		firstFixRight,
		lastFixRight,
		firstFixLeft,
		isSticky: stickyOffsets.isSticky
	};
}

//#endregion
//#region node_modules/rc-table/es/Footer/SummaryContext.js
var SummaryContext = /* @__PURE__ */ import_react.createContext({});
var SummaryContext_default = SummaryContext;

//#endregion
//#region node_modules/rc-table/es/Footer/Cell.js
function SummaryCell(_ref) {
	var className = _ref.className, index$2 = _ref.index, children = _ref.children, _ref$colSpan = _ref.colSpan, colSpan = _ref$colSpan === void 0 ? 1 : _ref$colSpan, rowSpan = _ref.rowSpan, align = _ref.align;
	var _useContext = useContext$2(TableContext_default, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction;
	var _React$useContext = import_react.useContext(SummaryContext_default), scrollColumnIndex = _React$useContext.scrollColumnIndex, stickyOffsets = _React$useContext.stickyOffsets, flattenColumns = _React$useContext.flattenColumns;
	var mergedColSpan = index$2 + colSpan - 1 + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
	var fixedInfo = getCellFixedInfo(index$2, index$2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
	return /* @__PURE__ */ import_react.createElement(Cell_default, _extends({
		className,
		index: index$2,
		component: "td",
		prefixCls,
		record: null,
		dataIndex: null,
		align,
		colSpan: mergedColSpan,
		rowSpan,
		render: function render$1() {
			return children;
		}
	}, fixedInfo));
}

//#endregion
//#region node_modules/rc-table/es/Footer/Row.js
var _excluded$12 = ["children"];
function FooterRow(_ref) {
	var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$12);
	return /* @__PURE__ */ import_react.createElement("tr", props, children);
}

//#endregion
//#region node_modules/rc-table/es/Footer/Summary.js
/**
* Syntactic sugar. Do not support HOC.
*/
function Summary(_ref) {
	return _ref.children;
}
Summary.Row = FooterRow;
Summary.Cell = SummaryCell;
var Summary_default = Summary;

//#endregion
//#region node_modules/rc-table/es/Footer/index.js
function Footer(props) {
	useRenderTimes_default(props);
	var children = props.children, stickyOffsets = props.stickyOffsets, flattenColumns = props.flattenColumns;
	var prefixCls = useContext$2(TableContext_default, "prefixCls");
	var lastColumnIndex = flattenColumns.length - 1;
	var scrollColumn = flattenColumns[lastColumnIndex];
	var summaryContext = import_react.useMemo(function() {
		return {
			stickyOffsets,
			flattenColumns,
			scrollColumnIndex: scrollColumn !== null && scrollColumn !== void 0 && scrollColumn.scrollbar ? lastColumnIndex : null
		};
	}, [
		scrollColumn,
		flattenColumns,
		lastColumnIndex,
		stickyOffsets
	]);
	return /* @__PURE__ */ import_react.createElement(SummaryContext_default.Provider, { value: summaryContext }, /* @__PURE__ */ import_react.createElement("tfoot", { className: "".concat(prefixCls, "-summary") }, children));
}
var Footer_default = responseImmutable(Footer);
var FooterComponents = Summary_default;

//#endregion
//#region node_modules/rc-table/es/sugar/Column.js
/* istanbul ignore next */
/**
* This is a syntactic sugar for `columns` prop.
* So HOC will not work on this.
*/
function Column$1(_) {
	return null;
}
var Column_default$1 = Column$1;

//#endregion
//#region node_modules/rc-table/es/sugar/ColumnGroup.js
/* istanbul ignore next */
/**
* This is a syntactic sugar for `columns` prop.
* So HOC will not work on this.
*/
function ColumnGroup$1(_) {
	return null;
}
var ColumnGroup_default$1 = ColumnGroup$1;

//#endregion
//#region node_modules/rc-table/es/hooks/useFlattenRecords.js
function fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index$2) {
	var key = getRowKey(record, index$2);
	list.push({
		record,
		indent,
		index: index$2,
		rowKey: key
	});
	var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key);
	if (record && Array.isArray(record[childrenColumnName]) && expanded) for (var i = 0; i < record[childrenColumnName].length; i += 1) fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
}
/**
* flat tree data on expanded state
*
* @export
* @template T
* @param {*} data : table data
* @param {string} childrenColumnName : 
* @param {Set<Key>} expandedKeys : keys
* @param {GetRowKey<T>} getRowKey  : rowKey
* @returns flattened data
*/
function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
	return import_react.useMemo(function() {
		if (expandedKeys !== null && expandedKeys !== void 0 && expandedKeys.size) {
			var list = [];
			for (var i = 0; i < (data === null || data === void 0 ? void 0 : data.length); i += 1) {
				var record = data[i];
				fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);
			}
			return list;
		}
		return data === null || data === void 0 ? void 0 : data.map(function(item, index$2) {
			return {
				record: item,
				indent: 0,
				index: index$2,
				rowKey: getRowKey(item, index$2)
			};
		});
	}, [
		data,
		childrenColumnName,
		expandedKeys,
		getRowKey
	]);
}

//#endregion
//#region node_modules/rc-table/es/hooks/useRowInfo.js
var import_classnames$48 = /* @__PURE__ */ __toESM(require_classnames());
function useRowInfo(record, rowKey, recordIndex, indent) {
	var context = useContext$2(TableContext_default, [
		"prefixCls",
		"fixedInfoList",
		"flattenColumns",
		"expandableType",
		"expandRowByClick",
		"onTriggerExpand",
		"rowClassName",
		"expandedRowClassName",
		"indentSize",
		"expandIcon",
		"expandedRowRender",
		"expandIconColumnIndex",
		"expandedKeys",
		"childrenColumnName",
		"rowExpandable",
		"onRow"
	]);
	var flattenColumns = context.flattenColumns, expandableType = context.expandableType, expandedKeys = context.expandedKeys, childrenColumnName = context.childrenColumnName, onTriggerExpand = context.onTriggerExpand, rowExpandable = context.rowExpandable, onRow = context.onRow, expandRowByClick = context.expandRowByClick, rowClassName = context.rowClassName;
	var nestExpandable = expandableType === "nest";
	var rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
	var mergedExpandable = rowSupportExpand || nestExpandable;
	var expanded = expandedKeys && expandedKeys.has(rowKey);
	var hasNestChildren = childrenColumnName && record && record[childrenColumnName];
	var onInternalTriggerExpand = useEvent(onTriggerExpand);
	var rowProps = onRow === null || onRow === void 0 ? void 0 : onRow(record, recordIndex);
	var onRowClick = rowProps === null || rowProps === void 0 ? void 0 : rowProps.onClick;
	var onClick = function onClick$1(event) {
		if (expandRowByClick && mergedExpandable) onTriggerExpand(record, event);
		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
		onRowClick === null || onRowClick === void 0 || onRowClick.apply(void 0, [event].concat(args));
	};
	var computeRowClassName;
	if (typeof rowClassName === "string") computeRowClassName = rowClassName;
	else if (typeof rowClassName === "function") computeRowClassName = rowClassName(record, recordIndex, indent);
	var columnsKey = getColumnsKey(flattenColumns);
	return _objectSpread2(_objectSpread2({}, context), {}, {
		columnsKey,
		nestExpandable,
		expanded,
		hasNestChildren,
		record,
		onTriggerExpand: onInternalTriggerExpand,
		rowSupportExpand,
		expandable: mergedExpandable,
		rowProps: _objectSpread2(_objectSpread2({}, rowProps), {}, {
			className: (0, import_classnames$48.default)(computeRowClassName, rowProps === null || rowProps === void 0 ? void 0 : rowProps.className),
			onClick
		})
	});
}

//#endregion
//#region node_modules/rc-table/es/Body/ExpandedRow.js
function ExpandedRow(props) {
	useRenderTimes_default(props);
	var prefixCls = props.prefixCls, children = props.children, Component$2 = props.component, cellComponent = props.cellComponent, className = props.className, expanded = props.expanded, colSpan = props.colSpan, isEmpty$1 = props.isEmpty, _props$stickyOffset = props.stickyOffset, stickyOffset = _props$stickyOffset === void 0 ? 0 : _props$stickyOffset;
	var _useContext = useContext$2(TableContext_default, [
		"scrollbarSize",
		"fixHeader",
		"fixColumn",
		"componentWidth",
		"horizonScroll"
	]), scrollbarSize = _useContext.scrollbarSize, fixHeader = _useContext.fixHeader, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth, horizonScroll = _useContext.horizonScroll;
	var contentNode = children;
	if (isEmpty$1 ? horizonScroll && componentWidth : fixColumn) contentNode = /* @__PURE__ */ import_react.createElement("div", {
		style: {
			width: componentWidth - stickyOffset - (fixHeader && !isEmpty$1 ? scrollbarSize : 0),
			position: "sticky",
			left: stickyOffset,
			overflow: "hidden"
		},
		className: "".concat(prefixCls, "-expanded-row-fixed")
	}, contentNode);
	return /* @__PURE__ */ import_react.createElement(Component$2, {
		className,
		style: { display: expanded ? null : "none" }
	}, /* @__PURE__ */ import_react.createElement(Cell_default, {
		component: cellComponent,
		prefixCls,
		colSpan
	}, contentNode));
}
var ExpandedRow_default = ExpandedRow;

//#endregion
//#region node_modules/rc-table/es/utils/expandUtil.js
var import_classnames$47 = /* @__PURE__ */ __toESM(require_classnames());
function renderExpandIcon$1(_ref) {
	var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable;
	var expandClassName = "".concat(prefixCls, "-row-expand-icon");
	if (!expandable) return /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$47.default)(expandClassName, "".concat(prefixCls, "-row-spaced")) });
	return /* @__PURE__ */ import_react.createElement("span", {
		className: (0, import_classnames$47.default)(expandClassName, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-row-expanded"), expanded), "".concat(prefixCls, "-row-collapsed"), !expanded)),
		onClick: function onClick(event) {
			onExpand(record, event);
			event.stopPropagation();
		}
	});
}
function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
	var keys$1 = [];
	function dig(list) {
		(list || []).forEach(function(item, index$2) {
			keys$1.push(getRowKey(item, index$2));
			dig(item[childrenColumnName]);
		});
	}
	dig(data);
	return keys$1;
}
function computedExpandedClassName(cls$12, record, index$2, indent) {
	if (typeof cls$12 === "string") return cls$12;
	if (typeof cls$12 === "function") return cls$12(record, index$2, indent);
	return "";
}

//#endregion
//#region node_modules/rc-table/es/Body/BodyRow.js
var import_classnames$46 = /* @__PURE__ */ __toESM(require_classnames());
function getCellProps(rowInfo, column$1, colIndex, indent, index$2) {
	var _column$onCell;
	var rowKeys = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
	var expandedRowOffset = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
	var record = rowInfo.record, prefixCls = rowInfo.prefixCls, columnsKey = rowInfo.columnsKey, fixedInfoList = rowInfo.fixedInfoList, expandIconColumnIndex = rowInfo.expandIconColumnIndex, nestExpandable = rowInfo.nestExpandable, indentSize = rowInfo.indentSize, expandIcon = rowInfo.expandIcon, expanded = rowInfo.expanded, hasNestChildren = rowInfo.hasNestChildren, onTriggerExpand = rowInfo.onTriggerExpand, expandable = rowInfo.expandable, expandedKeys = rowInfo.expandedKeys;
	var key = columnsKey[colIndex];
	var fixedInfo = fixedInfoList[colIndex];
	var appendCellNode;
	if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) appendCellNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("span", {
		style: { paddingLeft: "".concat(indentSize * indent, "px") },
		className: "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
	}), expandIcon({
		prefixCls,
		expanded,
		expandable: hasNestChildren,
		record,
		onExpand: onTriggerExpand
	}));
	var additionalCellProps = ((_column$onCell = column$1.onCell) === null || _column$onCell === void 0 ? void 0 : _column$onCell.call(column$1, record, index$2)) || {};
	if (expandedRowOffset) {
		var _additionalCellProps$ = additionalCellProps.rowSpan, rowSpan = _additionalCellProps$ === void 0 ? 1 : _additionalCellProps$;
		if (expandable && rowSpan && colIndex < expandedRowOffset) {
			var currentRowSpan = rowSpan;
			for (var i = index$2; i < index$2 + rowSpan; i += 1) {
				var rowKey = rowKeys[i];
				if (expandedKeys.has(rowKey)) currentRowSpan += 1;
			}
			additionalCellProps.rowSpan = currentRowSpan;
		}
	}
	return {
		key,
		fixedInfo,
		appendCellNode,
		additionalCellProps
	};
}
function BodyRow(props) {
	useRenderTimes_default(props);
	var className = props.className, style$1 = props.style, record = props.record, index$2 = props.index, renderIndex = props.renderIndex, rowKey = props.rowKey, rowKeys = props.rowKeys, _props$indent = props.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props.rowComponent, cellComponent = props.cellComponent, scopeCellComponent = props.scopeCellComponent, expandedRowInfo = props.expandedRowInfo;
	var rowInfo = useRowInfo(record, rowKey, index$2, indent);
	var prefixCls = rowInfo.prefixCls, flattenColumns = rowInfo.flattenColumns, expandedRowClassName = rowInfo.expandedRowClassName, expandedRowRender = rowInfo.expandedRowRender, rowProps = rowInfo.rowProps, expanded = rowInfo.expanded, rowSupportExpand = rowInfo.rowSupportExpand;
	var expandedRef = import_react.useRef(false);
	expandedRef.current || (expandedRef.current = expanded);
	useRenderTimes_default(props);
	var expandedClsName = computedExpandedClassName(expandedRowClassName, record, index$2, indent);
	var baseRowNode = /* @__PURE__ */ import_react.createElement(RowComponent, _extends({}, rowProps, {
		"data-row-key": rowKey,
		className: (0, import_classnames$46.default)(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), rowProps === null || rowProps === void 0 ? void 0 : rowProps.className, _defineProperty({}, expandedClsName, indent >= 1)),
		style: _objectSpread2(_objectSpread2({}, style$1), rowProps === null || rowProps === void 0 ? void 0 : rowProps.style)
	}), flattenColumns.map(function(column$1, colIndex) {
		var render$1 = column$1.render, dataIndex = column$1.dataIndex, columnClassName = column$1.className;
		var _getCellProps = getCellProps(rowInfo, column$1, colIndex, indent, index$2, rowKeys, expandedRowInfo === null || expandedRowInfo === void 0 ? void 0 : expandedRowInfo.offset), key = _getCellProps.key, fixedInfo = _getCellProps.fixedInfo, appendCellNode = _getCellProps.appendCellNode, additionalCellProps = _getCellProps.additionalCellProps;
		return /* @__PURE__ */ import_react.createElement(Cell_default, _extends({
			className: columnClassName,
			ellipsis: column$1.ellipsis,
			align: column$1.align,
			scope: column$1.rowScope,
			component: column$1.rowScope ? scopeCellComponent : cellComponent,
			prefixCls,
			key,
			record,
			index: index$2,
			renderIndex,
			dataIndex,
			render: render$1,
			shouldCellUpdate: column$1.shouldCellUpdate
		}, fixedInfo, {
			appendNode: appendCellNode,
			additionalProps: additionalCellProps
		}));
	}));
	var expandRowNode;
	if (rowSupportExpand && (expandedRef.current || expanded)) {
		var expandContent = expandedRowRender(record, index$2, indent + 1, expanded);
		expandRowNode = /* @__PURE__ */ import_react.createElement(ExpandedRow_default, {
			expanded,
			className: (0, import_classnames$46.default)("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), expandedClsName),
			prefixCls,
			component: RowComponent,
			cellComponent,
			colSpan: expandedRowInfo ? expandedRowInfo.colSpan : flattenColumns.length,
			stickyOffset: expandedRowInfo === null || expandedRowInfo === void 0 ? void 0 : expandedRowInfo.sticky,
			isEmpty: false
		}, expandContent);
	}
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, baseRowNode, expandRowNode);
}
BodyRow.displayName = "BodyRow";
var BodyRow_default = responseImmutable(BodyRow);

//#endregion
//#region node_modules/rc-table/es/Body/MeasureCell.js
function MeasureCell(_ref) {
	var columnKey = _ref.columnKey, onColumnResize = _ref.onColumnResize, column$1 = _ref.column;
	var cellRef = import_react.useRef();
	useLayoutEffect_default(function() {
		if (cellRef.current) onColumnResize(columnKey, cellRef.current.offsetWidth);
	}, []);
	return /* @__PURE__ */ import_react.createElement(es_default, { data: columnKey }, /* @__PURE__ */ import_react.createElement("td", {
		ref: cellRef,
		style: {
			paddingTop: 0,
			paddingBottom: 0,
			borderTop: 0,
			borderBottom: 0,
			height: 0
		}
	}, /* @__PURE__ */ import_react.createElement("div", { style: {
		height: 0,
		overflow: "hidden",
		fontWeight: "bold"
	} }, (column$1 === null || column$1 === void 0 ? void 0 : column$1.title) || "\xA0")));
}

//#endregion
//#region node_modules/rc-table/es/Body/MeasureRow.js
function MeasureRow(_ref) {
	var prefixCls = _ref.prefixCls, columnsKey = _ref.columnsKey, onColumnResize = _ref.onColumnResize, columns = _ref.columns;
	var ref = import_react.useRef(null);
	var _useContext = useContext$2(TableContext_default, ["measureRowRender"]), measureRowRender = _useContext.measureRowRender;
	var measureRow = /* @__PURE__ */ import_react.createElement("tr", {
		"aria-hidden": "true",
		className: "".concat(prefixCls, "-measure-row"),
		style: { height: 0 },
		ref
	}, /* @__PURE__ */ import_react.createElement(es_default.Collection, { onBatchResize: function onBatchResize(infoList) {
		if (isVisible_default(ref.current)) infoList.forEach(function(_ref2) {
			var columnKey = _ref2.data, size = _ref2.size;
			onColumnResize(columnKey, size.offsetWidth);
		});
	} }, columnsKey.map(function(columnKey) {
		var column$1 = columns.find(function(col) {
			return col.key === columnKey;
		});
		return /* @__PURE__ */ import_react.createElement(MeasureCell, {
			key: columnKey,
			columnKey,
			onColumnResize,
			column: column$1
		});
	})));
	return measureRowRender ? measureRowRender(measureRow) : measureRow;
}

//#endregion
//#region node_modules/rc-table/es/Body/index.js
function Body(props) {
	useRenderTimes_default(props);
	var data = props.data, measureColumnWidth = props.measureColumnWidth;
	var _useContext = useContext$2(TableContext_default, [
		"prefixCls",
		"getComponent",
		"onColumnResize",
		"flattenColumns",
		"getRowKey",
		"expandedKeys",
		"childrenColumnName",
		"emptyNode",
		"expandedRowOffset",
		"fixedInfoList",
		"colWidths"
	]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent, onColumnResize = _useContext.onColumnResize, flattenColumns = _useContext.flattenColumns, getRowKey = _useContext.getRowKey, expandedKeys = _useContext.expandedKeys, childrenColumnName = _useContext.childrenColumnName, emptyNode = _useContext.emptyNode, _useContext$expandedR = _useContext.expandedRowOffset, expandedRowOffset = _useContext$expandedR === void 0 ? 0 : _useContext$expandedR, colWidths = _useContext.colWidths;
	var flattenData$1 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
	var rowKeys = import_react.useMemo(function() {
		return flattenData$1.map(function(item) {
			return item.rowKey;
		});
	}, [flattenData$1]);
	var perfRef = import_react.useRef({ renderWithProps: false });
	var expandedRowInfo = import_react.useMemo(function() {
		var expandedColSpan = flattenColumns.length - expandedRowOffset;
		var expandedStickyStart = 0;
		for (var i = 0; i < expandedRowOffset; i += 1) expandedStickyStart += colWidths[i] || 0;
		return {
			offset: expandedRowOffset,
			colSpan: expandedColSpan,
			sticky: expandedStickyStart
		};
	}, [
		flattenColumns.length,
		expandedRowOffset,
		colWidths
	]);
	var WrapperComponent = getComponent(["body", "wrapper"], "tbody");
	var trComponent = getComponent(["body", "row"], "tr");
	var tdComponent = getComponent(["body", "cell"], "td");
	var thComponent = getComponent(["body", "cell"], "th");
	var rows;
	if (data.length) rows = flattenData$1.map(function(item, idx) {
		var record = item.record, indent = item.indent, renderIndex = item.index, rowKey = item.rowKey;
		return /* @__PURE__ */ import_react.createElement(BodyRow_default, {
			key: rowKey,
			rowKey,
			rowKeys,
			record,
			index: idx,
			renderIndex,
			rowComponent: trComponent,
			cellComponent: tdComponent,
			scopeCellComponent: thComponent,
			indent,
			expandedRowInfo
		});
	});
	else rows = /* @__PURE__ */ import_react.createElement(ExpandedRow_default, {
		expanded: true,
		className: "".concat(prefixCls, "-placeholder"),
		prefixCls,
		component: trComponent,
		cellComponent: tdComponent,
		colSpan: flattenColumns.length,
		isEmpty: true
	}, emptyNode);
	var columnsKey = getColumnsKey(flattenColumns);
	return /* @__PURE__ */ import_react.createElement(PerfContext_default.Provider, { value: perfRef.current }, /* @__PURE__ */ import_react.createElement(WrapperComponent, { className: "".concat(prefixCls, "-tbody") }, measureColumnWidth && /* @__PURE__ */ import_react.createElement(MeasureRow, {
		prefixCls,
		columnsKey,
		onColumnResize,
		columns: flattenColumns
	}), rows));
}
Body.displayName = "Body";
var Body_default = responseImmutable(Body);

//#endregion
//#region node_modules/rc-table/es/utils/legacyUtil.js
var _excluded$11 = ["expandable"];
var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
function getExpandableProps(props) {
	var expandable = props.expandable, legacyExpandableConfig = _objectWithoutProperties(props, _excluded$11);
	var config;
	if ("expandable" in props) config = _objectSpread2(_objectSpread2({}, legacyExpandableConfig), expandable);
	else {
		if ([
			"indentSize",
			"expandedRowKeys",
			"defaultExpandedRowKeys",
			"defaultExpandAllRows",
			"expandedRowRender",
			"expandRowByClick",
			"expandIcon",
			"onExpand",
			"onExpandedRowsChange",
			"expandedRowClassName",
			"expandIconColumnIndex",
			"showExpandColumn",
			"title"
		].some(function(prop) {
			return prop in props;
		})) warning_default(false, "expanded related props have been moved into `expandable`.");
		config = legacyExpandableConfig;
	}
	if (config.showExpandColumn === false) config.expandIconColumnIndex = -1;
	return config;
}

//#endregion
//#region node_modules/rc-table/es/ColGroup.js
var _excluded$10 = ["columnType"];
function ColGroup(_ref) {
	var colWidths = _ref.colWidths, columns = _ref.columns, columCount = _ref.columCount;
	var _useContext = useContext$2(TableContext_default, ["tableLayout"]), tableLayout = _useContext.tableLayout;
	var cols = [];
	var len = columCount || columns.length;
	var mustInsert = false;
	for (var i = len - 1; i >= 0; i -= 1) {
		var width = colWidths[i];
		var column$1 = columns && columns[i];
		var additionalProps = void 0;
		var minWidth = void 0;
		if (column$1) {
			additionalProps = column$1[INTERNAL_COL_DEFINE];
			if (tableLayout === "auto") minWidth = column$1.minWidth;
		}
		if (width || minWidth || additionalProps || mustInsert) {
			var _ref2 = additionalProps || {};
			_ref2.columnType;
			var restAdditionalProps = _objectWithoutProperties(_ref2, _excluded$10);
			cols.unshift(/* @__PURE__ */ import_react.createElement("col", _extends({
				key: i,
				style: {
					width,
					minWidth
				}
			}, restAdditionalProps)));
			mustInsert = true;
		}
	}
	return cols.length > 0 ? /* @__PURE__ */ import_react.createElement("colgroup", null, cols) : null;
}
var ColGroup_default = ColGroup;

//#endregion
//#region node_modules/rc-table/es/FixedHolder/index.js
var import_classnames$45 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$9 = [
	"className",
	"noData",
	"columns",
	"flattenColumns",
	"colWidths",
	"colGroup",
	"columCount",
	"stickyOffsets",
	"direction",
	"fixHeader",
	"stickyTopOffset",
	"stickyBottomOffset",
	"stickyClassName",
	"scrollX",
	"tableLayout",
	"onScroll",
	"children"
];
function useColumnWidth(colWidths, columCount) {
	return (0, import_react.useMemo)(function() {
		var cloneColumns = [];
		for (var i = 0; i < columCount; i += 1) {
			var val = colWidths[i];
			if (val !== void 0) cloneColumns[i] = val;
			else return null;
		}
		return cloneColumns;
	}, [colWidths.join("_"), columCount]);
}
var FixedHolder = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	useRenderTimes_default(props);
	var className = props.className, noData = props.noData, columns = props.columns, flattenColumns = props.flattenColumns, colWidths = props.colWidths, colGroup = props.colGroup, columCount = props.columCount, stickyOffsets = props.stickyOffsets, direction = props.direction, fixHeader = props.fixHeader, stickyTopOffset = props.stickyTopOffset, stickyBottomOffset = props.stickyBottomOffset, stickyClassName = props.stickyClassName, scrollX = props.scrollX, _props$tableLayout = props.tableLayout, tableLayout = _props$tableLayout === void 0 ? "fixed" : _props$tableLayout, onScroll = props.onScroll, children = props.children, restProps = _objectWithoutProperties(props, _excluded$9);
	var _useContext = useContext$2(TableContext_default, [
		"prefixCls",
		"scrollbarSize",
		"isSticky",
		"getComponent"
	]), prefixCls = _useContext.prefixCls, scrollbarSize = _useContext.scrollbarSize, isSticky = _useContext.isSticky, getComponent = _useContext.getComponent;
	var TableComponent = getComponent(["header", "table"], "table");
	var combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
	var scrollRef = import_react.useRef(null);
	var setScrollRef = import_react.useCallback(function(element) {
		fillRef(ref, element);
		fillRef(scrollRef, element);
	}, []);
	import_react.useEffect(function() {
		function onWheel(e$2) {
			var _ref = e$2, currentTarget = _ref.currentTarget, deltaX = _ref.deltaX;
			if (deltaX) {
				onScroll({
					currentTarget,
					scrollLeft: currentTarget.scrollLeft + deltaX
				});
				e$2.preventDefault();
			}
		}
		var scrollEle = scrollRef.current;
		scrollEle === null || scrollEle === void 0 || scrollEle.addEventListener("wheel", onWheel, { passive: false });
		return function() {
			scrollEle === null || scrollEle === void 0 || scrollEle.removeEventListener("wheel", onWheel);
		};
	}, []);
	var lastColumn = flattenColumns[flattenColumns.length - 1];
	var ScrollBarColumn = {
		fixed: lastColumn ? lastColumn.fixed : null,
		scrollbar: true,
		onHeaderCell: function onHeaderCell() {
			return { className: "".concat(prefixCls, "-cell-scrollbar") };
		}
	};
	var columnsWithScrollbar = (0, import_react.useMemo)(function() {
		return combinationScrollBarSize ? [].concat(_toConsumableArray(columns), [ScrollBarColumn]) : columns;
	}, [combinationScrollBarSize, columns]);
	var flattenColumnsWithScrollbar = (0, import_react.useMemo)(function() {
		return combinationScrollBarSize ? [].concat(_toConsumableArray(flattenColumns), [ScrollBarColumn]) : flattenColumns;
	}, [combinationScrollBarSize, flattenColumns]);
	var headerStickyOffsets = (0, import_react.useMemo)(function() {
		var right = stickyOffsets.right, left = stickyOffsets.left;
		return _objectSpread2(_objectSpread2({}, stickyOffsets), {}, {
			left: direction === "rtl" ? [].concat(_toConsumableArray(left.map(function(width) {
				return width + combinationScrollBarSize;
			})), [0]) : left,
			right: direction === "rtl" ? right : [].concat(_toConsumableArray(right.map(function(width) {
				return width + combinationScrollBarSize;
			})), [0]),
			isSticky
		});
	}, [
		combinationScrollBarSize,
		stickyOffsets,
		isSticky
	]);
	var mergedColumnWidth = useColumnWidth(colWidths, columCount);
	var isColGroupEmpty = (0, import_react.useMemo)(function() {
		var noWidth = !mergedColumnWidth || !mergedColumnWidth.length || mergedColumnWidth.every(function(w) {
			return !w;
		});
		return noData || noWidth;
	}, [noData, mergedColumnWidth]);
	return /* @__PURE__ */ import_react.createElement("div", {
		style: _objectSpread2({ overflow: "hidden" }, isSticky ? {
			top: stickyTopOffset,
			bottom: stickyBottomOffset
		} : {}),
		ref: setScrollRef,
		className: (0, import_classnames$45.default)(className, _defineProperty({}, stickyClassName, !!stickyClassName))
	}, /* @__PURE__ */ import_react.createElement(TableComponent, { style: {
		tableLayout,
		minWidth: "100%",
		width: scrollX
	} }, isColGroupEmpty ? colGroup : /* @__PURE__ */ import_react.createElement(ColGroup_default, {
		colWidths: [].concat(_toConsumableArray(mergedColumnWidth), [combinationScrollBarSize]),
		columCount: columCount + 1,
		columns: flattenColumnsWithScrollbar
	}), children(_objectSpread2(_objectSpread2({}, restProps), {}, {
		stickyOffsets: headerStickyOffsets,
		columns: columnsWithScrollbar,
		flattenColumns: flattenColumnsWithScrollbar
	}))));
});
FixedHolder.displayName = "FixedHolder";
/** Return a table in div as fixed element which contains sticky info */
var FixedHolder_default = /* @__PURE__ */ import_react.memo(FixedHolder);

//#endregion
//#region node_modules/rc-table/es/Header/HeaderRow.js
var HeaderRow = function HeaderRow$1(props) {
	var cells = props.cells, stickyOffsets = props.stickyOffsets, flattenColumns = props.flattenColumns, RowComponent = props.rowComponent, CellComponent = props.cellComponent, onHeaderRow = props.onHeaderRow, index$2 = props.index;
	var _useContext = useContext$2(TableContext_default, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction;
	var rowProps;
	if (onHeaderRow) rowProps = onHeaderRow(cells.map(function(cell) {
		return cell.column;
	}), index$2);
	var columnsKey = getColumnsKey(cells.map(function(cell) {
		return cell.column;
	}));
	return /* @__PURE__ */ import_react.createElement(RowComponent, rowProps, cells.map(function(cell, cellIndex) {
		var column$1 = cell.column;
		var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction);
		var additionalProps;
		if (column$1 && column$1.onHeaderCell) additionalProps = cell.column.onHeaderCell(column$1);
		return /* @__PURE__ */ import_react.createElement(Cell_default, _extends({}, cell, {
			scope: column$1.title ? cell.colSpan > 1 ? "colgroup" : "col" : null,
			ellipsis: column$1.ellipsis,
			align: column$1.align,
			component: CellComponent,
			prefixCls,
			key: columnsKey[cellIndex]
		}, fixedInfo, {
			additionalProps,
			rowType: "header"
		}));
	}));
};
HeaderRow.displayName = "HeaderRow";
var HeaderRow_default = HeaderRow;

//#endregion
//#region node_modules/rc-table/es/Header/Header.js
function parseHeaderRows(rootColumns) {
	var rows = [];
	function fillRowCells(columns, colIndex) {
		var rowIndex$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
		rows[rowIndex$1] = rows[rowIndex$1] || [];
		var currentColIndex = colIndex;
		return columns.filter(Boolean).map(function(column$1) {
			var cell = {
				key: column$1.key,
				className: column$1.className || "",
				children: column$1.title,
				column: column$1,
				colStart: currentColIndex
			};
			var colSpan = 1;
			var subColumns = column$1.children;
			if (subColumns && subColumns.length > 0) {
				colSpan = fillRowCells(subColumns, currentColIndex, rowIndex$1 + 1).reduce(function(total, count) {
					return total + count;
				}, 0);
				cell.hasSubColumns = true;
			}
			if ("colSpan" in column$1) colSpan = column$1.colSpan;
			if ("rowSpan" in column$1) cell.rowSpan = column$1.rowSpan;
			cell.colSpan = colSpan;
			cell.colEnd = cell.colStart + colSpan - 1;
			rows[rowIndex$1].push(cell);
			currentColIndex += colSpan;
			return colSpan;
		});
	}
	fillRowCells(rootColumns, 0);
	var rowCount = rows.length;
	var _loop = function _loop$1(rowIndex$1) {
		rows[rowIndex$1].forEach(function(cell) {
			if (!("rowSpan" in cell) && !cell.hasSubColumns) cell.rowSpan = rowCount - rowIndex$1;
		});
	};
	for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) _loop(rowIndex);
	return rows;
}
var Header = function Header$2(props) {
	useRenderTimes_default(props);
	var stickyOffsets = props.stickyOffsets, columns = props.columns, flattenColumns = props.flattenColumns, onHeaderRow = props.onHeaderRow;
	var _useContext = useContext$2(TableContext_default, ["prefixCls", "getComponent"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent;
	var rows = import_react.useMemo(function() {
		return parseHeaderRows(columns);
	}, [columns]);
	var WrapperComponent = getComponent(["header", "wrapper"], "thead");
	var trComponent = getComponent(["header", "row"], "tr");
	var thComponent = getComponent(["header", "cell"], "th");
	return /* @__PURE__ */ import_react.createElement(WrapperComponent, { className: "".concat(prefixCls, "-thead") }, rows.map(function(row, rowIndex) {
		return /* @__PURE__ */ import_react.createElement(HeaderRow_default, {
			key: rowIndex,
			flattenColumns,
			cells: row,
			stickyOffsets,
			rowComponent: trComponent,
			cellComponent: thComponent,
			onHeaderRow,
			index: rowIndex
		});
	}));
};
var Header_default = responseImmutable(Header);

//#endregion
//#region node_modules/rc-table/es/hooks/useColumns/useWidthColumns.js
function parseColWidth(totalWidth) {
	var width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
	if (typeof width === "number") return width;
	if (width.endsWith("%")) return totalWidth * parseFloat(width) / 100;
	return null;
}
/**
* Fill all column with width
*/
function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {
	return import_react.useMemo(function() {
		if (scrollWidth && scrollWidth > 0) {
			var totalWidth = 0;
			var missWidthCount = 0;
			flattenColumns.forEach(function(col) {
				var colWidth = parseColWidth(scrollWidth, col.width);
				if (colWidth) totalWidth += colWidth;
				else missWidthCount += 1;
			});
			var maxFitWidth = Math.max(scrollWidth, clientWidth);
			var restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);
			var restCount = missWidthCount;
			var avgWidth = restWidth / missWidthCount;
			var realTotal = 0;
			var filledColumns = flattenColumns.map(function(col) {
				var clone = _objectSpread2({}, col);
				var colWidth = parseColWidth(scrollWidth, clone.width);
				if (colWidth) clone.width = colWidth;
				else {
					var colAvgWidth = Math.floor(avgWidth);
					clone.width = restCount === 1 ? restWidth : colAvgWidth;
					restWidth -= colAvgWidth;
					restCount -= 1;
				}
				realTotal += clone.width;
				return clone;
			});
			if (realTotal < maxFitWidth) {
				var scale = maxFitWidth / realTotal;
				restWidth = maxFitWidth;
				filledColumns.forEach(function(col, index$2) {
					var colWidth = Math.floor(col.width * scale);
					col.width = index$2 === filledColumns.length - 1 ? restWidth : colWidth;
					restWidth -= colWidth;
				});
			}
			return [filledColumns, Math.max(realTotal, maxFitWidth)];
		}
		return [flattenColumns, scrollWidth];
	}, [
		flattenColumns,
		scrollWidth,
		clientWidth
	]);
}

//#endregion
//#region node_modules/rc-table/es/hooks/useColumns/index.js
var _excluded$8 = ["children"], _excluded2 = ["fixed"];
function convertChildrenToColumns(children) {
	return toArray(children).filter(function(node$1) {
		return /* @__PURE__ */ import_react.isValidElement(node$1);
	}).map(function(_ref) {
		var key = _ref.key, props = _ref.props;
		var nodeChildren = props.children, restProps = _objectWithoutProperties(props, _excluded$8);
		var column$1 = _objectSpread2({ key }, restProps);
		if (nodeChildren) column$1.children = convertChildrenToColumns(nodeChildren);
		return column$1;
	});
}
function filterHiddenColumns(columns) {
	return columns.filter(function(column$1) {
		return column$1 && _typeof(column$1) === "object" && !column$1.hidden;
	}).map(function(column$1) {
		var subColumns = column$1.children;
		if (subColumns && subColumns.length > 0) return _objectSpread2(_objectSpread2({}, column$1), {}, { children: filterHiddenColumns(subColumns) });
		return column$1;
	});
}
function flatColumns(columns) {
	var parentKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key";
	return columns.filter(function(column$1) {
		return column$1 && _typeof(column$1) === "object";
	}).reduce(function(list, column$1, index$2) {
		var fixed = column$1.fixed;
		var parsedFixed = fixed === true ? "left" : fixed;
		var mergedKey = "".concat(parentKey, "-").concat(index$2);
		var subColumns = column$1.children;
		if (subColumns && subColumns.length > 0) return [].concat(_toConsumableArray(list), _toConsumableArray(flatColumns(subColumns, mergedKey).map(function(subColum) {
			var _subColum$fixed;
			return _objectSpread2(_objectSpread2({}, subColum), {}, { fixed: (_subColum$fixed = subColum.fixed) !== null && _subColum$fixed !== void 0 ? _subColum$fixed : parsedFixed });
		})));
		return [].concat(_toConsumableArray(list), [_objectSpread2(_objectSpread2({ key: mergedKey }, column$1), {}, { fixed: parsedFixed })]);
	}, []);
}
function revertForRtl(columns) {
	return columns.map(function(column$1) {
		var fixed = column$1.fixed, restProps = _objectWithoutProperties(column$1, _excluded2);
		var parsedFixed = fixed;
		if (fixed === "left") parsedFixed = "right";
		else if (fixed === "right") parsedFixed = "left";
		return _objectSpread2({ fixed: parsedFixed }, restProps);
	});
}
/**
* Parse `columns` & `children` into `columns`.
*/
function useColumns(_ref2, transformColumns) {
	var prefixCls = _ref2.prefixCls, columns = _ref2.columns, children = _ref2.children, expandable = _ref2.expandable, expandedKeys = _ref2.expandedKeys, columnTitle = _ref2.columnTitle, getRowKey = _ref2.getRowKey, onTriggerExpand = _ref2.onTriggerExpand, expandIcon = _ref2.expandIcon, rowExpandable = _ref2.rowExpandable, expandIconColumnIndex = _ref2.expandIconColumnIndex, _ref2$expandedRowOffs = _ref2.expandedRowOffset, expandedRowOffset = _ref2$expandedRowOffs === void 0 ? 0 : _ref2$expandedRowOffs, direction = _ref2.direction, expandRowByClick = _ref2.expandRowByClick, columnWidth = _ref2.columnWidth, fixed = _ref2.fixed, scrollWidth = _ref2.scrollWidth, clientWidth = _ref2.clientWidth;
	var baseColumns = import_react.useMemo(function() {
		var newColumns = columns || convertChildrenToColumns(children) || [];
		return filterHiddenColumns(newColumns.slice());
	}, [columns, children]);
	var withExpandColumns = import_react.useMemo(function() {
		if (expandable) {
			var cloneColumns = baseColumns.slice();
			if (expandIconColumnIndex >= 0) warning_default(false, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead.");
			if (!cloneColumns.includes(EXPAND_COLUMN)) {
				var expandColIndex = expandIconColumnIndex || 0;
				var insertIndex = expandColIndex === 0 && fixed === "right" ? baseColumns.length : expandColIndex;
				if (insertIndex >= 0) cloneColumns.splice(insertIndex, 0, EXPAND_COLUMN);
			}
			if (cloneColumns.filter(function(c) {
				return c === EXPAND_COLUMN;
			}).length > 1) warning_default(false, "There exist more than one `EXPAND_COLUMN` in `columns`.");
			var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
			cloneColumns = cloneColumns.filter(function(column$1, index$2) {
				return column$1 !== EXPAND_COLUMN || index$2 === expandColumnIndex;
			});
			var prevColumn = baseColumns[expandColumnIndex];
			var fixedColumn;
			if (fixed) fixedColumn = fixed;
			else fixedColumn = prevColumn ? prevColumn.fixed : null;
			var expandColumn = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, INTERNAL_COL_DEFINE, {
				className: "".concat(prefixCls, "-expand-icon-col"),
				columnType: "EXPAND_COLUMN"
			}), "title", columnTitle), "fixed", fixedColumn), "className", "".concat(prefixCls, "-row-expand-icon-cell")), "width", columnWidth), "render", function render$1(_, record, index$2) {
				var rowKey = getRowKey(record, index$2);
				var expanded = expandedKeys.has(rowKey);
				var recordExpandable = rowExpandable ? rowExpandable(record) : true;
				var icon = expandIcon({
					prefixCls,
					expanded,
					expandable: recordExpandable,
					record,
					onExpand: onTriggerExpand
				});
				if (expandRowByClick) return /* @__PURE__ */ import_react.createElement("span", { onClick: function onClick(e$2) {
					return e$2.stopPropagation();
				} }, icon);
				return icon;
			});
			return cloneColumns.map(function(col, index$2) {
				var column$1 = col === EXPAND_COLUMN ? expandColumn : col;
				if (index$2 < expandedRowOffset) return _objectSpread2(_objectSpread2({}, column$1), {}, { fixed: column$1.fixed || "left" });
				return column$1;
			});
		}
		if (baseColumns.includes(EXPAND_COLUMN)) warning_default(false, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`.");
		return baseColumns.filter(function(col) {
			return col !== EXPAND_COLUMN;
		});
	}, [
		expandable,
		baseColumns,
		getRowKey,
		expandedKeys,
		expandIcon,
		direction,
		expandedRowOffset
	]);
	var mergedColumns = import_react.useMemo(function() {
		var finalColumns = withExpandColumns;
		if (transformColumns) finalColumns = transformColumns(finalColumns);
		if (!finalColumns.length) finalColumns = [{ render: function render$1() {
			return null;
		} }];
		return finalColumns;
	}, [
		transformColumns,
		withExpandColumns,
		direction
	]);
	var flattenColumns = import_react.useMemo(function() {
		if (direction === "rtl") return revertForRtl(flatColumns(mergedColumns));
		return flatColumns(mergedColumns);
	}, [
		mergedColumns,
		direction,
		scrollWidth
	]);
	var hasGapFixed = import_react.useMemo(function() {
		var lastLeftIndex = -1;
		for (var i = flattenColumns.length - 1; i >= 0; i -= 1) {
			var colFixed = flattenColumns[i].fixed;
			if (colFixed === "left" || colFixed === true) {
				lastLeftIndex = i;
				break;
			}
		}
		if (lastLeftIndex >= 0) for (var _i = 0; _i <= lastLeftIndex; _i += 1) {
			var _colFixed = flattenColumns[_i].fixed;
			if (_colFixed !== "left" && _colFixed !== true) return true;
		}
		var firstRightIndex = flattenColumns.findIndex(function(_ref3) {
			return _ref3.fixed === "right";
		});
		if (firstRightIndex >= 0) {
			for (var _i2 = firstRightIndex; _i2 < flattenColumns.length; _i2 += 1) if (flattenColumns[_i2].fixed !== "right") return true;
		}
		return false;
	}, [flattenColumns]);
	var _useWidthColumns = useWidthColumns(flattenColumns, scrollWidth, clientWidth), _useWidthColumns2 = _slicedToArray(_useWidthColumns, 2), filledColumns = _useWidthColumns2[0], realScrollWidth = _useWidthColumns2[1];
	return [
		mergedColumns,
		filledColumns,
		realScrollWidth,
		hasGapFixed
	];
}
var useColumns_default = useColumns;

//#endregion
//#region node_modules/rc-table/es/hooks/useExpand.js
function useExpand(props, mergedData, getRowKey) {
	var expandableConfig = getExpandableProps(props);
	var expandIcon = expandableConfig.expandIcon, expandedRowKeys = expandableConfig.expandedRowKeys, defaultExpandedRowKeys = expandableConfig.defaultExpandedRowKeys, defaultExpandAllRows = expandableConfig.defaultExpandAllRows, expandedRowRender = expandableConfig.expandedRowRender, onExpand = expandableConfig.onExpand, onExpandedRowsChange = expandableConfig.onExpandedRowsChange, childrenColumnName = expandableConfig.childrenColumnName;
	var mergedExpandIcon = expandIcon || renderExpandIcon$1;
	var mergedChildrenColumnName = childrenColumnName || "children";
	var expandableType = import_react.useMemo(function() {
		if (expandedRowRender) return "row";
		/**
		* Fix https://github.com/ant-design/ant-design/issues/21154
		* This is a workaround to not to break current behavior.
		* We can remove follow code after final release.
		*
		* To other developer:
		*  Do not use `__PARENT_RENDER_ICON__` in prod since we will remove this when refactor
		*/
		if (props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(function(record) {
			return record && _typeof(record) === "object" && record[mergedChildrenColumnName];
		})) return "nest";
		return false;
	}, [!!expandedRowRender, mergedData]);
	var _React$useState = import_react.useState(function() {
		if (defaultExpandedRowKeys) return defaultExpandedRowKeys;
		if (defaultExpandAllRows) return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
		return [];
	}), _React$useState2 = _slicedToArray(_React$useState, 2), innerExpandedKeys = _React$useState2[0], setInnerExpandedKeys = _React$useState2[1];
	var mergedExpandedKeys = import_react.useMemo(function() {
		return new Set(expandedRowKeys || innerExpandedKeys || []);
	}, [expandedRowKeys, innerExpandedKeys]);
	var onTriggerExpand = import_react.useCallback(function(record) {
		var key = getRowKey(record, mergedData.indexOf(record));
		var newExpandedKeys;
		var hasKey = mergedExpandedKeys.has(key);
		if (hasKey) {
			mergedExpandedKeys.delete(key);
			newExpandedKeys = _toConsumableArray(mergedExpandedKeys);
		} else newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys), [key]);
		setInnerExpandedKeys(newExpandedKeys);
		if (onExpand) onExpand(!hasKey, record);
		if (onExpandedRowsChange) onExpandedRowsChange(newExpandedKeys);
	}, [
		getRowKey,
		mergedExpandedKeys,
		mergedData,
		onExpand,
		onExpandedRowsChange
	]);
	if (expandedRowRender && mergedData.some(function(record) {
		return Array.isArray(record === null || record === void 0 ? void 0 : record[mergedChildrenColumnName]);
	})) warning_default(false, "`expandedRowRender` should not use with nested Table");
	return [
		expandableConfig,
		expandableType,
		mergedExpandedKeys,
		mergedExpandIcon,
		mergedChildrenColumnName,
		onTriggerExpand
	];
}

//#endregion
//#region node_modules/rc-table/es/hooks/useFixedInfo.js
function useFixedInfo(flattenColumns, stickyOffsets, direction) {
	var fixedInfoList = flattenColumns.map(function(_, colIndex) {
		return getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction);
	});
	return useMemo$1(function() {
		return fixedInfoList;
	}, [fixedInfoList], function(prev$1, next$1) {
		return !isEqual_default(prev$1, next$1);
	});
}

//#endregion
//#region node_modules/rc-table/es/hooks/useFrame.js
/**
* Execute code before next frame but async
*/
function useLayoutState(defaultState) {
	var stateRef = (0, import_react.useRef)(defaultState);
	var _useState = (0, import_react.useState)({}), _useState2 = _slicedToArray(_useState, 2), forceUpdate = _useState2[1];
	var lastPromiseRef = (0, import_react.useRef)(null);
	var updateBatchRef = (0, import_react.useRef)([]);
	function setFrameState(updater) {
		updateBatchRef.current.push(updater);
		var promise = Promise.resolve();
		lastPromiseRef.current = promise;
		promise.then(function() {
			if (lastPromiseRef.current === promise) {
				var prevBatch = updateBatchRef.current;
				var prevState = stateRef.current;
				updateBatchRef.current = [];
				prevBatch.forEach(function(batchUpdater) {
					stateRef.current = batchUpdater(stateRef.current);
				});
				lastPromiseRef.current = null;
				if (prevState !== stateRef.current) forceUpdate({});
			}
		});
	}
	(0, import_react.useEffect)(function() {
		return function() {
			lastPromiseRef.current = null;
		};
	}, []);
	return [stateRef.current, setFrameState];
}
/** Lock frame, when frame pass reset the lock. */
function useTimeoutLock(defaultState) {
	var frameRef = (0, import_react.useRef)(defaultState || null);
	var timeoutRef = (0, import_react.useRef)();
	function cleanUp() {
		window.clearTimeout(timeoutRef.current);
	}
	function setState(newState) {
		frameRef.current = newState;
		cleanUp();
		timeoutRef.current = window.setTimeout(function() {
			frameRef.current = null;
			timeoutRef.current = void 0;
		}, 100);
	}
	function getState() {
		return frameRef.current;
	}
	(0, import_react.useEffect)(function() {
		return cleanUp;
	}, []);
	return [setState, getState];
}

//#endregion
//#region node_modules/rc-table/es/hooks/useHover.js
function useHover() {
	var _React$useState = import_react.useState(-1), _React$useState2 = _slicedToArray(_React$useState, 2), startRow = _React$useState2[0], setStartRow = _React$useState2[1];
	var _React$useState3 = import_react.useState(-1), _React$useState4 = _slicedToArray(_React$useState3, 2), endRow = _React$useState4[0], setEndRow = _React$useState4[1];
	var onHover = import_react.useCallback(function(start, end) {
		setStartRow(start);
		setEndRow(end);
	}, []);
	return [
		startRow,
		endRow,
		onHover
	];
}

//#endregion
//#region node_modules/rc-table/es/hooks/useSticky.js
var defaultContainer = canUseDom() ? window : null;
/** Sticky header hooks */
function useSticky(sticky, prefixCls) {
	var _ref = _typeof(sticky) === "object" ? sticky : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer;
	var container = (_ref$getContainer === void 0 ? function() {
		return defaultContainer;
	} : _ref$getContainer)() || defaultContainer;
	var isSticky = !!sticky;
	return import_react.useMemo(function() {
		return {
			isSticky,
			stickyClassName: isSticky ? "".concat(prefixCls, "-sticky-holder") : "",
			offsetHeader,
			offsetSummary,
			offsetScroll,
			container
		};
	}, [
		isSticky,
		offsetScroll,
		offsetHeader,
		offsetSummary,
		prefixCls,
		container
	]);
}

//#endregion
//#region node_modules/rc-table/es/hooks/useStickyOffsets.js
/**
* Get sticky column offset width
*/
function useStickyOffsets(colWidths, flattenColumns, direction) {
	return (0, import_react.useMemo)(function() {
		var columnCount = flattenColumns.length;
		var getOffsets = function getOffsets$1(startIndex, endIndex, offset$2) {
			var offsets = [];
			var total = 0;
			for (var i = startIndex; i !== endIndex; i += offset$2) {
				offsets.push(total);
				if (flattenColumns[i].fixed) total += colWidths[i] || 0;
			}
			return offsets;
		};
		var startOffsets = getOffsets(0, columnCount, 1);
		var endOffsets = getOffsets(columnCount - 1, -1, -1).reverse();
		return direction === "rtl" ? {
			left: endOffsets,
			right: startOffsets
		} : {
			left: startOffsets,
			right: endOffsets
		};
	}, [
		colWidths,
		flattenColumns,
		direction
	]);
}
var useStickyOffsets_default = useStickyOffsets;

//#endregion
//#region node_modules/rc-table/es/Panel/index.js
function Panel$1(_ref) {
	var className = _ref.className, children = _ref.children;
	return /* @__PURE__ */ import_react.createElement("div", { className }, children);
}
var Panel_default$1 = Panel$1;

//#endregion
//#region node_modules/rc-table/es/utils/offsetUtil.js
function getOffset(node$1) {
	var box$1 = getDOM(node$1).getBoundingClientRect();
	var docElem = document.documentElement;
	return {
		left: box$1.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
		top: box$1.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
	};
}

//#endregion
//#region node_modules/rc-table/es/stickyScrollBar.js
var import_classnames$44 = /* @__PURE__ */ __toESM(require_classnames());
var StickyScrollBar = function StickyScrollBar$1(_ref, ref) {
	var _scrollBodyRef$curren, _scrollBodyRef$curren2;
	var scrollBodyRef = _ref.scrollBodyRef, onScroll = _ref.onScroll, offsetScroll = _ref.offsetScroll, container = _ref.container, direction = _ref.direction;
	var prefixCls = useContext$2(TableContext_default, "prefixCls");
	var bodyScrollWidth = ((_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 ? void 0 : _scrollBodyRef$curren.scrollWidth) || 0;
	var bodyWidth = ((_scrollBodyRef$curren2 = scrollBodyRef.current) === null || _scrollBodyRef$curren2 === void 0 ? void 0 : _scrollBodyRef$curren2.clientWidth) || 0;
	var scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
	var scrollBarRef = import_react.useRef();
	var _useLayoutState = useLayoutState({
		scrollLeft: 0,
		isHiddenScrollBar: true
	}), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1];
	var refState = import_react.useRef({
		delta: 0,
		x: 0
	});
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), isActive$1 = _React$useState2[0], setActive = _React$useState2[1];
	var rafRef = import_react.useRef(null);
	import_react.useEffect(function() {
		return function() {
			raf_default.cancel(rafRef.current);
		};
	}, []);
	var onMouseUp = function onMouseUp$1() {
		setActive(false);
	};
	var onMouseDown = function onMouseDown$1(event) {
		event.persist();
		refState.current.delta = event.pageX - scrollState.scrollLeft;
		refState.current.x = 0;
		setActive(true);
		event.preventDefault();
	};
	var onMouseMove = function onMouseMove$1(event) {
		var _window;
		var _ref2 = event || ((_window = window) === null || _window === void 0 ? void 0 : _window.event), buttons = _ref2.buttons;
		if (!isActive$1 || buttons === 0) {
			if (isActive$1) setActive(false);
			return;
		}
		var left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
		var isRTL = direction === "rtl";
		left = Math.max(isRTL ? scrollBarWidth - bodyWidth : 0, Math.min(isRTL ? 0 : bodyWidth - scrollBarWidth, left));
		if (!isRTL || Math.abs(left) + Math.abs(scrollBarWidth) < bodyWidth) {
			onScroll({ scrollLeft: left / bodyWidth * (bodyScrollWidth + 2) });
			refState.current.x = event.pageX;
		}
	};
	var checkScrollBarVisible = function checkScrollBarVisible$1() {
		raf_default.cancel(rafRef.current);
		rafRef.current = raf_default(function() {
			if (!scrollBodyRef.current) return;
			var tableOffsetTop = getOffset(scrollBodyRef.current).top;
			var tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
			var currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container).top + container.clientHeight;
			setScrollState(function(state) {
				return _objectSpread2(_objectSpread2({}, state), {}, { isHiddenScrollBar: tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll });
			});
		});
	};
	var setScrollLeft = function setScrollLeft$1(left) {
		setScrollState(function(state) {
			return _objectSpread2(_objectSpread2({}, state), {}, { scrollLeft: bodyScrollWidth ? left / bodyScrollWidth * bodyWidth : 0 });
		});
	};
	import_react.useImperativeHandle(ref, function() {
		return {
			setScrollLeft,
			checkScrollBarVisible
		};
	});
	import_react.useEffect(function() {
		var onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
		var onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
		checkScrollBarVisible();
		return function() {
			onMouseUpListener.remove();
			onMouseMoveListener.remove();
		};
	}, [scrollBarWidth, isActive$1]);
	import_react.useEffect(function() {
		if (!scrollBodyRef.current) return;
		var scrollParents = [];
		var parent = getDOM(scrollBodyRef.current);
		while (parent) {
			scrollParents.push(parent);
			parent = parent.parentElement;
		}
		scrollParents.forEach(function(p) {
			return p.addEventListener("scroll", checkScrollBarVisible, false);
		});
		window.addEventListener("resize", checkScrollBarVisible, false);
		window.addEventListener("scroll", checkScrollBarVisible, false);
		container.addEventListener("scroll", checkScrollBarVisible, false);
		return function() {
			scrollParents.forEach(function(p) {
				return p.removeEventListener("scroll", checkScrollBarVisible);
			});
			window.removeEventListener("resize", checkScrollBarVisible);
			window.removeEventListener("scroll", checkScrollBarVisible);
			container.removeEventListener("scroll", checkScrollBarVisible);
		};
	}, [container]);
	import_react.useEffect(function() {
		if (!scrollState.isHiddenScrollBar) setScrollState(function(state) {
			var bodyNode = scrollBodyRef.current;
			if (!bodyNode) return state;
			return _objectSpread2(_objectSpread2({}, state), {}, { scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth });
		});
	}, [scrollState.isHiddenScrollBar]);
	if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) return null;
	return /* @__PURE__ */ import_react.createElement("div", {
		style: {
			height: getScrollBarSize(),
			width: bodyWidth,
			bottom: offsetScroll
		},
		className: "".concat(prefixCls, "-sticky-scroll")
	}, /* @__PURE__ */ import_react.createElement("div", {
		onMouseDown,
		ref: scrollBarRef,
		className: (0, import_classnames$44.default)("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive$1)),
		style: {
			width: "".concat(scrollBarWidth, "px"),
			transform: "translate3d(".concat(scrollState.scrollLeft, "px, 0, 0)")
		}
	}));
};
var stickyScrollBar_default = /* @__PURE__ */ import_react.forwardRef(StickyScrollBar);

//#endregion
//#region node_modules/rc-table/es/Table.js
var import_classnames$43 = /* @__PURE__ */ __toESM(require_classnames());
var DEFAULT_PREFIX = "rc-table";
var EMPTY_DATA = [];
var EMPTY_SCROLL_TARGET = {};
function defaultEmpty() {
	return "No Data";
}
function Table$1(tableProps, ref) {
	var props = _objectSpread2({
		rowKey: "key",
		prefixCls: DEFAULT_PREFIX,
		emptyText: defaultEmpty
	}, tableProps);
	var prefixCls = props.prefixCls, className = props.className, rowClassName = props.rowClassName, style$1 = props.style, data = props.data, rowKey = props.rowKey, scroll = props.scroll, tableLayout = props.tableLayout, direction = props.direction, title = props.title, footer = props.footer, summary = props.summary, caption = props.caption, id = props.id, showHeader = props.showHeader, components$1 = props.components, emptyText = props.emptyText, onRow = props.onRow, onHeaderRow = props.onHeaderRow, measureRowRender = props.measureRowRender, onScroll = props.onScroll, internalHooks = props.internalHooks, transformColumns = props.transformColumns, internalRefs = props.internalRefs, tailor = props.tailor, getContainerWidth = props.getContainerWidth, sticky = props.sticky, _props$rowHoverable = props.rowHoverable, rowHoverable = _props$rowHoverable === void 0 ? true : _props$rowHoverable;
	var mergedData = data || EMPTY_DATA;
	var hasData = !!mergedData.length;
	var useInternalHooks = internalHooks === INTERNAL_HOOKS;
	[
		"onRowClick",
		"onRowDoubleClick",
		"onRowContextMenu",
		"onRowMouseEnter",
		"onRowMouseLeave"
	].forEach(function(name) {
		warning_default(props[name] === void 0, "`".concat(name, "` is removed, please use `onRow` instead."));
	});
	warning_default(!("getBodyWrapper" in props), "`getBodyWrapper` is deprecated, please use custom `components` instead.");
	var getComponent = import_react.useCallback(function(path$1, defaultComponent) {
		return get(components$1, path$1) || defaultComponent;
	}, [components$1]);
	var getRowKey = import_react.useMemo(function() {
		if (typeof rowKey === "function") return rowKey;
		return function(record) {
			var key = record && record[rowKey];
			warning_default(key !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key.");
			return key;
		};
	}, [rowKey]);
	var customizeScrollBody = getComponent(["body"]);
	var _useHover = useHover(), _useHover2 = _slicedToArray(_useHover, 3), startRow = _useHover2[0], endRow = _useHover2[1], onHover = _useHover2[2];
	var _useExpand = useExpand(props, mergedData, getRowKey), _useExpand2 = _slicedToArray(_useExpand, 6), expandableConfig = _useExpand2[0], expandableType = _useExpand2[1], mergedExpandedKeys = _useExpand2[2], mergedExpandIcon = _useExpand2[3], mergedChildrenColumnName = _useExpand2[4], onTriggerExpand = _useExpand2[5];
	var scrollX = scroll === null || scroll === void 0 ? void 0 : scroll.x;
	var _React$useState = import_react.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), componentWidth = _React$useState2[0], setComponentWidth = _React$useState2[1];
	var _useColumns = useColumns_default(_objectSpread2(_objectSpread2(_objectSpread2({}, props), expandableConfig), {}, {
		expandable: !!expandableConfig.expandedRowRender,
		columnTitle: expandableConfig.columnTitle,
		expandedKeys: mergedExpandedKeys,
		getRowKey,
		onTriggerExpand,
		expandIcon: mergedExpandIcon,
		expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
		direction,
		scrollWidth: useInternalHooks && tailor && typeof scrollX === "number" ? scrollX : null,
		clientWidth: componentWidth
	}), useInternalHooks ? transformColumns : null), _useColumns2 = _slicedToArray(_useColumns, 4), columns = _useColumns2[0], flattenColumns = _useColumns2[1], flattenScrollX = _useColumns2[2], hasGapFixed = _useColumns2[3];
	var mergedScrollX = flattenScrollX !== null && flattenScrollX !== void 0 ? flattenScrollX : scrollX;
	var columnContext = import_react.useMemo(function() {
		return {
			columns,
			flattenColumns
		};
	}, [columns, flattenColumns]);
	var fullTableRef = import_react.useRef();
	var scrollHeaderRef = import_react.useRef();
	var scrollBodyRef = import_react.useRef();
	var scrollBodyContainerRef = import_react.useRef();
	import_react.useImperativeHandle(ref, function() {
		return {
			nativeElement: fullTableRef.current,
			scrollTo: function scrollTo$1(config) {
				var _scrollBodyRef$curren3;
				if (scrollBodyRef.current instanceof HTMLElement) {
					var index$2 = config.index, top = config.top, key = config.key;
					if (validNumberValue(top)) {
						var _scrollBodyRef$curren;
						(_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 || _scrollBodyRef$curren.scrollTo({ top });
					} else {
						var _scrollBodyRef$curren2;
						var mergedKey = key !== null && key !== void 0 ? key : getRowKey(mergedData[index$2]);
						(_scrollBodyRef$curren2 = scrollBodyRef.current.querySelector("[data-row-key=\"".concat(mergedKey, "\"]"))) === null || _scrollBodyRef$curren2 === void 0 || _scrollBodyRef$curren2.scrollIntoView();
					}
				} else if ((_scrollBodyRef$curren3 = scrollBodyRef.current) !== null && _scrollBodyRef$curren3 !== void 0 && _scrollBodyRef$curren3.scrollTo) scrollBodyRef.current.scrollTo(config);
			}
		};
	});
	var scrollSummaryRef = import_react.useRef();
	var _React$useState3 = import_react.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), pingedLeft = _React$useState4[0], setPingedLeft = _React$useState4[1];
	var _React$useState5 = import_react.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), pingedRight = _React$useState6[0], setPingedRight = _React$useState6[1];
	var _React$useState7 = import_react.useState(/* @__PURE__ */ new Map()), _React$useState8 = _slicedToArray(_React$useState7, 2), colsWidths = _React$useState8[0], updateColsWidths = _React$useState8[1];
	var pureColWidths = getColumnsKey(flattenColumns).map(function(columnKey) {
		return colsWidths.get(columnKey);
	});
	var colWidths = import_react.useMemo(function() {
		return pureColWidths;
	}, [pureColWidths.join("_")]);
	var stickyOffsets = useStickyOffsets_default(colWidths, flattenColumns, direction);
	var fixHeader = scroll && validateValue(scroll.y);
	var horizonScroll = scroll && validateValue(mergedScrollX) || Boolean(expandableConfig.fixed);
	var fixColumn = horizonScroll && flattenColumns.some(function(_ref) {
		return _ref.fixed;
	});
	var stickyRef = import_react.useRef();
	var _useSticky = useSticky(sticky, prefixCls), isSticky = _useSticky.isSticky, offsetHeader = _useSticky.offsetHeader, offsetSummary = _useSticky.offsetSummary, offsetScroll = _useSticky.offsetScroll, stickyClassName = _useSticky.stickyClassName, container = _useSticky.container;
	var summaryNode = import_react.useMemo(function() {
		return summary === null || summary === void 0 ? void 0 : summary(mergedData);
	}, [summary, mergedData]);
	var fixFooter = (fixHeader || isSticky) && /* @__PURE__ */ import_react.isValidElement(summaryNode) && summaryNode.type === Summary_default && summaryNode.props.fixed;
	var scrollXStyle;
	var scrollYStyle;
	var scrollTableStyle;
	if (fixHeader) scrollYStyle = {
		overflowY: hasData ? "scroll" : "auto",
		maxHeight: scroll.y
	};
	if (horizonScroll) {
		scrollXStyle = { overflowX: "auto" };
		if (!fixHeader) scrollYStyle = { overflowY: "hidden" };
		scrollTableStyle = {
			width: mergedScrollX === true ? "auto" : mergedScrollX,
			minWidth: "100%"
		};
	}
	var onColumnResize = import_react.useCallback(function(columnKey, width) {
		updateColsWidths(function(widths) {
			if (widths.get(columnKey) !== width) {
				var newWidths = new Map(widths);
				newWidths.set(columnKey, width);
				return newWidths;
			}
			return widths;
		});
	}, []);
	var _useTimeoutLock = useTimeoutLock(null), _useTimeoutLock2 = _slicedToArray(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
	function forceScroll(scrollLeft, target) {
		if (!target) return;
		if (typeof target === "function") target(scrollLeft);
		else if (target.scrollLeft !== scrollLeft) {
			target.scrollLeft = scrollLeft;
			if (target.scrollLeft !== scrollLeft) setTimeout(function() {
				target.scrollLeft = scrollLeft;
			}, 0);
		}
	}
	var onInternalScroll = useEvent(function(_ref2) {
		var currentTarget = _ref2.currentTarget, scrollLeft = _ref2.scrollLeft;
		var isRTL = direction === "rtl";
		var mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
		var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
		if (!getScrollTarget() || getScrollTarget() === compareTarget) {
			var _stickyRef$current;
			setScrollTarget(compareTarget);
			forceScroll(mergedScrollLeft, scrollHeaderRef.current);
			forceScroll(mergedScrollLeft, scrollBodyRef.current);
			forceScroll(mergedScrollLeft, scrollSummaryRef.current);
			forceScroll(mergedScrollLeft, (_stickyRef$current = stickyRef.current) === null || _stickyRef$current === void 0 ? void 0 : _stickyRef$current.setScrollLeft);
		}
		var measureTarget = currentTarget || scrollHeaderRef.current;
		if (measureTarget) {
			var scrollWidth = useInternalHooks && tailor && typeof mergedScrollX === "number" ? mergedScrollX : measureTarget.scrollWidth;
			var clientWidth = measureTarget.clientWidth;
			if (scrollWidth === clientWidth) {
				setPingedLeft(false);
				setPingedRight(false);
				return;
			}
			if (isRTL) {
				setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
				setPingedRight(-mergedScrollLeft > 0);
			} else {
				setPingedLeft(mergedScrollLeft > 0);
				setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
			}
		}
	});
	var onBodyScroll = useEvent(function(e$2) {
		onInternalScroll(e$2);
		onScroll === null || onScroll === void 0 || onScroll(e$2);
	});
	var triggerOnScroll = function triggerOnScroll$1() {
		if (horizonScroll && scrollBodyRef.current) {
			var _scrollBodyRef$curren4;
			onInternalScroll({
				currentTarget: getDOM(scrollBodyRef.current),
				scrollLeft: (_scrollBodyRef$curren4 = scrollBodyRef.current) === null || _scrollBodyRef$curren4 === void 0 ? void 0 : _scrollBodyRef$curren4.scrollLeft
			});
		} else {
			setPingedLeft(false);
			setPingedRight(false);
		}
	};
	var onFullTableResize = function onFullTableResize$1(_ref3) {
		var _stickyRef$current2;
		var width = _ref3.width;
		(_stickyRef$current2 = stickyRef.current) === null || _stickyRef$current2 === void 0 || _stickyRef$current2.checkScrollBarVisible();
		var mergedWidth = fullTableRef.current ? fullTableRef.current.offsetWidth : width;
		if (useInternalHooks && getContainerWidth && fullTableRef.current) mergedWidth = getContainerWidth(fullTableRef.current, mergedWidth) || mergedWidth;
		if (mergedWidth !== componentWidth) {
			triggerOnScroll();
			setComponentWidth(mergedWidth);
		}
	};
	var mounted = import_react.useRef(false);
	import_react.useEffect(function() {
		if (mounted.current) triggerOnScroll();
	}, [
		horizonScroll,
		data,
		columns.length
	]);
	import_react.useEffect(function() {
		mounted.current = true;
	}, []);
	var _React$useState9 = import_react.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), scrollbarSize = _React$useState10[0], setScrollbarSize = _React$useState10[1];
	var _React$useState11 = import_react.useState(true), _React$useState12 = _slicedToArray(_React$useState11, 2), supportSticky = _React$useState12[0], setSupportSticky = _React$useState12[1];
	useLayoutEffect_default(function() {
		if (!tailor || !useInternalHooks) if (scrollBodyRef.current instanceof Element) setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
		else setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
		setSupportSticky(isStyleSupport("position", "sticky"));
	}, []);
	import_react.useEffect(function() {
		if (useInternalHooks && internalRefs) internalRefs.body.current = scrollBodyRef.current;
	});
	var renderFixedHeaderTable = import_react.useCallback(function(fixedHolderPassProps) {
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Header_default, fixedHolderPassProps), fixFooter === "top" && /* @__PURE__ */ import_react.createElement(Footer_default, fixedHolderPassProps, summaryNode));
	}, [fixFooter, summaryNode]);
	var renderFixedFooterTable = import_react.useCallback(function(fixedHolderPassProps) {
		return /* @__PURE__ */ import_react.createElement(Footer_default, fixedHolderPassProps, summaryNode);
	}, [summaryNode]);
	var TableComponent = getComponent(["table"], "table");
	var mergedTableLayout = import_react.useMemo(function() {
		if (tableLayout) return tableLayout;
		if (fixColumn) return mergedScrollX === "max-content" ? "auto" : "fixed";
		if (fixHeader || isSticky || flattenColumns.some(function(_ref4) {
			return _ref4.ellipsis;
		})) return "fixed";
		return "auto";
	}, [
		fixHeader,
		fixColumn,
		flattenColumns,
		tableLayout,
		isSticky
	]);
	var groupTableNode;
	var headerProps = {
		colWidths,
		columCount: flattenColumns.length,
		stickyOffsets,
		onHeaderRow,
		fixHeader,
		scroll
	};
	var emptyNode = import_react.useMemo(function() {
		if (hasData) return null;
		if (typeof emptyText === "function") return emptyText();
		return emptyText;
	}, [hasData, emptyText]);
	var bodyTable = /* @__PURE__ */ import_react.createElement(Body_default, {
		data: mergedData,
		measureColumnWidth: fixHeader || horizonScroll || isSticky
	});
	var bodyColGroup = /* @__PURE__ */ import_react.createElement(ColGroup_default, {
		colWidths: flattenColumns.map(function(_ref5) {
			return _ref5.width;
		}),
		columns: flattenColumns
	});
	var captionElement = caption !== null && caption !== void 0 ? /* @__PURE__ */ import_react.createElement("caption", { className: "".concat(prefixCls, "-caption") }, caption) : void 0;
	var dataProps = pickAttrs(props, { data: true });
	var ariaProps = pickAttrs(props, { aria: true });
	if (fixHeader || isSticky) {
		var bodyContent;
		if (typeof customizeScrollBody === "function") {
			bodyContent = customizeScrollBody(mergedData, {
				scrollbarSize,
				ref: scrollBodyRef,
				onScroll: onInternalScroll
			});
			headerProps.colWidths = flattenColumns.map(function(_ref6, index$2) {
				var width = _ref6.width;
				var colWidth = index$2 === flattenColumns.length - 1 ? width - scrollbarSize : width;
				if (typeof colWidth === "number" && !Number.isNaN(colWidth)) return colWidth;
				warning_default(props.columns.length === 0, "When use `components.body` with render props. Each column should have a fixed `width` value.");
				return 0;
			});
		} else bodyContent = /* @__PURE__ */ import_react.createElement("div", {
			style: _objectSpread2(_objectSpread2({}, scrollXStyle), scrollYStyle),
			onScroll: onBodyScroll,
			ref: scrollBodyRef,
			className: (0, import_classnames$43.default)("".concat(prefixCls, "-body"))
		}, /* @__PURE__ */ import_react.createElement(TableComponent, _extends({ style: _objectSpread2(_objectSpread2({}, scrollTableStyle), {}, { tableLayout: mergedTableLayout }) }, ariaProps), captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode && /* @__PURE__ */ import_react.createElement(Footer_default, {
			stickyOffsets,
			flattenColumns
		}, summaryNode)));
		var fixedHolderProps = _objectSpread2(_objectSpread2(_objectSpread2({ noData: !mergedData.length }, headerProps), columnContext), {}, {
			direction,
			stickyClassName,
			scrollX: mergedScrollX,
			tableLayout: mergedTableLayout,
			onScroll: onInternalScroll
		});
		groupTableNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, showHeader !== false && /* @__PURE__ */ import_react.createElement(FixedHolder_default, _extends({}, fixedHolderProps, {
			stickyTopOffset: offsetHeader,
			className: "".concat(prefixCls, "-header"),
			ref: scrollHeaderRef,
			colGroup: bodyColGroup
		}), renderFixedHeaderTable), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ import_react.createElement(FixedHolder_default, _extends({}, fixedHolderProps, {
			stickyBottomOffset: offsetSummary,
			className: "".concat(prefixCls, "-summary"),
			ref: scrollSummaryRef,
			colGroup: bodyColGroup
		}), renderFixedFooterTable), isSticky && scrollBodyRef.current && scrollBodyRef.current instanceof Element && /* @__PURE__ */ import_react.createElement(stickyScrollBar_default, {
			ref: stickyRef,
			offsetScroll,
			scrollBodyRef,
			onScroll: onInternalScroll,
			container,
			direction
		}));
	} else groupTableNode = /* @__PURE__ */ import_react.createElement("div", {
		style: _objectSpread2(_objectSpread2({}, scrollXStyle), scrollYStyle),
		className: (0, import_classnames$43.default)("".concat(prefixCls, "-content")),
		onScroll: onInternalScroll,
		ref: scrollBodyRef
	}, /* @__PURE__ */ import_react.createElement(TableComponent, _extends({ style: _objectSpread2(_objectSpread2({}, scrollTableStyle), {}, { tableLayout: mergedTableLayout }) }, ariaProps), captionElement, bodyColGroup, showHeader !== false && /* @__PURE__ */ import_react.createElement(Header_default, _extends({}, headerProps, columnContext)), bodyTable, summaryNode && /* @__PURE__ */ import_react.createElement(Footer_default, {
		stickyOffsets,
		flattenColumns
	}, summaryNode)));
	var fullTable = /* @__PURE__ */ import_react.createElement("div", _extends({
		className: (0, import_classnames$43.default)(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-rtl"), direction === "rtl"), "".concat(prefixCls, "-ping-left"), pingedLeft), "".concat(prefixCls, "-ping-right"), pingedRight), "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), "".concat(prefixCls, "-fixed-header"), fixHeader), "".concat(prefixCls, "-fixed-column"), fixColumn), "".concat(prefixCls, "-fixed-column-gapped"), fixColumn && hasGapFixed), "".concat(prefixCls, "-scroll-horizontal"), horizonScroll), "".concat(prefixCls, "-has-fix-left"), flattenColumns[0] && flattenColumns[0].fixed), "".concat(prefixCls, "-has-fix-right"), flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === "right")),
		style: style$1,
		id,
		ref: fullTableRef
	}, dataProps), title && /* @__PURE__ */ import_react.createElement(Panel_default$1, { className: "".concat(prefixCls, "-title") }, title(mergedData)), /* @__PURE__ */ import_react.createElement("div", {
		ref: scrollBodyContainerRef,
		className: "".concat(prefixCls, "-container")
	}, groupTableNode), footer && /* @__PURE__ */ import_react.createElement(Panel_default$1, { className: "".concat(prefixCls, "-footer") }, footer(mergedData)));
	if (horizonScroll) fullTable = /* @__PURE__ */ import_react.createElement(es_default, { onResize: onFullTableResize }, fullTable);
	var fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets, direction);
	var TableContextValue = import_react.useMemo(function() {
		return {
			scrollX: mergedScrollX,
			prefixCls,
			getComponent,
			scrollbarSize,
			direction,
			fixedInfoList,
			isSticky,
			supportSticky,
			componentWidth,
			fixHeader,
			fixColumn,
			horizonScroll,
			tableLayout: mergedTableLayout,
			rowClassName,
			expandedRowClassName: expandableConfig.expandedRowClassName,
			expandIcon: mergedExpandIcon,
			expandableType,
			expandRowByClick: expandableConfig.expandRowByClick,
			expandedRowRender: expandableConfig.expandedRowRender,
			expandedRowOffset: expandableConfig.expandedRowOffset,
			onTriggerExpand,
			expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
			indentSize: expandableConfig.indentSize,
			allColumnsFixedLeft: flattenColumns.every(function(col) {
				return col.fixed === "left";
			}),
			emptyNode,
			columns,
			flattenColumns,
			onColumnResize,
			colWidths,
			hoverStartRow: startRow,
			hoverEndRow: endRow,
			onHover,
			rowExpandable: expandableConfig.rowExpandable,
			onRow,
			getRowKey,
			expandedKeys: mergedExpandedKeys,
			childrenColumnName: mergedChildrenColumnName,
			rowHoverable,
			measureRowRender
		};
	}, [
		mergedScrollX,
		prefixCls,
		getComponent,
		scrollbarSize,
		direction,
		fixedInfoList,
		isSticky,
		supportSticky,
		componentWidth,
		fixHeader,
		fixColumn,
		horizonScroll,
		mergedTableLayout,
		rowClassName,
		expandableConfig.expandedRowClassName,
		mergedExpandIcon,
		expandableType,
		expandableConfig.expandRowByClick,
		expandableConfig.expandedRowRender,
		expandableConfig.expandedRowOffset,
		onTriggerExpand,
		expandableConfig.expandIconColumnIndex,
		expandableConfig.indentSize,
		emptyNode,
		columns,
		flattenColumns,
		onColumnResize,
		colWidths,
		startRow,
		endRow,
		onHover,
		expandableConfig.rowExpandable,
		onRow,
		getRowKey,
		mergedExpandedKeys,
		mergedChildrenColumnName,
		rowHoverable,
		measureRowRender
	]);
	return /* @__PURE__ */ import_react.createElement(TableContext_default.Provider, { value: TableContextValue }, fullTable);
}
var RefTable = /* @__PURE__ */ import_react.forwardRef(Table$1);
RefTable.displayName = "Table";
function genTable(shouldTriggerRender) {
	return makeImmutable(RefTable, shouldTriggerRender);
}
var ImmutableTable = genTable();
ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
ImmutableTable.INTERNAL_HOOKS = INTERNAL_HOOKS;
ImmutableTable.Column = Column_default$1;
ImmutableTable.ColumnGroup = ColumnGroup_default$1;
ImmutableTable.Summary = FooterComponents;
var Table_default$1 = ImmutableTable;

//#endregion
//#region node_modules/rc-table/es/VirtualTable/context.js
var StaticContext = createContext(null);
var GridContext = createContext(null);

//#endregion
//#region node_modules/rc-table/es/VirtualTable/VirtualCell.js
var import_classnames$42 = /* @__PURE__ */ __toESM(require_classnames());
/**
* Return the width of the column by `colSpan`.
* When `colSpan` is `0` will be trade as `1`.
*/
function getColumnWidth(colIndex, colSpan, columnsOffset) {
	return columnsOffset[colIndex + (colSpan || 1)] - (columnsOffset[colIndex] || 0);
}
function VirtualCell(props) {
	var rowInfo = props.rowInfo, column$1 = props.column, colIndex = props.colIndex, indent = props.indent, index$2 = props.index, component = props.component, renderIndex = props.renderIndex, record = props.record, style$1 = props.style, className = props.className, inverse = props.inverse, getHeight$1 = props.getHeight;
	var render$1 = column$1.render, dataIndex = column$1.dataIndex, columnClassName = column$1.className, colWidth = column$1.width;
	var _useContext = useContext$2(GridContext, ["columnsOffset"]), columnsOffset = _useContext.columnsOffset;
	var _getCellProps = getCellProps(rowInfo, column$1, colIndex, indent, index$2), key = _getCellProps.key, fixedInfo = _getCellProps.fixedInfo, appendCellNode = _getCellProps.appendCellNode, additionalCellProps = _getCellProps.additionalCellProps;
	var cellStyle = additionalCellProps.style, _additionalCellProps$ = additionalCellProps.colSpan, colSpan = _additionalCellProps$ === void 0 ? 1 : _additionalCellProps$, _additionalCellProps$2 = additionalCellProps.rowSpan, rowSpan = _additionalCellProps$2 === void 0 ? 1 : _additionalCellProps$2;
	var startColIndex = colIndex - 1;
	var concatColWidth = getColumnWidth(startColIndex, colSpan, columnsOffset);
	var marginOffset = colSpan > 1 ? colWidth - concatColWidth : 0;
	var mergedStyle = _objectSpread2(_objectSpread2(_objectSpread2({}, cellStyle), style$1), {}, {
		flex: "0 0 ".concat(concatColWidth, "px"),
		width: "".concat(concatColWidth, "px"),
		marginRight: marginOffset,
		pointerEvents: "auto"
	});
	var needHide = import_react.useMemo(function() {
		if (inverse) return rowSpan <= 1;
		else return colSpan === 0 || rowSpan === 0 || rowSpan > 1;
	}, [
		rowSpan,
		colSpan,
		inverse
	]);
	if (needHide) mergedStyle.visibility = "hidden";
	else if (inverse) mergedStyle.height = getHeight$1 === null || getHeight$1 === void 0 ? void 0 : getHeight$1(rowSpan);
	var mergedRender = needHide ? function() {
		return null;
	} : render$1;
	var cellSpan = {};
	if (rowSpan === 0 || colSpan === 0) {
		cellSpan.rowSpan = 1;
		cellSpan.colSpan = 1;
	}
	return /* @__PURE__ */ import_react.createElement(Cell_default, _extends({
		className: (0, import_classnames$42.default)(columnClassName, className),
		ellipsis: column$1.ellipsis,
		align: column$1.align,
		scope: column$1.rowScope,
		component,
		prefixCls: rowInfo.prefixCls,
		key,
		record,
		index: index$2,
		renderIndex,
		dataIndex,
		render: mergedRender,
		shouldCellUpdate: column$1.shouldCellUpdate
	}, fixedInfo, {
		appendNode: appendCellNode,
		additionalProps: _objectSpread2(_objectSpread2({}, additionalCellProps), {}, { style: mergedStyle }, cellSpan)
	}));
}
var VirtualCell_default = VirtualCell;

//#endregion
//#region node_modules/rc-table/es/VirtualTable/BodyLine.js
var import_classnames$41 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$7 = [
	"data",
	"index",
	"className",
	"rowKey",
	"style",
	"extra",
	"getHeight"
];
var ResponseBodyLine = responseImmutable(/* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var data = props.data, index$2 = props.index, className = props.className, rowKey = props.rowKey, style$1 = props.style, extra = props.extra, getHeight$1 = props.getHeight, restProps = _objectWithoutProperties(props, _excluded$7);
	var record = data.record, indent = data.indent, renderIndex = data.index;
	var _useContext = useContext$2(TableContext_default, [
		"prefixCls",
		"flattenColumns",
		"fixColumn",
		"componentWidth",
		"scrollX"
	]), scrollX = _useContext.scrollX, flattenColumns = _useContext.flattenColumns, prefixCls = _useContext.prefixCls, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth;
	var _useContext2 = useContext$2(StaticContext, ["getComponent"]), getComponent = _useContext2.getComponent;
	var rowInfo = useRowInfo(record, rowKey, index$2, indent);
	var RowComponent = getComponent(["body", "row"], "div");
	var cellComponent = getComponent(["body", "cell"], "div");
	var rowSupportExpand = rowInfo.rowSupportExpand, expanded = rowInfo.expanded, rowProps = rowInfo.rowProps, expandedRowRender = rowInfo.expandedRowRender, expandedRowClassName = rowInfo.expandedRowClassName;
	var expandRowNode;
	if (rowSupportExpand && expanded) {
		var expandContent = expandedRowRender(record, index$2, indent + 1, expanded);
		var expandedClsName = computedExpandedClassName(expandedRowClassName, record, index$2, indent);
		var additionalProps = {};
		if (fixColumn) additionalProps = { style: _defineProperty({}, "--virtual-width", "".concat(componentWidth, "px")) };
		var rowCellCls = "".concat(prefixCls, "-expanded-row-cell");
		expandRowNode = /* @__PURE__ */ import_react.createElement(RowComponent, { className: (0, import_classnames$41.default)("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), expandedClsName) }, /* @__PURE__ */ import_react.createElement(Cell_default, {
			component: cellComponent,
			prefixCls,
			className: (0, import_classnames$41.default)(rowCellCls, _defineProperty({}, "".concat(rowCellCls, "-fixed"), fixColumn)),
			additionalProps
		}, expandContent));
	}
	var rowStyle = _objectSpread2(_objectSpread2({}, style$1), {}, { width: scrollX });
	if (extra) {
		rowStyle.position = "absolute";
		rowStyle.pointerEvents = "none";
	}
	var rowNode = /* @__PURE__ */ import_react.createElement(RowComponent, _extends({}, rowProps, restProps, {
		"data-row-key": rowKey,
		ref: rowSupportExpand ? null : ref,
		className: (0, import_classnames$41.default)(className, "".concat(prefixCls, "-row"), rowProps === null || rowProps === void 0 ? void 0 : rowProps.className, _defineProperty({}, "".concat(prefixCls, "-row-extra"), extra)),
		style: _objectSpread2(_objectSpread2({}, rowStyle), rowProps === null || rowProps === void 0 ? void 0 : rowProps.style)
	}), flattenColumns.map(function(column$1, colIndex) {
		return /* @__PURE__ */ import_react.createElement(VirtualCell_default, {
			key: colIndex,
			component: cellComponent,
			rowInfo,
			column: column$1,
			colIndex,
			indent,
			index: index$2,
			renderIndex,
			record,
			inverse: extra,
			getHeight: getHeight$1
		});
	}));
	if (rowSupportExpand) return /* @__PURE__ */ import_react.createElement("div", { ref }, rowNode, expandRowNode);
	return rowNode;
}));
ResponseBodyLine.displayName = "BodyLine";
var BodyLine_default = ResponseBodyLine;

//#endregion
//#region node_modules/rc-table/es/VirtualTable/BodyGrid.js
var ResponseGrid = responseImmutable(/* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var data = props.data, onScroll = props.onScroll;
	var _useContext = useContext$2(TableContext_default, [
		"flattenColumns",
		"onColumnResize",
		"getRowKey",
		"prefixCls",
		"expandedKeys",
		"childrenColumnName",
		"scrollX",
		"direction"
	]), flattenColumns = _useContext.flattenColumns, onColumnResize = _useContext.onColumnResize, getRowKey = _useContext.getRowKey, expandedKeys = _useContext.expandedKeys, prefixCls = _useContext.prefixCls, childrenColumnName = _useContext.childrenColumnName, scrollX = _useContext.scrollX, direction = _useContext.direction;
	var _useContext2 = useContext$2(StaticContext), sticky = _useContext2.sticky, scrollY = _useContext2.scrollY, listItemHeight = _useContext2.listItemHeight, getComponent = _useContext2.getComponent, onTablePropScroll = _useContext2.onScroll;
	var listRef = import_react.useRef();
	var flattenData$1 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
	var columnsWidth = import_react.useMemo(function() {
		var total = 0;
		return flattenColumns.map(function(_ref) {
			var width = _ref.width, minWidth = _ref.minWidth, key = _ref.key;
			var finalWidth = Math.max(width || 0, minWidth || 0);
			total += finalWidth;
			return [
				key,
				finalWidth,
				total
			];
		});
	}, [flattenColumns]);
	var columnsOffset = import_react.useMemo(function() {
		return columnsWidth.map(function(colWidth) {
			return colWidth[2];
		});
	}, [columnsWidth]);
	import_react.useEffect(function() {
		columnsWidth.forEach(function(_ref2) {
			var _ref3 = _slicedToArray(_ref2, 2), key = _ref3[0], width = _ref3[1];
			onColumnResize(key, width);
		});
	}, [columnsWidth]);
	import_react.useImperativeHandle(ref, function() {
		var _listRef$current2;
		var obj = {
			scrollTo: function scrollTo$1(config) {
				var _listRef$current;
				(_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(config);
			},
			nativeElement: (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 ? void 0 : _listRef$current2.nativeElement
		};
		Object.defineProperty(obj, "scrollLeft", {
			get: function get$1() {
				var _listRef$current3;
				return ((_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 ? void 0 : _listRef$current3.getScrollInfo().x) || 0;
			},
			set: function set$1(value) {
				var _listRef$current4;
				(_listRef$current4 = listRef.current) === null || _listRef$current4 === void 0 || _listRef$current4.scrollTo({ left: value });
			}
		});
		Object.defineProperty(obj, "scrollTop", {
			get: function get$1() {
				var _listRef$current5;
				return ((_listRef$current5 = listRef.current) === null || _listRef$current5 === void 0 ? void 0 : _listRef$current5.getScrollInfo().y) || 0;
			},
			set: function set$1(value) {
				var _listRef$current6;
				(_listRef$current6 = listRef.current) === null || _listRef$current6 === void 0 || _listRef$current6.scrollTo({ top: value });
			}
		});
		return obj;
	});
	var getRowSpan = function getRowSpan$1(column$1, index$2) {
		var _flattenData$index;
		var record = (_flattenData$index = flattenData$1[index$2]) === null || _flattenData$index === void 0 ? void 0 : _flattenData$index.record;
		var onCell = column$1.onCell;
		if (onCell) {
			var _cellProps$rowSpan;
			var cellProps = onCell(record, index$2);
			return (_cellProps$rowSpan = cellProps === null || cellProps === void 0 ? void 0 : cellProps.rowSpan) !== null && _cellProps$rowSpan !== void 0 ? _cellProps$rowSpan : 1;
		}
		return 1;
	};
	var extraRender = function extraRender$1(info) {
		var start = info.start, end = info.end, getSize$2 = info.getSize, offsetY = info.offsetY;
		if (end < 0) return null;
		var firstRowSpanColumns = flattenColumns.filter(function(column$1) {
			return getRowSpan(column$1, start) === 0;
		});
		var startIndex = start;
		var _loop = function _loop$1(i$1) {
			firstRowSpanColumns = firstRowSpanColumns.filter(function(column$1) {
				return getRowSpan(column$1, i$1) === 0;
			});
			if (!firstRowSpanColumns.length) {
				startIndex = i$1;
				return 1;
			}
		};
		for (var i = start; i >= 0; i -= 1) if (_loop(i)) break;
		var lastRowSpanColumns = flattenColumns.filter(function(column$1) {
			return getRowSpan(column$1, end) !== 1;
		});
		var endIndex = end;
		var _loop2 = function _loop2$1(_i$1) {
			lastRowSpanColumns = lastRowSpanColumns.filter(function(column$1) {
				return getRowSpan(column$1, _i$1) !== 1;
			});
			if (!lastRowSpanColumns.length) {
				endIndex = Math.max(_i$1 - 1, end);
				return 1;
			}
		};
		for (var _i = end; _i < flattenData$1.length; _i += 1) if (_loop2(_i)) break;
		var spanLines = [];
		var _loop3 = function _loop3$1(_i2$1) {
			if (!flattenData$1[_i2$1]) return 1;
			if (flattenColumns.some(function(column$1) {
				return getRowSpan(column$1, _i2$1) > 1;
			})) spanLines.push(_i2$1);
		};
		for (var _i2 = startIndex; _i2 <= endIndex; _i2 += 1) if (_loop3(_i2)) continue;
		return spanLines.map(function(index$2) {
			var item = flattenData$1[index$2];
			var rowKey = getRowKey(item.record, index$2);
			var getHeight$1 = function getHeight$2(rowSpan) {
				var endItemIndex = index$2 + rowSpan - 1;
				var endItemKey = getRowKey(flattenData$1[endItemIndex].record, endItemIndex);
				var sizeInfo$1 = getSize$2(rowKey, endItemKey);
				return sizeInfo$1.bottom - sizeInfo$1.top;
			};
			var sizeInfo = getSize$2(rowKey);
			return /* @__PURE__ */ import_react.createElement(BodyLine_default, {
				key: index$2,
				data: item,
				rowKey,
				index: index$2,
				style: { top: -offsetY + sizeInfo.top },
				extra: true,
				getHeight: getHeight$1
			});
		});
	};
	var gridContext = import_react.useMemo(function() {
		return { columnsOffset };
	}, [columnsOffset]);
	var tblPrefixCls = "".concat(prefixCls, "-tbody");
	var wrapperComponent = getComponent(["body", "wrapper"]);
	var horizontalScrollBarStyle = {};
	if (sticky) {
		horizontalScrollBarStyle.position = "sticky";
		horizontalScrollBarStyle.bottom = 0;
		if (_typeof(sticky) === "object" && sticky.offsetScroll) horizontalScrollBarStyle.bottom = sticky.offsetScroll;
	}
	return /* @__PURE__ */ import_react.createElement(GridContext.Provider, { value: gridContext }, /* @__PURE__ */ import_react.createElement(es_default$8, {
		fullHeight: false,
		ref: listRef,
		prefixCls: "".concat(tblPrefixCls, "-virtual"),
		styles: { horizontalScrollBar: horizontalScrollBarStyle },
		className: tblPrefixCls,
		height: scrollY,
		itemHeight: listItemHeight || 24,
		data: flattenData$1,
		itemKey: function itemKey$2(item) {
			return getRowKey(item.record);
		},
		component: wrapperComponent,
		scrollWidth: scrollX,
		direction,
		onVirtualScroll: function onVirtualScroll(_ref4) {
			var _listRef$current7;
			var x = _ref4.x;
			onScroll({
				currentTarget: (_listRef$current7 = listRef.current) === null || _listRef$current7 === void 0 ? void 0 : _listRef$current7.nativeElement,
				scrollLeft: x
			});
		},
		onScroll: onTablePropScroll,
		extraRender
	}, function(item, index$2, itemProps) {
		var rowKey = getRowKey(item.record, index$2);
		return /* @__PURE__ */ import_react.createElement(BodyLine_default, {
			data: item,
			rowKey,
			index: index$2,
			style: itemProps.style
		});
	}));
}));
ResponseGrid.displayName = "ResponseGrid";
var BodyGrid_default = ResponseGrid;

//#endregion
//#region node_modules/rc-table/es/VirtualTable/index.js
var import_classnames$40 = /* @__PURE__ */ __toESM(require_classnames());
var renderBody = function renderBody$1(rawData, props) {
	var ref = props.ref, onScroll = props.onScroll;
	return /* @__PURE__ */ import_react.createElement(BodyGrid_default, {
		ref,
		data: rawData,
		onScroll
	});
};
function VirtualTable(props, ref) {
	var data = props.data, columns = props.columns, scroll = props.scroll, sticky = props.sticky, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? DEFAULT_PREFIX : _props$prefixCls, className = props.className, listItemHeight = props.listItemHeight, components$1 = props.components, onScroll = props.onScroll;
	var _ref = scroll || {}, scrollX = _ref.x, scrollY = _ref.y;
	if (typeof scrollX !== "number") {
		warning_default(!scrollX, "`scroll.x` in virtual table must be number.");
		scrollX = 1;
	}
	if (typeof scrollY !== "number") {
		scrollY = 500;
		warning_default(false, "`scroll.y` in virtual table must be number.");
	}
	var getComponent = useEvent(function(path$1, defaultComponent) {
		return get(components$1, path$1) || defaultComponent;
	});
	var onInternalScroll = useEvent(onScroll);
	var context = import_react.useMemo(function() {
		return {
			sticky,
			scrollY,
			listItemHeight,
			getComponent,
			onScroll: onInternalScroll
		};
	}, [
		sticky,
		scrollY,
		listItemHeight,
		getComponent,
		onInternalScroll
	]);
	return /* @__PURE__ */ import_react.createElement(StaticContext.Provider, { value: context }, /* @__PURE__ */ import_react.createElement(Table_default$1, _extends({}, props, {
		className: (0, import_classnames$40.default)(className, "".concat(prefixCls, "-virtual")),
		scroll: _objectSpread2(_objectSpread2({}, scroll), {}, { x: scrollX }),
		components: _objectSpread2(_objectSpread2({}, components$1), {}, { body: data !== null && data !== void 0 && data.length ? renderBody : void 0 }),
		columns,
		internalHooks: INTERNAL_HOOKS,
		tailor: true,
		ref
	})));
}
var RefVirtualTable = /* @__PURE__ */ import_react.forwardRef(VirtualTable);
RefVirtualTable.displayName = "VirtualTable";
function genVirtualTable(shouldTriggerRender) {
	return makeImmutable(RefVirtualTable, shouldTriggerRender);
}
var VirtualTable_default$1 = genVirtualTable();

//#endregion
//#region node_modules/antd/es/table/Column.js
/* istanbul ignore next */
/** This is a syntactic sugar for `columns` prop. So HOC will not work on this. */
var Column = (_) => null;
var Column_default = Column;

//#endregion
//#region node_modules/antd/es/table/ColumnGroup.js
/* istanbul ignore next */
/** This is a syntactic sugar for `columns` prop. So HOC will not work on this. */
var ColumnGroup = (_) => null;
var ColumnGroup_default = ColumnGroup;

//#endregion
//#region node_modules/rc-tree/es/contextTypes.js
var TreeContext = /* @__PURE__ */ import_react.createContext(null);
/** Internal usage, safe to remove. Do not use in prod */
var UnstableContext = /* @__PURE__ */ import_react.createContext({});

//#endregion
//#region node_modules/rc-tree/es/Indent.js
var import_classnames$39 = /* @__PURE__ */ __toESM(require_classnames());
var Indent = function Indent$1(_ref) {
	var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
	var baseClassName = "".concat(prefixCls, "-indent-unit");
	var list = [];
	for (var i = 0; i < level; i += 1) list.push(/* @__PURE__ */ import_react.createElement("span", {
		key: i,
		className: (0, import_classnames$39.default)(baseClassName, _defineProperty(_defineProperty({}, "".concat(baseClassName, "-start"), isStart[i]), "".concat(baseClassName, "-end"), isEnd[i]))
	}));
	return /* @__PURE__ */ import_react.createElement("span", {
		"aria-hidden": "true",
		className: "".concat(prefixCls, "-indent")
	}, list);
};
var Indent_default = /* @__PURE__ */ import_react.memo(Indent);

//#endregion
//#region node_modules/rc-tree/es/TreeNode.js
var import_classnames$38 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$6 = [
	"eventKey",
	"className",
	"style",
	"dragOver",
	"dragOverGapTop",
	"dragOverGapBottom",
	"isLeaf",
	"isStart",
	"isEnd",
	"expanded",
	"selected",
	"checked",
	"halfChecked",
	"loading",
	"domRef",
	"active",
	"data",
	"onMouseMove",
	"selectable"
];
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var TreeNode$1 = function TreeNode$2(props) {
	var _unstableContext$node, _context$filterTreeNo, _classNames4;
	var eventKey = props.eventKey, className = props.className, style$1 = props.style, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, isLeaf$1 = props.isLeaf, isStart = props.isStart, isEnd = props.isEnd, expanded = props.expanded, selected = props.selected, checked = props.checked, halfChecked = props.halfChecked, loading = props.loading, domRef = props.domRef, active = props.active, data = props.data, onMouseMove = props.onMouseMove, selectable = props.selectable, otherProps = _objectWithoutProperties(props, _excluded$6);
	var context = import_react.useContext(TreeContext);
	var unstableContext = import_react.useContext(UnstableContext);
	var selectHandleRef = import_react.useRef(null);
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragNodeHighlight = _React$useState2[0], setDragNodeHighlight = _React$useState2[1];
	var isDisabled = !!(context.disabled || props.disabled || (_unstableContext$node = unstableContext.nodeDisabled) !== null && _unstableContext$node !== void 0 && _unstableContext$node.call(unstableContext, data));
	var isCheckable = import_react.useMemo(function() {
		if (!context.checkable || props.checkable === false) return false;
		return context.checkable;
	}, [context.checkable, props.checkable]);
	var onSelect = function onSelect$1(e$2) {
		if (isDisabled) return;
		context.onNodeSelect(e$2, convertNodePropsToEventData(props));
	};
	var onCheck = function onCheck$1(e$2) {
		if (isDisabled) return;
		if (!isCheckable || props.disableCheckbox) return;
		context.onNodeCheck(e$2, convertNodePropsToEventData(props), !checked);
	};
	var isSelectable = import_react.useMemo(function() {
		if (typeof selectable === "boolean") return selectable;
		return context.selectable;
	}, [selectable, context.selectable]);
	var onSelectorClick = function onSelectorClick$1(e$2) {
		context.onNodeClick(e$2, convertNodePropsToEventData(props));
		if (isSelectable) onSelect(e$2);
		else onCheck(e$2);
	};
	var onSelectorDoubleClick = function onSelectorDoubleClick$1(e$2) {
		context.onNodeDoubleClick(e$2, convertNodePropsToEventData(props));
	};
	var onMouseEnter = function onMouseEnter$1(e$2) {
		context.onNodeMouseEnter(e$2, convertNodePropsToEventData(props));
	};
	var onMouseLeave = function onMouseLeave$1(e$2) {
		context.onNodeMouseLeave(e$2, convertNodePropsToEventData(props));
	};
	var onContextMenu = function onContextMenu$1(e$2) {
		context.onNodeContextMenu(e$2, convertNodePropsToEventData(props));
	};
	var isDraggable = import_react.useMemo(function() {
		return !!(context.draggable && (!context.draggable.nodeDraggable || context.draggable.nodeDraggable(data)));
	}, [context.draggable, data]);
	var onDragStart = function onDragStart$1(e$2) {
		e$2.stopPropagation();
		setDragNodeHighlight(true);
		context.onNodeDragStart(e$2, props);
		try {
			e$2.dataTransfer.setData("text/plain", "");
		} catch (_unused) {}
	};
	var onDragEnter = function onDragEnter$1(e$2) {
		e$2.preventDefault();
		e$2.stopPropagation();
		context.onNodeDragEnter(e$2, props);
	};
	var onDragOver = function onDragOver$1(e$2) {
		e$2.preventDefault();
		e$2.stopPropagation();
		context.onNodeDragOver(e$2, props);
	};
	var onDragLeave = function onDragLeave$1(e$2) {
		e$2.stopPropagation();
		context.onNodeDragLeave(e$2, props);
	};
	var onDragEnd = function onDragEnd$1(e$2) {
		e$2.stopPropagation();
		setDragNodeHighlight(false);
		context.onNodeDragEnd(e$2, props);
	};
	var onDrop = function onDrop$1(e$2) {
		e$2.preventDefault();
		e$2.stopPropagation();
		setDragNodeHighlight(false);
		context.onNodeDrop(e$2, props);
	};
	var onExpand = function onExpand$1(e$2) {
		if (loading) return;
		context.onNodeExpand(e$2, convertNodePropsToEventData(props));
	};
	var hasChildren = import_react.useMemo(function() {
		var _ref = getEntity(context.keyEntities, eventKey) || {}, children = _ref.children;
		return Boolean((children || []).length);
	}, [context.keyEntities, eventKey]);
	var memoizedIsLeaf = import_react.useMemo(function() {
		if (isLeaf$1 === false) return false;
		return isLeaf$1 || !context.loadData && !hasChildren || context.loadData && props.loaded && !hasChildren;
	}, [
		isLeaf$1,
		context.loadData,
		hasChildren,
		props.loaded
	]);
	import_react.useEffect(function() {
		if (loading) return;
		if (typeof context.loadData === "function" && expanded && !memoizedIsLeaf && !props.loaded) context.onNodeLoad(convertNodePropsToEventData(props));
	}, [
		loading,
		context.loadData,
		context.onNodeLoad,
		expanded,
		memoizedIsLeaf,
		props
	]);
	var dragHandlerNode = import_react.useMemo(function() {
		var _context$draggable;
		if (!((_context$draggable = context.draggable) !== null && _context$draggable !== void 0 && _context$draggable.icon)) return null;
		return /* @__PURE__ */ import_react.createElement("span", { className: "".concat(context.prefixCls, "-draggable-icon") }, context.draggable.icon);
	}, [context.draggable]);
	var renderSwitcherIconDom = function renderSwitcherIconDom$1(isInternalLeaf) {
		var switcherIcon = props.switcherIcon || context.switcherIcon;
		if (typeof switcherIcon === "function") return switcherIcon(_objectSpread2(_objectSpread2({}, props), {}, { isLeaf: isInternalLeaf }));
		return switcherIcon;
	};
	var renderSwitcher = function renderSwitcher$1() {
		if (memoizedIsLeaf) {
			var _switcherIconDom = renderSwitcherIconDom(true);
			return _switcherIconDom !== false ? /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$38.default)("".concat(context.prefixCls, "-switcher"), "".concat(context.prefixCls, "-switcher-noop")) }, _switcherIconDom) : null;
		}
		var switcherIconDom = renderSwitcherIconDom(false);
		return switcherIconDom !== false ? /* @__PURE__ */ import_react.createElement("span", {
			onClick: onExpand,
			className: (0, import_classnames$38.default)("".concat(context.prefixCls, "-switcher"), "".concat(context.prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE))
		}, switcherIconDom) : null;
	};
	var checkboxNode = import_react.useMemo(function() {
		if (!isCheckable) return null;
		var $custom = typeof isCheckable !== "boolean" ? isCheckable : null;
		return /* @__PURE__ */ import_react.createElement("span", {
			className: (0, import_classnames$38.default)("".concat(context.prefixCls, "-checkbox"), _defineProperty(_defineProperty(_defineProperty({}, "".concat(context.prefixCls, "-checkbox-checked"), checked), "".concat(context.prefixCls, "-checkbox-indeterminate"), !checked && halfChecked), "".concat(context.prefixCls, "-checkbox-disabled"), isDisabled || props.disableCheckbox)),
			onClick: onCheck,
			role: "checkbox",
			"aria-checked": halfChecked ? "mixed" : checked,
			"aria-disabled": isDisabled || props.disableCheckbox,
			"aria-label": "Select ".concat(typeof props.title === "string" ? props.title : "tree node")
		}, $custom);
	}, [
		isCheckable,
		checked,
		halfChecked,
		isDisabled,
		props.disableCheckbox,
		props.title
	]);
	var nodeState = import_react.useMemo(function() {
		if (memoizedIsLeaf) return null;
		return expanded ? ICON_OPEN : ICON_CLOSE;
	}, [memoizedIsLeaf, expanded]);
	var iconNode = import_react.useMemo(function() {
		return /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$38.default)("".concat(context.prefixCls, "-iconEle"), "".concat(context.prefixCls, "-icon__").concat(nodeState || "docu"), _defineProperty({}, "".concat(context.prefixCls, "-icon_loading"), loading)) });
	}, [
		context.prefixCls,
		nodeState,
		loading
	]);
	var dropIndicatorNode = import_react.useMemo(function() {
		var rootDraggable = Boolean(context.draggable);
		if (!(!props.disabled && rootDraggable && context.dragOverNodeKey === eventKey)) return null;
		return context.dropIndicatorRender({
			dropPosition: context.dropPosition,
			dropLevelOffset: context.dropLevelOffset,
			indent: context.indent,
			prefixCls: context.prefixCls,
			direction: context.direction
		});
	}, [
		context.dropPosition,
		context.dropLevelOffset,
		context.indent,
		context.prefixCls,
		context.direction,
		context.draggable,
		context.dragOverNodeKey,
		context.dropIndicatorRender
	]);
	var selectorNode = import_react.useMemo(function() {
		var _props$title = props.title, title = _props$title === void 0 ? defaultTitle : _props$title;
		var wrapClass = "".concat(context.prefixCls, "-node-content-wrapper");
		var $icon;
		if (context.showIcon) {
			var currentIcon = props.icon || context.icon;
			$icon = currentIcon ? /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$38.default)("".concat(context.prefixCls, "-iconEle"), "".concat(context.prefixCls, "-icon__customize")) }, typeof currentIcon === "function" ? currentIcon(props) : currentIcon) : iconNode;
		} else if (context.loadData && loading) $icon = iconNode;
		var titleNode;
		if (typeof title === "function") titleNode = title(data);
		else if (context.titleRender) titleNode = context.titleRender(data);
		else titleNode = title;
		return /* @__PURE__ */ import_react.createElement("span", {
			ref: selectHandleRef,
			title: typeof title === "string" ? title : "",
			className: (0, import_classnames$38.default)(wrapClass, "".concat(wrapClass, "-").concat(nodeState || "normal"), _defineProperty({}, "".concat(context.prefixCls, "-node-selected"), !isDisabled && (selected || dragNodeHighlight))),
			onMouseEnter,
			onMouseLeave,
			onContextMenu,
			onClick: onSelectorClick,
			onDoubleClick: onSelectorDoubleClick
		}, $icon, /* @__PURE__ */ import_react.createElement("span", { className: "".concat(context.prefixCls, "-title") }, titleNode), dropIndicatorNode);
	}, [
		context.prefixCls,
		context.showIcon,
		props,
		context.icon,
		iconNode,
		context.titleRender,
		data,
		nodeState,
		onMouseEnter,
		onMouseLeave,
		onContextMenu,
		onSelectorClick,
		onSelectorDoubleClick
	]);
	var dataOrAriaAttributeProps = pickAttrs(otherProps, {
		aria: true,
		data: true
	});
	var _ref2 = getEntity(context.keyEntities, eventKey) || {}, level = _ref2.level;
	var isEndNode = isEnd[isEnd.length - 1];
	var draggableWithoutDisabled = !isDisabled && isDraggable;
	var dragging = context.draggingNodeKey === eventKey;
	var ariaSelected = selectable !== void 0 ? { "aria-selected": !!selectable } : void 0;
	return /* @__PURE__ */ import_react.createElement("div", _extends({
		ref: domRef,
		role: "treeitem",
		"aria-expanded": isLeaf$1 ? void 0 : expanded,
		className: (0, import_classnames$38.default)(className, "".concat(context.prefixCls, "-treenode"), (_classNames4 = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_classNames4, "".concat(context.prefixCls, "-treenode-disabled"), isDisabled), "".concat(context.prefixCls, "-treenode-switcher-").concat(expanded ? "open" : "close"), !isLeaf$1), "".concat(context.prefixCls, "-treenode-checkbox-checked"), checked), "".concat(context.prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), "".concat(context.prefixCls, "-treenode-selected"), selected), "".concat(context.prefixCls, "-treenode-loading"), loading), "".concat(context.prefixCls, "-treenode-active"), active), "".concat(context.prefixCls, "-treenode-leaf-last"), isEndNode), "".concat(context.prefixCls, "-treenode-draggable"), isDraggable), "dragging", dragging), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_classNames4, "drop-target", context.dropTargetKey === eventKey), "drop-container", context.dropContainerKey === eventKey), "drag-over", !isDisabled && dragOver), "drag-over-gap-top", !isDisabled && dragOverGapTop), "drag-over-gap-bottom", !isDisabled && dragOverGapBottom), "filter-node", (_context$filterTreeNo = context.filterTreeNode) === null || _context$filterTreeNo === void 0 ? void 0 : _context$filterTreeNo.call(context, convertNodePropsToEventData(props))), "".concat(context.prefixCls, "-treenode-leaf"), memoizedIsLeaf))),
		style: style$1,
		draggable: draggableWithoutDisabled,
		onDragStart: draggableWithoutDisabled ? onDragStart : void 0,
		onDragEnter: isDraggable ? onDragEnter : void 0,
		onDragOver: isDraggable ? onDragOver : void 0,
		onDragLeave: isDraggable ? onDragLeave : void 0,
		onDrop: isDraggable ? onDrop : void 0,
		onDragEnd: isDraggable ? onDragEnd : void 0,
		onMouseMove
	}, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ import_react.createElement(Indent_default, {
		prefixCls: context.prefixCls,
		level,
		isStart,
		isEnd
	}), dragHandlerNode, renderSwitcher(), checkboxNode, selectorNode);
};
TreeNode$1.isTreeNode = 1;
TreeNode$1.displayName = "TreeNode";
var TreeNode_default$1 = TreeNode$1;

//#endregion
//#region node_modules/rc-tree/es/util.js
function arrDel(list, value) {
	if (!list) return [];
	var clone = list.slice();
	var index$2 = clone.indexOf(value);
	if (index$2 >= 0) clone.splice(index$2, 1);
	return clone;
}
function arrAdd(list, value) {
	var clone = (list || []).slice();
	if (clone.indexOf(value) === -1) clone.push(value);
	return clone;
}
function posToArr(pos) {
	return pos.split("-");
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
	var dragChildrenKeys = [];
	var entity = getEntity(keyEntities, dragNodeKey);
	function dig() {
		(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach(function(_ref) {
			var key = _ref.key, children = _ref.children;
			dragChildrenKeys.push(key);
			dig(children);
		});
	}
	dig(entity.children);
	return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
	if (treeNodeEntity.parent) {
		var posArr = posToArr(treeNodeEntity.pos);
		return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
	}
	return false;
}
function isFirstChild(treeNodeEntity) {
	var posArr = posToArr(treeNodeEntity.pos);
	return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNodeProps, targetNodeProps, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
	var _abstractDropNodeEnti;
	var clientX = event.clientX, clientY = event.clientY;
	var _getBoundingClientRec = event.target.getBoundingClientRect(), top = _getBoundingClientRec.top, height = _getBoundingClientRec.height;
	var rawDropLevelOffset = ((direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX) - 12) / indent;
	var filteredExpandKeys = expandKeys.filter(function(key) {
		var _keyEntities$key;
		return (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.children) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key.length;
	});
	var abstractDropNodeEntity = getEntity(keyEntities, targetNodeProps.eventKey);
	if (clientY < top + height / 2) {
		var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
			return flattenedNode.key === abstractDropNodeEntity.key;
		});
		var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
		var prevNodeKey = flattenedNodes[prevNodeIndex].key;
		abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
	}
	var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
	var abstractDragOverEntity = abstractDropNodeEntity;
	var dragOverNodeKey = abstractDropNodeEntity.key;
	var dropPosition = 0;
	var dropLevelOffset = 0;
	if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) for (var i = 0; i < rawDropLevelOffset; i += 1) if (isLastChild(abstractDropNodeEntity)) {
		abstractDropNodeEntity = abstractDropNodeEntity.parent;
		dropLevelOffset += 1;
	} else break;
	var abstractDragDataNode = dragNodeProps.data;
	var abstractDropDataNode = abstractDropNodeEntity.node;
	var dropAllowed = true;
	if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: -1
	}) && abstractDropNodeEntity.key === targetNodeProps.eventKey) dropPosition = -1;
	else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 0
	})) dropPosition = 0;
	else dropAllowed = false;
	else if (dropLevelOffset === 0) if (rawDropLevelOffset > -1.5) if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 1
	})) dropPosition = 1;
	else dropAllowed = false;
	else if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 0
	})) dropPosition = 0;
	else if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 1
	})) dropPosition = 1;
	else dropAllowed = false;
	else if (allowDrop({
		dragNode: abstractDragDataNode,
		dropNode: abstractDropDataNode,
		dropPosition: 1
	})) dropPosition = 1;
	else dropAllowed = false;
	return {
		dropPosition,
		dropLevelOffset,
		dropTargetKey: abstractDropNodeEntity.key,
		dropTargetPos: abstractDropNodeEntity.pos,
		dragOverNodeKey,
		dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
		dropAllowed
	};
}
/**
* Return selectedKeys according with multiple prop
* @param selectedKeys
* @param props
* @returns [string]
*/
function calcSelectedKeys(selectedKeys, props) {
	if (!selectedKeys) return void 0;
	if (props.multiple) return selectedKeys.slice();
	if (selectedKeys.length) return [selectedKeys[0]];
	return selectedKeys;
}
/**
* Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style
*/
function parseCheckedKeys(keys$1) {
	if (!keys$1) return null;
	var keyProps;
	if (Array.isArray(keys$1)) keyProps = {
		checkedKeys: keys$1,
		halfCheckedKeys: void 0
	};
	else if (_typeof(keys$1) === "object") keyProps = {
		checkedKeys: keys$1.checked || void 0,
		halfCheckedKeys: keys$1.halfChecked || void 0
	};
	else {
		warning_default(false, "`checkedKeys` is not an array or an object");
		return null;
	}
	return keyProps;
}
/**
* If user use `autoExpandParent` we should get the list of parent node
* @param keyList
* @param keyEntities
*/
function conductExpandParent(keyList, keyEntities) {
	var expandedKeys = /* @__PURE__ */ new Set();
	function conductUp(key) {
		if (expandedKeys.has(key)) return;
		var entity = getEntity(keyEntities, key);
		if (!entity) return;
		expandedKeys.add(key);
		var parent = entity.parent;
		if (entity.node.disabled) return;
		if (parent) conductUp(parent.key);
	}
	(keyList || []).forEach(function(key) {
		conductUp(key);
	});
	return _toConsumableArray(expandedKeys);
}

//#endregion
//#region node_modules/antd/es/_util/hooks/useMultipleSelect.js
/**
* @title multipleSelect hooks
* @description multipleSelect by hold down shift key
*/
function useMultipleSelect(getKey$3) {
	const [prevSelectedIndex, setPrevSelectedIndex] = (0, import_react.useState)(null);
	const multipleSelect = (0, import_react.useCallback)((currentSelectedIndex, data, selectedKeys) => {
		const configPrevSelectedIndex = prevSelectedIndex !== null && prevSelectedIndex !== void 0 ? prevSelectedIndex : currentSelectedIndex;
		const startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex);
		const endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex);
		const rangeKeys = data.slice(startIndex, endIndex + 1).map((item) => getKey$3(item));
		const shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey));
		const changedKeys = [];
		rangeKeys.forEach((item) => {
			if (shouldSelected) {
				if (!selectedKeys.has(item)) changedKeys.push(item);
				selectedKeys.add(item);
			} else {
				selectedKeys.delete(item);
				changedKeys.push(item);
			}
		});
		setPrevSelectedIndex(shouldSelected ? endIndex : null);
		return changedKeys;
	}, [prevSelectedIndex]);
	const updatePrevSelectedIndex = (val) => {
		setPrevSelectedIndex(val);
	};
	return [multipleSelect, updatePrevSelectedIndex];
}

//#endregion
//#region node_modules/antd/es/table/hooks/useSelection.js
var import_classnames$37 = /* @__PURE__ */ __toESM(require_classnames());
const SELECTION_COLUMN = {};
const SELECTION_ALL = "SELECT_ALL";
const SELECTION_INVERT = "SELECT_INVERT";
const SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST$1 = [];
var flattenData = (childrenColumnName, data, list = []) => {
	(data || []).forEach((record) => {
		list.push(record);
		if (record && typeof record === "object" && childrenColumnName in record) flattenData(childrenColumnName, record[childrenColumnName], list);
	});
	return list;
};
var useSelection$1 = (config, rowSelection) => {
	const { preserveSelectedRowKeys, selectedRowKeys, defaultSelectedRowKeys, getCheckboxProps, getTitleCheckboxProps, onChange: onSelectionChange, onSelect, onSelectAll, onSelectInvert, onSelectNone, onSelectMultiple, columnWidth: selectionColWidth, type: selectionType, selections, fixed, renderCell: customizeRenderCell, hideSelectAll, checkStrictly = true } = rowSelection || {};
	const { prefixCls, data, pageData, getRecordByKey, getRowKey, expandType, childrenColumnName, locale: tableLocale, getPopupContainer } = config;
	const warning$4 = devUseWarning("Table");
	const [multipleSelect, updatePrevSelectedIndex] = useMultipleSelect((item) => item);
	const [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST$1, { value: selectedRowKeys });
	const preserveRecordsRef = import_react.useRef(/* @__PURE__ */ new Map());
	const updatePreserveRecordsCache = (0, import_react.useCallback)((keys$1) => {
		if (preserveSelectedRowKeys) {
			const newCache = /* @__PURE__ */ new Map();
			keys$1.forEach((key) => {
				let record = getRecordByKey(key);
				if (!record && preserveRecordsRef.current.has(key)) record = preserveRecordsRef.current.get(key);
				newCache.set(key, record);
			});
			preserveRecordsRef.current = newCache;
		}
	}, [getRecordByKey, preserveSelectedRowKeys]);
	import_react.useEffect(() => {
		updatePreserveRecordsCache(mergedSelectedKeys);
	}, [mergedSelectedKeys]);
	const flattedData = (0, import_react.useMemo)(() => flattenData(childrenColumnName, pageData), [childrenColumnName, pageData]);
	const { keyEntities } = (0, import_react.useMemo)(() => {
		if (checkStrictly) return { keyEntities: null };
		let convertData = data;
		if (preserveSelectedRowKeys) {
			const keysSet = new Set(flattedData.map((record, index$2) => getRowKey(record, index$2)));
			const preserveRecords = Array.from(preserveRecordsRef.current).reduce((total, [key, value]) => keysSet.has(key) ? total : total.concat(value), []);
			convertData = [].concat(_toConsumableArray(convertData), _toConsumableArray(preserveRecords));
		}
		return convertDataToEntities(convertData, {
			externalGetKey: getRowKey,
			childrenPropName: childrenColumnName
		});
	}, [
		data,
		getRowKey,
		checkStrictly,
		childrenColumnName,
		preserveSelectedRowKeys,
		flattedData
	]);
	const checkboxPropsMap = (0, import_react.useMemo)(() => {
		const map = /* @__PURE__ */ new Map();
		flattedData.forEach((record, index$2) => {
			const key = getRowKey(record, index$2);
			const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
			map.set(key, checkboxProps);
			warning$4(!("checked" in checkboxProps || "defaultChecked" in checkboxProps), "usage", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.");
		});
		return map;
	}, [
		flattedData,
		getRowKey,
		getCheckboxProps
	]);
	const isCheckboxDisabled = (0, import_react.useCallback)((r$1) => {
		const rowKey = getRowKey(r$1);
		let checkboxProps;
		if (checkboxPropsMap.has(rowKey)) checkboxProps = checkboxPropsMap.get(getRowKey(r$1));
		else checkboxProps = getCheckboxProps ? getCheckboxProps(r$1) : void 0;
		return !!(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.disabled);
	}, [checkboxPropsMap, getRowKey]);
	const [derivedSelectedKeys, derivedHalfSelectedKeys] = (0, import_react.useMemo)(() => {
		if (checkStrictly) return [mergedSelectedKeys || [], []];
		const { checkedKeys, halfCheckedKeys } = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled);
		return [checkedKeys || [], halfCheckedKeys];
	}, [
		mergedSelectedKeys,
		checkStrictly,
		keyEntities,
		isCheckboxDisabled
	]);
	const derivedSelectedKeySet = (0, import_react.useMemo)(() => {
		const keys$1 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
		return new Set(keys$1);
	}, [derivedSelectedKeys, selectionType]);
	const derivedHalfSelectedKeySet = (0, import_react.useMemo)(() => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys), [derivedHalfSelectedKeys, selectionType]);
	import_react.useEffect(() => {
		if (!rowSelection) setMergedSelectedKeys(EMPTY_LIST$1);
	}, [!!rowSelection]);
	const setSelectedKeys = (0, import_react.useCallback)((keys$1, method$1) => {
		let availableKeys;
		let records;
		updatePreserveRecordsCache(keys$1);
		if (preserveSelectedRowKeys) {
			availableKeys = keys$1;
			records = keys$1.map((key) => preserveRecordsRef.current.get(key));
		} else {
			availableKeys = [];
			records = [];
			keys$1.forEach((key) => {
				const record = getRecordByKey(key);
				if (record !== void 0) {
					availableKeys.push(key);
					records.push(record);
				}
			});
		}
		setMergedSelectedKeys(availableKeys);
		onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(availableKeys, records, { type: method$1 });
	}, [
		setMergedSelectedKeys,
		getRecordByKey,
		onSelectionChange,
		preserveSelectedRowKeys
	]);
	const triggerSingleSelection = (0, import_react.useCallback)((key, selected, keys$1, event) => {
		if (onSelect) {
			const rows = keys$1.map((k) => getRecordByKey(k));
			onSelect(getRecordByKey(key), selected, rows, event);
		}
		setSelectedKeys(keys$1, "single");
	}, [
		onSelect,
		getRecordByKey,
		setSelectedKeys
	]);
	const mergedSelections = (0, import_react.useMemo)(() => {
		if (!selections || hideSelectAll) return null;
		return (selections === true ? [
			SELECTION_ALL,
			SELECTION_INVERT,
			SELECTION_NONE
		] : selections).map((selection) => {
			if (selection === SELECTION_ALL) return {
				key: "all",
				text: tableLocale.selectionAll,
				onSelect() {
					setSelectedKeys(data.map((record, index$2) => getRowKey(record, index$2)).filter((key) => {
						const checkProps = checkboxPropsMap.get(key);
						return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key);
					}), "all");
				}
			};
			if (selection === SELECTION_INVERT) return {
				key: "invert",
				text: tableLocale.selectInvert,
				onSelect() {
					const keySet = new Set(derivedSelectedKeySet);
					pageData.forEach((record, index$2) => {
						const key = getRowKey(record, index$2);
						const checkProps = checkboxPropsMap.get(key);
						if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) if (keySet.has(key)) keySet.delete(key);
						else keySet.add(key);
					});
					const keys$1 = Array.from(keySet);
					if (onSelectInvert) {
						warning$4.deprecated(false, "onSelectInvert", "onChange");
						onSelectInvert(keys$1);
					}
					setSelectedKeys(keys$1, "invert");
				}
			};
			if (selection === SELECTION_NONE) return {
				key: "none",
				text: tableLocale.selectNone,
				onSelect() {
					onSelectNone === null || onSelectNone === void 0 || onSelectNone();
					setSelectedKeys(Array.from(derivedSelectedKeySet).filter((key) => {
						const checkProps = checkboxPropsMap.get(key);
						return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
					}), "none");
				}
			};
			return selection;
		}).map((selection) => Object.assign(Object.assign({}, selection), { onSelect: (...rest) => {
			var _a2;
			var _a;
			(_a = selection.onSelect) === null || _a === void 0 || (_a2 = _a).call.apply(_a2, [selection].concat(rest));
			updatePrevSelectedIndex(null);
		} }));
	}, [
		selections,
		derivedSelectedKeySet,
		pageData,
		getRowKey,
		onSelectInvert,
		setSelectedKeys
	]);
	return [(0, import_react.useCallback)((columns) => {
		var _a;
		if (!rowSelection) {
			warning$4(!columns.includes(SELECTION_COLUMN), "usage", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`.");
			return columns.filter((col) => col !== SELECTION_COLUMN);
		}
		let cloneColumns = _toConsumableArray(columns);
		const keySet = new Set(derivedSelectedKeySet);
		const recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled);
		const checkedCurrentAll = recordKeys.every((key) => keySet.has(key));
		const checkedCurrentSome = recordKeys.some((key) => keySet.has(key));
		const onSelectAllChange = () => {
			const changeKeys = [];
			if (checkedCurrentAll) recordKeys.forEach((key) => {
				keySet.delete(key);
				changeKeys.push(key);
			});
			else recordKeys.forEach((key) => {
				if (!keySet.has(key)) {
					keySet.add(key);
					changeKeys.push(key);
				}
			});
			const keys$1 = Array.from(keySet);
			onSelectAll === null || onSelectAll === void 0 || onSelectAll(!checkedCurrentAll, keys$1.map((k) => getRecordByKey(k)), changeKeys.map((k) => getRecordByKey(k)));
			setSelectedKeys(keys$1, "all");
			updatePrevSelectedIndex(null);
		};
		let title;
		let columnTitleCheckbox;
		if (selectionType !== "radio") {
			let customizeSelections;
			if (mergedSelections) {
				const menu = {
					getPopupContainer,
					items: mergedSelections.map((selection, index$2) => {
						const { key, text, onSelect: onSelectionClick } = selection;
						return {
							key: key !== null && key !== void 0 ? key : index$2,
							onClick: () => {
								onSelectionClick === null || onSelectionClick === void 0 || onSelectionClick(recordKeys);
							},
							label: text
						};
					})
				};
				customizeSelections = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-selection-extra` }, /* @__PURE__ */ import_react.createElement(dropdown_default, {
					menu,
					getPopupContainer
				}, /* @__PURE__ */ import_react.createElement("span", null, /* @__PURE__ */ import_react.createElement(DownOutlined_default, null))));
			}
			const allDisabledData = flattedData.map((record, index$2) => {
				const key = getRowKey(record, index$2);
				const checkboxProps = checkboxPropsMap.get(key) || {};
				return Object.assign({ checked: keySet.has(key) }, checkboxProps);
			}).filter(({ disabled: disabled$1 }) => disabled$1);
			const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
			const allDisabledAndChecked = allDisabled && allDisabledData.every(({ checked }) => checked);
			const allDisabledSomeChecked = allDisabled && allDisabledData.some(({ checked }) => checked);
			const customCheckboxProps = (getTitleCheckboxProps === null || getTitleCheckboxProps === void 0 ? void 0 : getTitleCheckboxProps()) || {};
			const { onChange, disabled } = customCheckboxProps;
			columnTitleCheckbox = /* @__PURE__ */ import_react.createElement(checkbox_default, Object.assign({ "aria-label": customizeSelections ? "Custom selection" : "Select all" }, customCheckboxProps, {
				checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
				indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
				onChange: (e$2) => {
					onSelectAllChange();
					onChange === null || onChange === void 0 || onChange(e$2);
				},
				disabled: disabled !== null && disabled !== void 0 ? disabled : flattedData.length === 0 || allDisabled,
				skipGroup: true
			}));
			title = !hideSelectAll && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-selection` }, columnTitleCheckbox, customizeSelections);
		}
		let renderCell;
		if (selectionType === "radio") renderCell = (_, record, index$2) => {
			const key = getRowKey(record, index$2);
			const checked = keySet.has(key);
			const checkboxProps = checkboxPropsMap.get(key);
			return {
				node: /* @__PURE__ */ import_react.createElement(radio_default, Object.assign({}, checkboxProps, {
					checked,
					onClick: (e$2) => {
						var _a$1;
						e$2.stopPropagation();
						(_a$1 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a$1 === void 0 || _a$1.call(checkboxProps, e$2);
					},
					onChange: (event) => {
						var _a$1;
						if (!keySet.has(key)) triggerSingleSelection(key, true, [key], event.nativeEvent);
						(_a$1 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a$1 === void 0 || _a$1.call(checkboxProps, event);
					}
				})),
				checked
			};
		};
		else renderCell = (_, record, index$2) => {
			var _a$1;
			const key = getRowKey(record, index$2);
			const checked = keySet.has(key);
			const indeterminate = derivedHalfSelectedKeySet.has(key);
			const checkboxProps = checkboxPropsMap.get(key);
			let mergedIndeterminate;
			if (expandType === "nest") {
				mergedIndeterminate = indeterminate;
				warning$4(typeof (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== "boolean", "usage", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.");
			} else mergedIndeterminate = (_a$1 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== null && _a$1 !== void 0 ? _a$1 : indeterminate;
			return {
				node: /* @__PURE__ */ import_react.createElement(checkbox_default, Object.assign({}, checkboxProps, {
					indeterminate: mergedIndeterminate,
					checked,
					skipGroup: true,
					onClick: (e$2) => {
						var _a$2;
						e$2.stopPropagation();
						(_a$2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a$2 === void 0 || _a$2.call(checkboxProps, e$2);
					},
					onChange: (event) => {
						var _a$2;
						const { nativeEvent } = event;
						const { shiftKey } = nativeEvent;
						const currentSelectedIndex = recordKeys.findIndex((item) => item === key);
						const isMultiple$1 = derivedSelectedKeys.some((item) => recordKeys.includes(item));
						if (shiftKey && checkStrictly && isMultiple$1) {
							const changedKeys = multipleSelect(currentSelectedIndex, recordKeys, keySet);
							const keys$1 = Array.from(keySet);
							onSelectMultiple === null || onSelectMultiple === void 0 || onSelectMultiple(!checked, keys$1.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
							setSelectedKeys(keys$1, "multiple");
						} else {
							const originCheckedKeys = derivedSelectedKeys;
							if (checkStrictly) {
								const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
								triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
							} else {
								const { checkedKeys, halfCheckedKeys } = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
								let nextCheckedKeys = checkedKeys;
								if (checked) {
									const tempKeySet = new Set(checkedKeys);
									tempKeySet.delete(key);
									nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
										checked: false,
										halfCheckedKeys
									}, keyEntities, isCheckboxDisabled).checkedKeys;
								}
								triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
							}
						}
						if (checked) updatePrevSelectedIndex(null);
						else updatePrevSelectedIndex(currentSelectedIndex);
						(_a$2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a$2 === void 0 || _a$2.call(checkboxProps, event);
					}
				})),
				checked
			};
		};
		const renderSelectionCell = (_, record, index$2) => {
			const { node: node$1, checked } = renderCell(_, record, index$2);
			if (customizeRenderCell) return customizeRenderCell(checked, record, index$2, node$1);
			return node$1;
		};
		if (!cloneColumns.includes(SELECTION_COLUMN)) if (cloneColumns.findIndex((col) => {
			var _a$1;
			return ((_a$1 = col[INTERNAL_COL_DEFINE]) === null || _a$1 === void 0 ? void 0 : _a$1.columnType) === "EXPAND_COLUMN";
		}) === 0) {
			const [expandColumn, ...restColumns] = cloneColumns;
			cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
		} else cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
		const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
		warning$4(cloneColumns.filter((col) => col === SELECTION_COLUMN).length <= 1, "usage", "Multiple `SELECTION_COLUMN` exist in `columns`.");
		cloneColumns = cloneColumns.filter((column$1, index$2) => column$1 !== SELECTION_COLUMN || index$2 === selectionColumnIndex);
		const prevCol = cloneColumns[selectionColumnIndex - 1];
		const nextCol = cloneColumns[selectionColumnIndex + 1];
		let mergedFixed = fixed;
		if (mergedFixed === void 0) {
			if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) mergedFixed = nextCol.fixed;
			else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) mergedFixed = prevCol.fixed;
		}
		if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) prevCol.fixed = mergedFixed;
		const columnCls = (0, import_classnames$37.default)(`${prefixCls}-selection-col`, { [`${prefixCls}-selection-col-with-dropdown`]: selections && selectionType === "checkbox" });
		const renderColumnTitle$1 = () => {
			if (!(rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.columnTitle)) return title;
			if (typeof rowSelection.columnTitle === "function") return rowSelection.columnTitle(columnTitleCheckbox);
			return rowSelection.columnTitle;
		};
		const selectionColumn = {
			fixed: mergedFixed,
			width: selectionColWidth,
			className: `${prefixCls}-selection-column`,
			title: renderColumnTitle$1(),
			render: renderSelectionCell,
			onCell: rowSelection.onCell,
			align: rowSelection.align,
			[INTERNAL_COL_DEFINE]: { className: columnCls }
		};
		return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
	}, [
		getRowKey,
		flattedData,
		rowSelection,
		derivedSelectedKeys,
		derivedSelectedKeySet,
		derivedHalfSelectedKeySet,
		selectionColWidth,
		mergedSelections,
		expandType,
		checkboxPropsMap,
		onSelectMultiple,
		triggerSingleSelection,
		isCheckboxDisabled
	]), derivedSelectedKeySet];
};
var useSelection_default$1 = useSelection$1;

//#endregion
//#region node_modules/antd/es/_util/hooks/useProxyImperativeHandle.js
function fillProxy(element, handler) {
	element._antProxy = element._antProxy || {};
	Object.keys(handler).forEach((key) => {
		if (!(key in element._antProxy)) {
			const ori = element[key];
			element._antProxy[key] = ori;
			element[key] = handler[key];
		}
	});
	return element;
}
function useProxyImperativeHandle(ref, init) {
	return (0, import_react.useImperativeHandle)(ref, () => {
		const refObj = init();
		const { nativeElement } = refObj;
		if (typeof Proxy !== "undefined") return new Proxy(nativeElement, { get(obj, prop) {
			if (refObj[prop]) return refObj[prop];
			return Reflect.get(obj, prop);
		} });
		return fillProxy(nativeElement, refObj);
	});
}

//#endregion
//#region node_modules/antd/es/table/ExpandIcon.js
var import_classnames$36 = /* @__PURE__ */ __toESM(require_classnames());
function renderExpandIcon(locale$5) {
	return (props) => {
		const { prefixCls, onExpand, record, expanded, expandable } = props;
		const iconPrefix = `${prefixCls}-row-expand-icon`;
		return /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			onClick: (e$2) => {
				onExpand(record, e$2);
				e$2.stopPropagation();
			},
			className: (0, import_classnames$36.default)(iconPrefix, {
				[`${iconPrefix}-spaced`]: !expandable,
				[`${iconPrefix}-expanded`]: expandable && expanded,
				[`${iconPrefix}-collapsed`]: expandable && !expanded
			}),
			"aria-label": expanded ? locale$5.collapse : locale$5.expand,
			"aria-expanded": expanded
		});
	};
}
var ExpandIcon_default = renderExpandIcon;

//#endregion
//#region node_modules/antd/es/table/hooks/useContainerWidth.js
function useContainerWidth(prefixCls) {
	const getContainerWidth = (ele, width) => {
		const container = ele.querySelector(`.${prefixCls}-container`);
		let returnWidth = width;
		if (container) {
			const style$1 = getComputedStyle(container);
			const borderLeft = parseInt(style$1.borderLeftWidth, 10);
			const borderRight = parseInt(style$1.borderRightWidth, 10);
			returnWidth = width - borderLeft - borderRight;
		}
		return returnWidth;
	};
	return getContainerWidth;
}

//#endregion
//#region node_modules/antd/es/table/util.js
const getColumnKey = (column$1, defaultKey) => {
	if ("key" in column$1 && column$1.key !== void 0 && column$1.key !== null) return column$1.key;
	if (column$1.dataIndex) return Array.isArray(column$1.dataIndex) ? column$1.dataIndex.join(".") : column$1.dataIndex;
	return defaultKey;
};
function getColumnPos(index$2, pos) {
	return pos ? `${pos}-${index$2}` : `${index$2}`;
}
const renderColumnTitle = (title, props) => {
	if (typeof title === "function") return title(props);
	return title;
};
/**
* Safe get column title
*
* Should filter [object Object]
*
* @param title
*/
const safeColumnTitle = (title, props) => {
	const res = renderColumnTitle(title, props);
	if (Object.prototype.toString.call(res) === "[object Object]") return "";
	return res;
};

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/FilterFilled.js
var FilterFilled = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" }
		}]
	},
	"name": "filter",
	"theme": "filled"
};
var FilterFilled_default$1 = FilterFilled;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/FilterFilled.js
/**![filter](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTM0OSA4MzhjMCAxNy43IDE0LjIgMzIgMzEuOCAzMmgyNjIuNGMxNy42IDAgMzEuOC0xNC4zIDMxLjgtMzJWNjQySDM0OXYxOTZ6bTUzMS4xLTY4NEgxNDMuOWMtMjQuNSAwLTM5LjggMjYuNy0yNy41IDQ4bDIyMS4zIDM3NmgzNDguOGwyMjEuMy0zNzZjMTIuMS0yMS4zLTMuMi00OC0yNy43LTQ4eiIgLz48L3N2Zz4=) */
var RefIcon$17 = /* @__PURE__ */ import_react.forwardRef(function FilterFilled$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: FilterFilled_default$1
	}));
});
RefIcon$17.displayName = "FilterFilled";
var FilterFilled_default = RefIcon$17;

//#endregion
//#region node_modules/antd/es/_util/hooks/useSyncState.js
function useSyncState(initialValue) {
	const ref = import_react.useRef(initialValue);
	const forceUpdate = useForceUpdate();
	return [() => ref.current, (newValue) => {
		ref.current = newValue;
		forceUpdate();
	}];
}

//#endregion
//#region node_modules/rc-tree/es/DropIndicator.js
var DropIndicator = function DropIndicator$1(props) {
	var dropPosition = props.dropPosition, dropLevelOffset = props.dropLevelOffset, indent = props.indent;
	var style$1 = {
		pointerEvents: "none",
		position: "absolute",
		right: 0,
		backgroundColor: "red",
		height: 2
	};
	switch (dropPosition) {
		case -1:
			style$1.top = 0;
			style$1.left = -dropLevelOffset * indent;
			break;
		case 1:
			style$1.bottom = 0;
			style$1.left = -dropLevelOffset * indent;
			break;
		case 0:
			style$1.bottom = 0;
			style$1.left = indent;
			break;
	}
	return /* @__PURE__ */ import_react.createElement("div", { style: style$1 });
};
DropIndicator.displayName = "DropIndicator";
var DropIndicator_default = DropIndicator;

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js
function _objectDestructuringEmpty(t$1) {
	if (null == t$1) throw new TypeError("Cannot destructure " + t$1);
}

//#endregion
//#region node_modules/rc-tree/es/useUnmount.js
/**
* Trigger only when component unmount
*/
function useUnmount(triggerStart, triggerEnd) {
	var _React$useState = import_react.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), firstMount = _React$useState2[0], setFirstMount = _React$useState2[1];
	useLayoutEffect_default(function() {
		if (firstMount) {
			triggerStart();
			return function() {
				triggerEnd();
			};
		}
	}, [firstMount]);
	useLayoutEffect_default(function() {
		setFirstMount(true);
		return function() {
			setFirstMount(false);
		};
	}, []);
}
var useUnmount_default = useUnmount;

//#endregion
//#region node_modules/rc-tree/es/MotionTreeNode.js
var import_classnames$35 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$5 = [
	"className",
	"style",
	"motion",
	"motionNodes",
	"motionType",
	"onMotionStart",
	"onMotionEnd",
	"active",
	"treeNodeRequiredProps"
];
var MotionTreeNode = /* @__PURE__ */ import_react.forwardRef(function(oriProps, ref) {
	var className = oriProps.className, style$1 = oriProps.style, motion$1 = oriProps.motion, motionNodes = oriProps.motionNodes, motionType = oriProps.motionType, onOriginMotionStart = oriProps.onMotionStart, onOriginMotionEnd = oriProps.onMotionEnd, active = oriProps.active, treeNodeRequiredProps = oriProps.treeNodeRequiredProps, props = _objectWithoutProperties(oriProps, _excluded$5);
	var _React$useState = import_react.useState(true), _React$useState2 = _slicedToArray(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
	var _React$useContext = import_react.useContext(TreeContext), prefixCls = _React$useContext.prefixCls;
	var targetVisible = motionNodes && motionType !== "hide";
	useLayoutEffect_default(function() {
		if (motionNodes) {
			if (targetVisible !== visible) setVisible(targetVisible);
		}
	}, [motionNodes]);
	var triggerMotionStart = function triggerMotionStart$1() {
		if (motionNodes) onOriginMotionStart();
	};
	var triggerMotionEndRef = import_react.useRef(false);
	var triggerMotionEnd = function triggerMotionEnd$1() {
		if (motionNodes && !triggerMotionEndRef.current) {
			triggerMotionEndRef.current = true;
			onOriginMotionEnd();
		}
	};
	useUnmount_default(triggerMotionStart, triggerMotionEnd);
	var onVisibleChanged = function onVisibleChanged$1(nextVisible) {
		if (targetVisible === nextVisible) triggerMotionEnd();
	};
	if (motionNodes) return /* @__PURE__ */ import_react.createElement(es_default$2, _extends({
		ref,
		visible
	}, motion$1, {
		motionAppear: motionType === "show",
		onVisibleChanged
	}), function(_ref, motionRef) {
		var motionClassName = _ref.className, motionStyle = _ref.style;
		return /* @__PURE__ */ import_react.createElement("div", {
			ref: motionRef,
			className: (0, import_classnames$35.default)("".concat(prefixCls, "-treenode-motion"), motionClassName),
			style: motionStyle
		}, motionNodes.map(function(treeNode) {
			var restProps = Object.assign({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
			delete restProps.children;
			var treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
			return /* @__PURE__ */ import_react.createElement(TreeNode_default$1, _extends({}, restProps, treeNodeProps, {
				title,
				active,
				data: treeNode.data,
				key,
				isStart,
				isEnd
			}));
		}));
	});
	return /* @__PURE__ */ import_react.createElement(TreeNode_default$1, _extends({
		domRef: ref,
		className,
		style: style$1
	}, props, { active }));
});
MotionTreeNode.displayName = "MotionTreeNode";
var MotionTreeNode_default = MotionTreeNode;

//#endregion
//#region node_modules/rc-tree/es/utils/diffUtil.js
function findExpandedKeys() {
	var prev$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
	var next$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	var prevLen = prev$1.length;
	var nextLen = next$1.length;
	if (Math.abs(prevLen - nextLen) !== 1) return {
		add: false,
		key: null
	};
	function find(shorter, longer) {
		var cache = /* @__PURE__ */ new Map();
		shorter.forEach(function(key) {
			cache.set(key, true);
		});
		var keys$1 = longer.filter(function(key) {
			return !cache.has(key);
		});
		return keys$1.length === 1 ? keys$1[0] : null;
	}
	if (prevLen < nextLen) return {
		add: true,
		key: find(prev$1, next$1)
	};
	return {
		add: false,
		key: find(next$1, prev$1)
	};
}
function getExpandRange(shorter, longer, key) {
	var shorterStartIndex = shorter.findIndex(function(data) {
		return data.key === key;
	});
	var shorterEndNode = shorter[shorterStartIndex + 1];
	var longerStartIndex = longer.findIndex(function(data) {
		return data.key === key;
	});
	if (shorterEndNode) {
		var longerEndIndex = longer.findIndex(function(data) {
			return data.key === shorterEndNode.key;
		});
		return longer.slice(longerStartIndex + 1, longerEndIndex);
	}
	return longer.slice(longerStartIndex + 1);
}

//#endregion
//#region node_modules/rc-tree/es/NodeList.js
var _excluded$4 = [
	"prefixCls",
	"data",
	"selectable",
	"checkable",
	"expandedKeys",
	"selectedKeys",
	"checkedKeys",
	"loadedKeys",
	"loadingKeys",
	"halfCheckedKeys",
	"keyEntities",
	"disabled",
	"dragging",
	"dragOverNodeKey",
	"dropPosition",
	"motion",
	"height",
	"itemHeight",
	"virtual",
	"scrollWidth",
	"focusable",
	"activeItem",
	"focused",
	"tabIndex",
	"onKeyDown",
	"onFocus",
	"onBlur",
	"onActiveChange",
	"onListChangeStart",
	"onListChangeEnd"
];
var HIDDEN_STYLE$1 = {
	width: 0,
	height: 0,
	display: "flex",
	overflow: "hidden",
	opacity: 0,
	border: 0,
	padding: 0,
	margin: 0
};
var noop = function noop$5() {};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = { key: MOTION_KEY };
var MotionEntity = {
	key: MOTION_KEY,
	level: 0,
	index: 0,
	pos: "0",
	node: MotionNode,
	nodes: [MotionNode]
};
var MotionFlattenData = {
	parent: null,
	children: [],
	pos: MotionEntity.pos,
	data: MotionNode,
	title: null,
	key: MOTION_KEY,
	isStart: [],
	isEnd: []
};
/**
* We only need get visible content items to play the animation.
*/
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
	if (virtual === false || !height) return list;
	return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
	var key = item.key, pos = item.pos;
	return getKey(key, pos);
}
function getAccessibilityPath(item) {
	var path$1 = String(item.data.key);
	var current = item;
	while (current.parent) {
		current = current.parent;
		path$1 = "".concat(current.data.key, " > ").concat(path$1);
	}
	return path$1;
}
var NodeList = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var prefixCls = props.prefixCls, data = props.data;
	props.selectable;
	props.checkable;
	var expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion$1 = props.motion, height = props.height, itemHeight = props.itemHeight, virtual = props.virtual, scrollWidth = props.scrollWidth, focusable$1 = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown$1 = props.onKeyDown, onFocus = props.onFocus, onBlur = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = _objectWithoutProperties(props, _excluded$4);
	var listRef = import_react.useRef(null);
	var indentMeasurerRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, function() {
		return {
			scrollTo: function scrollTo$1(scroll) {
				listRef.current.scrollTo(scroll);
			},
			getIndentWidth: function getIndentWidth() {
				return indentMeasurerRef.current.offsetWidth;
			}
		};
	});
	var _React$useState = import_react.useState(expandedKeys), _React$useState2 = _slicedToArray(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1];
	var _React$useState3 = import_react.useState(data), _React$useState4 = _slicedToArray(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1];
	var _React$useState5 = import_react.useState(data), _React$useState6 = _slicedToArray(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1];
	var _React$useState7 = import_react.useState([]), _React$useState8 = _slicedToArray(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1];
	var _React$useState9 = import_react.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1];
	var dataRef = import_react.useRef(data);
	dataRef.current = data;
	function onMotionEnd() {
		var latestData = dataRef.current;
		setPrevData(latestData);
		setTransitionData(latestData);
		setTransitionRange([]);
		setMotionType(null);
		onListChangeEnd();
	}
	useLayoutEffect_default(function() {
		setPrevExpandedKeys(expandedKeys);
		var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
		if (diffExpanded.key !== null) if (diffExpanded.add) {
			var keyIndex$1 = prevData.findIndex(function(_ref) {
				return _ref.key === diffExpanded.key;
			});
			var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
			var newTransitionData = prevData.slice();
			newTransitionData.splice(keyIndex$1 + 1, 0, MotionFlattenData);
			setTransitionData(newTransitionData);
			setTransitionRange(rangeNodes);
			setMotionType("show");
		} else {
			var _keyIndex = data.findIndex(function(_ref2) {
				return _ref2.key === diffExpanded.key;
			});
			var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
			var _newTransitionData = data.slice();
			_newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
			setTransitionData(_newTransitionData);
			setTransitionRange(_rangeNodes);
			setMotionType("hide");
		}
		else if (prevData !== data) {
			setPrevData(data);
			setTransitionData(data);
		}
	}, [expandedKeys, data]);
	import_react.useEffect(function() {
		if (!dragging) onMotionEnd();
	}, [dragging]);
	var mergedData = motion$1 ? transitionData : data;
	var treeNodeRequiredProps = {
		expandedKeys,
		selectedKeys,
		loadedKeys,
		loadingKeys,
		checkedKeys,
		halfCheckedKeys,
		dragOverNodeKey,
		dropPosition,
		keyEntities
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, focused && activeItem && /* @__PURE__ */ import_react.createElement("span", {
		style: HIDDEN_STYLE$1,
		"aria-live": "assertive"
	}, getAccessibilityPath(activeItem)), /* @__PURE__ */ import_react.createElement("div", null, /* @__PURE__ */ import_react.createElement("input", {
		style: HIDDEN_STYLE$1,
		disabled: focusable$1 === false || disabled,
		tabIndex: focusable$1 !== false ? tabIndex : null,
		onKeyDown: onKeyDown$1,
		onFocus,
		onBlur,
		value: "",
		onChange: noop,
		"aria-label": "for screen reader"
	})), /* @__PURE__ */ import_react.createElement("div", {
		className: "".concat(prefixCls, "-treenode"),
		"aria-hidden": true,
		style: {
			position: "absolute",
			pointerEvents: "none",
			visibility: "hidden",
			height: 0,
			overflow: "hidden",
			border: 0,
			padding: 0
		}
	}, /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-indent") }, /* @__PURE__ */ import_react.createElement("div", {
		ref: indentMeasurerRef,
		className: "".concat(prefixCls, "-indent-unit")
	}))), /* @__PURE__ */ import_react.createElement(es_default$8, _extends({}, domProps, {
		data: mergedData,
		itemKey,
		height,
		fullHeight: false,
		virtual,
		itemHeight,
		scrollWidth,
		prefixCls: "".concat(prefixCls, "-list"),
		ref: listRef,
		role: "tree",
		onVisibleChange: function onVisibleChange(originList) {
			if (originList.every(function(item) {
				return itemKey(item) !== MOTION_KEY;
			})) onMotionEnd();
		}
	}), function(treeNode) {
		var pos = treeNode.pos, restProps = Object.assign({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
		var mergedKey = getKey(key, pos);
		delete restProps.key;
		delete restProps.children;
		var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
		return /* @__PURE__ */ import_react.createElement(MotionTreeNode_default, _extends({}, restProps, treeNodeProps, {
			title,
			active: !!activeItem && key === activeItem.key,
			pos,
			data: treeNode.data,
			isStart,
			isEnd,
			motion: motion$1,
			motionNodes: key === MOTION_KEY ? transitionRange : null,
			motionType,
			onMotionStart: onListChangeStart,
			onMotionEnd,
			treeNodeRequiredProps,
			onMouseMove: function onMouseMove() {
				onActiveChange(null);
			}
		}));
	}));
});
NodeList.displayName = "NodeList";
var NodeList_default = NodeList;

//#endregion
//#region node_modules/rc-tree/es/Tree.js
var import_classnames$34 = /* @__PURE__ */ __toESM(require_classnames());
var MAX_RETRY_TIMES = 10;
var Tree$2 = /* @__PURE__ */ function(_React$Component) {
	_inherits(Tree$3, _React$Component);
	var _super = _createSuper(Tree$3);
	function Tree$3() {
		var _this;
		_classCallCheck(this, Tree$3);
		for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) _args[_key] = arguments[_key];
		_this = _super.call.apply(_super, [this].concat(_args));
		_defineProperty(_assertThisInitialized(_this), "destroyed", false);
		_defineProperty(_assertThisInitialized(_this), "delayedDragEnterLogic", void 0);
		_defineProperty(_assertThisInitialized(_this), "loadingRetryTimes", {});
		_defineProperty(_assertThisInitialized(_this), "state", {
			keyEntities: {},
			indent: null,
			selectedKeys: [],
			checkedKeys: [],
			halfCheckedKeys: [],
			loadedKeys: [],
			loadingKeys: [],
			expandedKeys: [],
			draggingNodeKey: null,
			dragChildrenKeys: [],
			dropTargetKey: null,
			dropPosition: null,
			dropContainerKey: null,
			dropLevelOffset: null,
			dropTargetPos: null,
			dropAllowed: true,
			dragOverNodeKey: null,
			treeData: [],
			flattenNodes: [],
			focused: false,
			activeKey: null,
			listChanging: false,
			prevProps: null,
			fieldNames: fillFieldNames$1()
		});
		_defineProperty(_assertThisInitialized(_this), "dragStartMousePosition", null);
		_defineProperty(_assertThisInitialized(_this), "dragNodeProps", null);
		_defineProperty(_assertThisInitialized(_this), "currentMouseOverDroppableNodeKey", null);
		_defineProperty(_assertThisInitialized(_this), "listRef", /* @__PURE__ */ import_react.createRef());
		_defineProperty(_assertThisInitialized(_this), "onNodeDragStart", function(event, nodeProps) {
			var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities;
			var onDragStart = _this.props.onDragStart;
			var eventKey = nodeProps.eventKey;
			_this.dragNodeProps = nodeProps;
			_this.dragStartMousePosition = {
				x: event.clientX,
				y: event.clientY
			};
			var newExpandedKeys = arrDel(expandedKeys, eventKey);
			_this.setState({
				draggingNodeKey: eventKey,
				dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
				indent: _this.listRef.current.getIndentWidth()
			});
			_this.setExpandedKeys(newExpandedKeys);
			window.addEventListener("dragend", _this.onWindowDragEnd);
			onDragStart === null || onDragStart === void 0 || onDragStart({
				event,
				node: convertNodePropsToEventData(nodeProps)
			});
		});
		/**
		* [Legacy] Select handler is smaller than node,
		* so that this will trigger when drag enter node or select handler.
		* This is a little tricky if customize css without padding.
		* Better for use mouse move event to refresh drag state.
		* But let's just keep it to avoid event trigger logic change.
		*/
		_defineProperty(_assertThisInitialized(_this), "onNodeDragEnter", function(event, nodeProps) {
			var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent;
			var _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop = _this$props.allowDrop, direction = _this$props.direction;
			var pos = nodeProps.pos, eventKey = nodeProps.eventKey;
			if (_this.currentMouseOverDroppableNodeKey !== eventKey) _this.currentMouseOverDroppableNodeKey = eventKey;
			if (!_this.dragNodeProps) {
				_this.resetDragState();
				return;
			}
			var _calcDropPosition = calcDropPosition(event, _this.dragNodeProps, nodeProps, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
			if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {
				_this.resetDragState();
				return;
			}
			if (!_this.delayedDragEnterLogic) _this.delayedDragEnterLogic = {};
			Object.keys(_this.delayedDragEnterLogic).forEach(function(key) {
				clearTimeout(_this.delayedDragEnterLogic[key]);
			});
			if (_this.dragNodeProps.eventKey !== nodeProps.eventKey) {
				event.persist();
				_this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
					if (_this.state.draggingNodeKey === null) return;
					var newExpandedKeys = _toConsumableArray(expandedKeys);
					var entity = getEntity(keyEntities, nodeProps.eventKey);
					if (entity && (entity.children || []).length) newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);
					if (!_this.props.hasOwnProperty("expandedKeys")) _this.setExpandedKeys(newExpandedKeys);
					onExpand === null || onExpand === void 0 || onExpand(newExpandedKeys, {
						node: convertNodePropsToEventData(nodeProps),
						expanded: true,
						nativeEvent: event.nativeEvent
					});
				}, 800);
			}
			if (_this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
				_this.resetDragState();
				return;
			}
			_this.setState({
				dragOverNodeKey,
				dropPosition,
				dropLevelOffset,
				dropTargetKey,
				dropContainerKey,
				dropTargetPos,
				dropAllowed
			});
			onDragEnter === null || onDragEnter === void 0 || onDragEnter({
				event,
				node: convertNodePropsToEventData(nodeProps),
				expandedKeys
			});
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeDragOver", function(event, nodeProps) {
			var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent;
			var _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop = _this$props2.allowDrop, direction = _this$props2.direction;
			if (!_this.dragNodeProps) return;
			var _calcDropPosition2 = calcDropPosition(event, _this.dragNodeProps, nodeProps, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropTargetPos = _calcDropPosition2.dropTargetPos, dropAllowed = _calcDropPosition2.dropAllowed, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
			if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) return;
			if (_this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
				if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) _this.resetDragState();
			} else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) _this.setState({
				dropPosition,
				dropLevelOffset,
				dropTargetKey,
				dropContainerKey,
				dropTargetPos,
				dropAllowed,
				dragOverNodeKey
			});
			onDragOver === null || onDragOver === void 0 || onDragOver({
				event,
				node: convertNodePropsToEventData(nodeProps)
			});
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeDragLeave", function(event, nodeProps) {
			if (_this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
				_this.resetDragState();
				_this.currentMouseOverDroppableNodeKey = null;
			}
			var onDragLeave = _this.props.onDragLeave;
			onDragLeave === null || onDragLeave === void 0 || onDragLeave({
				event,
				node: convertNodePropsToEventData(nodeProps)
			});
		});
		_defineProperty(_assertThisInitialized(_this), "onWindowDragEnd", function(event) {
			_this.onNodeDragEnd(event, null, true);
			window.removeEventListener("dragend", _this.onWindowDragEnd);
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeDragEnd", function(event, nodeProps) {
			var onDragEnd = _this.props.onDragEnd;
			_this.setState({ dragOverNodeKey: null });
			_this.cleanDragState();
			onDragEnd === null || onDragEnd === void 0 || onDragEnd({
				event,
				node: convertNodePropsToEventData(nodeProps)
			});
			_this.dragNodeProps = null;
			window.removeEventListener("dragend", _this.onWindowDragEnd);
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeDrop", function(event, _) {
			var _this$getActiveItem;
			var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
			var _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos;
			if (!_this$state4.dropAllowed) return;
			var onDrop = _this.props.onDrop;
			_this.setState({ dragOverNodeKey: null });
			_this.cleanDragState();
			if (dropTargetKey === null) return;
			var abstractDropNodeProps = _objectSpread2(_objectSpread2({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
				active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
				data: getEntity(_this.state.keyEntities, dropTargetKey).node
			});
			var dropToChild = dragChildrenKeys.includes(dropTargetKey);
			warning_default(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
			var posArr = posToArr(dropTargetPos);
			var dropResult = {
				event,
				node: convertNodePropsToEventData(abstractDropNodeProps),
				dragNode: _this.dragNodeProps ? convertNodePropsToEventData(_this.dragNodeProps) : null,
				dragNodesKeys: [_this.dragNodeProps.eventKey].concat(dragChildrenKeys),
				dropToGap: dropPosition !== 0,
				dropPosition: dropPosition + Number(posArr[posArr.length - 1])
			};
			if (!outsideTree) onDrop === null || onDrop === void 0 || onDrop(dropResult);
			_this.dragNodeProps = null;
		});
		_defineProperty(_assertThisInitialized(_this), "cleanDragState", function() {
			if (_this.state.draggingNodeKey !== null) _this.setState({
				draggingNodeKey: null,
				dropPosition: null,
				dropContainerKey: null,
				dropTargetKey: null,
				dropLevelOffset: null,
				dropAllowed: true,
				dragOverNodeKey: null
			});
			_this.dragStartMousePosition = null;
			_this.currentMouseOverDroppableNodeKey = null;
		});
		_defineProperty(_assertThisInitialized(_this), "triggerExpandActionExpand", function(e$2, treeNode) {
			var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes;
			var expanded = treeNode.expanded, key = treeNode.key;
			if (treeNode.isLeaf || e$2.shiftKey || e$2.metaKey || e$2.ctrlKey) return;
			var node$1 = flattenNodes.filter(function(nodeItem) {
				return nodeItem.key === key;
			})[0];
			var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(key, _this.getTreeNodeRequiredProps())), {}, { data: node$1.data }));
			_this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
			_this.onNodeExpand(e$2, eventNode);
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeClick", function(e$2, treeNode) {
			var _this$props3 = _this.props, onClick = _this$props3.onClick;
			if (_this$props3.expandAction === "click") _this.triggerExpandActionExpand(e$2, treeNode);
			onClick === null || onClick === void 0 || onClick(e$2, treeNode);
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeDoubleClick", function(e$2, treeNode) {
			var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick;
			if (_this$props4.expandAction === "doubleClick") _this.triggerExpandActionExpand(e$2, treeNode);
			onDoubleClick === null || onDoubleClick === void 0 || onDoubleClick(e$2, treeNode);
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeSelect", function(e$2, treeNode) {
			var selectedKeys = _this.state.selectedKeys;
			var _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames;
			var _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple;
			var selected = treeNode.selected;
			var key = treeNode[fieldNames.key];
			var targetSelected = !selected;
			if (!targetSelected) selectedKeys = arrDel(selectedKeys, key);
			else if (!multiple) selectedKeys = [key];
			else selectedKeys = arrAdd(selectedKeys, key);
			var selectedNodes = selectedKeys.map(function(selectedKey) {
				var entity = getEntity(keyEntities, selectedKey);
				return entity ? entity.node : null;
			}).filter(Boolean);
			_this.setUncontrolledState({ selectedKeys });
			onSelect === null || onSelect === void 0 || onSelect(selectedKeys, {
				event: "select",
				selected: targetSelected,
				node: treeNode,
				selectedNodes,
				nativeEvent: e$2.nativeEvent
			});
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeCheck", function(e$2, treeNode, checked) {
			var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
			var _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck;
			var key = treeNode.key;
			var checkedObj;
			var eventObj = {
				event: "check",
				node: treeNode,
				checked,
				nativeEvent: e$2.nativeEvent
			};
			if (checkStrictly) {
				var checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
				var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
				checkedObj = {
					checked: checkedKeys,
					halfChecked: halfCheckedKeys
				};
				eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
					return getEntity(keyEntities, checkedKey);
				}).filter(Boolean).map(function(entity) {
					return entity.node;
				});
				_this.setUncontrolledState({ checkedKeys });
			} else {
				var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key]), true, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
				if (!checked) {
					var keySet = new Set(_checkedKeys);
					keySet.delete(key);
					var _conductCheck2 = conductCheck(Array.from(keySet), {
						checked: false,
						halfCheckedKeys: _halfCheckedKeys
					}, keyEntities);
					_checkedKeys = _conductCheck2.checkedKeys;
					_halfCheckedKeys = _conductCheck2.halfCheckedKeys;
				}
				checkedObj = _checkedKeys;
				eventObj.checkedNodes = [];
				eventObj.checkedNodesPositions = [];
				eventObj.halfCheckedKeys = _halfCheckedKeys;
				_checkedKeys.forEach(function(checkedKey) {
					var entity = getEntity(keyEntities, checkedKey);
					if (!entity) return;
					var node$1 = entity.node, pos = entity.pos;
					eventObj.checkedNodes.push(node$1);
					eventObj.checkedNodesPositions.push({
						node: node$1,
						pos
					});
				});
				_this.setUncontrolledState({ checkedKeys: _checkedKeys }, false, { halfCheckedKeys: _halfCheckedKeys });
			}
			onCheck === null || onCheck === void 0 || onCheck(checkedObj, eventObj);
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeLoad", function(treeNode) {
			var _entity$children;
			var key = treeNode.key;
			var keyEntities = _this.state.keyEntities;
			var entity = getEntity(keyEntities, key);
			if (entity !== null && entity !== void 0 && (_entity$children = entity.children) !== null && _entity$children !== void 0 && _entity$children.length) return;
			var loadPromise = new Promise(function(resolve, reject) {
				_this.setState(function(_ref) {
					var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
					var _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
					if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) return null;
					loadData(treeNode).then(function() {
						var currentLoadedKeys = _this.state.loadedKeys;
						var newLoadedKeys = arrAdd(currentLoadedKeys, key);
						onLoad === null || onLoad === void 0 || onLoad(newLoadedKeys, {
							event: "load",
							node: treeNode
						});
						_this.setUncontrolledState({ loadedKeys: newLoadedKeys });
						_this.setState(function(prevState) {
							return { loadingKeys: arrDel(prevState.loadingKeys, key) };
						});
						resolve();
					}).catch(function(e$2) {
						_this.setState(function(prevState) {
							return { loadingKeys: arrDel(prevState.loadingKeys, key) };
						});
						_this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1;
						if (_this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
							var currentLoadedKeys = _this.state.loadedKeys;
							warning_default(false, "Retry for `loadData` many times but still failed. No more retry.");
							_this.setUncontrolledState({ loadedKeys: arrAdd(currentLoadedKeys, key) });
							resolve();
						}
						reject(e$2);
					});
					return { loadingKeys: arrAdd(loadingKeys, key) };
				});
			});
			loadPromise.catch(function() {});
			return loadPromise;
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeMouseEnter", function(event, node$1) {
			var onMouseEnter = _this.props.onMouseEnter;
			onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
				event,
				node: node$1
			});
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeMouseLeave", function(event, node$1) {
			var onMouseLeave = _this.props.onMouseLeave;
			onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
				event,
				node: node$1
			});
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeContextMenu", function(event, node$1) {
			var onRightClick = _this.props.onRightClick;
			if (onRightClick) {
				event.preventDefault();
				onRightClick({
					event,
					node: node$1
				});
			}
		});
		_defineProperty(_assertThisInitialized(_this), "onFocus", function() {
			var onFocus = _this.props.onFocus;
			_this.setState({ focused: true });
			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
			onFocus === null || onFocus === void 0 || onFocus.apply(void 0, args);
		});
		_defineProperty(_assertThisInitialized(_this), "onBlur", function() {
			var onBlur = _this.props.onBlur;
			_this.setState({ focused: false });
			_this.onActiveChange(null);
			for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
			onBlur === null || onBlur === void 0 || onBlur.apply(void 0, args);
		});
		_defineProperty(_assertThisInitialized(_this), "getTreeNodeRequiredProps", function() {
			var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
			return {
				expandedKeys: expandedKeys || [],
				selectedKeys: selectedKeys || [],
				loadedKeys: loadedKeys || [],
				loadingKeys: loadingKeys || [],
				checkedKeys: checkedKeys || [],
				halfCheckedKeys: halfCheckedKeys || [],
				dragOverNodeKey,
				dropPosition,
				keyEntities
			};
		});
		/** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */
		_defineProperty(_assertThisInitialized(_this), "setExpandedKeys", function(expandedKeys) {
			var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames;
			var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
			_this.setUncontrolledState({
				expandedKeys,
				flattenNodes
			}, true);
		});
		_defineProperty(_assertThisInitialized(_this), "onNodeExpand", function(e$2, treeNode) {
			var expandedKeys = _this.state.expandedKeys;
			var _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames;
			var _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData;
			var expanded = treeNode.expanded;
			var key = treeNode[fieldNames.key];
			if (listChanging) return;
			var certain = expandedKeys.includes(key);
			var targetExpanded = !expanded;
			warning_default(expanded && certain || !expanded && !certain, "Expand state not sync with index check");
			expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);
			_this.setExpandedKeys(expandedKeys);
			onExpand === null || onExpand === void 0 || onExpand(expandedKeys, {
				node: treeNode,
				expanded: targetExpanded,
				nativeEvent: e$2.nativeEvent
			});
			if (targetExpanded && loadData) {
				var loadPromise = _this.onNodeLoad(treeNode);
				if (loadPromise) loadPromise.then(function() {
					var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
					_this.setUncontrolledState({ flattenNodes: newFlattenTreeData });
				}).catch(function() {
					var currentExpandedKeys = _this.state.expandedKeys;
					var expandedKeysToRestore = arrDel(currentExpandedKeys, key);
					_this.setExpandedKeys(expandedKeysToRestore);
				});
			}
		});
		_defineProperty(_assertThisInitialized(_this), "onListChangeStart", function() {
			_this.setUncontrolledState({ listChanging: true });
		});
		_defineProperty(_assertThisInitialized(_this), "onListChangeEnd", function() {
			setTimeout(function() {
				_this.setUncontrolledState({ listChanging: false });
			});
		});
		_defineProperty(_assertThisInitialized(_this), "onActiveChange", function(newActiveKey) {
			var activeKey = _this.state.activeKey;
			var _this$props9 = _this.props, onActiveChange = _this$props9.onActiveChange, _this$props9$itemScro = _this$props9.itemScrollOffset, itemScrollOffset = _this$props9$itemScro === void 0 ? 0 : _this$props9$itemScro;
			if (activeKey === newActiveKey) return;
			_this.setState({ activeKey: newActiveKey });
			if (newActiveKey !== null) _this.scrollTo({
				key: newActiveKey,
				offset: itemScrollOffset
			});
			onActiveChange === null || onActiveChange === void 0 || onActiveChange(newActiveKey);
		});
		_defineProperty(_assertThisInitialized(_this), "getActiveItem", function() {
			var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
			if (activeKey === null) return null;
			return flattenNodes.find(function(_ref2) {
				return _ref2.key === activeKey;
			}) || null;
		});
		_defineProperty(_assertThisInitialized(_this), "offsetActiveKey", function(offset$2) {
			var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey;
			var index$2 = flattenNodes.findIndex(function(_ref3) {
				return _ref3.key === activeKey;
			});
			if (index$2 === -1 && offset$2 < 0) index$2 = flattenNodes.length;
			index$2 = (index$2 + offset$2 + flattenNodes.length) % flattenNodes.length;
			var item = flattenNodes[index$2];
			if (item) {
				var _key4 = item.key;
				_this.onActiveChange(_key4);
			} else _this.onActiveChange(null);
		});
		_defineProperty(_assertThisInitialized(_this), "onKeyDown", function(event) {
			var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames;
			var _this$props10 = _this.props, onKeyDown$1 = _this$props10.onKeyDown, checkable = _this$props10.checkable, selectable = _this$props10.selectable;
			switch (event.which) {
				case KeyCode_default.UP:
					_this.offsetActiveKey(-1);
					event.preventDefault();
					break;
				case KeyCode_default.DOWN:
					_this.offsetActiveKey(1);
					event.preventDefault();
					break;
			}
			var activeItem = _this.getActiveItem();
			if (activeItem && activeItem.data) {
				var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
				var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
				var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
					data: activeItem.data,
					active: true
				}));
				switch (event.which) {
					case KeyCode_default.LEFT:
						if (expandable && expandedKeys.includes(activeKey)) _this.onNodeExpand({}, eventNode);
						else if (activeItem.parent) _this.onActiveChange(activeItem.parent.key);
						event.preventDefault();
						break;
					case KeyCode_default.RIGHT:
						if (expandable && !expandedKeys.includes(activeKey)) _this.onNodeExpand({}, eventNode);
						else if (activeItem.children && activeItem.children.length) _this.onActiveChange(activeItem.children[0].key);
						event.preventDefault();
						break;
					case KeyCode_default.ENTER:
					case KeyCode_default.SPACE:
						if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
						else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) _this.onNodeSelect({}, eventNode);
						break;
				}
			}
			onKeyDown$1 === null || onKeyDown$1 === void 0 || onKeyDown$1(event);
		});
		/**
		* Only update the value which is not in props
		*/
		_defineProperty(_assertThisInitialized(_this), "setUncontrolledState", function(state) {
			var atomic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			var forceState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
			if (!_this.destroyed) {
				var needSync = false;
				var allPassed = true;
				var newState = {};
				Object.keys(state).forEach(function(name) {
					if (_this.props.hasOwnProperty(name)) {
						allPassed = false;
						return;
					}
					needSync = true;
					newState[name] = state[name];
				});
				if (needSync && (!atomic || allPassed)) _this.setState(_objectSpread2(_objectSpread2({}, newState), forceState));
			}
		});
		_defineProperty(_assertThisInitialized(_this), "scrollTo", function(scroll) {
			_this.listRef.current.scrollTo(scroll);
		});
		return _this;
	}
	_createClass(Tree$3, [
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				this.destroyed = false;
				this.onUpdated();
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate() {
				this.onUpdated();
			}
		},
		{
			key: "onUpdated",
			value: function onUpdated() {
				var _this$props11 = this.props, activeKey = _this$props11.activeKey, _this$props11$itemScr = _this$props11.itemScrollOffset, itemScrollOffset = _this$props11$itemScr === void 0 ? 0 : _this$props11$itemScr;
				if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
					this.setState({ activeKey });
					if (activeKey !== null) this.scrollTo({
						key: activeKey,
						offset: itemScrollOffset
					});
				}
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				window.removeEventListener("dragend", this.onWindowDragEnd);
				this.destroyed = true;
			}
		},
		{
			key: "resetDragState",
			value: function resetDragState() {
				this.setState({
					dragOverNodeKey: null,
					dropPosition: null,
					dropLevelOffset: null,
					dropTargetKey: null,
					dropContainerKey: null,
					dropTargetPos: null,
					dropAllowed: false
				});
			}
		},
		{
			key: "render",
			value: function render$1() {
				var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent;
				var _this$props12 = this.props, prefixCls = _this$props12.prefixCls, className = _this$props12.className, style$1 = _this$props12.style, showLine = _this$props12.showLine, focusable$1 = _this$props12.focusable, _this$props12$tabInde = _this$props12.tabIndex, tabIndex = _this$props12$tabInde === void 0 ? 0 : _this$props12$tabInde, selectable = _this$props12.selectable, showIcon = _this$props12.showIcon, icon = _this$props12.icon, switcherIcon = _this$props12.switcherIcon, draggable = _this$props12.draggable, checkable = _this$props12.checkable, checkStrictly = _this$props12.checkStrictly, disabled = _this$props12.disabled, motion$1 = _this$props12.motion, loadData = _this$props12.loadData, filterTreeNode = _this$props12.filterTreeNode, height = _this$props12.height, itemHeight = _this$props12.itemHeight, scrollWidth = _this$props12.scrollWidth, virtual = _this$props12.virtual, titleRender = _this$props12.titleRender, dropIndicatorRender$1 = _this$props12.dropIndicatorRender, onContextMenu = _this$props12.onContextMenu, onScroll = _this$props12.onScroll, direction = _this$props12.direction, rootClassName = _this$props12.rootClassName, rootStyle = _this$props12.rootStyle;
				var domProps = pickAttrs(this.props, {
					aria: true,
					data: true
				});
				var draggableConfig;
				if (draggable) if (_typeof(draggable) === "object") draggableConfig = draggable;
				else if (typeof draggable === "function") draggableConfig = { nodeDraggable: draggable };
				else draggableConfig = {};
				var contextValue = {
					prefixCls,
					selectable,
					showIcon,
					icon,
					switcherIcon,
					draggable: draggableConfig,
					draggingNodeKey,
					checkable,
					checkStrictly,
					disabled,
					keyEntities,
					dropLevelOffset,
					dropContainerKey,
					dropTargetKey,
					dropPosition,
					dragOverNodeKey,
					indent,
					direction,
					dropIndicatorRender: dropIndicatorRender$1,
					loadData,
					filterTreeNode,
					titleRender,
					onNodeClick: this.onNodeClick,
					onNodeDoubleClick: this.onNodeDoubleClick,
					onNodeExpand: this.onNodeExpand,
					onNodeSelect: this.onNodeSelect,
					onNodeCheck: this.onNodeCheck,
					onNodeLoad: this.onNodeLoad,
					onNodeMouseEnter: this.onNodeMouseEnter,
					onNodeMouseLeave: this.onNodeMouseLeave,
					onNodeContextMenu: this.onNodeContextMenu,
					onNodeDragStart: this.onNodeDragStart,
					onNodeDragEnter: this.onNodeDragEnter,
					onNodeDragOver: this.onNodeDragOver,
					onNodeDragLeave: this.onNodeDragLeave,
					onNodeDragEnd: this.onNodeDragEnd,
					onNodeDrop: this.onNodeDrop
				};
				return /* @__PURE__ */ import_react.createElement(TreeContext.Provider, { value: contextValue }, /* @__PURE__ */ import_react.createElement("div", {
					className: (0, import_classnames$34.default)(prefixCls, className, rootClassName, _defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-show-line"), showLine), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-active-focused"), activeKey !== null)),
					style: rootStyle
				}, /* @__PURE__ */ import_react.createElement(NodeList_default, _extends({
					ref: this.listRef,
					prefixCls,
					style: style$1,
					data: flattenNodes,
					disabled,
					selectable,
					checkable: !!checkable,
					motion: motion$1,
					dragging: draggingNodeKey !== null,
					height,
					itemHeight,
					virtual,
					focusable: focusable$1,
					focused,
					tabIndex,
					activeItem: this.getActiveItem(),
					onFocus: this.onFocus,
					onBlur: this.onBlur,
					onKeyDown: this.onKeyDown,
					onActiveChange: this.onActiveChange,
					onListChangeStart: this.onListChangeStart,
					onListChangeEnd: this.onListChangeEnd,
					onContextMenu,
					onScroll,
					scrollWidth
				}, this.getTreeNodeRequiredProps(), domProps))));
			}
		}
	], [{
		key: "getDerivedStateFromProps",
		value: function getDerivedStateFromProps(props, prevState) {
			var prevProps = prevState.prevProps;
			var newState = { prevProps: props };
			function needSync(name) {
				return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];
			}
			var treeData;
			var fieldNames = prevState.fieldNames;
			if (needSync("fieldNames")) {
				fieldNames = fillFieldNames$1(props.fieldNames);
				newState.fieldNames = fieldNames;
			}
			if (needSync("treeData")) treeData = props.treeData;
			else if (needSync("children")) {
				warning_default(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
				treeData = convertTreeToData(props.children);
			}
			if (treeData) {
				newState.treeData = treeData;
				var entitiesMap = convertDataToEntities(treeData, { fieldNames });
				newState.keyEntities = _objectSpread2(_defineProperty({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
				warningWithoutKey(treeData, fieldNames);
			}
			var keyEntities = newState.keyEntities || prevState.keyEntities;
			if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
			else if (!prevProps && props.defaultExpandAll) {
				var cloneKeyEntities = _objectSpread2({}, keyEntities);
				delete cloneKeyEntities[MOTION_KEY];
				var nextExpandedKeys = [];
				Object.keys(cloneKeyEntities).forEach(function(key) {
					var entity = cloneKeyEntities[key];
					if (entity.children && entity.children.length) nextExpandedKeys.push(entity.key);
				});
				newState.expandedKeys = nextExpandedKeys;
			} else if (!prevProps && props.defaultExpandedKeys) newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
			if (!newState.expandedKeys) delete newState.expandedKeys;
			if (treeData || newState.expandedKeys) newState.flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
			if (props.selectable) {
				if (needSync("selectedKeys")) newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
				else if (!prevProps && props.defaultSelectedKeys) newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
			}
			if (props.checkable) {
				var checkedKeyEntity;
				if (needSync("checkedKeys")) checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
				else if (!prevProps && props.defaultCheckedKeys) checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
				else if (treeData) checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
					checkedKeys: prevState.checkedKeys,
					halfCheckedKeys: prevState.halfCheckedKeys
				};
				if (checkedKeyEntity) {
					var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
					if (!props.checkStrictly) {
						var conductKeys = conductCheck(checkedKeys, true, keyEntities);
						checkedKeys = conductKeys.checkedKeys;
						halfCheckedKeys = conductKeys.halfCheckedKeys;
					}
					newState.checkedKeys = checkedKeys;
					newState.halfCheckedKeys = halfCheckedKeys;
				}
			}
			if (needSync("loadedKeys")) newState.loadedKeys = props.loadedKeys;
			return newState;
		}
	}]);
	return Tree$3;
}(import_react.Component);
_defineProperty(Tree$2, "defaultProps", {
	prefixCls: "rc-tree",
	showLine: false,
	showIcon: true,
	selectable: true,
	multiple: false,
	checkable: false,
	disabled: false,
	checkStrictly: false,
	draggable: false,
	defaultExpandParent: true,
	autoExpandParent: false,
	defaultExpandAll: false,
	defaultExpandedKeys: [],
	defaultCheckedKeys: [],
	defaultSelectedKeys: [],
	dropIndicatorRender: DropIndicator_default,
	allowDrop: function allowDrop() {
		return true;
	},
	expandAction: false
});
_defineProperty(Tree$2, "TreeNode", TreeNode_default$1);
var Tree_default$1 = Tree$2;

//#endregion
//#region node_modules/rc-tree/es/index.js
var es_default$4 = Tree_default$1;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/FileOutlined.js
var FileOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" }
		}]
	},
	"name": "file",
	"theme": "outlined"
};
var FileOutlined_default$1 = FileOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/FileOutlined.js
/**![file](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg1NC42IDI4OC42TDYzOS40IDczLjRjLTYtNi0xNC4xLTkuNC0yMi42LTkuNEgxOTJjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjgzMmMwIDE3LjcgMTQuMyAzMiAzMiAzMmg2NDBjMTcuNyAwIDMyLTE0LjMgMzItMzJWMzExLjNjMC04LjUtMy40LTE2LjctOS40LTIyLjd6TTc5MC4yIDMyNkg2MDJWMTM3LjhMNzkwLjIgMzI2em0xLjggNTYySDIzMlYxMzZoMzAydjIxNmE0MiA0MiAwIDAwNDIgNDJoMjE2djQ5NHoiIC8+PC9zdmc+) */
var RefIcon$16 = /* @__PURE__ */ import_react.forwardRef(function FileOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: FileOutlined_default$1
	}));
});
RefIcon$16.displayName = "FileOutlined";
var FileOutlined_default = RefIcon$16;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/FolderOpenOutlined.js
var FolderOpenOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" }
		}]
	},
	"name": "folder-open",
	"theme": "outlined"
};
var FolderOpenOutlined_default$1 = FolderOpenOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/FolderOpenOutlined.js
/**![folder-open](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkyOCA0NDRIODIwVjMzMC40YzAtMTcuNy0xNC4zLTMyLTMyLTMySDQ3M0wzNTUuNyAxODYuMmE4LjE1IDguMTUgMCAwMC01LjUtMi4ySDk2Yy0xNy43IDAtMzIgMTQuMy0zMiAzMnY1OTJjMCAxNy43IDE0LjMgMzIgMzIgMzJoNjk4YzEzIDAgMjQuOC03LjkgMjkuNy0yMGwxMzQtMzMyYzEuNS0zLjggMi4zLTcuOSAyLjMtMTIgMC0xNy43LTE0LjMtMzItMzItMzJ6TTEzNiAyNTZoMTg4LjVsMTE5LjYgMTE0LjRINzQ4VjQ0NEgyMzhjLTEzIDAtMjQuOCA3LjktMjkuNyAyMEwxMzYgNjQzLjJWMjU2em02MzUuMyA1MTJIMTU5bDEwMy4zLTI1Nmg2MTIuNEw3NzEuMyA3Njh6IiAvPjwvc3ZnPg==) */
var RefIcon$15 = /* @__PURE__ */ import_react.forwardRef(function FolderOpenOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: FolderOpenOutlined_default$1
	}));
});
RefIcon$15.displayName = "FolderOpenOutlined";
var FolderOpenOutlined_default = RefIcon$15;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/FolderOutlined.js
var FolderOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" }
		}]
	},
	"name": "folder",
	"theme": "outlined"
};
var FolderOutlined_default$1 = FolderOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/FolderOutlined.js
/**![folder](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg4MCAyOTguNEg1MjFMNDAzLjcgMTg2LjJhOC4xNSA4LjE1IDAgMDAtNS41LTIuMkgxNDRjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjU5MmMwIDE3LjcgMTQuMyAzMiAzMiAzMmg3MzZjMTcuNyAwIDMyLTE0LjMgMzItMzJWMzMwLjRjMC0xNy43LTE0LjMtMzItMzItMzJ6TTg0MCA3NjhIMTg0VjI1NmgxODguNWwxMTkuNiAxMTQuNEg4NDBWNzY4eiIgLz48L3N2Zz4=) */
var RefIcon$14 = /* @__PURE__ */ import_react.forwardRef(function FolderOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: FolderOutlined_default$1
	}));
});
RefIcon$14.displayName = "FolderOutlined";
var FolderOutlined_default = RefIcon$14;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/HolderOutlined.js
var HolderOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" }
		}]
	},
	"name": "holder",
	"theme": "outlined"
};
var HolderOutlined_default$1 = HolderOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/HolderOutlined.js
/**![holder](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTMwMCAyNzYuNWE1NiA1NiAwIDEwNTYtOTcgNTYgNTYgMCAwMC01NiA5N3ptMCAyODRhNTYgNTYgMCAxMDU2LTk3IDU2IDU2IDAgMDAtNTYgOTd6TTY0MCAyMjhhNTYgNTYgMCAxMDExMiAwIDU2IDU2IDAgMDAtMTEyIDB6bTAgMjg0YTU2IDU2IDAgMTAxMTIgMCA1NiA1NiAwIDAwLTExMiAwek0zMDAgODQ0LjVhNTYgNTYgMCAxMDU2LTk3IDU2IDU2IDAgMDAtNTYgOTd6TTY0MCA3OTZhNTYgNTYgMCAxMDExMiAwIDU2IDU2IDAgMDAtMTEyIDB6IiAvPjwvc3ZnPg==) */
var RefIcon$13 = /* @__PURE__ */ import_react.forwardRef(function HolderOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: HolderOutlined_default$1
	}));
});
RefIcon$13.displayName = "HolderOutlined";
var HolderOutlined_default = RefIcon$13;

//#endregion
//#region node_modules/antd/es/tree/style/directory.js
const genDirectoryStyle = ({ treeCls, treeNodeCls, directoryNodeSelectedBg, directoryNodeSelectedColor, motionDurationMid, borderRadius, controlItemBgHover }) => ({ [`${treeCls}${treeCls}-directory ${treeNodeCls}`]: {
	[`${treeCls}-node-content-wrapper`]: {
		position: "static",
		[`&:has(${treeCls}-drop-indicator)`]: { position: "relative" },
		[`> *:not(${treeCls}-drop-indicator)`]: { position: "relative" },
		"&:hover": { background: "transparent" },
		"&:before": {
			position: "absolute",
			inset: 0,
			transition: `background-color ${motionDurationMid}`,
			content: "\"\"",
			borderRadius
		},
		"&:hover:before": { background: controlItemBgHover }
	},
	[`${treeCls}-switcher, ${treeCls}-checkbox, ${treeCls}-draggable-icon`]: { zIndex: 1 },
	"&-selected": {
		background: directoryNodeSelectedBg,
		borderRadius,
		[`${treeCls}-switcher, ${treeCls}-draggable-icon`]: { color: directoryNodeSelectedColor },
		[`${treeCls}-node-content-wrapper`]: {
			color: directoryNodeSelectedColor,
			background: "transparent",
			"&, &:hover": { color: directoryNodeSelectedColor },
			"&:before, &:hover:before": { background: directoryNodeSelectedBg }
		}
	}
} });

//#endregion
//#region node_modules/antd/es/tree/style/index.js
var treeNodeFX = new Keyframes_default("ant-tree-node-fx-do-not-use", {
	"0%": { opacity: 0 },
	"100%": { opacity: 1 }
});
var getSwitchStyle = (prefixCls, token$1) => ({ [`.${prefixCls}-switcher-icon`]: {
	display: "inline-block",
	fontSize: 10,
	verticalAlign: "baseline",
	svg: { transition: `transform ${token$1.motionDurationSlow}` }
} });
var getDropIndicatorStyle = (prefixCls, token$1) => ({ [`.${prefixCls}-drop-indicator`]: {
	position: "absolute",
	zIndex: 1,
	height: 2,
	backgroundColor: token$1.colorPrimary,
	borderRadius: 1,
	pointerEvents: "none",
	"&:after": {
		position: "absolute",
		top: -3,
		insetInlineStart: -6,
		width: 8,
		height: 8,
		backgroundColor: "transparent",
		border: `${unit(token$1.lineWidthBold)} solid ${token$1.colorPrimary}`,
		borderRadius: "50%",
		content: "\"\""
	}
} });
const genBaseStyle$4 = (prefixCls, token$1) => {
	const { treeCls, treeNodeCls, treeNodePadding, titleHeight, indentSize, nodeSelectedBg, nodeHoverBg, colorTextQuaternary, controlItemBgActiveDisabled } = token$1;
	return { [treeCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		["--rc-virtual-list-scrollbar-bg"]: token$1.colorSplit,
		background: token$1.colorBgContainer,
		borderRadius: token$1.borderRadius,
		transition: `background-color ${token$1.motionDurationSlow}`,
		"&-rtl": { direction: "rtl" },
		[`&${treeCls}-rtl ${treeCls}-switcher_close ${treeCls}-switcher-icon svg`]: { transform: "rotate(90deg)" },
		[`&-focused:not(:hover):not(${treeCls}-active-focused)`]: genFocusOutline(token$1),
		[`${treeCls}-list-holder-inner`]: { alignItems: "flex-start" },
		[`&${treeCls}-block-node`]: { [`${treeCls}-list-holder-inner`]: {
			alignItems: "stretch",
			[`${treeCls}-node-content-wrapper`]: { flex: "auto" },
			[`${treeNodeCls}.dragging:after`]: {
				position: "absolute",
				inset: 0,
				border: `1px solid ${token$1.colorPrimary}`,
				opacity: 0,
				animationName: treeNodeFX,
				animationDuration: token$1.motionDurationSlow,
				animationPlayState: "running",
				animationFillMode: "forwards",
				content: "\"\"",
				pointerEvents: "none",
				borderRadius: token$1.borderRadius
			}
		} },
		[treeNodeCls]: {
			display: "flex",
			alignItems: "flex-start",
			marginBottom: treeNodePadding,
			lineHeight: unit(titleHeight),
			position: "relative",
			"&:before": {
				content: "\"\"",
				position: "absolute",
				zIndex: 1,
				insetInlineStart: 0,
				width: "100%",
				top: "100%",
				height: treeNodePadding
			},
			[`&-disabled ${treeCls}-node-content-wrapper`]: {
				color: token$1.colorTextDisabled,
				cursor: "not-allowed",
				"&:hover": { background: "transparent" }
			},
			[`${treeCls}-checkbox-disabled + ${treeCls}-node-selected,&${treeNodeCls}-disabled${treeNodeCls}-selected ${treeCls}-node-content-wrapper`]: { backgroundColor: controlItemBgActiveDisabled },
			[`${treeCls}-checkbox-disabled`]: { pointerEvents: "unset" },
			[`&:not(${treeNodeCls}-disabled)`]: { [`${treeCls}-node-content-wrapper`]: { "&:hover": { color: token$1.nodeHoverColor } } },
			[`&-active ${treeCls}-node-content-wrapper`]: { background: token$1.controlItemBgHover },
			[`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
				color: token$1.colorPrimary,
				fontWeight: token$1.fontWeightStrong
			},
			"&-draggable": {
				cursor: "grab",
				[`${treeCls}-draggable-icon`]: {
					flexShrink: 0,
					width: titleHeight,
					textAlign: "center",
					visibility: "visible",
					color: colorTextQuaternary
				},
				[`&${treeNodeCls}-disabled ${treeCls}-draggable-icon`]: { visibility: "hidden" }
			}
		},
		[`${treeCls}-indent`]: {
			alignSelf: "stretch",
			whiteSpace: "nowrap",
			userSelect: "none",
			"&-unit": {
				display: "inline-block",
				width: indentSize
			}
		},
		[`${treeCls}-draggable-icon`]: { visibility: "hidden" },
		[`${treeCls}-switcher, ${treeCls}-checkbox`]: { marginInlineEnd: token$1.calc(token$1.calc(titleHeight).sub(token$1.controlInteractiveSize)).div(2).equal() },
		[`${treeCls}-switcher`]: Object.assign(Object.assign({}, getSwitchStyle(prefixCls, token$1)), {
			position: "relative",
			flex: "none",
			alignSelf: "stretch",
			width: titleHeight,
			textAlign: "center",
			cursor: "pointer",
			userSelect: "none",
			transition: `all ${token$1.motionDurationSlow}`,
			"&-noop": { cursor: "unset" },
			"&:before": {
				pointerEvents: "none",
				content: "\"\"",
				width: titleHeight,
				height: titleHeight,
				position: "absolute",
				left: {
					_skip_check_: true,
					value: 0
				},
				top: 0,
				borderRadius: token$1.borderRadius,
				transition: `all ${token$1.motionDurationSlow}`
			},
			[`&:not(${treeCls}-switcher-noop):hover:before`]: { backgroundColor: token$1.colorBgTextHover },
			[`&_close ${treeCls}-switcher-icon svg`]: { transform: "rotate(-90deg)" },
			"&-loading-icon": { color: token$1.colorPrimary },
			"&-leaf-line": {
				position: "relative",
				zIndex: 1,
				display: "inline-block",
				width: "100%",
				height: "100%",
				"&:before": {
					position: "absolute",
					top: 0,
					insetInlineEnd: token$1.calc(titleHeight).div(2).equal(),
					bottom: token$1.calc(treeNodePadding).mul(-1).equal(),
					marginInlineStart: -1,
					borderInlineEnd: `1px solid ${token$1.colorBorder}`,
					content: "\"\""
				},
				"&:after": {
					position: "absolute",
					width: token$1.calc(token$1.calc(titleHeight).div(2).equal()).mul(.8).equal(),
					height: token$1.calc(titleHeight).div(2).equal(),
					borderBottom: `1px solid ${token$1.colorBorder}`,
					content: "\"\""
				}
			}
		}),
		[`${treeCls}-node-content-wrapper`]: Object.assign(Object.assign({
			position: "relative",
			minHeight: titleHeight,
			paddingBlock: 0,
			paddingInline: token$1.paddingXS,
			background: "transparent",
			borderRadius: token$1.borderRadius,
			cursor: "pointer",
			transition: `all ${token$1.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`
		}, getDropIndicatorStyle(prefixCls, token$1)), {
			"&:hover": { backgroundColor: nodeHoverBg },
			[`&${treeCls}-node-selected`]: {
				color: token$1.nodeSelectedColor,
				backgroundColor: nodeSelectedBg
			},
			[`${treeCls}-iconEle`]: {
				display: "inline-block",
				width: titleHeight,
				height: titleHeight,
				textAlign: "center",
				verticalAlign: "top",
				"&:empty": { display: "none" }
			}
		}),
		[`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: { backgroundColor: "transparent" },
		[`${treeNodeCls}.drop-container > [draggable]`]: { boxShadow: `0 0 0 2px ${token$1.colorPrimary}` },
		"&-show-line": {
			[`${treeCls}-indent-unit`]: {
				position: "relative",
				height: "100%",
				"&:before": {
					position: "absolute",
					top: 0,
					insetInlineEnd: token$1.calc(titleHeight).div(2).equal(),
					bottom: token$1.calc(treeNodePadding).mul(-1).equal(),
					borderInlineEnd: `1px solid ${token$1.colorBorder}`,
					content: "\"\""
				},
				"&-end:before": { display: "none" }
			},
			[`${treeCls}-switcher`]: {
				background: "transparent",
				"&-line-icon": { verticalAlign: "-0.15em" }
			}
		},
		[`${treeNodeCls}-leaf-last ${treeCls}-switcher-leaf-line:before`]: {
			top: "auto !important",
			bottom: "auto !important",
			height: `${unit(token$1.calc(titleHeight).div(2).equal())} !important`
		}
	}) };
};
const genTreeStyle = (prefixCls, token$1, enableDirectory = true) => {
	const treeCls = `.${prefixCls}`;
	const treeNodeCls = `${treeCls}-treenode`;
	const treeNodePadding = token$1.calc(token$1.paddingXS).div(2).equal();
	const treeToken = merge(token$1, {
		treeCls,
		treeNodeCls,
		treeNodePadding
	});
	return [genBaseStyle$4(prefixCls, treeToken), enableDirectory && genDirectoryStyle(treeToken)].filter(Boolean);
};
const initComponentToken = (token$1) => {
	const { controlHeightSM, controlItemBgHover, controlItemBgActive } = token$1;
	const titleHeight = controlHeightSM;
	return {
		titleHeight,
		indentSize: titleHeight,
		nodeHoverBg: controlItemBgHover,
		nodeHoverColor: token$1.colorText,
		nodeSelectedBg: controlItemBgActive,
		nodeSelectedColor: token$1.colorText
	};
};
const prepareComponentToken$8 = (token$1) => {
	const { colorTextLightSolid, colorPrimary } = token$1;
	return Object.assign(Object.assign({}, initComponentToken(token$1)), {
		directoryNodeSelectedColor: colorTextLightSolid,
		directoryNodeSelectedBg: colorPrimary
	});
};
var style_default$9 = genStyleHooks("Tree", (token$1, { prefixCls }) => [
	{ [token$1.componentCls]: getStyle(`${prefixCls}-checkbox`, token$1) },
	genTreeStyle(prefixCls, token$1),
	collapse_default$1(token$1)
], prepareComponentToken$8);

//#endregion
//#region node_modules/antd/es/tree/utils/dropIndicator.js
const offset = 4;
function dropIndicatorRender(props) {
	const { dropPosition, dropLevelOffset, prefixCls, indent, direction = "ltr" } = props;
	const startPosition = direction === "ltr" ? "left" : "right";
	const endPosition = direction === "ltr" ? "right" : "left";
	const style$1 = {
		[startPosition]: -dropLevelOffset * indent + offset,
		[endPosition]: 0
	};
	switch (dropPosition) {
		case -1:
			style$1.top = -3;
			break;
		case 1:
			style$1.bottom = -3;
			break;
		default:
			style$1.bottom = -3;
			style$1[startPosition] = indent + offset;
			break;
	}
	return /* @__PURE__ */ import_react.createElement("div", {
		style: style$1,
		className: `${prefixCls}-drop-indicator`
	});
}
var dropIndicator_default = dropIndicatorRender;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CaretDownFilled.js
var CaretDownFilled = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }
		}]
	},
	"name": "caret-down",
	"theme": "filled"
};
var CaretDownFilled_default$1 = CaretDownFilled;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CaretDownFilled.js
/**![caret-down](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg0MC40IDMwMEgxODMuNmMtMTkuNyAwLTMwLjcgMjAuOC0xOC41IDM1bDMyOC40IDM4MC44YzkuNCAxMC45IDI3LjUgMTAuOSAzNyAwTDg1OC45IDMzNWMxMi4yLTE0LjIgMS4yLTM1LTE4LjUtMzV6IiAvPjwvc3ZnPg==) */
var RefIcon$12 = /* @__PURE__ */ import_react.forwardRef(function CaretDownFilled$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CaretDownFilled_default$1
	}));
});
RefIcon$12.displayName = "CaretDownFilled";
var CaretDownFilled_default = RefIcon$12;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/MinusSquareOutlined.js
var MinusSquareOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" }
		}]
	},
	"name": "minus-square",
	"theme": "outlined"
};
var MinusSquareOutlined_default$1 = MinusSquareOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/MinusSquareOutlined.js
/**![minus-square](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTMyOCA1NDRoMzY4YzQuNCAwIDgtMy42IDgtOHYtNDhjMC00LjQtMy42LTgtOC04SDMyOGMtNC40IDAtOCAzLjYtOCA4djQ4YzAgNC40IDMuNiA4IDggOHoiIC8+PHBhdGggZD0iTTg4MCAxMTJIMTQ0Yy0xNy43IDAtMzIgMTQuMy0zMiAzMnY3MzZjMCAxNy43IDE0LjMgMzIgMzIgMzJoNzM2YzE3LjcgMCAzMi0xNC4zIDMyLTMyVjE0NGMwLTE3LjctMTQuMy0zMi0zMi0zMnptLTQwIDcyOEgxODRWMTg0aDY1NnY2NTZ6IiAvPjwvc3ZnPg==) */
var RefIcon$11 = /* @__PURE__ */ import_react.forwardRef(function MinusSquareOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: MinusSquareOutlined_default$1
	}));
});
RefIcon$11.displayName = "MinusSquareOutlined";
var MinusSquareOutlined_default = RefIcon$11;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/PlusSquareOutlined.js
var PlusSquareOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" }
		}, {
			"tag": "path",
			"attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" }
		}]
	},
	"name": "plus-square",
	"theme": "outlined"
};
var PlusSquareOutlined_default$1 = PlusSquareOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/PlusSquareOutlined.js
/**![plus-square](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTMyOCA1NDRoMTUydjE1MmMwIDQuNCAzLjYgOCA4IDhoNDhjNC40IDAgOC0zLjYgOC04VjU0NGgxNTJjNC40IDAgOC0zLjYgOC04di00OGMwLTQuNC0zLjYtOC04LThINTQ0VjMyOGMwLTQuNC0zLjYtOC04LThoLTQ4Yy00LjQgMC04IDMuNi04IDh2MTUySDMyOGMtNC40IDAtOCAzLjYtOCA4djQ4YzAgNC40IDMuNiA4IDggOHoiIC8+PHBhdGggZD0iTTg4MCAxMTJIMTQ0Yy0xNy43IDAtMzIgMTQuMy0zMiAzMnY3MzZjMCAxNy43IDE0LjMgMzIgMzIgMzJoNzM2YzE3LjcgMCAzMi0xNC4zIDMyLTMyVjE0NGMwLTE3LjctMTQuMy0zMi0zMi0zMnptLTQwIDcyOEgxODRWMTg0aDY1NnY2NTZ6IiAvPjwvc3ZnPg==) */
var RefIcon$10 = /* @__PURE__ */ import_react.forwardRef(function PlusSquareOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: PlusSquareOutlined_default$1
	}));
});
RefIcon$10.displayName = "PlusSquareOutlined";
var PlusSquareOutlined_default = RefIcon$10;

//#endregion
//#region node_modules/antd/es/tree/utils/iconUtil.js
var import_classnames$33 = /* @__PURE__ */ __toESM(require_classnames());
var SwitcherIconCom = (props) => {
	var _a, _b;
	const { prefixCls, switcherIcon, treeNodeProps, showLine, switcherLoadingIcon } = props;
	const { isLeaf: isLeaf$1, expanded, loading } = treeNodeProps;
	if (loading) {
		if (/* @__PURE__ */ import_react.isValidElement(switcherLoadingIcon)) return switcherLoadingIcon;
		return /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, { className: `${prefixCls}-switcher-loading-icon` });
	}
	let showLeafIcon;
	if (showLine && typeof showLine === "object") showLeafIcon = showLine.showLeafIcon;
	if (isLeaf$1) {
		if (!showLine) return null;
		if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
			const leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
			const leafCls = `${prefixCls}-switcher-line-custom-icon`;
			if (/* @__PURE__ */ import_react.isValidElement(leafIcon)) return cloneElement(leafIcon, { className: (0, import_classnames$33.default)((_a = leafIcon.props) === null || _a === void 0 ? void 0 : _a.className, leafCls) });
			return leafIcon;
		}
		return showLeafIcon ? /* @__PURE__ */ import_react.createElement(FileOutlined_default, { className: `${prefixCls}-switcher-line-icon` }) : /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-switcher-leaf-line` });
	}
	const switcherCls = `${prefixCls}-switcher-icon`;
	const switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
	if (/* @__PURE__ */ import_react.isValidElement(switcher)) return cloneElement(switcher, { className: (0, import_classnames$33.default)((_b = switcher.props) === null || _b === void 0 ? void 0 : _b.className, switcherCls) });
	if (switcher !== void 0) return switcher;
	if (showLine) return expanded ? /* @__PURE__ */ import_react.createElement(MinusSquareOutlined_default, { className: `${prefixCls}-switcher-line-icon` }) : /* @__PURE__ */ import_react.createElement(PlusSquareOutlined_default, { className: `${prefixCls}-switcher-line-icon` });
	return /* @__PURE__ */ import_react.createElement(CaretDownFilled_default, { className: switcherCls });
};
var iconUtil_default = SwitcherIconCom;

//#endregion
//#region node_modules/antd/es/tree/Tree.js
var import_classnames$32 = /* @__PURE__ */ __toESM(require_classnames());
var Tree$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a;
	const { getPrefixCls, direction, virtual, tree } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, className, showIcon = false, showLine, switcherIcon, switcherLoadingIcon, blockNode = false, children, checkable = false, selectable = true, draggable, motion: customMotion, style: style$1 } = props;
	const prefixCls = getPrefixCls("tree", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const motion$1 = customMotion !== null && customMotion !== void 0 ? customMotion : Object.assign(Object.assign({}, motion_default(rootPrefixCls)), { motionAppear: false });
	const newProps = Object.assign(Object.assign({}, props), {
		checkable,
		selectable,
		showIcon,
		motion: motion$1,
		blockNode,
		showLine: Boolean(showLine),
		dropIndicatorRender: dropIndicator_default
	});
	const [wrapCSSVar, hashId, cssVarCls] = style_default$9(prefixCls);
	const [, token$1] = useToken();
	const itemHeight = token$1.paddingXS / 2 + (((_a = token$1.Tree) === null || _a === void 0 ? void 0 : _a.titleHeight) || token$1.controlHeightSM);
	const draggableConfig = import_react.useMemo(() => {
		if (!draggable) return false;
		let mergedDraggable = {};
		switch (typeof draggable) {
			case "function":
				mergedDraggable.nodeDraggable = draggable;
				break;
			case "object":
				mergedDraggable = Object.assign({}, draggable);
				break;
			default: break;
		}
		if (mergedDraggable.icon !== false) mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ import_react.createElement(HolderOutlined_default, null);
		return mergedDraggable;
	}, [draggable]);
	const renderSwitcherIcon = (nodeProps) => /* @__PURE__ */ import_react.createElement(iconUtil_default, {
		prefixCls,
		switcherIcon,
		switcherLoadingIcon,
		treeNodeProps: nodeProps,
		showLine
	});
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default$4, Object.assign({
		itemHeight,
		ref,
		virtual
	}, newProps, {
		style: Object.assign(Object.assign({}, tree === null || tree === void 0 ? void 0 : tree.style), style$1),
		prefixCls,
		className: (0, import_classnames$32.default)({
			[`${prefixCls}-icon-hide`]: !showIcon,
			[`${prefixCls}-block-node`]: blockNode,
			[`${prefixCls}-unselectable`]: !selectable,
			[`${prefixCls}-rtl`]: direction === "rtl"
		}, tree === null || tree === void 0 ? void 0 : tree.className, className, hashId, cssVarCls),
		direction,
		checkable: checkable ? /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-checkbox-inner` }) : checkable,
		selectable,
		switcherIcon: renderSwitcherIcon,
		draggable: draggableConfig
	}), children));
});
Tree$1.displayName = "Tree";
var Tree_default = Tree$1;

//#endregion
//#region node_modules/antd/es/tree/utils/dictUtil.js
var RECORD_NONE = 0;
var RECORD_START = 1;
var RECORD_END = 2;
function traverseNodesKey(treeData, callback, fieldNames) {
	const { key: fieldKey, children: fieldChildren } = fieldNames;
	function processNode(dataNode) {
		const key = dataNode[fieldKey];
		const children = dataNode[fieldChildren];
		if (callback(key, dataNode) !== false) traverseNodesKey(children || [], callback, fieldNames);
	}
	treeData.forEach(processNode);
}
/** expanded */
function calcRangeKeys({ treeData, expandedKeys, startKey, endKey, fieldNames }) {
	const keys$1 = [];
	let record = RECORD_NONE;
	if (startKey && startKey === endKey) return [startKey];
	if (!startKey || !endKey) return [];
	function matchKey(key) {
		return key === startKey || key === endKey;
	}
	traverseNodesKey(treeData, (key) => {
		if (record === RECORD_END) return false;
		if (matchKey(key)) {
			keys$1.push(key);
			if (record === RECORD_NONE) record = RECORD_START;
			else if (record === RECORD_START) {
				record = RECORD_END;
				return false;
			}
		} else if (record === RECORD_START) keys$1.push(key);
		return expandedKeys.includes(key);
	}, fillFieldNames$1(fieldNames));
	return keys$1;
}
function convertDirectoryKeysToNodes(treeData, keys$1, fieldNames) {
	const restKeys = _toConsumableArray(keys$1);
	const nodes = [];
	traverseNodesKey(treeData, (key, node$1) => {
		const index$2 = restKeys.indexOf(key);
		if (index$2 !== -1) {
			nodes.push(node$1);
			restKeys.splice(index$2, 1);
		}
		return !!restKeys.length;
	}, fillFieldNames$1(fieldNames));
	return nodes;
}

//#endregion
//#region node_modules/antd/es/tree/DirectoryTree.js
var import_classnames$31 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$17 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function getIcon(props) {
	const { isLeaf: isLeaf$1, expanded } = props;
	if (isLeaf$1) return /* @__PURE__ */ import_react.createElement(FileOutlined_default, null);
	return expanded ? /* @__PURE__ */ import_react.createElement(FolderOpenOutlined_default, null) : /* @__PURE__ */ import_react.createElement(FolderOutlined_default, null);
}
function getTreeData({ treeData, children }) {
	return treeData || convertTreeToData(children);
}
var DirectoryTree = (_a, ref) => {
	var { defaultExpandAll, defaultExpandParent, defaultExpandedKeys } = _a, props = __rest$17(_a, [
		"defaultExpandAll",
		"defaultExpandParent",
		"defaultExpandedKeys"
	]);
	const lastSelectedKey = import_react.useRef(null);
	const cachedSelectedKeys = import_react.useRef(null);
	const getInitExpandedKeys = () => {
		const { keyEntities } = convertDataToEntities(getTreeData(props));
		let initExpandedKeys;
		if (defaultExpandAll) initExpandedKeys = Object.keys(keyEntities);
		else if (defaultExpandParent) initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
		else initExpandedKeys = props.expandedKeys || defaultExpandedKeys || [];
		return initExpandedKeys;
	};
	const [selectedKeys, setSelectedKeys] = import_react.useState(props.selectedKeys || props.defaultSelectedKeys || []);
	const [expandedKeys, setExpandedKeys] = import_react.useState(() => getInitExpandedKeys());
	import_react.useEffect(() => {
		if ("selectedKeys" in props) setSelectedKeys(props.selectedKeys);
	}, [props.selectedKeys]);
	import_react.useEffect(() => {
		if ("expandedKeys" in props) setExpandedKeys(props.expandedKeys);
	}, [props.expandedKeys]);
	const onExpand = (keys$1, info) => {
		var _a$1;
		if (!("expandedKeys" in props)) setExpandedKeys(keys$1);
		return (_a$1 = props.onExpand) === null || _a$1 === void 0 ? void 0 : _a$1.call(props, keys$1, info);
	};
	const onSelect = (keys$1, event) => {
		var _a$1;
		const { multiple, fieldNames } = props;
		const { node: node$1, nativeEvent } = event;
		const { key = "" } = node$1;
		const treeData = getTreeData(props);
		const newEvent = Object.assign(Object.assign({}, event), { selected: true });
		const ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
		const shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
		let newSelectedKeys;
		if (multiple && ctrlPick) {
			newSelectedKeys = keys$1;
			lastSelectedKey.current = key;
			cachedSelectedKeys.current = newSelectedKeys;
			newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
		} else if (multiple && shiftPick) {
			newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
				treeData,
				expandedKeys,
				startKey: key,
				endKey: lastSelectedKey.current,
				fieldNames
			})))));
			newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
		} else {
			newSelectedKeys = [key];
			lastSelectedKey.current = key;
			cachedSelectedKeys.current = newSelectedKeys;
			newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
		}
		(_a$1 = props.onSelect) === null || _a$1 === void 0 || _a$1.call(props, newSelectedKeys, newEvent);
		if (!("selectedKeys" in props)) setSelectedKeys(newSelectedKeys);
	};
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, className, showIcon = true, expandAction = "click" } = props, otherProps = __rest$17(props, [
		"prefixCls",
		"className",
		"showIcon",
		"expandAction"
	]);
	const prefixCls = getPrefixCls("tree", customizePrefixCls);
	const connectClassName = (0, import_classnames$31.default)(`${prefixCls}-directory`, { [`${prefixCls}-directory-rtl`]: direction === "rtl" }, className);
	return /* @__PURE__ */ import_react.createElement(Tree_default, Object.assign({
		icon: getIcon,
		ref,
		blockNode: true
	}, otherProps, {
		showIcon,
		expandAction,
		prefixCls,
		className: connectClassName,
		expandedKeys,
		selectedKeys,
		onSelect,
		onExpand
	}));
};
var ForwardDirectoryTree = /* @__PURE__ */ import_react.forwardRef(DirectoryTree);
ForwardDirectoryTree.displayName = "DirectoryTree";
var DirectoryTree_default = ForwardDirectoryTree;

//#endregion
//#region node_modules/antd/es/tree/index.js
var Tree = Tree_default;
Tree.DirectoryTree = DirectoryTree_default;
Tree.TreeNode = TreeNode_default$1;
var tree_default = Tree;

//#endregion
//#region node_modules/antd/es/table/hooks/useFilter/FilterSearch.js
var FilterSearch = (props) => {
	const { value, filterSearch, tablePrefixCls, locale: locale$5, onChange } = props;
	if (!filterSearch) return null;
	return /* @__PURE__ */ import_react.createElement("div", { className: `${tablePrefixCls}-filter-dropdown-search` }, /* @__PURE__ */ import_react.createElement(Input_default, {
		prefix: /* @__PURE__ */ import_react.createElement(SearchOutlined_default, null),
		placeholder: locale$5.filterSearchPlaceholder,
		onChange,
		value,
		htmlSize: 1,
		className: `${tablePrefixCls}-filter-dropdown-search-input`
	}));
};
var FilterSearch_default = FilterSearch;

//#endregion
//#region node_modules/antd/es/table/hooks/useFilter/FilterWrapper.js
var onKeyDown = (event) => {
	const { keyCode } = event;
	if (keyCode === KeyCode_default.ENTER) event.stopPropagation();
};
var FilterDropdownMenuWrapper = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ import_react.createElement("div", {
	className: props.className,
	onClick: (e$2) => e$2.stopPropagation(),
	onKeyDown,
	ref
}, props.children));
FilterDropdownMenuWrapper.displayName = "FilterDropdownMenuWrapper";
var FilterWrapper_default = FilterDropdownMenuWrapper;

//#endregion
//#region node_modules/antd/es/table/hooks/useFilter/FilterDropdown.js
var import_classnames$30 = /* @__PURE__ */ __toESM(require_classnames());
function flattenKeys$1(filters) {
	let keys$1 = [];
	(filters || []).forEach(({ value, children }) => {
		keys$1.push(value);
		if (children) keys$1 = [].concat(_toConsumableArray(keys$1), _toConsumableArray(flattenKeys$1(children)));
	});
	return keys$1;
}
function hasSubMenu(filters) {
	return filters.some(({ children }) => children);
}
function searchValueMatched(searchValue, text) {
	if (typeof text === "string" || typeof text === "number") return text === null || text === void 0 ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
	return false;
}
function renderFilterItems({ filters, prefixCls, filteredKeys, filterMultiple, searchValue, filterSearch }) {
	return filters.map((filter$2, index$2) => {
		const key = String(filter$2.value);
		if (filter$2.children) return {
			key: key || index$2,
			label: filter$2.text,
			popupClassName: `${prefixCls}-dropdown-submenu`,
			children: renderFilterItems({
				filters: filter$2.children,
				prefixCls,
				filteredKeys,
				filterMultiple,
				searchValue,
				filterSearch
			})
		};
		const Component$2 = filterMultiple ? checkbox_default : radio_default;
		const item = {
			key: filter$2.value !== void 0 ? key : index$2,
			label: /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Component$2, { checked: filteredKeys.includes(key) }), /* @__PURE__ */ import_react.createElement("span", null, filter$2.text))
		};
		if (searchValue.trim()) {
			if (typeof filterSearch === "function") return filterSearch(searchValue, filter$2) ? item : null;
			return searchValueMatched(searchValue, filter$2.text) ? item : null;
		}
		return item;
	});
}
function wrapStringListType(keys$1) {
	return keys$1 || [];
}
var FilterDropdown = (props) => {
	var _a, _b, _c, _d;
	const { tablePrefixCls, prefixCls, column: column$1, dropdownPrefixCls, columnKey, filterOnClose, filterMultiple, filterMode = "menu", filterSearch = false, filterState, triggerFilter, locale: locale$5, children, getPopupContainer, rootClassName } = props;
	const { filterResetToDefaultFilteredValue, defaultFilteredValue, filterDropdownProps = {}, filterDropdownOpen, filterDropdownVisible, onFilterDropdownVisibleChange, onFilterDropdownOpenChange } = column$1;
	const [visible, setVisible] = import_react.useState(false);
	const filtered = !!(filterState && (((_a = filterState.filteredKeys) === null || _a === void 0 ? void 0 : _a.length) || filterState.forceFiltered));
	const triggerVisible = (newVisible) => {
		var _a$1;
		setVisible(newVisible);
		(_a$1 = filterDropdownProps.onOpenChange) === null || _a$1 === void 0 || _a$1.call(filterDropdownProps, newVisible);
		onFilterDropdownOpenChange === null || onFilterDropdownOpenChange === void 0 || onFilterDropdownOpenChange(newVisible);
		onFilterDropdownVisibleChange === null || onFilterDropdownVisibleChange === void 0 || onFilterDropdownVisibleChange(newVisible);
	};
	{
		const warning$4 = devUseWarning("Table");
		[
			["filterDropdownOpen", "filterDropdownProps.open"],
			["filterDropdownVisible", "filterDropdownProps.open"],
			["onFilterDropdownOpenChange", "filterDropdownProps.onOpenChange"],
			["onFilterDropdownVisibleChange", "filterDropdownProps.onOpenChange"]
		].forEach(([deprecatedName, newName]) => {
			warning$4.deprecated(!(deprecatedName in column$1), deprecatedName, newName);
		});
		warning$4.deprecated(!("filterCheckall" in locale$5), "filterCheckall", "locale.filterCheckAll");
	}
	const mergedVisible = (_d = (_c = (_b = filterDropdownProps.open) !== null && _b !== void 0 ? _b : filterDropdownOpen) !== null && _c !== void 0 ? _c : filterDropdownVisible) !== null && _d !== void 0 ? _d : visible;
	const propFilteredKeys = filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys;
	const [getFilteredKeysSync, setFilteredKeysSync] = useSyncState(wrapStringListType(propFilteredKeys));
	const onSelectKeys = ({ selectedKeys }) => {
		setFilteredKeysSync(selectedKeys);
	};
	const onCheck = (keys$1, { node: node$1, checked }) => {
		if (!filterMultiple) onSelectKeys({ selectedKeys: checked && node$1.key ? [node$1.key] : [] });
		else onSelectKeys({ selectedKeys: keys$1 });
	};
	import_react.useEffect(() => {
		if (!visible) return;
		onSelectKeys({ selectedKeys: wrapStringListType(propFilteredKeys) });
	}, [propFilteredKeys]);
	const [openKeys, setOpenKeys] = import_react.useState([]);
	const onOpenChange = (keys$1) => {
		setOpenKeys(keys$1);
	};
	const [searchValue, setSearchValue] = import_react.useState("");
	const onSearch = (e$2) => {
		const { value } = e$2.target;
		setSearchValue(value);
	};
	import_react.useEffect(() => {
		if (!visible) setSearchValue("");
	}, [visible]);
	const internalTriggerFilter = (keys$1) => {
		const mergedKeys = (keys$1 === null || keys$1 === void 0 ? void 0 : keys$1.length) ? keys$1 : null;
		if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) return null;
		if (isEqual_default(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys, true)) return null;
		triggerFilter({
			column: column$1,
			key: columnKey,
			filteredKeys: mergedKeys
		});
	};
	const onConfirm = () => {
		triggerVisible(false);
		internalTriggerFilter(getFilteredKeysSync());
	};
	const onReset = ({ confirm: confirm$1, closeDropdown } = {
		confirm: false,
		closeDropdown: false
	}) => {
		if (confirm$1) internalTriggerFilter([]);
		if (closeDropdown) triggerVisible(false);
		setSearchValue("");
		if (filterResetToDefaultFilteredValue) setFilteredKeysSync((defaultFilteredValue || []).map((key) => String(key)));
		else setFilteredKeysSync([]);
	};
	const doFilter = ({ closeDropdown } = { closeDropdown: true }) => {
		if (closeDropdown) triggerVisible(false);
		internalTriggerFilter(getFilteredKeysSync());
	};
	const onVisibleChange = (newVisible, info) => {
		if (info.source === "trigger") {
			if (newVisible && propFilteredKeys !== void 0) setFilteredKeysSync(wrapStringListType(propFilteredKeys));
			triggerVisible(newVisible);
			if (!newVisible && !column$1.filterDropdown && filterOnClose) onConfirm();
		}
	};
	const dropdownMenuClass = (0, import_classnames$30.default)({ [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column$1.filters || []) });
	const onCheckAll = (e$2) => {
		if (e$2.target.checked) {
			const allFilterKeys = flattenKeys$1(column$1 === null || column$1 === void 0 ? void 0 : column$1.filters).map((key) => String(key));
			setFilteredKeysSync(allFilterKeys);
		} else setFilteredKeysSync([]);
	};
	const getTreeData$1 = ({ filters }) => (filters || []).map((filter$2, index$2) => {
		const key = String(filter$2.value);
		const item = {
			title: filter$2.text,
			key: filter$2.value !== void 0 ? key : String(index$2)
		};
		if (filter$2.children) item.children = getTreeData$1({ filters: filter$2.children });
		return item;
	});
	const getFilterData$1 = (node$1) => {
		var _a$1;
		return Object.assign(Object.assign({}, node$1), {
			text: node$1.title,
			value: node$1.key,
			children: ((_a$1 = node$1.children) === null || _a$1 === void 0 ? void 0 : _a$1.map((item) => getFilterData$1(item))) || []
		});
	};
	let dropdownContent;
	const { direction, renderEmpty } = import_react.useContext(ConfigContext);
	if (typeof column$1.filterDropdown === "function") dropdownContent = column$1.filterDropdown({
		prefixCls: `${dropdownPrefixCls}-custom`,
		setSelectedKeys: (selectedKeys) => onSelectKeys({ selectedKeys }),
		selectedKeys: getFilteredKeysSync(),
		confirm: doFilter,
		clearFilters: onReset,
		filters: column$1.filters,
		visible: mergedVisible,
		close: () => {
			triggerVisible(false);
		}
	});
	else if (column$1.filterDropdown) dropdownContent = column$1.filterDropdown;
	else {
		const selectedKeys = getFilteredKeysSync() || [];
		const getFilterComponent = () => {
			var _a$1, _b$1;
			const empty$1 = (_a$1 = renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Table.filter")) !== null && _a$1 !== void 0 ? _a$1 : /* @__PURE__ */ import_react.createElement(empty_default, {
				image: empty_default.PRESENTED_IMAGE_SIMPLE,
				description: locale$5.filterEmptyText,
				styles: { image: { height: 24 } },
				style: {
					margin: 0,
					padding: "16px 0"
				}
			});
			if ((column$1.filters || []).length === 0) return empty$1;
			if (filterMode === "tree") return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(FilterSearch_default, {
				filterSearch,
				value: searchValue,
				onChange: onSearch,
				tablePrefixCls,
				locale: locale$5
			}), /* @__PURE__ */ import_react.createElement("div", { className: `${tablePrefixCls}-filter-dropdown-tree` }, filterMultiple ? /* @__PURE__ */ import_react.createElement(checkbox_default, {
				checked: selectedKeys.length === flattenKeys$1(column$1.filters).length,
				indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys$1(column$1.filters).length,
				className: `${tablePrefixCls}-filter-dropdown-checkall`,
				onChange: onCheckAll
			}, (_b$1 = locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.filterCheckall) !== null && _b$1 !== void 0 ? _b$1 : locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.filterCheckAll) : null, /* @__PURE__ */ import_react.createElement(tree_default, {
				checkable: true,
				selectable: false,
				blockNode: true,
				multiple: filterMultiple,
				checkStrictly: !filterMultiple,
				className: `${dropdownPrefixCls}-menu`,
				onCheck,
				checkedKeys: selectedKeys,
				selectedKeys,
				showIcon: false,
				treeData: getTreeData$1({ filters: column$1.filters }),
				autoExpandParent: true,
				defaultExpandAll: true,
				filterTreeNode: searchValue.trim() ? (node$1) => {
					if (typeof filterSearch === "function") return filterSearch(searchValue, getFilterData$1(node$1));
					return searchValueMatched(searchValue, node$1.title);
				} : void 0
			})));
			const items = renderFilterItems({
				filters: column$1.filters || [],
				filterSearch,
				prefixCls,
				filteredKeys: getFilteredKeysSync(),
				filterMultiple,
				searchValue
			});
			const isEmpty$1 = items.every((item) => item === null);
			return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(FilterSearch_default, {
				filterSearch,
				value: searchValue,
				onChange: onSearch,
				tablePrefixCls,
				locale: locale$5
			}), isEmpty$1 ? empty$1 : /* @__PURE__ */ import_react.createElement(menu_default, {
				selectable: true,
				multiple: filterMultiple,
				prefixCls: `${dropdownPrefixCls}-menu`,
				className: dropdownMenuClass,
				onSelect: onSelectKeys,
				onDeselect: onSelectKeys,
				selectedKeys,
				getPopupContainer,
				openKeys,
				onOpenChange,
				items
			}));
		};
		const getResetDisabled = () => {
			if (filterResetToDefaultFilteredValue) return isEqual_default((defaultFilteredValue || []).map((key) => String(key)), selectedKeys, true);
			return selectedKeys.length === 0;
		};
		dropdownContent = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, getFilterComponent(), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-dropdown-btns` }, /* @__PURE__ */ import_react.createElement(button_default, {
			type: "link",
			size: "small",
			disabled: getResetDisabled(),
			onClick: () => onReset()
		}, locale$5.filterReset), /* @__PURE__ */ import_react.createElement(button_default, {
			type: "primary",
			size: "small",
			onClick: onConfirm
		}, locale$5.filterConfirm)));
	}
	if (column$1.filterDropdown) dropdownContent = /* @__PURE__ */ import_react.createElement(OverrideProvider, { selectable: void 0 }, dropdownContent);
	dropdownContent = /* @__PURE__ */ import_react.createElement(FilterWrapper_default, { className: `${prefixCls}-dropdown` }, dropdownContent);
	const getDropdownTrigger = () => {
		let filterIcon;
		if (typeof column$1.filterIcon === "function") filterIcon = column$1.filterIcon(filtered);
		else if (column$1.filterIcon) filterIcon = column$1.filterIcon;
		else filterIcon = /* @__PURE__ */ import_react.createElement(FilterFilled_default, null);
		return /* @__PURE__ */ import_react.createElement("span", {
			role: "button",
			tabIndex: -1,
			className: (0, import_classnames$30.default)(`${prefixCls}-trigger`, { active: filtered }),
			onClick: (e$2) => {
				e$2.stopPropagation();
			}
		}, filterIcon);
	};
	const mergedDropdownProps = extendsObject_default({
		trigger: ["click"],
		placement: direction === "rtl" ? "bottomLeft" : "bottomRight",
		children: getDropdownTrigger(),
		getPopupContainer
	}, Object.assign(Object.assign({}, filterDropdownProps), {
		rootClassName: (0, import_classnames$30.default)(rootClassName, filterDropdownProps.rootClassName),
		open: mergedVisible,
		onOpenChange: onVisibleChange,
		popupRender: () => {
			if (typeof (filterDropdownProps === null || filterDropdownProps === void 0 ? void 0 : filterDropdownProps.dropdownRender) === "function") return filterDropdownProps.dropdownRender(dropdownContent);
			return dropdownContent;
		}
	}));
	return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-column` }, /* @__PURE__ */ import_react.createElement("span", { className: `${tablePrefixCls}-column-title` }, children), /* @__PURE__ */ import_react.createElement(dropdown_default, Object.assign({}, mergedDropdownProps)));
};
var FilterDropdown_default = FilterDropdown;

//#endregion
//#region node_modules/antd/es/table/hooks/useFilter/index.js
var collectFilterStates = (columns, init, pos) => {
	let filterStates = [];
	(columns || []).forEach((column$1, index$2) => {
		var _a;
		const columnPos = getColumnPos(index$2, pos);
		const filterDropdownIsDefined = column$1.filterDropdown !== void 0;
		if (column$1.filters || filterDropdownIsDefined || "onFilter" in column$1) if ("filteredValue" in column$1) {
			let filteredValues = column$1.filteredValue;
			if (!filterDropdownIsDefined) filteredValues = (_a = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _a !== void 0 ? _a : filteredValues;
			filterStates.push({
				column: column$1,
				key: getColumnKey(column$1, columnPos),
				filteredKeys: filteredValues,
				forceFiltered: column$1.filtered
			});
		} else filterStates.push({
			column: column$1,
			key: getColumnKey(column$1, columnPos),
			filteredKeys: init && column$1.defaultFilteredValue ? column$1.defaultFilteredValue : void 0,
			forceFiltered: column$1.filtered
		});
		if ("children" in column$1) filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column$1.children, init, columnPos)));
	});
	return filterStates;
};
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale$5, triggerFilter, getPopupContainer, pos, rootClassName) {
	return columns.map((column$1, index$2) => {
		const columnPos = getColumnPos(index$2, pos);
		const { filterOnClose = true, filterMultiple = true, filterMode, filterSearch } = column$1;
		let newColumn = column$1;
		if (newColumn.filters || newColumn.filterDropdown) {
			const columnKey = getColumnKey(newColumn, columnPos);
			const filterState = filterStates.find(({ key }) => columnKey === key);
			newColumn = Object.assign(Object.assign({}, newColumn), { title: (renderProps) => /* @__PURE__ */ import_react.createElement(FilterDropdown_default, {
				tablePrefixCls: prefixCls,
				prefixCls: `${prefixCls}-filter`,
				dropdownPrefixCls,
				column: newColumn,
				columnKey,
				filterState,
				filterOnClose,
				filterMultiple,
				filterMode,
				filterSearch,
				triggerFilter,
				locale: locale$5,
				getPopupContainer,
				rootClassName
			}, renderColumnTitle(column$1.title, renderProps)) });
		}
		if ("children" in newColumn) newColumn = Object.assign(Object.assign({}, newColumn), { children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale$5, triggerFilter, getPopupContainer, columnPos, rootClassName) });
		return newColumn;
	});
}
var generateFilterInfo = (filterStates) => {
	const currentFilters = {};
	filterStates.forEach(({ key, filteredKeys, column: column$1 }) => {
		const keyAsString = key;
		const { filters, filterDropdown } = column$1;
		if (filterDropdown) currentFilters[keyAsString] = filteredKeys || null;
		else if (Array.isArray(filteredKeys)) currentFilters[keyAsString] = flattenKeys$1(filters).filter((originKey) => filteredKeys.includes(String(originKey)));
		else currentFilters[keyAsString] = null;
	});
	return currentFilters;
};
const getFilterData = (data, filterStates, childrenColumnName) => {
	return filterStates.reduce((currentData, filterState) => {
		const { column: { onFilter, filters }, filteredKeys } = filterState;
		if (onFilter && filteredKeys && filteredKeys.length) return currentData.map((record) => Object.assign({}, record)).filter((record) => filteredKeys.some((key) => {
			const keys$1 = flattenKeys$1(filters);
			const keyIndex$1 = keys$1.findIndex((k) => String(k) === String(key));
			const realKey = keyIndex$1 !== -1 ? keys$1[keyIndex$1] : key;
			if (record[childrenColumnName]) record[childrenColumnName] = getFilterData(record[childrenColumnName], filterStates, childrenColumnName);
			return onFilter(realKey, record);
		}));
		return currentData;
	}, data);
};
var getMergedColumns = (rawMergedColumns) => rawMergedColumns.flatMap((column$1) => {
	if ("children" in column$1) return [column$1].concat(_toConsumableArray(getMergedColumns(column$1.children || [])));
	return [column$1];
});
var useFilter = (props) => {
	const { prefixCls, dropdownPrefixCls, mergedColumns: rawMergedColumns, onFilterChange, getPopupContainer, locale: tableLocale, rootClassName } = props;
	const warning$4 = devUseWarning("Table");
	const mergedColumns = import_react.useMemo(() => getMergedColumns(rawMergedColumns || []), [rawMergedColumns]);
	const [filterStates, setFilterStates] = import_react.useState(() => collectFilterStates(mergedColumns, true));
	const mergedFilterStates = import_react.useMemo(() => {
		const collectedStates = collectFilterStates(mergedColumns, false);
		if (collectedStates.length === 0) return collectedStates;
		let filteredKeysIsAllNotControlled = true;
		let filteredKeysIsAllControlled = true;
		collectedStates.forEach(({ filteredKeys }) => {
			if (filteredKeys !== void 0) filteredKeysIsAllNotControlled = false;
			else filteredKeysIsAllControlled = false;
		});
		if (filteredKeysIsAllNotControlled) {
			const keyList = (mergedColumns || []).map((column$1, index$2) => getColumnKey(column$1, getColumnPos(index$2)));
			return filterStates.filter(({ key }) => keyList.includes(key)).map((item) => {
				const col = mergedColumns[keyList.findIndex((key) => key === item.key)];
				return Object.assign(Object.assign({}, item), {
					column: Object.assign(Object.assign({}, item.column), col),
					forceFiltered: col.filtered
				});
			});
		}
		warning$4(filteredKeysIsAllControlled, "usage", "Columns should all contain `filteredValue` or not contain `filteredValue`.");
		return collectedStates;
	}, [mergedColumns, filterStates]);
	const filters = import_react.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]);
	const triggerFilter = (filterState) => {
		const newFilterStates = mergedFilterStates.filter(({ key }) => key !== filterState.key);
		newFilterStates.push(filterState);
		setFilterStates(newFilterStates);
		onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
	};
	const transformColumns = (innerColumns) => injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, tableLocale, triggerFilter, getPopupContainer, void 0, rootClassName);
	return [
		transformColumns,
		mergedFilterStates,
		filters
	];
};
var useFilter_default = useFilter;

//#endregion
//#region node_modules/antd/es/table/hooks/useLazyKVMap.js
var useLazyKVMap = (data, childrenColumnName, getRowKey) => {
	const mapCacheRef = import_react.useRef({});
	function getRecordByKey(key) {
		var _a;
		if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
			const kvMap = /* @__PURE__ */ new Map();
			function dig(records) {
				records.forEach((record, index$2) => {
					const rowKey = getRowKey(record, index$2);
					kvMap.set(rowKey, record);
					if (record && typeof record === "object" && childrenColumnName in record) dig(record[childrenColumnName] || []);
				});
			}
			dig(data);
			mapCacheRef.current = {
				data,
				childrenColumnName,
				kvMap,
				getRowKey
			};
		}
		return (_a = mapCacheRef.current.kvMap) === null || _a === void 0 ? void 0 : _a.get(key);
	}
	return [getRecordByKey];
};
var useLazyKVMap_default = useLazyKVMap;

//#endregion
//#region node_modules/antd/es/table/hooks/usePagination.js
var __rest$16 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
const DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(mergedPagination, pagination) {
	const param = {
		current: mergedPagination.current,
		pageSize: mergedPagination.pageSize
	};
	const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
	Object.keys(paginationObj).forEach((pageProp) => {
		const value = mergedPagination[pageProp];
		if (typeof value !== "function") param[pageProp] = value;
	});
	return param;
}
function usePagination(total, onChange, pagination) {
	const _a = pagination && typeof pagination === "object" ? pagination : {}, { total: paginationTotal = 0 } = _a, paginationObj = __rest$16(_a, ["total"]);
	const [innerPagination, setInnerPagination] = (0, import_react.useState)(() => ({
		current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
		pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
	}));
	const mergedPagination = extendsObject_default(innerPagination, paginationObj, { total: paginationTotal > 0 ? paginationTotal : total });
	const maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
	if (mergedPagination.current > maxPage) mergedPagination.current = maxPage || 1;
	const refreshPagination = (current, pageSize) => {
		setInnerPagination({
			current: current !== null && current !== void 0 ? current : 1,
			pageSize: pageSize || mergedPagination.pageSize
		});
	};
	const onInternalChange = (current, pageSize) => {
		var _a$1;
		if (pagination) (_a$1 = pagination.onChange) === null || _a$1 === void 0 || _a$1.call(pagination, current, pageSize);
		refreshPagination(current, pageSize);
		onChange(current, pageSize || (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize));
	};
	if (pagination === false) return [{}, () => {}];
	return [Object.assign(Object.assign({}, mergedPagination), { onChange: onInternalChange }), refreshPagination];
}
var usePagination_default = usePagination;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CaretDownOutlined.js
var CaretDownOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }
		}]
	},
	"name": "caret-down",
	"theme": "outlined"
};
var CaretDownOutlined_default$1 = CaretDownOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CaretDownOutlined.js
/**![caret-down](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg0MC40IDMwMEgxODMuNmMtMTkuNyAwLTMwLjcgMjAuOC0xOC41IDM1bDMyOC40IDM4MC44YzkuNCAxMC45IDI3LjUgMTAuOSAzNyAwTDg1OC45IDMzNWMxMi4yLTE0LjIgMS4yLTM1LTE4LjUtMzV6IiAvPjwvc3ZnPg==) */
var RefIcon$9 = /* @__PURE__ */ import_react.forwardRef(function CaretDownOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CaretDownOutlined_default$1
	}));
});
RefIcon$9.displayName = "CaretDownOutlined";
var CaretDownOutlined_default = RefIcon$9;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CaretUpOutlined.js
var CaretUpOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "0 0 1024 1024",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" }
		}]
	},
	"name": "caret-up",
	"theme": "outlined"
};
var CaretUpOutlined_default$1 = CaretUpOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CaretUpOutlined.js
/**![caret-up](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg1OC45IDY4OUw1MzAuNSAzMDguMmMtOS40LTEwLjktMjcuNS0xMC45LTM3IDBMMTY1LjEgNjg5Yy0xMi4yIDE0LjItMS4yIDM1IDE4LjUgMzVoNjU2LjhjMTkuNyAwIDMwLjctMjAuOCAxOC41LTM1eiIgLz48L3N2Zz4=) */
var RefIcon$8 = /* @__PURE__ */ import_react.forwardRef(function CaretUpOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CaretUpOutlined_default$1
	}));
});
RefIcon$8.displayName = "CaretUpOutlined";
var CaretUpOutlined_default = RefIcon$8;

//#endregion
//#region node_modules/antd/es/table/hooks/useSorter.js
var import_classnames$29 = /* @__PURE__ */ __toESM(require_classnames());
var ASCEND = "ascend";
var DESCEND = "descend";
var getMultiplePriority = (column$1) => {
	if (typeof column$1.sorter === "object" && typeof column$1.sorter.multiple === "number") return column$1.sorter.multiple;
	return false;
};
var getSortFunction = (sorter) => {
	if (typeof sorter === "function") return sorter;
	if (sorter && typeof sorter === "object" && sorter.compare) return sorter.compare;
	return false;
};
var nextSortDirection = (sortDirections, current) => {
	if (!current) return sortDirections[0];
	return sortDirections[sortDirections.indexOf(current) + 1];
};
var collectSortStates = (columns, init, pos) => {
	let sortStates = [];
	const pushState = (column$1, columnPos) => {
		sortStates.push({
			column: column$1,
			key: getColumnKey(column$1, columnPos),
			multiplePriority: getMultiplePriority(column$1),
			sortOrder: column$1.sortOrder
		});
	};
	(columns || []).forEach((column$1, index$2) => {
		const columnPos = getColumnPos(index$2, pos);
		if (column$1.children) {
			if ("sortOrder" in column$1) pushState(column$1, columnPos);
			sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column$1.children, init, columnPos)));
		} else if (column$1.sorter) {
			if ("sortOrder" in column$1) pushState(column$1, columnPos);
			else if (init && column$1.defaultSortOrder) sortStates.push({
				column: column$1,
				key: getColumnKey(column$1, columnPos),
				multiplePriority: getMultiplePriority(column$1),
				sortOrder: column$1.defaultSortOrder
			});
		}
	});
	return sortStates;
};
var injectSorter = (prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) => {
	return (columns || []).map((column$1, index$2) => {
		const columnPos = getColumnPos(index$2, pos);
		let newColumn = column$1;
		if (newColumn.sorter) {
			const sortDirections = newColumn.sortDirections || defaultSortDirections;
			const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
			const columnKey = getColumnKey(newColumn, columnPos);
			const sorterState = sorterStates.find(({ key }) => key === columnKey);
			const sortOrder = sorterState ? sorterState.sortOrder : null;
			const nextSortOrder = nextSortDirection(sortDirections, sortOrder);
			let sorter;
			if (column$1.sortIcon) sorter = column$1.sortIcon({ sortOrder });
			else {
				const upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ import_react.createElement(CaretUpOutlined_default, { className: (0, import_classnames$29.default)(`${prefixCls}-column-sorter-up`, { active: sortOrder === ASCEND }) });
				const downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ import_react.createElement(CaretDownOutlined_default, { className: (0, import_classnames$29.default)(`${prefixCls}-column-sorter-down`, { active: sortOrder === DESCEND }) });
				sorter = /* @__PURE__ */ import_react.createElement("span", { className: (0, import_classnames$29.default)(`${prefixCls}-column-sorter`, { [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode) }) }, /* @__PURE__ */ import_react.createElement("span", {
					className: `${prefixCls}-column-sorter-inner`,
					"aria-hidden": "true"
				}, upNode, downNode));
			}
			const { cancelSort, triggerAsc, triggerDesc } = tableLocale || {};
			let sortTip = cancelSort;
			if (nextSortOrder === DESCEND) sortTip = triggerDesc;
			else if (nextSortOrder === ASCEND) sortTip = triggerAsc;
			const tooltipProps = typeof showSorterTooltip === "object" ? Object.assign({ title: sortTip }, showSorterTooltip) : { title: sortTip };
			newColumn = Object.assign(Object.assign({}, newColumn), {
				className: (0, import_classnames$29.default)(newColumn.className, { [`${prefixCls}-column-sort`]: sortOrder }),
				title: (renderProps) => {
					const columnSortersClass = `${prefixCls}-column-sorters`;
					const renderColumnTitleWrapper = /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-column-title` }, renderColumnTitle(column$1.title, renderProps));
					const renderSortTitle = /* @__PURE__ */ import_react.createElement("div", { className: columnSortersClass }, renderColumnTitleWrapper, sorter);
					if (showSorterTooltip) {
						if (typeof showSorterTooltip !== "boolean" && (showSorterTooltip === null || showSorterTooltip === void 0 ? void 0 : showSorterTooltip.target) === "sorter-icon") return /* @__PURE__ */ import_react.createElement("div", { className: `${columnSortersClass} ${prefixCls}-column-sorters-tooltip-target-sorter` }, renderColumnTitleWrapper, /* @__PURE__ */ import_react.createElement(tooltip_default, Object.assign({}, tooltipProps), sorter));
						return /* @__PURE__ */ import_react.createElement(tooltip_default, Object.assign({}, tooltipProps), renderSortTitle);
					}
					return renderSortTitle;
				},
				onHeaderCell: (col) => {
					var _a;
					const cell = ((_a = column$1.onHeaderCell) === null || _a === void 0 ? void 0 : _a.call(column$1, col)) || {};
					const originOnClick = cell.onClick;
					const originOKeyDown = cell.onKeyDown;
					cell.onClick = (event) => {
						triggerSorter({
							column: column$1,
							key: columnKey,
							sortOrder: nextSortOrder,
							multiplePriority: getMultiplePriority(column$1)
						});
						originOnClick === null || originOnClick === void 0 || originOnClick(event);
					};
					cell.onKeyDown = (event) => {
						if (event.keyCode === KeyCode_default.ENTER) {
							triggerSorter({
								column: column$1,
								key: columnKey,
								sortOrder: nextSortOrder,
								multiplePriority: getMultiplePriority(column$1)
							});
							originOKeyDown === null || originOKeyDown === void 0 || originOKeyDown(event);
						}
					};
					const renderTitle = safeColumnTitle(column$1.title, {});
					const displayTitle = renderTitle === null || renderTitle === void 0 ? void 0 : renderTitle.toString();
					if (sortOrder) cell["aria-sort"] = sortOrder === "ascend" ? "ascending" : "descending";
					cell["aria-label"] = displayTitle || "";
					cell.className = (0, import_classnames$29.default)(cell.className, `${prefixCls}-column-has-sorters`);
					cell.tabIndex = 0;
					if (column$1.ellipsis) cell.title = (renderTitle !== null && renderTitle !== void 0 ? renderTitle : "").toString();
					return cell;
				}
			});
		}
		if ("children" in newColumn) newColumn = Object.assign(Object.assign({}, newColumn), { children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos) });
		return newColumn;
	});
};
var stateToInfo = (sorterState) => {
	const { column: column$1, sortOrder } = sorterState;
	return {
		column: column$1,
		order: sortOrder,
		field: column$1.dataIndex,
		columnKey: column$1.key
	};
};
var generateSorterInfo = (sorterStates) => {
	const activeSorters = sorterStates.filter(({ sortOrder }) => sortOrder).map(stateToInfo);
	if (activeSorters.length === 0 && sorterStates.length) {
		const lastIndex = sorterStates.length - 1;
		return Object.assign(Object.assign({}, stateToInfo(sorterStates[lastIndex])), {
			column: void 0,
			order: void 0,
			field: void 0,
			columnKey: void 0
		});
	}
	if (activeSorters.length <= 1) return activeSorters[0] || {};
	return activeSorters;
};
const getSortData = (data, sortStates, childrenColumnName) => {
	const innerSorterStates = sortStates.slice().sort((a, b) => b.multiplePriority - a.multiplePriority);
	const cloneData = data.slice();
	const runningSorters = innerSorterStates.filter(({ column: { sorter }, sortOrder }) => getSortFunction(sorter) && sortOrder);
	if (!runningSorters.length) return cloneData;
	return cloneData.sort((record1, record2) => {
		for (let i = 0; i < runningSorters.length; i += 1) {
			const { column: { sorter }, sortOrder } = runningSorters[i];
			const compareFn = getSortFunction(sorter);
			if (compareFn && sortOrder) {
				const compareResult = compareFn(record1, record2, sortOrder);
				if (compareResult !== 0) return sortOrder === ASCEND ? compareResult : -compareResult;
			}
		}
		return 0;
	}).map((record) => {
		const subRecords = record[childrenColumnName];
		if (subRecords) return Object.assign(Object.assign({}, record), { [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName) });
		return record;
	});
};
var useFilterSorter = (props) => {
	const { prefixCls, mergedColumns, sortDirections, tableLocale, showSorterTooltip, onSorterChange } = props;
	const [sortStates, setSortStates] = import_react.useState(() => collectSortStates(mergedColumns, true));
	const getColumnKeys = (columns, pos) => {
		const newKeys = [];
		columns.forEach((item, index$2) => {
			const columnPos = getColumnPos(index$2, pos);
			newKeys.push(getColumnKey(item, columnPos));
			if (Array.isArray(item.children)) {
				const childKeys = getColumnKeys(item.children, columnPos);
				newKeys.push.apply(newKeys, _toConsumableArray(childKeys));
			}
		});
		return newKeys;
	};
	const mergedSorterStates = import_react.useMemo(() => {
		let validate = true;
		const collectedStates = collectSortStates(mergedColumns, false);
		if (!collectedStates.length) {
			const mergedColumnsKeys = getColumnKeys(mergedColumns);
			return sortStates.filter(({ key }) => mergedColumnsKeys.includes(key));
		}
		const validateStates = [];
		function patchStates(state) {
			if (validate) validateStates.push(state);
			else validateStates.push(Object.assign(Object.assign({}, state), { sortOrder: null }));
		}
		let multipleMode = null;
		collectedStates.forEach((state) => {
			if (multipleMode === null) {
				patchStates(state);
				if (state.sortOrder) if (state.multiplePriority === false) validate = false;
				else multipleMode = true;
			} else if (multipleMode && state.multiplePriority !== false) patchStates(state);
			else {
				validate = false;
				patchStates(state);
			}
		});
		return validateStates;
	}, [mergedColumns, sortStates]);
	const columnTitleSorterProps = import_react.useMemo(() => {
		var _a, _b;
		const sortColumns = mergedSorterStates.map(({ column: column$1, sortOrder }) => ({
			column: column$1,
			order: sortOrder
		}));
		return {
			sortColumns,
			sortColumn: (_a = sortColumns[0]) === null || _a === void 0 ? void 0 : _a.column,
			sortOrder: (_b = sortColumns[0]) === null || _b === void 0 ? void 0 : _b.order
		};
	}, [mergedSorterStates]);
	const triggerSorter = (sortState) => {
		let newSorterStates;
		if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) newSorterStates = [sortState];
		else newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter(({ key }) => key !== sortState.key)), [sortState]);
		setSortStates(newSorterStates);
		onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
	};
	const transformColumns = (innerColumns) => injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip);
	const getSorters = () => generateSorterInfo(mergedSorterStates);
	return [
		transformColumns,
		mergedSorterStates,
		columnTitleSorterProps,
		getSorters
	];
};
var useSorter_default = useFilterSorter;

//#endregion
//#region node_modules/antd/es/table/hooks/useTitleColumns.js
var fillTitle = (columns, columnTitleProps) => {
	return columns.map((column$1) => {
		const cloneColumn = Object.assign({}, column$1);
		cloneColumn.title = renderColumnTitle(column$1.title, columnTitleProps);
		if ("children" in cloneColumn) cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
		return cloneColumn;
	});
};
var useTitleColumns = (columnTitleProps) => {
	return [import_react.useCallback((columns) => fillTitle(columns, columnTitleProps), [columnTitleProps])];
};
var useTitleColumns_default = useTitleColumns;

//#endregion
//#region node_modules/antd/es/table/RcTable/index.js
/**
* Same as `rc-table` but we modify trigger children update logic instead.
*/
var RcTable = genTable((prev$1, next$1) => {
	const { _renderTimes: prevRenderTimes } = prev$1;
	const { _renderTimes: nextRenderTimes } = next$1;
	return prevRenderTimes !== nextRenderTimes;
});
var RcTable_default = RcTable;

//#endregion
//#region node_modules/antd/es/table/RcTable/VirtualTable.js
/**
* Same as `rc-table` but we modify trigger children update logic instead.
*/
var RcVirtualTable = genVirtualTable((prev$1, next$1) => {
	const { _renderTimes: prevRenderTimes } = prev$1;
	const { _renderTimes: nextRenderTimes } = next$1;
	return prevRenderTimes !== nextRenderTimes;
});
var VirtualTable_default = RcVirtualTable;

//#endregion
//#region node_modules/antd/es/table/style/bordered.js
var genBorderedStyle = (token$1) => {
	const { componentCls, lineWidth, lineType, tableBorderColor, tableHeaderBg, tablePaddingVertical, tablePaddingHorizontal, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({ [`&${componentCls}-${size}`]: { [`> ${componentCls}-container`]: { [`> ${componentCls}-content, > ${componentCls}-body`]: { [`
            > table > tbody > tr > th,
            > table > tbody > tr > td
          `]: { [`> ${componentCls}-expanded-row-fixed`]: { margin: `${unit(calc(paddingVertical).mul(-1).equal())}
              ${unit(calc(calc(paddingHorizontal).add(lineWidth)).mul(-1).equal())}` } } } } } });
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}${componentCls}-bordered`]: Object.assign(Object.assign(Object.assign({
			[`> ${componentCls}-title`]: {
				border: tableBorder,
				borderBottom: 0
			},
			[`> ${componentCls}-container`]: {
				borderInlineStart: tableBorder,
				borderTop: tableBorder,
				[`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: { "> table": {
					[`
                > thead > tr > th,
                > thead > tr > td,
                > tbody > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: { borderInlineEnd: tableBorder },
					"> thead": {
						"> tr:not(:last-child) > th": { borderBottom: tableBorder },
						"> tr > th::before": { backgroundColor: "transparent !important" }
					},
					[`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: { [`> ${componentCls}-cell-fix-right-first::after`]: { borderInlineEnd: tableBorder } },
					[`
                > tbody > tr > th,
                > tbody > tr > td
              `]: { [`> ${componentCls}-expanded-row-fixed`]: {
						margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(calc(tablePaddingHorizontal).add(lineWidth)).mul(-1).equal())}`,
						"&::after": {
							position: "absolute",
							top: 0,
							insetInlineEnd: lineWidth,
							bottom: 0,
							borderInlineEnd: tableBorder,
							content: "\"\""
						}
					} }
				} }
			},
			[`&${componentCls}-scroll-horizontal`]: { [`> ${componentCls}-container > ${componentCls}-body`]: { "> table > tbody": { [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: { "> th, > td": { borderInlineEnd: 0 } } } } }
		}, getSizeBorderStyle("middle", token$1.tablePaddingVerticalMiddle, token$1.tablePaddingHorizontalMiddle)), getSizeBorderStyle("small", token$1.tablePaddingVerticalSmall, token$1.tablePaddingHorizontalSmall)), { [`> ${componentCls}-footer`]: {
			border: tableBorder,
			borderTop: 0
		} }),
		[`${componentCls}-cell`]: {
			[`${componentCls}-container:first-child`]: { borderTop: 0 },
			"&-scrollbar:not([rowspan])": { boxShadow: `0 ${unit(lineWidth)} 0 ${unit(lineWidth)} ${tableHeaderBg}` }
		},
		[`${componentCls}-bordered ${componentCls}-cell-scrollbar`]: { borderInlineEnd: tableBorder }
	} };
};
var bordered_default = genBorderedStyle;

//#endregion
//#region node_modules/antd/es/table/style/ellipsis.js
var genEllipsisStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-cell-ellipsis`]: Object.assign(Object.assign({}, textEllipsis), {
		wordBreak: "keep-all",
		[`
          &${componentCls}-cell-fix-left-last,
          &${componentCls}-cell-fix-right-first
        `]: {
			overflow: "visible",
			[`${componentCls}-cell-content`]: {
				display: "block",
				overflow: "hidden",
				textOverflow: "ellipsis"
			}
		},
		[`${componentCls}-column-title`]: {
			overflow: "hidden",
			textOverflow: "ellipsis",
			wordBreak: "keep-all"
		}
	}) } };
};
var ellipsis_default = genEllipsisStyle;

//#endregion
//#region node_modules/antd/es/table/style/empty.js
var genEmptyStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
		textAlign: "center",
		color: token$1.colorTextDisabled,
		[`
          &:hover > th,
          &:hover > td,
        `]: { background: token$1.colorBgContainer }
	} } };
};
var empty_default$1 = genEmptyStyle;

//#endregion
//#region node_modules/antd/es/table/style/expand.js
var genExpandStyle = (token$1) => {
	const { componentCls, antCls, motionDurationSlow, lineWidth, paddingXS, lineType, tableBorderColor, tableExpandIconBg, tableExpandColumnWidth, borderRadius, tablePaddingVertical, tablePaddingHorizontal, tableExpandedRowBg, paddingXXS, expandIconMarginTop, expandIconSize, expandIconHalfInner, expandIconScale, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	const expandIconLineOffset = calc(paddingXXS).sub(lineWidth).equal();
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-expand-icon-col`]: { width: tableExpandColumnWidth },
		[`${componentCls}-row-expand-icon-cell`]: {
			textAlign: "center",
			[`${componentCls}-row-expand-icon`]: {
				display: "inline-flex",
				float: "none",
				verticalAlign: "sub"
			}
		},
		[`${componentCls}-row-indent`]: {
			height: 1,
			float: "left"
		},
		[`${componentCls}-row-expand-icon`]: Object.assign(Object.assign({}, operationUnit(token$1)), {
			position: "relative",
			float: "left",
			width: expandIconSize,
			height: expandIconSize,
			color: "inherit",
			lineHeight: unit(expandIconSize),
			background: tableExpandIconBg,
			border: tableBorder,
			borderRadius,
			transform: `scale(${expandIconScale})`,
			"&:focus, &:hover, &:active": { borderColor: "currentcolor" },
			"&::before, &::after": {
				position: "absolute",
				background: "currentcolor",
				transition: `transform ${motionDurationSlow} ease-out`,
				content: "\"\""
			},
			"&::before": {
				top: expandIconHalfInner,
				insetInlineEnd: expandIconLineOffset,
				insetInlineStart: expandIconLineOffset,
				height: lineWidth
			},
			"&::after": {
				top: expandIconLineOffset,
				bottom: expandIconLineOffset,
				insetInlineStart: expandIconHalfInner,
				width: lineWidth,
				transform: "rotate(90deg)"
			},
			"&-collapsed::before": { transform: "rotate(-180deg)" },
			"&-collapsed::after": { transform: "rotate(0deg)" },
			"&-spaced": {
				"&::before, &::after": {
					display: "none",
					content: "none"
				},
				background: "transparent",
				border: 0,
				visibility: "hidden"
			}
		}),
		[`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
			marginTop: expandIconMarginTop,
			marginInlineEnd: paddingXS
		},
		[`tr${componentCls}-expanded-row`]: {
			"&, &:hover": { "> th, > td": { background: tableExpandedRowBg } },
			[`${antCls}-descriptions-view`]: {
				display: "flex",
				table: {
					flex: "auto",
					width: "100%"
				}
			}
		},
		[`${componentCls}-expanded-row-fixed`]: {
			position: "relative",
			margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
			padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
		}
	} };
};
var expand_default = genExpandStyle;

//#endregion
//#region node_modules/antd/es/table/style/filter.js
var genFilterStyle = (token$1) => {
	const { componentCls, antCls, iconCls, tableFilterDropdownWidth, tableFilterDropdownSearchWidth, paddingXXS, paddingXS, colorText, lineWidth, lineType, tableBorderColor, headerIconColor, fontSizeSM, tablePaddingHorizontal, borderRadius, motionDurationSlow, colorIcon, colorPrimary, tableHeaderFilterActiveBg, colorTextDisabled, tableFilterDropdownBg, tableFilterDropdownHeight, controlItemBgHover, controlItemBgActive, boxShadowSecondary, filterDropdownMenuBg, calc } = token$1;
	const dropdownPrefixCls = `${antCls}-dropdown`;
	const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
	const treePrefixCls = `${antCls}-tree`;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	return [
		{ [`${componentCls}-wrapper`]: {
			[`${componentCls}-filter-column`]: {
				display: "flex",
				justifyContent: "space-between"
			},
			[`${componentCls}-filter-trigger`]: {
				position: "relative",
				display: "flex",
				alignItems: "center",
				marginBlock: calc(paddingXXS).mul(-1).equal(),
				marginInline: `${unit(paddingXXS)} ${unit(calc(tablePaddingHorizontal).div(2).mul(-1).equal())}`,
				padding: `0 ${unit(paddingXXS)}`,
				color: headerIconColor,
				fontSize: fontSizeSM,
				borderRadius,
				cursor: "pointer",
				transition: `all ${motionDurationSlow}`,
				"&:hover": {
					color: colorIcon,
					background: tableHeaderFilterActiveBg
				},
				"&.active": { color: colorPrimary }
			}
		} },
		{ [`${antCls}-dropdown`]: { [tableFilterDropdownPrefixCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			minWidth: tableFilterDropdownWidth,
			backgroundColor: tableFilterDropdownBg,
			borderRadius,
			boxShadow: boxShadowSecondary,
			overflow: "hidden",
			[`${dropdownPrefixCls}-menu`]: {
				maxHeight: tableFilterDropdownHeight,
				overflowX: "hidden",
				border: 0,
				boxShadow: "none",
				borderRadius: "unset",
				backgroundColor: filterDropdownMenuBg,
				"&:empty::after": {
					display: "block",
					padding: `${unit(paddingXS)} 0`,
					color: colorTextDisabled,
					fontSize: fontSizeSM,
					textAlign: "center",
					content: "\"Not Found\""
				}
			},
			[`${tableFilterDropdownPrefixCls}-tree`]: {
				paddingBlock: `${unit(paddingXS)} 0`,
				paddingInline: paddingXS,
				[treePrefixCls]: { padding: 0 },
				[`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: { backgroundColor: controlItemBgHover },
				[`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: { "&, &:hover": { backgroundColor: controlItemBgActive } }
			},
			[`${tableFilterDropdownPrefixCls}-search`]: {
				padding: paddingXS,
				borderBottom: tableBorder,
				"&-input": {
					input: { minWidth: tableFilterDropdownSearchWidth },
					[iconCls]: { color: colorTextDisabled }
				}
			},
			[`${tableFilterDropdownPrefixCls}-checkall`]: {
				width: "100%",
				marginBottom: paddingXXS,
				marginInlineStart: paddingXXS
			},
			[`${tableFilterDropdownPrefixCls}-btns`]: {
				display: "flex",
				justifyContent: "space-between",
				padding: `${unit(calc(paddingXS).sub(lineWidth).equal())} ${unit(paddingXS)}`,
				overflow: "hidden",
				borderTop: tableBorder
			}
		}) } },
		{ [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
			[`${antCls}-checkbox-wrapper + span`]: {
				paddingInlineStart: paddingXS,
				color: colorText
			},
			"> ul": {
				maxHeight: "calc(100vh - 130px)",
				overflowX: "hidden",
				overflowY: "auto"
			}
		} }
	];
};
var filter_default = genFilterStyle;

//#endregion
//#region node_modules/antd/es/table/style/fixed.js
var genFixedStyle = (token$1) => {
	const { componentCls, lineWidth, colorSplit, motionDurationSlow, zIndexTableFixed: zIndexTableFixed$1, tableBg, zIndexTableSticky, calc } = token$1;
	const shadowColor = colorSplit;
	return { [`${componentCls}-wrapper`]: {
		[`
        ${componentCls}-cell-fix-left,
        ${componentCls}-cell-fix-right
      `]: {
			position: "sticky !important",
			zIndex: zIndexTableFixed$1,
			background: tableBg
		},
		[`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after
      `]: {
			position: "absolute",
			top: 0,
			right: {
				_skip_check_: true,
				value: 0
			},
			bottom: calc(lineWidth).mul(-1).equal(),
			width: 30,
			transform: "translateX(100%)",
			transition: `box-shadow ${motionDurationSlow}`,
			content: "\"\"",
			pointerEvents: "none",
			willChange: "transform"
		},
		[`${componentCls}-cell-fix-left-all::after`]: { display: "none" },
		[`
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
			position: "absolute",
			top: 0,
			bottom: calc(lineWidth).mul(-1).equal(),
			left: {
				_skip_check_: true,
				value: 0
			},
			width: 30,
			transform: "translateX(-100%)",
			transition: `box-shadow ${motionDurationSlow}`,
			content: "\"\"",
			pointerEvents: "none"
		},
		[`${componentCls}-container`]: {
			position: "relative",
			"&::before, &::after": {
				position: "absolute",
				top: 0,
				bottom: 0,
				zIndex: calc(zIndexTableSticky).add(1).equal({ unit: false }),
				width: 30,
				transition: `box-shadow ${motionDurationSlow}`,
				content: "\"\"",
				pointerEvents: "none"
			},
			"&::before": { insetInlineStart: 0 },
			"&::after": { insetInlineEnd: 0 }
		},
		[`${componentCls}-ping-left`]: {
			[`&:not(${componentCls}-has-fix-left) ${componentCls}-container::before`]: { boxShadow: `inset 10px 0 8px -8px ${shadowColor}` },
			[`
          ${componentCls}-cell-fix-left-first::after,
          ${componentCls}-cell-fix-left-last::after
        `]: { boxShadow: `inset 10px 0 8px -8px ${shadowColor}` },
			[`${componentCls}-cell-fix-left-last::before`]: { backgroundColor: "transparent !important" }
		},
		[`${componentCls}-ping-right`]: {
			[`&:not(${componentCls}-has-fix-right) ${componentCls}-container::after`]: { boxShadow: `inset -10px 0 8px -8px ${shadowColor}` },
			[`
          ${componentCls}-cell-fix-right-first::after,
          ${componentCls}-cell-fix-right-last::after
        `]: { boxShadow: `inset -10px 0 8px -8px ${shadowColor}` }
		},
		[`${componentCls}-fixed-column-gapped`]: { [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after,
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: { boxShadow: "none" } }
	} };
};
var fixed_default = genFixedStyle;

//#endregion
//#region node_modules/antd/es/table/style/pagination.js
var genPaginationStyle = (token$1) => {
	const { componentCls, antCls, margin } = token$1;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-pagination${antCls}-pagination`]: { margin: `${unit(margin)} 0` },
		[`${componentCls}-pagination`]: {
			display: "flex",
			flexWrap: "wrap",
			rowGap: token$1.paddingXS,
			"> *": { flex: "none" },
			"&-left": { justifyContent: "flex-start" },
			"&-center": { justifyContent: "center" },
			"&-right": { justifyContent: "flex-end" }
		}
	} };
};
var pagination_default$1 = genPaginationStyle;

//#endregion
//#region node_modules/antd/es/table/style/radius.js
var genRadiusStyle = (token$1) => {
	const { componentCls, tableRadius } = token$1;
	return { [`${componentCls}-wrapper`]: { [componentCls]: {
		[`${componentCls}-title, ${componentCls}-header`]: { borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0` },
		[`${componentCls}-title + ${componentCls}-container`]: {
			borderStartStartRadius: 0,
			borderStartEndRadius: 0,
			[`${componentCls}-header, table`]: { borderRadius: 0 },
			"table > thead > tr:first-child": { "th:first-child, th:last-child, td:first-child, td:last-child": { borderRadius: 0 } }
		},
		"&-container": {
			borderStartStartRadius: tableRadius,
			borderStartEndRadius: tableRadius,
			"table > thead > tr:first-child": {
				"> *:first-child": { borderStartStartRadius: tableRadius },
				"> *:last-child": { borderStartEndRadius: tableRadius }
			}
		},
		"&-footer": { borderRadius: `0 0 ${unit(tableRadius)} ${unit(tableRadius)}` }
	} } };
};
var radius_default = genRadiusStyle;

//#endregion
//#region node_modules/antd/es/table/style/rtl.js
var genStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-wrapper-rtl`]: {
		direction: "rtl",
		table: { direction: "rtl" },
		[`${componentCls}-pagination-left`]: { justifyContent: "flex-end" },
		[`${componentCls}-pagination-right`]: { justifyContent: "flex-start" },
		[`${componentCls}-row-expand-icon`]: {
			float: "right",
			"&::after": { transform: "rotate(-90deg)" },
			"&-collapsed::before": { transform: "rotate(180deg)" },
			"&-collapsed::after": { transform: "rotate(0deg)" }
		},
		[`${componentCls}-container`]: {
			"&::before": {
				insetInlineStart: "unset",
				insetInlineEnd: 0
			},
			"&::after": {
				insetInlineStart: 0,
				insetInlineEnd: "unset"
			},
			[`${componentCls}-row-indent`]: { float: "right" }
		}
	} };
};
var rtl_default$1 = genStyle;

//#endregion
//#region node_modules/antd/es/table/style/selection.js
var genSelectionStyle = (token$1) => {
	const { componentCls, antCls, iconCls, fontSizeIcon, padding, paddingXS, headerIconColor, headerIconHoverColor, tableSelectionColumnWidth, tableSelectedRowBg, tableSelectedRowHoverBg, tableRowHoverBg, tablePaddingHorizontal, calc } = token$1;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-selection-col`]: {
			width: tableSelectionColumnWidth,
			[`&${componentCls}-selection-col-with-dropdown`]: { width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).equal() }
		},
		[`${componentCls}-bordered ${componentCls}-selection-col`]: {
			width: calc(tableSelectionColumnWidth).add(calc(paddingXS).mul(2)).equal(),
			[`&${componentCls}-selection-col-with-dropdown`]: { width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).add(calc(paddingXS).mul(2)).equal() }
		},
		[`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column,
        ${componentCls}-selection-column
      `]: {
			paddingInlineEnd: token$1.paddingXS,
			paddingInlineStart: token$1.paddingXS,
			textAlign: "center",
			[`${antCls}-radio-wrapper`]: { marginInlineEnd: 0 }
		},
		[`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: { zIndex: calc(token$1.zIndexTableFixed).add(1).equal({ unit: false }) },
		[`table tr th${componentCls}-selection-column::after`]: { backgroundColor: "transparent !important" },
		[`${componentCls}-selection`]: {
			position: "relative",
			display: "inline-flex",
			flexDirection: "column"
		},
		[`${componentCls}-selection-extra`]: {
			position: "absolute",
			top: 0,
			zIndex: 1,
			cursor: "pointer",
			transition: `all ${token$1.motionDurationSlow}`,
			marginInlineStart: "100%",
			paddingInlineStart: unit(calc(tablePaddingHorizontal).div(4).equal()),
			[iconCls]: {
				color: headerIconColor,
				fontSize: fontSizeIcon,
				verticalAlign: "baseline",
				"&:hover": { color: headerIconHoverColor }
			}
		},
		[`${componentCls}-tbody`]: { [`${componentCls}-row`]: {
			[`&${componentCls}-row-selected`]: { [`> ${componentCls}-cell`]: {
				background: tableSelectedRowBg,
				"&-row-hover": { background: tableSelectedRowHoverBg }
			} },
			[`> ${componentCls}-cell-row-hover`]: { background: tableRowHoverBg }
		} }
	} };
};
var selection_default = genSelectionStyle;

//#endregion
//#region node_modules/antd/es/table/style/size.js
var genSizeStyle = (token$1) => {
	const { componentCls, tableExpandColumnWidth, calc } = token$1;
	const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({ [`${componentCls}${componentCls}-${size}`]: {
		fontSize,
		[`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-cell,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: { padding: `${unit(paddingVertical)} ${unit(paddingHorizontal)}` },
		[`${componentCls}-filter-trigger`]: { marginInlineEnd: unit(calc(paddingHorizontal).div(2).mul(-1).equal()) },
		[`${componentCls}-expanded-row-fixed`]: { margin: `${unit(calc(paddingVertical).mul(-1).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}` },
		[`${componentCls}-tbody`]: { [`${componentCls}-wrapper:only-child ${componentCls}`]: {
			marginBlock: unit(calc(paddingVertical).mul(-1).equal()),
			marginInline: `${unit(calc(tableExpandColumnWidth).sub(paddingHorizontal).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
		} },
		[`${componentCls}-selection-extra`]: { paddingInlineStart: unit(calc(paddingHorizontal).div(4).equal()) }
	} });
	return { [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, getSizeStyle("middle", token$1.tablePaddingVerticalMiddle, token$1.tablePaddingHorizontalMiddle, token$1.tableFontSizeMiddle)), getSizeStyle("small", token$1.tablePaddingVerticalSmall, token$1.tablePaddingHorizontalSmall, token$1.tableFontSizeSmall)) };
};
var size_default = genSizeStyle;

//#endregion
//#region node_modules/antd/es/table/style/sorter.js
var genSorterStyle = (token$1) => {
	const { componentCls, marginXXS, fontSizeIcon, headerIconColor, headerIconHoverColor } = token$1;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
			outline: "none",
			cursor: "pointer",
			transition: `all ${token$1.motionDurationSlow}, left 0s`,
			"&:hover": {
				background: token$1.tableHeaderSortHoverBg,
				"&::before": { backgroundColor: "transparent !important" }
			},
			"&:focus-visible": { color: token$1.colorPrimary },
			[`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: { background: token$1.tableFixedHeaderSortActiveBg }
		},
		[`${componentCls}-thead th${componentCls}-column-sort`]: {
			background: token$1.tableHeaderSortBg,
			"&::before": { backgroundColor: "transparent !important" }
		},
		[`td${componentCls}-column-sort`]: { background: token$1.tableBodySortBg },
		[`${componentCls}-column-title`]: {
			position: "relative",
			zIndex: 1,
			flex: 1,
			minWidth: 0
		},
		[`${componentCls}-column-sorters`]: {
			display: "flex",
			flex: "auto",
			alignItems: "center",
			justifyContent: "space-between",
			"&::after": {
				position: "absolute",
				inset: 0,
				width: "100%",
				height: "100%",
				content: "\"\""
			}
		},
		[`${componentCls}-column-sorters-tooltip-target-sorter`]: { "&::after": { content: "none" } },
		[`${componentCls}-column-sorter`]: {
			marginInlineStart: marginXXS,
			color: headerIconColor,
			fontSize: 0,
			transition: `color ${token$1.motionDurationSlow}`,
			"&-inner": {
				display: "inline-flex",
				flexDirection: "column",
				alignItems: "center"
			},
			"&-up, &-down": {
				fontSize: fontSizeIcon,
				"&.active": { color: token$1.colorPrimary }
			},
			[`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: { marginTop: "-0.3em" }
		},
		[`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: { color: headerIconHoverColor }
	} };
};
var sorter_default = genSorterStyle;

//#endregion
//#region node_modules/antd/es/table/style/sticky.js
var genStickyStyle = (token$1) => {
	const { componentCls, opacityLoading, tableScrollThumbBg, tableScrollThumbBgHover, tableScrollThumbSize, tableScrollBg, zIndexTableSticky, stickyScrollBarBorderRadius, lineWidth, lineType, tableBorderColor } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-sticky`]: {
		"&-holder": {
			position: "sticky",
			zIndex: zIndexTableSticky,
			background: token$1.colorBgContainer
		},
		"&-scroll": {
			position: "sticky",
			bottom: 0,
			height: `${unit(tableScrollThumbSize)} !important`,
			zIndex: zIndexTableSticky,
			display: "flex",
			alignItems: "center",
			background: tableScrollBg,
			borderTop: tableBorder,
			opacity: opacityLoading,
			"&:hover": { transformOrigin: "center bottom" },
			"&-bar": {
				height: tableScrollThumbSize,
				backgroundColor: tableScrollThumbBg,
				borderRadius: stickyScrollBarBorderRadius,
				transition: `all ${token$1.motionDurationSlow}, transform 0s`,
				position: "absolute",
				bottom: 0,
				"&:hover, &-active": { backgroundColor: tableScrollThumbBgHover }
			}
		}
	} } };
};
var sticky_default = genStickyStyle;

//#endregion
//#region node_modules/antd/es/table/style/summary.js
var genSummaryStyle = (token$1) => {
	const { componentCls, lineWidth, tableBorderColor, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${token$1.lineType} ${tableBorderColor}`;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-summary`]: {
			position: "relative",
			zIndex: token$1.zIndexTableFixed,
			background: token$1.tableBg,
			"> tr": { "> th, > td": { borderBottom: tableBorder } }
		},
		[`div${componentCls}-summary`]: { boxShadow: `0 ${unit(calc(lineWidth).mul(-1).equal())} 0 ${tableBorderColor}` }
	} };
};
var summary_default = genSummaryStyle;

//#endregion
//#region node_modules/antd/es/table/style/virtual.js
var genVirtualStyle = (token$1) => {
	const { componentCls, motionDurationMid, lineWidth, lineType, tableBorderColor, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	const rowCellCls = `${componentCls}-expanded-row-cell`;
	return { [`${componentCls}-wrapper`]: {
		[`${componentCls}-tbody-virtual`]: {
			[`${componentCls}-tbody-virtual-holder-inner`]: { [`
            & > ${componentCls}-row, 
            & > div:not(${componentCls}-row) > ${componentCls}-row
          `]: {
				display: "flex",
				boxSizing: "border-box",
				width: "100%"
			} },
			[`${componentCls}-cell`]: {
				borderBottom: tableBorder,
				transition: `background ${motionDurationMid}`
			},
			[`${componentCls}-expanded-row`]: { [`${rowCellCls}${rowCellCls}-fixed`]: {
				position: "sticky",
				insetInlineStart: 0,
				overflow: "hidden",
				width: `calc(var(--virtual-width) - ${unit(lineWidth)})`,
				borderInlineEnd: "none"
			} }
		},
		[`${componentCls}-bordered`]: {
			[`${componentCls}-tbody-virtual`]: {
				"&:after": {
					content: "\"\"",
					insetInline: 0,
					bottom: 0,
					borderBottom: tableBorder,
					position: "absolute"
				},
				[`${componentCls}-cell`]: {
					borderInlineEnd: tableBorder,
					[`&${componentCls}-cell-fix-right-first:before`]: {
						content: "\"\"",
						position: "absolute",
						insetBlock: 0,
						insetInlineStart: calc(lineWidth).mul(-1).equal(),
						borderInlineStart: tableBorder
					}
				}
			},
			[`&${componentCls}-virtual`]: { [`${componentCls}-placeholder ${componentCls}-cell`]: {
				borderInlineEnd: tableBorder,
				borderBottom: tableBorder
			} }
		}
	} };
};
var virtual_default = genVirtualStyle;

//#endregion
//#region node_modules/antd/es/table/style/index.js
var genTableStyle = (token$1) => {
	const { componentCls, fontWeightStrong, tablePaddingVertical, tablePaddingHorizontal, tableExpandColumnWidth, lineWidth, lineType, tableBorderColor, tableFontSize, tableBg, tableRadius, tableHeaderTextColor, motionDurationMid, tableHeaderBg, tableHeaderCellSplitColor, tableFooterTextColor, tableFooterBg, calc } = token$1;
	const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
	return { [`${componentCls}-wrapper`]: Object.assign(Object.assign({
		clear: "both",
		maxWidth: "100%",
		["--rc-virtual-list-scrollbar-bg"]: token$1.tableScrollBg
	}, clearFix()), {
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			fontSize: tableFontSize,
			background: tableBg,
			borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
			scrollbarColor: `${token$1.tableScrollThumbBg} ${token$1.tableScrollBg}`
		}),
		table: {
			width: "100%",
			textAlign: "start",
			borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
			borderCollapse: "separate",
			borderSpacing: 0
		},
		[`
          ${componentCls}-cell,
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
			position: "relative",
			padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
			overflowWrap: "break-word"
		},
		[`${componentCls}-title`]: { padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}` },
		[`${componentCls}-thead`]: {
			[`
          > tr > th,
          > tr > td
        `]: {
				position: "relative",
				color: tableHeaderTextColor,
				fontWeight: fontWeightStrong,
				textAlign: "start",
				background: tableHeaderBg,
				borderBottom: tableBorder,
				transition: `background ${motionDurationMid} ease`,
				"&[colspan]:not([colspan='1'])": { textAlign: "center" },
				[`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
					position: "absolute",
					top: "50%",
					insetInlineEnd: 0,
					width: 1,
					height: "1.6em",
					backgroundColor: tableHeaderCellSplitColor,
					transform: "translateY(-50%)",
					transition: `background-color ${motionDurationMid}`,
					content: "\"\""
				}
			},
			"> tr:not(:last-child) > th[colspan]": { borderBottom: 0 }
		},
		[`${componentCls}-tbody`]: { "> tr": {
			"> th, > td": {
				transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
				borderBottom: tableBorder,
				[`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: { [componentCls]: {
					marginBlock: unit(calc(tablePaddingVertical).mul(-1).equal()),
					marginInline: `${unit(calc(tableExpandColumnWidth).sub(tablePaddingHorizontal).equal())}
                ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
					[`${componentCls}-tbody > tr:last-child > td`]: {
						borderBottomWidth: 0,
						"&:first-child, &:last-child": { borderRadius: 0 }
					}
				} }
			},
			"> th": {
				position: "relative",
				color: tableHeaderTextColor,
				fontWeight: fontWeightStrong,
				textAlign: "start",
				background: tableHeaderBg,
				borderBottom: tableBorder,
				transition: `background ${motionDurationMid} ease`
			}
		} },
		[`${componentCls}-footer`]: {
			padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
			color: tableFooterTextColor,
			background: tableFooterBg
		}
	}) };
};
const prepareComponentToken$7 = (token$1) => {
	const { colorFillAlter, colorBgContainer, colorTextHeading, colorFillSecondary, colorFillContent, controlItemBgActive, controlItemBgActiveHover, padding, paddingSM, paddingXS, colorBorderSecondary, borderRadiusLG, controlHeight, colorTextPlaceholder, fontSize, fontSizeSM, lineHeight, lineWidth, colorIcon, colorIconHover, opacityLoading, controlInteractiveSize } = token$1;
	const colorFillSecondarySolid = new FastColor(colorFillSecondary).onBackground(colorBgContainer).toHexString();
	const colorFillContentSolid = new FastColor(colorFillContent).onBackground(colorBgContainer).toHexString();
	const colorFillAlterSolid = new FastColor(colorFillAlter).onBackground(colorBgContainer).toHexString();
	const baseColorAction = new FastColor(colorIcon);
	const baseColorActionHover = new FastColor(colorIconHover);
	const expandIconHalfInner = controlInteractiveSize / 2 - lineWidth;
	const expandIconSize = expandIconHalfInner * 2 + lineWidth * 3;
	return {
		headerBg: colorFillAlterSolid,
		headerColor: colorTextHeading,
		headerSortActiveBg: colorFillSecondarySolid,
		headerSortHoverBg: colorFillContentSolid,
		bodySortBg: colorFillAlterSolid,
		rowHoverBg: colorFillAlterSolid,
		rowSelectedBg: controlItemBgActive,
		rowSelectedHoverBg: controlItemBgActiveHover,
		rowExpandedBg: colorFillAlter,
		cellPaddingBlock: padding,
		cellPaddingInline: padding,
		cellPaddingBlockMD: paddingSM,
		cellPaddingInlineMD: paddingXS,
		cellPaddingBlockSM: paddingXS,
		cellPaddingInlineSM: paddingXS,
		borderColor: colorBorderSecondary,
		headerBorderRadius: borderRadiusLG,
		footerBg: colorFillAlterSolid,
		footerColor: colorTextHeading,
		cellFontSize: fontSize,
		cellFontSizeMD: fontSize,
		cellFontSizeSM: fontSize,
		headerSplitColor: colorBorderSecondary,
		fixedHeaderSortActiveBg: colorFillSecondarySolid,
		headerFilterHoverBg: colorFillContent,
		filterDropdownMenuBg: colorBgContainer,
		filterDropdownBg: colorBgContainer,
		expandIconBg: colorBgContainer,
		selectionColumnWidth: controlHeight,
		stickyScrollBarBg: colorTextPlaceholder,
		stickyScrollBarBorderRadius: 100,
		expandIconMarginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
		headerIconColor: baseColorAction.clone().setA(baseColorAction.a * opacityLoading).toRgbString(),
		headerIconHoverColor: baseColorActionHover.clone().setA(baseColorActionHover.a * opacityLoading).toRgbString(),
		expandIconHalfInner,
		expandIconSize,
		expandIconScale: controlInteractiveSize / expandIconSize
	};
};
var zIndexTableFixed = 2;
var style_default$8 = genStyleHooks("Table", (token$1) => {
	const { colorTextHeading, colorSplit, colorBgContainer, controlInteractiveSize: checkboxSize, headerBg, headerColor, headerSortActiveBg, headerSortHoverBg, bodySortBg, rowHoverBg, rowSelectedBg, rowSelectedHoverBg, rowExpandedBg, cellPaddingBlock, cellPaddingInline, cellPaddingBlockMD, cellPaddingInlineMD, cellPaddingBlockSM, cellPaddingInlineSM, borderColor, footerBg, footerColor, headerBorderRadius, cellFontSize, cellFontSizeMD, cellFontSizeSM, headerSplitColor, fixedHeaderSortActiveBg, headerFilterHoverBg, filterDropdownBg, expandIconBg, selectionColumnWidth, stickyScrollBarBg, calc } = token$1;
	const tableToken = merge(token$1, {
		tableFontSize: cellFontSize,
		tableBg: colorBgContainer,
		tableRadius: headerBorderRadius,
		tablePaddingVertical: cellPaddingBlock,
		tablePaddingHorizontal: cellPaddingInline,
		tablePaddingVerticalMiddle: cellPaddingBlockMD,
		tablePaddingHorizontalMiddle: cellPaddingInlineMD,
		tablePaddingVerticalSmall: cellPaddingBlockSM,
		tablePaddingHorizontalSmall: cellPaddingInlineSM,
		tableBorderColor: borderColor,
		tableHeaderTextColor: headerColor,
		tableHeaderBg: headerBg,
		tableFooterTextColor: footerColor,
		tableFooterBg: footerBg,
		tableHeaderCellSplitColor: headerSplitColor,
		tableHeaderSortBg: headerSortActiveBg,
		tableHeaderSortHoverBg: headerSortHoverBg,
		tableBodySortBg: bodySortBg,
		tableFixedHeaderSortActiveBg: fixedHeaderSortActiveBg,
		tableHeaderFilterActiveBg: headerFilterHoverBg,
		tableFilterDropdownBg: filterDropdownBg,
		tableRowHoverBg: rowHoverBg,
		tableSelectedRowBg: rowSelectedBg,
		tableSelectedRowHoverBg: rowSelectedHoverBg,
		zIndexTableFixed,
		zIndexTableSticky: calc(zIndexTableFixed).add(1).equal({ unit: false }),
		tableFontSizeMiddle: cellFontSizeMD,
		tableFontSizeSmall: cellFontSizeSM,
		tableSelectionColumnWidth: selectionColumnWidth,
		tableExpandIconBg: expandIconBg,
		tableExpandColumnWidth: calc(checkboxSize).add(calc(token$1.padding).mul(2)).equal(),
		tableExpandedRowBg: rowExpandedBg,
		tableFilterDropdownWidth: 120,
		tableFilterDropdownHeight: 264,
		tableFilterDropdownSearchWidth: 140,
		tableScrollThumbSize: 8,
		tableScrollThumbBg: stickyScrollBarBg,
		tableScrollThumbBgHover: colorTextHeading,
		tableScrollBg: colorSplit
	});
	return [
		genTableStyle(tableToken),
		pagination_default$1(tableToken),
		summary_default(tableToken),
		sorter_default(tableToken),
		filter_default(tableToken),
		bordered_default(tableToken),
		radius_default(tableToken),
		expand_default(tableToken),
		summary_default(tableToken),
		empty_default$1(tableToken),
		selection_default(tableToken),
		fixed_default(tableToken),
		sticky_default(tableToken),
		ellipsis_default(tableToken),
		size_default(tableToken),
		rtl_default$1(tableToken),
		virtual_default(tableToken)
	];
}, prepareComponentToken$7, { unitless: { expandIconScale: true } });

//#endregion
//#region node_modules/antd/es/table/InternalTable.js
var import_classnames$28 = /* @__PURE__ */ __toESM(require_classnames());
var EMPTY_LIST = [];
var InternalTable = (props, ref) => {
	var _a, _b;
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, size: customizeSize, bordered, dropdownPrefixCls: customizeDropdownPrefixCls, dataSource, pagination, rowSelection, rowKey = "key", rowClassName, columns, children, childrenColumnName: legacyChildrenColumnName, onChange, getPopupContainer, loading, expandIcon, expandable, expandedRowRender, expandIconColumnIndex, indentSize, scroll, sortDirections, locale: locale$5, showSorterTooltip = { target: "full-header" }, virtual } = props;
	const warning$4 = devUseWarning("Table");
	warning$4(!(typeof rowKey === "function" && rowKey.length > 1), "usage", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.");
	const baseColumns = import_react.useMemo(() => columns || convertChildrenToColumns(children), [columns, children]);
	const needResponsive = import_react.useMemo(() => baseColumns.some((col) => col.responsive), [baseColumns]);
	const screens = useBreakpoint_default(needResponsive);
	const mergedColumns = import_react.useMemo(() => {
		const matched = new Set(Object.keys(screens).filter((m) => screens[m]));
		return baseColumns.filter((c) => !c.responsive || c.responsive.some((r$1) => matched.has(r$1)));
	}, [baseColumns, screens]);
	const tableProps = omit(props, [
		"className",
		"style",
		"columns"
	]);
	const { locale: contextLocale = en_US_default, direction, table, renderEmpty, getPrefixCls, getPopupContainer: getContextPopupContainer } = import_react.useContext(ConfigContext);
	const mergedSize = useSize_default(customizeSize);
	const tableLocale = Object.assign(Object.assign({}, contextLocale.Table), locale$5);
	const rawData = dataSource || EMPTY_LIST;
	const prefixCls = getPrefixCls("table", customizePrefixCls);
	const dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
	const [, token$1] = useToken();
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$8(prefixCls, rootCls);
	const mergedExpandable = Object.assign(Object.assign({
		childrenColumnName: legacyChildrenColumnName,
		expandIconColumnIndex
	}, expandable), { expandIcon: (_a = expandable === null || expandable === void 0 ? void 0 : expandable.expandIcon) !== null && _a !== void 0 ? _a : (_b = table === null || table === void 0 ? void 0 : table.expandable) === null || _b === void 0 ? void 0 : _b.expandIcon });
	const { childrenColumnName = "children" } = mergedExpandable;
	const expandType = import_react.useMemo(() => {
		if (rawData.some((item) => item === null || item === void 0 ? void 0 : item[childrenColumnName])) return "nest";
		if (expandedRowRender || (expandable === null || expandable === void 0 ? void 0 : expandable.expandedRowRender)) return "row";
		return null;
	}, [rawData]);
	const internalRefs = { body: import_react.useRef(null) };
	const getContainerWidth = useContainerWidth(prefixCls);
	const rootRef = import_react.useRef(null);
	const tblRef = import_react.useRef(null);
	useProxyImperativeHandle(ref, () => Object.assign(Object.assign({}, tblRef.current), { nativeElement: rootRef.current }));
	const getRowKey = import_react.useMemo(() => {
		if (typeof rowKey === "function") return rowKey;
		return (record) => record === null || record === void 0 ? void 0 : record[rowKey];
	}, [rowKey]);
	const [getRecordByKey] = useLazyKVMap_default(rawData, childrenColumnName, getRowKey);
	const changeEventInfo = {};
	const triggerOnChange = (info, action, reset = false) => {
		var _a$1, _b$1, _c, _d;
		const changeInfo = Object.assign(Object.assign({}, changeEventInfo), info);
		if (reset) {
			(_a$1 = changeEventInfo.resetPagination) === null || _a$1 === void 0 || _a$1.call(changeEventInfo);
			if ((_b$1 = changeInfo.pagination) === null || _b$1 === void 0 ? void 0 : _b$1.current) changeInfo.pagination.current = 1;
			if (pagination) (_c = pagination.onChange) === null || _c === void 0 || _c.call(pagination, 1, (_d = changeInfo.pagination) === null || _d === void 0 ? void 0 : _d.pageSize);
		}
		if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) scrollTo(0, { getContainer: () => internalRefs.body.current });
		onChange === null || onChange === void 0 || onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
			currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates, childrenColumnName),
			action
		});
	};
	/**
	* Controlled state in `columns` is not a good idea that makes too many code (1000+ line?) to read
	* state out and then put it back to title render. Move these code into `hooks` but still too
	* complex. We should provides Table props like `sorter` & `filter` to handle control in next big
	* version.
	*/
	const onSorterChange = (sorter, sorterStates) => {
		triggerOnChange({
			sorter,
			sorterStates
		}, "sort", false);
	};
	const [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useSorter_default({
		prefixCls,
		mergedColumns,
		onSorterChange,
		sortDirections: sortDirections || ["ascend", "descend"],
		tableLocale,
		showSorterTooltip
	});
	const sortedData = import_react.useMemo(() => getSortData(rawData, sortStates, childrenColumnName), [rawData, sortStates]);
	changeEventInfo.sorter = getSorters();
	changeEventInfo.sorterStates = sortStates;
	const onFilterChange = (filters$1, filterStates$1) => {
		triggerOnChange({
			filters: filters$1,
			filterStates: filterStates$1
		}, "filter", true);
	};
	const [transformFilterColumns, filterStates, filters] = useFilter_default({
		prefixCls,
		locale: tableLocale,
		dropdownPrefixCls,
		mergedColumns,
		onFilterChange,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		rootClassName: (0, import_classnames$28.default)(rootClassName, rootCls)
	});
	const mergedData = getFilterData(sortedData, filterStates, childrenColumnName);
	changeEventInfo.filters = filters;
	changeEventInfo.filterStates = filterStates;
	const columnTitleProps = import_react.useMemo(() => {
		const mergedFilters = {};
		Object.keys(filters).forEach((filterKey) => {
			if (filters[filterKey] !== null) mergedFilters[filterKey] = filters[filterKey];
		});
		return Object.assign(Object.assign({}, sorterTitleProps), { filters: mergedFilters });
	}, [sorterTitleProps, filters]);
	const [transformTitleColumns] = useTitleColumns_default(columnTitleProps);
	const onPaginationChange = (current, pageSize) => {
		triggerOnChange({ pagination: Object.assign(Object.assign({}, changeEventInfo.pagination), {
			current,
			pageSize
		}) }, "paginate");
	};
	const [mergedPagination, resetPagination] = usePagination_default(mergedData.length, onPaginationChange, pagination);
	changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(mergedPagination, pagination);
	changeEventInfo.resetPagination = resetPagination;
	const pageData = import_react.useMemo(() => {
		if (pagination === false || !mergedPagination.pageSize) return mergedData;
		const { current = 1, total, pageSize = DEFAULT_PAGE_SIZE } = mergedPagination;
		warning$4(current > 0, "usage", "`current` should be positive number.");
		if (mergedData.length < total) {
			if (mergedData.length > pageSize) {
				warning$4(false, "usage", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
				return mergedData.slice((current - 1) * pageSize, current * pageSize);
			}
			return mergedData;
		}
		return mergedData.slice((current - 1) * pageSize, current * pageSize);
	}, [
		!!pagination,
		mergedData,
		mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.current,
		mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize,
		mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total
	]);
	const [transformSelectionColumns, selectedKeySet] = useSelection_default$1({
		prefixCls,
		data: mergedData,
		pageData,
		getRowKey,
		getRecordByKey,
		expandType,
		childrenColumnName,
		locale: tableLocale,
		getPopupContainer: getPopupContainer || getContextPopupContainer
	}, rowSelection);
	const internalRowClassName = (record, index$2, indent) => {
		let mergedRowClassName;
		if (typeof rowClassName === "function") mergedRowClassName = (0, import_classnames$28.default)(rowClassName(record, index$2, indent));
		else mergedRowClassName = (0, import_classnames$28.default)(rowClassName);
		return (0, import_classnames$28.default)({ [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index$2)) }, mergedRowClassName);
	};
	mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
	mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || ExpandIcon_default(tableLocale);
	if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
	else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) mergedExpandable.expandIconColumnIndex -= 1;
	if (typeof mergedExpandable.indentSize !== "number") mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
	const transformColumns = import_react.useCallback((innerColumns) => transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))), [
		transformSorterColumns,
		transformFilterColumns,
		transformSelectionColumns
	]);
	let topPaginationNode;
	let bottomPaginationNode;
	if (pagination !== false && (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total)) {
		let paginationSize;
		if (mergedPagination.size) paginationSize = mergedPagination.size;
		else paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
		const renderPagination = (position$3) => /* @__PURE__ */ import_react.createElement(pagination_default, Object.assign({}, mergedPagination, {
			className: (0, import_classnames$28.default)(`${prefixCls}-pagination ${prefixCls}-pagination-${position$3}`, mergedPagination.className),
			size: paginationSize
		}));
		const defaultPosition = direction === "rtl" ? "left" : "right";
		const { position: position$2 } = mergedPagination;
		if (position$2 !== null && Array.isArray(position$2)) {
			const topPos = position$2.find((p) => p.includes("top"));
			const bottomPos = position$2.find((p) => p.includes("bottom"));
			const isDisable = position$2.every((p) => `${p}` === "none");
			if (!topPos && !bottomPos && !isDisable) bottomPaginationNode = renderPagination(defaultPosition);
			if (topPos) topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
			if (bottomPos) bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
		} else bottomPaginationNode = renderPagination(defaultPosition);
	}
	let spinProps;
	if (typeof loading === "boolean") spinProps = { spinning: loading };
	else if (typeof loading === "object") spinProps = Object.assign({ spinning: true }, loading);
	const wrapperClassNames = (0, import_classnames$28.default)(cssVarCls, rootCls, `${prefixCls}-wrapper`, table === null || table === void 0 ? void 0 : table.className, { [`${prefixCls}-wrapper-rtl`]: direction === "rtl" }, className, rootClassName, hashId);
	const mergedStyle = Object.assign(Object.assign({}, table === null || table === void 0 ? void 0 : table.style), style$1);
	const mergedEmptyNode = import_react.useMemo(() => {
		if ((spinProps === null || spinProps === void 0 ? void 0 : spinProps.spinning) && rawData === EMPTY_LIST) return null;
		if (typeof (locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.emptyText) !== "undefined") return locale$5.emptyText;
		return (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Table")) || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Table" });
	}, [
		spinProps === null || spinProps === void 0 ? void 0 : spinProps.spinning,
		rawData,
		locale$5 === null || locale$5 === void 0 ? void 0 : locale$5.emptyText,
		renderEmpty
	]);
	const TableComponent = virtual ? VirtualTable_default : RcTable_default;
	const virtualProps = {};
	const listItemHeight = import_react.useMemo(() => {
		const { fontSize, lineHeight, lineWidth, padding, paddingXS, paddingSM } = token$1;
		const fontHeight = Math.floor(fontSize * lineHeight);
		switch (mergedSize) {
			case "middle": return paddingSM * 2 + fontHeight + lineWidth;
			case "small": return paddingXS * 2 + fontHeight + lineWidth;
			default: return padding * 2 + fontHeight + lineWidth;
		}
	}, [token$1, mergedSize]);
	if (virtual) virtualProps.listItemHeight = listItemHeight;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
		ref: rootRef,
		className: wrapperClassNames,
		style: mergedStyle
	}, /* @__PURE__ */ import_react.createElement(spin_default, Object.assign({ spinning: false }, spinProps), topPaginationNode, /* @__PURE__ */ import_react.createElement(TableComponent, Object.assign({}, virtualProps, tableProps, {
		ref: tblRef,
		columns: mergedColumns,
		direction,
		expandable: mergedExpandable,
		prefixCls,
		className: (0, import_classnames$28.default)({
			[`${prefixCls}-middle`]: mergedSize === "middle",
			[`${prefixCls}-small`]: mergedSize === "small",
			[`${prefixCls}-bordered`]: bordered,
			[`${prefixCls}-empty`]: rawData.length === 0
		}, cssVarCls, rootCls, hashId),
		data: pageData,
		rowKey: getRowKey,
		rowClassName: internalRowClassName,
		emptyText: mergedEmptyNode,
		internalHooks: INTERNAL_HOOKS,
		internalRefs,
		transformColumns,
		getContainerWidth,
		measureRowRender: (measureRow) => /* @__PURE__ */ import_react.createElement(config_provider_default, { getPopupContainer: (node$1) => node$1 }, measureRow)
	})), bottomPaginationNode)));
};
var InternalTable_default = /* @__PURE__ */ import_react.forwardRef(InternalTable);

//#endregion
//#region node_modules/antd/es/table/Table.js
var Table = (props, ref) => {
	const renderTimesRef = import_react.useRef(0);
	renderTimesRef.current += 1;
	return /* @__PURE__ */ import_react.createElement(InternalTable_default, Object.assign({}, props, {
		ref,
		_renderTimes: renderTimesRef.current
	}));
};
var ForwardTable = /* @__PURE__ */ import_react.forwardRef(Table);
ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
ForwardTable.SELECTION_ALL = SELECTION_ALL;
ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
ForwardTable.SELECTION_NONE = SELECTION_NONE;
ForwardTable.Column = Column_default;
ForwardTable.ColumnGroup = ColumnGroup_default;
ForwardTable.Summary = FooterComponents;
ForwardTable.displayName = "Table";
var Table_default = ForwardTable;

//#endregion
//#region node_modules/antd/es/table/index.js
var table_default = Table_default;

//#endregion
//#region node_modules/antd/es/tag/style/index.js
var genBaseStyle$3 = (token$1) => {
	const { paddingXXS, lineWidth, tagPaddingHorizontal, componentCls, calc } = token$1;
	const paddingInline = calc(tagPaddingHorizontal).sub(lineWidth).equal();
	const iconMarginInline = calc(paddingXXS).sub(lineWidth).equal();
	return {
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			display: "inline-block",
			height: "auto",
			marginInlineEnd: token$1.marginXS,
			paddingInline,
			fontSize: token$1.tagFontSize,
			lineHeight: token$1.tagLineHeight,
			whiteSpace: "nowrap",
			background: token$1.defaultBg,
			border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
			borderRadius: token$1.borderRadiusSM,
			opacity: 1,
			transition: `all ${token$1.motionDurationMid}`,
			textAlign: "start",
			position: "relative",
			[`&${componentCls}-rtl`]: { direction: "rtl" },
			"&, a, a:hover": { color: token$1.defaultColor },
			[`${componentCls}-close-icon`]: {
				marginInlineStart: iconMarginInline,
				fontSize: token$1.tagIconSize,
				color: token$1.colorIcon,
				cursor: "pointer",
				transition: `all ${token$1.motionDurationMid}`,
				"&:hover": { color: token$1.colorTextHeading }
			},
			[`&${componentCls}-has-color`]: {
				borderColor: "transparent",
				[`&, a, a:hover, ${token$1.iconCls}-close, ${token$1.iconCls}-close:hover`]: { color: token$1.colorTextLightSolid }
			},
			"&-checkable": {
				backgroundColor: "transparent",
				borderColor: "transparent",
				cursor: "pointer",
				[`&:not(${componentCls}-checkable-checked):hover`]: {
					color: token$1.colorPrimary,
					backgroundColor: token$1.colorFillSecondary
				},
				"&:active, &-checked": { color: token$1.colorTextLightSolid },
				"&-checked": {
					backgroundColor: token$1.colorPrimary,
					"&:hover": { backgroundColor: token$1.colorPrimaryHover }
				},
				"&:active": { backgroundColor: token$1.colorPrimaryActive }
			},
			"&-hidden": { display: "none" },
			[`> ${token$1.iconCls} + span, > span + ${token$1.iconCls}`]: { marginInlineStart: paddingInline }
		}),
		[`${componentCls}-borderless`]: {
			borderColor: "transparent",
			background: token$1.tagBorderlessBg
		}
	};
};
const prepareToken = (token$1) => {
	const { lineWidth, fontSizeIcon, calc } = token$1;
	const tagFontSize = token$1.fontSizeSM;
	return merge(token$1, {
		tagFontSize,
		tagLineHeight: unit(calc(token$1.lineHeightSM).mul(tagFontSize).equal()),
		tagIconSize: calc(fontSizeIcon).sub(calc(lineWidth).mul(2)).equal(),
		tagPaddingHorizontal: 8,
		tagBorderlessBg: token$1.defaultBg
	});
};
const prepareComponentToken$6 = (token$1) => ({
	defaultBg: new FastColor(token$1.colorFillQuaternary).onBackground(token$1.colorBgContainer).toHexString(),
	defaultColor: token$1.colorText
});
var style_default$7 = genStyleHooks("Tag", (token$1) => {
	const tagToken = prepareToken(token$1);
	return genBaseStyle$3(tagToken);
}, prepareComponentToken$6);

//#endregion
//#region node_modules/antd/es/tag/CheckableTag.js
var import_classnames$27 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$15 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var CheckableTag = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, style: style$1, className, checked, children, icon, onChange, onClick } = props, restProps = __rest$15(props, [
		"prefixCls",
		"style",
		"className",
		"checked",
		"children",
		"icon",
		"onChange",
		"onClick"
	]);
	const { getPrefixCls, tag } = import_react.useContext(ConfigContext);
	const handleClick = (e$2) => {
		onChange === null || onChange === void 0 || onChange(!checked);
		onClick === null || onClick === void 0 || onClick(e$2);
	};
	const prefixCls = getPrefixCls("tag", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$7(prefixCls);
	const cls$12 = (0, import_classnames$27.default)(prefixCls, `${prefixCls}-checkable`, { [`${prefixCls}-checkable-checked`]: checked }, tag === null || tag === void 0 ? void 0 : tag.className, className, hashId, cssVarCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("span", Object.assign({}, restProps, {
		ref,
		style: Object.assign(Object.assign({}, style$1), tag === null || tag === void 0 ? void 0 : tag.style),
		className: cls$12,
		onClick: handleClick
	}), icon, /* @__PURE__ */ import_react.createElement("span", null, children)));
});
var CheckableTag_default = CheckableTag;

//#endregion
//#region node_modules/antd/es/tag/style/presetCmp.js
var genPresetStyle = (token$1) => genPresetColor(token$1, (colorKey, { textColor, lightBorderColor, lightColor, darkColor }) => ({ [`${token$1.componentCls}${token$1.componentCls}-${colorKey}`]: {
	color: textColor,
	background: lightColor,
	borderColor: lightBorderColor,
	"&-inverse": {
		color: token$1.colorTextLightSolid,
		background: darkColor,
		borderColor: darkColor
	},
	[`&${token$1.componentCls}-borderless`]: { borderColor: "transparent" }
} }));
var presetCmp_default = genSubStyleComponent(["Tag", "preset"], (token$1) => {
	const tagToken = prepareToken(token$1);
	return genPresetStyle(tagToken);
}, prepareComponentToken$6);

//#endregion
//#region node_modules/antd/es/_util/capitalize.js
function capitalize(str) {
	if (typeof str !== "string") return str;
	return str.charAt(0).toUpperCase() + str.slice(1);
}

//#endregion
//#region node_modules/antd/es/tag/style/statusCmp.js
var genTagStatusStyle = (token$1, status, cssVariableType) => {
	const capitalizedCssVariableType = capitalize(cssVariableType);
	return { [`${token$1.componentCls}${token$1.componentCls}-${status}`]: {
		color: token$1[`color${cssVariableType}`],
		background: token$1[`color${capitalizedCssVariableType}Bg`],
		borderColor: token$1[`color${capitalizedCssVariableType}Border`],
		[`&${token$1.componentCls}-borderless`]: { borderColor: "transparent" }
	} };
};
var statusCmp_default = genSubStyleComponent(["Tag", "status"], (token$1) => {
	const tagToken = prepareToken(token$1);
	return [
		genTagStatusStyle(tagToken, "success", "Success"),
		genTagStatusStyle(tagToken, "processing", "Info"),
		genTagStatusStyle(tagToken, "error", "Error"),
		genTagStatusStyle(tagToken, "warning", "Warning")
	];
}, prepareComponentToken$6);

//#endregion
//#region node_modules/antd/es/tag/index.js
var import_classnames$26 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$14 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Tag = /* @__PURE__ */ import_react.forwardRef((tagProps, ref) => {
	const { prefixCls: customizePrefixCls, className, rootClassName, style: style$1, children, icon, color, onClose, bordered = true, visible: deprecatedVisible } = tagProps, props = __rest$14(tagProps, [
		"prefixCls",
		"className",
		"rootClassName",
		"style",
		"children",
		"icon",
		"color",
		"onClose",
		"bordered",
		"visible"
	]);
	const { getPrefixCls, direction, tag: tagContext } = import_react.useContext(ConfigContext);
	const [visible, setVisible] = import_react.useState(true);
	const domProps = omit(props, ["closeIcon", "closable"]);
	devUseWarning("Tag").deprecated(!("visible" in tagProps), "visible", "visible && <Tag />");
	import_react.useEffect(() => {
		if (deprecatedVisible !== void 0) setVisible(deprecatedVisible);
	}, [deprecatedVisible]);
	const isPreset = isPresetColor(color);
	const isStatus = isPresetStatusColor(color);
	const isInternalColor = isPreset || isStatus;
	const tagStyle = Object.assign(Object.assign({ backgroundColor: color && !isInternalColor ? color : void 0 }, tagContext === null || tagContext === void 0 ? void 0 : tagContext.style), style$1);
	const prefixCls = getPrefixCls("tag", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$7(prefixCls);
	const tagClassName = (0, import_classnames$26.default)(prefixCls, tagContext === null || tagContext === void 0 ? void 0 : tagContext.className, {
		[`${prefixCls}-${color}`]: isInternalColor,
		[`${prefixCls}-has-color`]: color && !isInternalColor,
		[`${prefixCls}-hidden`]: !visible,
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-borderless`]: !bordered
	}, className, rootClassName, hashId, cssVarCls);
	const handleCloseClick = (e$2) => {
		e$2.stopPropagation();
		onClose === null || onClose === void 0 || onClose(e$2);
		if (e$2.defaultPrevented) return;
		setVisible(false);
	};
	const [, mergedCloseIcon] = useClosable(pickClosable(tagProps), pickClosable(tagContext), {
		closable: false,
		closeIconRender: (iconNode$1) => {
			const replacement = /* @__PURE__ */ import_react.createElement("span", {
				className: `${prefixCls}-close-icon`,
				onClick: handleCloseClick
			}, iconNode$1);
			return replaceElement(iconNode$1, replacement, (originProps) => ({
				onClick: (e$2) => {
					var _a;
					(_a = originProps === null || originProps === void 0 ? void 0 : originProps.onClick) === null || _a === void 0 || _a.call(originProps, e$2);
					handleCloseClick(e$2);
				},
				className: (0, import_classnames$26.default)(originProps === null || originProps === void 0 ? void 0 : originProps.className, `${prefixCls}-close-icon`)
			}));
		}
	});
	const isNeedWave = typeof props.onClick === "function" || children && children.type === "a";
	const iconNode = icon || null;
	const kids = iconNode ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, iconNode, children && /* @__PURE__ */ import_react.createElement("span", null, children)) : children;
	const tagNode = /* @__PURE__ */ import_react.createElement("span", Object.assign({}, domProps, {
		ref,
		className: tagClassName,
		style: tagStyle
	}), kids, mergedCloseIcon, isPreset && /* @__PURE__ */ import_react.createElement(presetCmp_default, {
		key: "preset",
		prefixCls
	}), isStatus && /* @__PURE__ */ import_react.createElement(statusCmp_default, {
		key: "status",
		prefixCls
	}));
	return wrapCSSVar(isNeedWave ? /* @__PURE__ */ import_react.createElement(wave_default, { component: "Tag" }, tagNode) : tagNode);
});
Tag.displayName = "Tag";
Tag.CheckableTag = CheckableTag_default;
var tag_default = Tag;

//#endregion
//#region node_modules/antd/es/theme/getDesignToken.js
var getDesignToken = (config) => {
	const theme = (config === null || config === void 0 ? void 0 : config.algorithm) ? createTheme(config.algorithm) : theme_default$1;
	const mergedToken = Object.assign(Object.assign({}, seed_default), config === null || config === void 0 ? void 0 : config.token);
	return getComputedToken(mergedToken, { override: config === null || config === void 0 ? void 0 : config.token }, theme, formatToken);
};
var getDesignToken_default = getDesignToken;

//#endregion
//#region node_modules/antd/es/theme/themes/compact/genCompactSizeMapToken.js
function genSizeMapToken(token$1) {
	const { sizeUnit, sizeStep } = token$1;
	const compactSizeStep = sizeStep - 2;
	return {
		sizeXXL: sizeUnit * (compactSizeStep + 10),
		sizeXL: sizeUnit * (compactSizeStep + 6),
		sizeLG: sizeUnit * (compactSizeStep + 2),
		sizeMD: sizeUnit * (compactSizeStep + 2),
		sizeMS: sizeUnit * (compactSizeStep + 1),
		size: sizeUnit * compactSizeStep,
		sizeSM: sizeUnit * compactSizeStep,
		sizeXS: sizeUnit * (compactSizeStep - 1),
		sizeXXS: sizeUnit * (compactSizeStep - 1)
	};
}

//#endregion
//#region node_modules/antd/es/theme/themes/compact/index.js
var derivative$2 = (token$1, mapToken) => {
	const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative(token$1);
	const fontSize = mergedMapToken.fontSizeSM;
	const controlHeight = mergedMapToken.controlHeight - 4;
	return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, mergedMapToken), genSizeMapToken(mapToken !== null && mapToken !== void 0 ? mapToken : token$1)), genFontMapToken_default(fontSize)), { controlHeight }), genControlHeight_default(Object.assign(Object.assign({}, mergedMapToken), { controlHeight })));
};
var compact_default = derivative$2;

//#endregion
//#region node_modules/antd/es/theme/themes/dark/colorAlgorithm.js
const getAlphaColor = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
const getSolidColor = (baseColor, brightness) => {
	return new FastColor(baseColor).lighten(brightness).toHexString();
};

//#endregion
//#region node_modules/antd/es/theme/themes/dark/colors.js
const generateColorPalettes = (baseColor) => {
	const colors = generate(baseColor, { theme: "dark" });
	return {
		1: colors[0],
		2: colors[1],
		3: colors[2],
		4: colors[3],
		5: colors[6],
		6: colors[5],
		7: colors[4],
		8: colors[6],
		9: colors[5],
		10: colors[4]
	};
};
const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
	const colorBgBase = bgBaseColor || "#000";
	const colorTextBase = textBaseColor || "#fff";
	return {
		colorBgBase,
		colorTextBase,
		colorText: getAlphaColor(colorTextBase, .85),
		colorTextSecondary: getAlphaColor(colorTextBase, .65),
		colorTextTertiary: getAlphaColor(colorTextBase, .45),
		colorTextQuaternary: getAlphaColor(colorTextBase, .25),
		colorFill: getAlphaColor(colorTextBase, .18),
		colorFillSecondary: getAlphaColor(colorTextBase, .12),
		colorFillTertiary: getAlphaColor(colorTextBase, .08),
		colorFillQuaternary: getAlphaColor(colorTextBase, .04),
		colorBgSolid: getAlphaColor(colorTextBase, .95),
		colorBgSolidHover: getAlphaColor(colorTextBase, 1),
		colorBgSolidActive: getAlphaColor(colorTextBase, .9),
		colorBgElevated: getSolidColor(colorBgBase, 12),
		colorBgContainer: getSolidColor(colorBgBase, 8),
		colorBgLayout: getSolidColor(colorBgBase, 0),
		colorBgSpotlight: getSolidColor(colorBgBase, 26),
		colorBgBlur: getAlphaColor(colorTextBase, .04),
		colorBorder: getSolidColor(colorBgBase, 26),
		colorBorderSecondary: getSolidColor(colorBgBase, 19)
	};
};

//#endregion
//#region node_modules/antd/es/theme/themes/dark/index.js
var derivative$1 = (token$1, mapToken) => {
	const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
		const colors = generate(token$1[colorKey], { theme: "dark" });
		return Array.from({ length: 10 }, () => 1).reduce((prev$1, _, i) => {
			prev$1[`${colorKey}-${i + 1}`] = colors[i];
			prev$1[`${colorKey}${i + 1}`] = colors[i];
			return prev$1;
		}, {});
	}).reduce((prev$1, cur) => {
		prev$1 = Object.assign(Object.assign({}, prev$1), cur);
		return prev$1;
	}, {});
	const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative(token$1);
	const colorMapToken = genColorMapToken(token$1, {
		generateColorPalettes,
		generateNeutralColorPalettes
	});
	return Object.assign(Object.assign(Object.assign(Object.assign({}, mergedMapToken), colorPalettes), colorMapToken), {
		colorPrimaryBg: colorMapToken.colorPrimaryBorder,
		colorPrimaryBgHover: colorMapToken.colorPrimaryBorderHover
	});
};
var dark_default = derivative$1;

//#endregion
//#region node_modules/antd/es/theme/index.js
/** Get current context Design Token. Will be different if you are using nest theme config. */
function useToken$1() {
	const [theme, token$1, hashId] = useToken();
	return {
		theme,
		token: token$1,
		hashId
	};
}
var theme_default = {
	defaultSeed: defaultConfig.token,
	useToken: useToken$1,
	defaultAlgorithm: derivative,
	darkAlgorithm: dark_default,
	compactAlgorithm: compact_default,
	getDesignToken: getDesignToken_default,
	defaultConfig,
	_internalContext: DesignTokenContext
};

//#endregion
//#region node_modules/antd/es/time-picker/index.js
var __rest$13 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var { TimePicker: InternalTimePicker, RangePicker: InternalRangePicker } = date_picker_default;
var RangePicker = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ import_react.createElement(InternalRangePicker, Object.assign({}, props, {
	picker: "time",
	mode: void 0,
	ref
})));
var TimePicker = /* @__PURE__ */ import_react.forwardRef((_a, ref) => {
	var { addon, renderExtraFooter, variant, bordered } = _a, restProps = __rest$13(_a, [
		"addon",
		"renderExtraFooter",
		"variant",
		"bordered"
	]);
	devUseWarning("TimePicker").deprecated(!addon, "addon", "renderExtraFooter");
	const [mergedVariant] = useVariants_default("timePicker", variant, bordered);
	const internalRenderExtraFooter = import_react.useMemo(() => {
		if (renderExtraFooter) return renderExtraFooter;
		if (addon) return addon;
	}, [addon, renderExtraFooter]);
	return /* @__PURE__ */ import_react.createElement(InternalTimePicker, Object.assign({}, restProps, {
		mode: void 0,
		ref,
		renderExtraFooter: internalRenderExtraFooter,
		variant: mergedVariant
	}));
});
TimePicker.displayName = "TimePicker";
/* istanbul ignore next */
var PurePanel$2 = PurePanel_default(TimePicker, "popupAlign", void 0, "picker");
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
TimePicker.RangePicker = RangePicker;
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
var time_picker_default = TimePicker;

//#endregion
//#region node_modules/antd/es/timeline/style/index.js
var genTimelineStyle = (token$1) => {
	const { componentCls, calc } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		margin: 0,
		padding: 0,
		listStyle: "none",
		[`${componentCls}-item`]: {
			position: "relative",
			margin: 0,
			paddingBottom: token$1.itemPaddingBottom,
			fontSize: token$1.fontSize,
			listStyle: "none",
			"&-tail": {
				position: "absolute",
				insetBlockStart: token$1.itemHeadSize,
				insetInlineStart: calc(calc(token$1.itemHeadSize).sub(token$1.tailWidth)).div(2).equal(),
				height: `calc(100% - ${unit(token$1.itemHeadSize)})`,
				borderInlineStart: `${unit(token$1.tailWidth)} ${token$1.lineType} ${token$1.tailColor}`
			},
			"&-pending": {
				[`${componentCls}-item-head`]: {
					fontSize: token$1.fontSizeSM,
					backgroundColor: "transparent"
				},
				[`${componentCls}-item-tail`]: { display: "none" }
			},
			"&-head": {
				position: "absolute",
				width: token$1.itemHeadSize,
				height: token$1.itemHeadSize,
				backgroundColor: token$1.dotBg,
				border: `${unit(token$1.dotBorderWidth)} ${token$1.lineType} transparent`,
				borderRadius: "50%",
				"&-blue": {
					color: token$1.colorPrimary,
					borderColor: token$1.colorPrimary
				},
				"&-red": {
					color: token$1.colorError,
					borderColor: token$1.colorError
				},
				"&-green": {
					color: token$1.colorSuccess,
					borderColor: token$1.colorSuccess
				},
				"&-gray": {
					color: token$1.colorTextDisabled,
					borderColor: token$1.colorTextDisabled
				}
			},
			"&-head-custom": {
				position: "absolute",
				insetBlockStart: calc(token$1.itemHeadSize).div(2).equal(),
				insetInlineStart: calc(token$1.itemHeadSize).div(2).equal(),
				width: "auto",
				height: "auto",
				marginBlockStart: 0,
				paddingBlock: token$1.customHeadPaddingVertical,
				lineHeight: 1,
				textAlign: "center",
				border: 0,
				borderRadius: 0,
				transform: "translate(-50%, -50%)"
			},
			"&-content": {
				position: "relative",
				insetBlockStart: calc(calc(token$1.fontSize).mul(token$1.lineHeight).sub(token$1.fontSize)).mul(-1).add(token$1.lineWidth).equal(),
				marginInlineStart: calc(token$1.margin).add(token$1.itemHeadSize).equal(),
				marginInlineEnd: 0,
				marginBlockStart: 0,
				marginBlockEnd: 0,
				wordBreak: "break-word"
			},
			"&-last": {
				[`> ${componentCls}-item-tail`]: { display: "none" },
				[`> ${componentCls}-item-content`]: { minHeight: calc(token$1.controlHeightLG).mul(1.2).equal() }
			}
		},
		[`&${componentCls}-alternate,
        &${componentCls}-right,
        &${componentCls}-label`]: { [`${componentCls}-item`]: {
			"&-tail, &-head, &-head-custom": { insetInlineStart: "50%" },
			"&-head": {
				marginInlineStart: calc(token$1.marginXXS).mul(-1).equal(),
				"&-custom": { marginInlineStart: calc(token$1.tailWidth).div(2).equal() }
			},
			"&-left": { [`${componentCls}-item-content`]: {
				insetInlineStart: `calc(50% - ${unit(token$1.marginXXS)})`,
				width: `calc(50% - ${unit(token$1.marginSM)})`,
				textAlign: "start"
			} },
			"&-right": { [`${componentCls}-item-content`]: {
				width: `calc(50% - ${unit(token$1.marginSM)})`,
				margin: 0,
				textAlign: "end"
			} }
		} },
		[`&${componentCls}-right`]: { [`${componentCls}-item-right`]: {
			[`${componentCls}-item-tail,
            ${componentCls}-item-head,
            ${componentCls}-item-head-custom`]: { insetInlineStart: `calc(100% - ${unit(calc(calc(token$1.itemHeadSize).add(token$1.tailWidth)).div(2).equal())})` },
			[`${componentCls}-item-content`]: { width: `calc(100% - ${unit(calc(token$1.itemHeadSize).add(token$1.marginXS).equal())})` }
		} },
		[`&${componentCls}-pending
        ${componentCls}-item-last
        ${componentCls}-item-tail`]: {
			display: "block",
			height: `calc(100% - ${unit(token$1.margin)})`,
			borderInlineStart: `${unit(token$1.tailWidth)} dotted ${token$1.tailColor}`
		},
		[`&${componentCls}-reverse
        ${componentCls}-item-last
        ${componentCls}-item-tail`]: { display: "none" },
		[`&${componentCls}-reverse ${componentCls}-item-pending`]: {
			[`${componentCls}-item-tail`]: {
				insetBlockStart: token$1.margin,
				display: "block",
				height: `calc(100% - ${unit(token$1.margin)})`,
				borderInlineStart: `${unit(token$1.tailWidth)} dotted ${token$1.tailColor}`
			},
			[`${componentCls}-item-content`]: { minHeight: calc(token$1.controlHeightLG).mul(1.2).equal() }
		},
		[`&${componentCls}-label`]: {
			[`${componentCls}-item-label`]: {
				position: "absolute",
				insetBlockStart: calc(calc(token$1.fontSize).mul(token$1.lineHeight).sub(token$1.fontSize)).mul(-1).add(token$1.tailWidth).equal(),
				width: `calc(50% - ${unit(token$1.marginSM)})`,
				textAlign: "end"
			},
			[`${componentCls}-item-right`]: { [`${componentCls}-item-label`]: {
				insetInlineStart: `calc(50% + ${unit(token$1.marginSM)})`,
				width: `calc(50% - ${unit(token$1.marginSM)})`,
				textAlign: "start"
			} }
		},
		"&-rtl": {
			direction: "rtl",
			[`${componentCls}-item-head-custom`]: { transform: `translate(50%, -50%)` }
		}
	}) };
};
const prepareComponentToken$5 = (token$1) => ({
	tailColor: token$1.colorSplit,
	tailWidth: token$1.lineWidthBold,
	dotBorderWidth: token$1.wireframe ? token$1.lineWidthBold : token$1.lineWidth * 3,
	dotBg: token$1.colorBgContainer,
	itemPaddingBottom: token$1.padding * 1.25
});
var style_default$6 = genStyleHooks("Timeline", (token$1) => {
	const timeLineToken = merge(token$1, {
		itemHeadSize: 10,
		customHeadPaddingVertical: token$1.paddingXXS,
		paddingInlineEnd: 2
	});
	return genTimelineStyle(timeLineToken);
}, prepareComponentToken$5);

//#endregion
//#region node_modules/antd/es/timeline/TimelineItem.js
var import_classnames$25 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$12 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var TimelineItem = (_a) => {
	var { prefixCls: customizePrefixCls, className, color = "blue", dot, pending = false, position: position$2, label, children } = _a, restProps = __rest$12(_a, [
		"prefixCls",
		"className",
		"color",
		"dot",
		"pending",
		"position",
		"label",
		"children"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("timeline", customizePrefixCls);
	const itemClassName = (0, import_classnames$25.default)(`${prefixCls}-item`, { [`${prefixCls}-item-pending`]: pending }, className);
	const customColor = /blue|red|green|gray/.test(color || "") ? void 0 : color;
	const dotClassName = (0, import_classnames$25.default)(`${prefixCls}-item-head`, {
		[`${prefixCls}-item-head-custom`]: !!dot,
		[`${prefixCls}-item-head-${color}`]: !customColor
	});
	return /* @__PURE__ */ import_react.createElement("li", Object.assign({}, restProps, { className: itemClassName }), label && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-label` }, label), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-tail` }), /* @__PURE__ */ import_react.createElement("div", {
		className: dotClassName,
		style: {
			borderColor: customColor,
			color: customColor
		}
	}, dot), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-item-content` }, children));
};
var TimelineItem_default = TimelineItem;

//#endregion
//#region node_modules/antd/es/timeline/TimelineItemList.js
var import_classnames$24 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$11 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var TimelineItemList = (_a) => {
	var { prefixCls, className, pending = false, children, items, rootClassName, reverse = false, direction, hashId, pendingDot, mode = "" } = _a, restProps = __rest$11(_a, [
		"prefixCls",
		"className",
		"pending",
		"children",
		"items",
		"rootClassName",
		"reverse",
		"direction",
		"hashId",
		"pendingDot",
		"mode"
	]);
	const getPositionCls = (position$2, idx) => {
		if (mode === "alternate") {
			if (position$2 === "right") return `${prefixCls}-item-right`;
			if (position$2 === "left") return `${prefixCls}-item-left`;
			return idx % 2 === 0 ? `${prefixCls}-item-left` : `${prefixCls}-item-right`;
		}
		if (mode === "left") return `${prefixCls}-item-left`;
		if (mode === "right") return `${prefixCls}-item-right`;
		if (position$2 === "right") return `${prefixCls}-item-right`;
		return "";
	};
	const mergedItems = _toConsumableArray(items || []);
	const pendingNode = typeof pending === "boolean" ? null : pending;
	if (pending) mergedItems.push({
		pending: !!pending,
		dot: pendingDot || /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null),
		children: pendingNode
	});
	if (reverse) mergedItems.reverse();
	const itemsCount = mergedItems.length;
	const lastCls = `${prefixCls}-item-last`;
	const itemsList = mergedItems.filter((item) => !!item).map((item, idx) => {
		var _a$1;
		const pendingClass = idx === itemsCount - 2 ? lastCls : "";
		const readyClass = idx === itemsCount - 1 ? lastCls : "";
		const { className: itemClassName } = item, itemProps = __rest$11(item, ["className"]);
		return /* @__PURE__ */ import_react.createElement(TimelineItem_default, Object.assign({}, itemProps, {
			className: (0, import_classnames$24.default)([
				itemClassName,
				!reverse && !!pending ? pendingClass : readyClass,
				getPositionCls((_a$1 = item === null || item === void 0 ? void 0 : item.position) !== null && _a$1 !== void 0 ? _a$1 : "", idx)
			]),
			key: (item === null || item === void 0 ? void 0 : item.key) || idx
		}));
	});
	const hasLabelItem = mergedItems.some((item) => !!(item === null || item === void 0 ? void 0 : item.label));
	const classString = (0, import_classnames$24.default)(prefixCls, {
		[`${prefixCls}-pending`]: !!pending,
		[`${prefixCls}-reverse`]: !!reverse,
		[`${prefixCls}-${mode}`]: !!mode && !hasLabelItem,
		[`${prefixCls}-label`]: hasLabelItem,
		[`${prefixCls}-rtl`]: direction === "rtl"
	}, className, rootClassName, hashId);
	return /* @__PURE__ */ import_react.createElement("ol", Object.assign({}, restProps, { className: classString }), itemsList);
};
var TimelineItemList_default = TimelineItemList;

//#endregion
//#region node_modules/antd/es/timeline/useItems.js
function useItems$1(items, children) {
	if (items && Array.isArray(items)) return items;
	return toArray(children).map((ele) => {
		var _a, _b;
		return Object.assign({ children: (_b = (_a = ele === null || ele === void 0 ? void 0 : ele.props) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : "" }, ele.props);
	});
}
var useItems_default$1 = useItems$1;

//#endregion
//#region node_modules/antd/es/timeline/Timeline.js
var import_classnames$23 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$10 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Timeline = (props) => {
	const { getPrefixCls, direction, timeline } = import_react.useContext(ConfigContext);
	const { prefixCls: customizePrefixCls, children, items, className, style: style$1 } = props, restProps = __rest$10(props, [
		"prefixCls",
		"children",
		"items",
		"className",
		"style"
	]);
	const prefixCls = getPrefixCls("timeline", customizePrefixCls);
	devUseWarning("Timeline").deprecated(!children, "Timeline.Item", "items");
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$6(prefixCls, rootCls);
	const mergedItems = useItems_default$1(items, children);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(TimelineItemList_default, Object.assign({}, restProps, {
		className: (0, import_classnames$23.default)(timeline === null || timeline === void 0 ? void 0 : timeline.className, className, cssVarCls, rootCls),
		style: Object.assign(Object.assign({}, timeline === null || timeline === void 0 ? void 0 : timeline.style), style$1),
		prefixCls,
		direction,
		items: mergedItems,
		hashId
	})));
};
Timeline.Item = TimelineItem_default;
Timeline.displayName = "Timeline";
var Timeline_default = Timeline;

//#endregion
//#region node_modules/antd/es/timeline/index.js
var timeline_default = Timeline_default;

//#endregion
//#region node_modules/@rc-component/tour/es/hooks/useClosable.js
function isConfigObj(closable) {
	return closable !== null && _typeof(closable) === "object";
}
/**
* Convert `closable` to ClosableConfig.
* When `preset` is true, will auto fill ClosableConfig with default value.
*/
function getClosableConfig(closable, closeIcon, preset) {
	if (closable === false || closeIcon === false && (!isConfigObj(closable) || !closable.closeIcon)) return null;
	var mergedCloseIcon = typeof closeIcon !== "boolean" ? closeIcon : void 0;
	if (isConfigObj(closable)) {
		var _closable$closeIcon;
		return _objectSpread2(_objectSpread2({}, closable), {}, { closeIcon: (_closable$closeIcon = closable.closeIcon) !== null && _closable$closeIcon !== void 0 ? _closable$closeIcon : mergedCloseIcon });
	}
	return preset || closable || closeIcon ? { closeIcon: mergedCloseIcon } : "empty";
}
function useClosable$1(stepClosable, stepCloseIcon, closable, closeIcon) {
	return import_react.useMemo(function() {
		var stepClosableConfig = getClosableConfig(stepClosable, stepCloseIcon, false);
		var rootClosableConfig = getClosableConfig(closable, closeIcon, true);
		if (stepClosableConfig !== "empty") return stepClosableConfig;
		return rootClosableConfig;
	}, [
		closable,
		closeIcon,
		stepClosable,
		stepCloseIcon
	]);
}

//#endregion
//#region node_modules/@rc-component/tour/es/util.js
function isInViewPort(element) {
	var viewWidth = window.innerWidth || document.documentElement.clientWidth;
	var viewHeight = window.innerHeight || document.documentElement.clientHeight;
	var _element$getBoundingC = element.getBoundingClientRect(), top = _element$getBoundingC.top, right = _element$getBoundingC.right, bottom = _element$getBoundingC.bottom, left = _element$getBoundingC.left;
	return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}
function getPlacement(targetElement, placement, stepPlacement) {
	var _ref;
	return (_ref = stepPlacement !== null && stepPlacement !== void 0 ? stepPlacement : placement) !== null && _ref !== void 0 ? _ref : targetElement === null ? "center" : "bottom";
}

//#endregion
//#region node_modules/@rc-component/tour/es/hooks/useTarget.js
function isValidNumber(val) {
	return typeof val === "number" && !Number.isNaN(val);
}
function useTarget(target, open$2, gap, scrollIntoViewOptions) {
	var _useState = (0, import_react.useState)(void 0), _useState2 = _slicedToArray(_useState, 2), targetElement = _useState2[0], setTargetElement = _useState2[1];
	useLayoutEffect_default(function() {
		var nextElement = typeof target === "function" ? target() : target;
		setTargetElement(nextElement || null);
	});
	var _useState3 = (0, import_react.useState)(null), _useState4 = _slicedToArray(_useState3, 2), posInfo = _useState4[0], setPosInfo = _useState4[1];
	var updatePos = useEvent(function() {
		if (targetElement) {
			if (!isInViewPort(targetElement) && open$2) targetElement.scrollIntoView(scrollIntoViewOptions);
			var _targetElement$getBou = targetElement.getBoundingClientRect(), left = _targetElement$getBou.left, top = _targetElement$getBou.top, width = _targetElement$getBou.width, height = _targetElement$getBou.height;
			var nextPosInfo = {
				left,
				top,
				width,
				height,
				radius: 0
			};
			setPosInfo(function(origin) {
				if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) return nextPosInfo;
				return origin;
			});
		} else setPosInfo(null);
	});
	var getGapOffset = function getGapOffset$1(index$2) {
		var _ref;
		return (_ref = Array.isArray(gap === null || gap === void 0 ? void 0 : gap.offset) ? gap === null || gap === void 0 ? void 0 : gap.offset[index$2] : gap === null || gap === void 0 ? void 0 : gap.offset) !== null && _ref !== void 0 ? _ref : 6;
	};
	useLayoutEffect_default(function() {
		updatePos();
		window.addEventListener("resize", updatePos);
		return function() {
			window.removeEventListener("resize", updatePos);
		};
	}, [
		targetElement,
		open$2,
		updatePos
	]);
	return [(0, import_react.useMemo)(function() {
		if (!posInfo) return posInfo;
		var gapOffsetX = getGapOffset(0);
		var gapOffsetY = getGapOffset(1);
		var gapRadius = isValidNumber(gap === null || gap === void 0 ? void 0 : gap.radius) ? gap === null || gap === void 0 ? void 0 : gap.radius : 2;
		return {
			left: posInfo.left - gapOffsetX,
			top: posInfo.top - gapOffsetY,
			width: posInfo.width + gapOffsetX * 2,
			height: posInfo.height + gapOffsetY * 2,
			radius: gapRadius
		};
	}, [posInfo, gap]), targetElement];
}

//#endregion
//#region node_modules/@rc-component/tour/es/Mask.js
var import_classnames$22 = /* @__PURE__ */ __toESM(require_classnames());
var COVER_PROPS = {
	fill: "transparent",
	pointerEvents: "auto"
};
var Mask = function Mask$3(props) {
	var prefixCls = props.prefixCls, rootClassName = props.rootClassName, pos = props.pos, showMask = props.showMask, _props$style = props.style, style$1 = _props$style === void 0 ? {} : _props$style, _props$fill = props.fill, fill = _props$fill === void 0 ? "rgba(0,0,0,0.5)" : _props$fill, open$2 = props.open, animated = props.animated, zIndex = props.zIndex, disabledInteraction = props.disabledInteraction;
	var id = useId_default();
	var maskId = "".concat(prefixCls, "-mask-").concat(id);
	var mergedAnimated = _typeof(animated) === "object" ? animated === null || animated === void 0 ? void 0 : animated.placeholder : animated;
	var maskRectSize = typeof navigator !== "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? {
		width: "100%",
		height: "100%"
	} : {
		width: "100vw",
		height: "100vh"
	};
	return /* @__PURE__ */ import_react.createElement(es_default$6, {
		open: open$2,
		autoLock: true
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$22.default)("".concat(prefixCls, "-mask"), rootClassName),
		style: _objectSpread2({
			position: "fixed",
			left: 0,
			right: 0,
			top: 0,
			bottom: 0,
			zIndex,
			pointerEvents: pos && !disabledInteraction ? "none" : "auto"
		}, style$1)
	}, showMask ? /* @__PURE__ */ import_react.createElement("svg", { style: {
		width: "100%",
		height: "100%"
	} }, /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("mask", { id: maskId }, /* @__PURE__ */ import_react.createElement("rect", _extends({
		x: "0",
		y: "0"
	}, maskRectSize, { fill: "white" })), pos && /* @__PURE__ */ import_react.createElement("rect", {
		x: pos.left,
		y: pos.top,
		rx: pos.radius,
		width: pos.width,
		height: pos.height,
		fill: "black",
		className: mergedAnimated ? "".concat(prefixCls, "-placeholder-animated") : ""
	}))), /* @__PURE__ */ import_react.createElement("rect", {
		x: "0",
		y: "0",
		width: "100%",
		height: "100%",
		fill,
		mask: "url(#".concat(maskId, ")")
	}), pos && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("rect", _extends({}, COVER_PROPS, {
		x: "0",
		y: "0",
		width: "100%",
		height: pos.top
	})), /* @__PURE__ */ import_react.createElement("rect", _extends({}, COVER_PROPS, {
		x: "0",
		y: "0",
		width: pos.left,
		height: "100%"
	})), /* @__PURE__ */ import_react.createElement("rect", _extends({}, COVER_PROPS, {
		x: "0",
		y: pos.top + pos.height,
		width: "100%",
		height: "calc(100vh - ".concat(pos.top + pos.height, "px)")
	})), /* @__PURE__ */ import_react.createElement("rect", _extends({}, COVER_PROPS, {
		x: pos.left + pos.width,
		y: "0",
		width: "calc(100vw - ".concat(pos.left + pos.width, "px)"),
		height: "100%"
	})))) : null));
};
var Mask_default = Mask;

//#endregion
//#region node_modules/@rc-component/tour/es/placements.js
var targetOffset = [0, 0];
var basePlacements = {
	left: {
		points: ["cr", "cl"],
		offset: [-8, 0]
	},
	right: {
		points: ["cl", "cr"],
		offset: [8, 0]
	},
	top: {
		points: ["bc", "tc"],
		offset: [0, -8]
	},
	bottom: {
		points: ["tc", "bc"],
		offset: [0, 8]
	},
	topLeft: {
		points: ["bl", "tl"],
		offset: [0, -8]
	},
	leftTop: {
		points: ["tr", "tl"],
		offset: [-8, 0]
	},
	topRight: {
		points: ["br", "tr"],
		offset: [0, -8]
	},
	rightTop: {
		points: ["tl", "tr"],
		offset: [8, 0]
	},
	bottomRight: {
		points: ["tr", "br"],
		offset: [0, 8]
	},
	rightBottom: {
		points: ["bl", "br"],
		offset: [8, 0]
	},
	bottomLeft: {
		points: ["tl", "bl"],
		offset: [0, 8]
	},
	leftBottom: {
		points: ["br", "bl"],
		offset: [-8, 0]
	}
};
function getPlacements$1() {
	var arrowPointAtCenter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
	var placements$4 = {};
	Object.keys(basePlacements).forEach(function(key) {
		placements$4[key] = _objectSpread2(_objectSpread2({}, basePlacements[key]), {}, {
			autoArrow: arrowPointAtCenter,
			targetOffset
		});
	});
	return placements$4;
}
var placements = getPlacements$1();

//#endregion
//#region node_modules/@rc-component/tour/es/TourStep/DefaultPanel.js
var import_classnames$21 = /* @__PURE__ */ __toESM(require_classnames());
function DefaultPanel(props) {
	var _closable$closeIcon;
	var prefixCls = props.prefixCls, current = props.current, total = props.total, title = props.title, description = props.description, onClose = props.onClose, onPrev = props.onPrev, onNext = props.onNext, onFinish = props.onFinish, className = props.className, closable = props.closable;
	var ariaProps = pickAttrs(closable || {}, true);
	var closeIcon = (_closable$closeIcon = closable === null || closable === void 0 ? void 0 : closable.closeIcon) !== null && _closable$closeIcon !== void 0 ? _closable$closeIcon : /* @__PURE__ */ import_react.createElement("span", { className: "".concat(prefixCls, "-close-x") }, "");
	var mergedClosable = !!closable;
	return /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$21.default)("".concat(prefixCls, "-content"), className) }, /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-inner") }, mergedClosable && /* @__PURE__ */ import_react.createElement("button", _extends({
		type: "button",
		onClick: onClose,
		"aria-label": "Close"
	}, ariaProps, { className: "".concat(prefixCls, "-close") }), closeIcon), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-header") }, /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-title") }, title)), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-description") }, description), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-footer") }, /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-sliders") }, total > 1 ? _toConsumableArray(Array.from({ length: total }).keys()).map(function(item, index$2) {
		return /* @__PURE__ */ import_react.createElement("span", {
			key: item,
			className: index$2 === current ? "active" : ""
		});
	}) : null), /* @__PURE__ */ import_react.createElement("div", { className: "".concat(prefixCls, "-buttons") }, current !== 0 ? /* @__PURE__ */ import_react.createElement("button", {
		className: "".concat(prefixCls, "-prev-btn"),
		onClick: onPrev
	}, "Prev") : null, current === total - 1 ? /* @__PURE__ */ import_react.createElement("button", {
		className: "".concat(prefixCls, "-finish-btn"),
		onClick: onFinish
	}, "Finish") : /* @__PURE__ */ import_react.createElement("button", {
		className: "".concat(prefixCls, "-next-btn"),
		onClick: onNext
	}, "Next")))));
}

//#endregion
//#region node_modules/@rc-component/tour/es/TourStep/index.js
var TourStep = function TourStep$1(props) {
	var current = props.current, renderPanel = props.renderPanel;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, typeof renderPanel === "function" ? renderPanel(props, current) : /* @__PURE__ */ import_react.createElement(DefaultPanel, props));
};
var TourStep_default = TourStep;

//#endregion
//#region node_modules/@rc-component/tour/es/Tour.js
var import_classnames$20 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded$3 = [
	"prefixCls",
	"steps",
	"defaultCurrent",
	"current",
	"onChange",
	"onClose",
	"onFinish",
	"open",
	"mask",
	"arrow",
	"rootClassName",
	"placement",
	"renderPanel",
	"gap",
	"animated",
	"scrollIntoViewOptions",
	"zIndex",
	"closeIcon",
	"closable",
	"builtinPlacements",
	"disabledInteraction"
];
var CENTER_PLACEHOLDER = {
	left: "50%",
	top: "50%",
	width: 1,
	height: 1
};
var defaultScrollIntoViewOptions = {
	block: "center",
	inline: "center"
};
var Tour$1 = function Tour$2(props) {
	var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tour" : _props$prefixCls, _props$steps = props.steps, steps = _props$steps === void 0 ? [] : _props$steps, defaultCurrent = props.defaultCurrent, current = props.current, onChange = props.onChange, onClose = props.onClose, _onFinish = props.onFinish, open$2 = props.open, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? true : _props$arrow, rootClassName = props.rootClassName, placement = props.placement, renderPanel = props.renderPanel, gap = props.gap, animated = props.animated, _props$scrollIntoView = props.scrollIntoViewOptions, scrollIntoViewOptions = _props$scrollIntoView === void 0 ? defaultScrollIntoViewOptions : _props$scrollIntoView, _props$zIndex = props.zIndex, zIndex = _props$zIndex === void 0 ? 1001 : _props$zIndex, closeIcon = props.closeIcon, closable = props.closable, builtinPlacements = props.builtinPlacements, disabledInteraction = props.disabledInteraction, restProps = _objectWithoutProperties(props, _excluded$3);
	var triggerRef = import_react.useRef();
	var _useMergedState = useMergedState(0, {
		value: current,
		defaultValue: defaultCurrent
	}), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedCurrent = _useMergedState2[0], setMergedCurrent = _useMergedState2[1];
	var _useMergedState3 = useMergedState(void 0, {
		value: open$2,
		postState: function postState(origin) {
			return mergedCurrent < 0 || mergedCurrent >= steps.length ? false : origin !== null && origin !== void 0 ? origin : true;
		}
	}), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedOpen = _useMergedState4[0], setMergedOpen = _useMergedState4[1];
	var _React$useState = import_react.useState(mergedOpen), _React$useState2 = _slicedToArray(_React$useState, 2), hasOpened = _React$useState2[0], setHasOpened = _React$useState2[1];
	var openRef = import_react.useRef(mergedOpen);
	useLayoutEffect_default(function() {
		if (mergedOpen) {
			if (!openRef.current) setMergedCurrent(0);
			setHasOpened(true);
		}
		openRef.current = mergedOpen;
	}, [mergedOpen]);
	var _ref = steps[mergedCurrent] || {}, target = _ref.target, stepPlacement = _ref.placement, stepStyle = _ref.style, stepArrow = _ref.arrow, stepClassName = _ref.className, stepMask = _ref.mask, _ref$scrollIntoViewOp = _ref.scrollIntoViewOptions, stepScrollIntoViewOptions = _ref$scrollIntoViewOp === void 0 ? defaultScrollIntoViewOptions : _ref$scrollIntoViewOp, stepCloseIcon = _ref.closeIcon, stepClosable = _ref.closable;
	var mergedClosable = useClosable$1(stepClosable, stepCloseIcon, closable, closeIcon);
	var mergedMask = mergedOpen && (stepMask !== null && stepMask !== void 0 ? stepMask : mask);
	var _useTarget = useTarget(target, open$2, gap, stepScrollIntoViewOptions !== null && stepScrollIntoViewOptions !== void 0 ? stepScrollIntoViewOptions : scrollIntoViewOptions), _useTarget2 = _slicedToArray(_useTarget, 2), posInfo = _useTarget2[0], targetElement = _useTarget2[1];
	var mergedPlacement = getPlacement(targetElement, placement, stepPlacement);
	var mergedArrow = targetElement ? typeof stepArrow === "undefined" ? arrow : stepArrow : false;
	var arrowPointAtCenter = _typeof(mergedArrow) === "object" ? mergedArrow.pointAtCenter : false;
	useLayoutEffect_default(function() {
		var _triggerRef$current;
		(_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 || _triggerRef$current.forceAlign();
	}, [arrowPointAtCenter, mergedCurrent]);
	var onInternalChange = function onInternalChange$1(nextCurrent) {
		setMergedCurrent(nextCurrent);
		onChange === null || onChange === void 0 || onChange(nextCurrent);
	};
	var mergedBuiltinPlacements$1 = (0, import_react.useMemo)(function() {
		if (builtinPlacements) return typeof builtinPlacements === "function" ? builtinPlacements({ arrowPointAtCenter }) : builtinPlacements;
		return getPlacements$1(arrowPointAtCenter);
	}, [builtinPlacements, arrowPointAtCenter]);
	if (targetElement === void 0 || !hasOpened) return null;
	var handleClose = function handleClose$1() {
		setMergedOpen(false);
		onClose === null || onClose === void 0 || onClose(mergedCurrent);
	};
	var getPopupElement = function getPopupElement$1() {
		return /* @__PURE__ */ import_react.createElement(TourStep_default, _extends({
			arrow: mergedArrow,
			key: "content",
			prefixCls,
			total: steps.length,
			renderPanel,
			onPrev: function onPrev() {
				onInternalChange(mergedCurrent - 1);
			},
			onNext: function onNext() {
				onInternalChange(mergedCurrent + 1);
			},
			onClose: handleClose,
			current: mergedCurrent,
			onFinish: function onFinish() {
				handleClose();
				_onFinish === null || _onFinish === void 0 || _onFinish();
			}
		}, steps[mergedCurrent], { closable: mergedClosable }));
	};
	var mergedShowMask = typeof mergedMask === "boolean" ? mergedMask : !!mergedMask;
	var mergedMaskStyle = typeof mergedMask === "boolean" ? void 0 : mergedMask;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Mask_default, {
		zIndex,
		prefixCls,
		pos: posInfo,
		showMask: mergedShowMask,
		style: mergedMaskStyle === null || mergedMaskStyle === void 0 ? void 0 : mergedMaskStyle.style,
		fill: mergedMaskStyle === null || mergedMaskStyle === void 0 ? void 0 : mergedMaskStyle.color,
		open: mergedOpen,
		animated,
		rootClassName,
		disabledInteraction
	}), /* @__PURE__ */ import_react.createElement(es_default$7, _extends({}, restProps, {
		builtinPlacements: mergedBuiltinPlacements$1,
		ref: triggerRef,
		popupStyle: stepStyle,
		popupPlacement: mergedPlacement,
		popupVisible: mergedOpen,
		popupClassName: (0, import_classnames$20.default)(rootClassName, stepClassName),
		prefixCls,
		popup: getPopupElement,
		forceRender: false,
		destroyPopupOnHide: true,
		zIndex,
		getTriggerDOMNode: function getTriggerDOMNode(node$1) {
			return node$1 || targetElement || document.body;
		},
		arrow: !!mergedArrow
	}), /* @__PURE__ */ import_react.createElement(es_default$6, {
		open: mergedOpen,
		autoLock: true
	}, /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$20.default)(rootClassName, "".concat(prefixCls, "-target-placeholder")),
		style: _objectSpread2(_objectSpread2({}, posInfo || CENTER_PLACEHOLDER), {}, {
			position: "fixed",
			pointerEvents: "none"
		})
	}))));
};
var Tour_default = Tour$1;

//#endregion
//#region node_modules/@rc-component/tour/es/index.js
var es_default$5 = Tour_default;

//#endregion
//#region node_modules/antd/es/tour/panelRender.js
var import_classnames$19 = /* @__PURE__ */ __toESM(require_classnames());
function isValidNode(node$1) {
	return node$1 !== void 0 && node$1 !== null;
}
var TourPanel = (props) => {
	var _a, _b;
	const { stepProps, current, type: type$2, indicatorsRender, actionsRender } = props;
	const { prefixCls, total = 1, title, onClose, onPrev, onNext, onFinish, cover, description, nextButtonProps, prevButtonProps, type: stepType, closable } = stepProps;
	const mergedType = stepType !== null && stepType !== void 0 ? stepType : type$2;
	const ariaProps = pickAttrs(closable !== null && closable !== void 0 ? closable : {}, true);
	const [contextLocaleGlobal] = useLocale_default("global", en_US_default.global);
	const [contextLocaleTour] = useLocale_default("Tour", en_US_default.Tour);
	const mergedCloseIcon = /* @__PURE__ */ import_react.createElement("button", Object.assign({
		type: "button",
		onClick: onClose,
		className: `${prefixCls}-close`,
		"aria-label": contextLocaleGlobal === null || contextLocaleGlobal === void 0 ? void 0 : contextLocaleGlobal.close
	}, ariaProps), (closable === null || closable === void 0 ? void 0 : closable.closeIcon) || /* @__PURE__ */ import_react.createElement(CloseOutlined_default, { className: `${prefixCls}-close-icon` }));
	const isLastStep = current === total - 1;
	const prevBtnClick = () => {
		var _a$1;
		onPrev === null || onPrev === void 0 || onPrev();
		(_a$1 = prevButtonProps === null || prevButtonProps === void 0 ? void 0 : prevButtonProps.onClick) === null || _a$1 === void 0 || _a$1.call(prevButtonProps);
	};
	const nextBtnClick = () => {
		var _a$1;
		if (isLastStep) onFinish === null || onFinish === void 0 || onFinish();
		else onNext === null || onNext === void 0 || onNext();
		(_a$1 = nextButtonProps === null || nextButtonProps === void 0 ? void 0 : nextButtonProps.onClick) === null || _a$1 === void 0 || _a$1.call(nextButtonProps);
	};
	const headerNode = isValidNode(title) ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-header` }, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-title` }, title)) : null;
	const descriptionNode = isValidNode(description) ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-description` }, description) : null;
	const coverNode = isValidNode(cover) ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-cover` }, cover) : null;
	let mergedIndicatorNode;
	if (indicatorsRender) mergedIndicatorNode = indicatorsRender(current, total);
	else mergedIndicatorNode = _toConsumableArray(Array.from({ length: total }).keys()).map((stepItem, index$2) => /* @__PURE__ */ import_react.createElement("span", {
		key: stepItem,
		className: (0, import_classnames$19.default)(index$2 === current && `${prefixCls}-indicator-active`, `${prefixCls}-indicator`)
	}));
	const mainBtnType = mergedType === "primary" ? "default" : "primary";
	const secondaryBtnProps = {
		type: "default",
		ghost: mergedType === "primary"
	};
	const defaultActionsNode = /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, current !== 0 ? /* @__PURE__ */ import_react.createElement(button_default, Object.assign({ size: "small" }, secondaryBtnProps, prevButtonProps, {
		onClick: prevBtnClick,
		className: (0, import_classnames$19.default)(`${prefixCls}-prev-btn`, prevButtonProps === null || prevButtonProps === void 0 ? void 0 : prevButtonProps.className)
	}), (_a = prevButtonProps === null || prevButtonProps === void 0 ? void 0 : prevButtonProps.children) !== null && _a !== void 0 ? _a : contextLocaleTour === null || contextLocaleTour === void 0 ? void 0 : contextLocaleTour.Previous) : null, /* @__PURE__ */ import_react.createElement(button_default, Object.assign({
		size: "small",
		type: mainBtnType
	}, nextButtonProps, {
		onClick: nextBtnClick,
		className: (0, import_classnames$19.default)(`${prefixCls}-next-btn`, nextButtonProps === null || nextButtonProps === void 0 ? void 0 : nextButtonProps.className)
	}), (_b = nextButtonProps === null || nextButtonProps === void 0 ? void 0 : nextButtonProps.children) !== null && _b !== void 0 ? _b : isLastStep ? contextLocaleTour === null || contextLocaleTour === void 0 ? void 0 : contextLocaleTour.Finish : contextLocaleTour === null || contextLocaleTour === void 0 ? void 0 : contextLocaleTour.Next));
	return /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-content` }, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-inner` }, closable && mergedCloseIcon, coverNode, headerNode, descriptionNode, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-footer` }, total > 1 && /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-indicators` }, mergedIndicatorNode), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-buttons` }, actionsRender ? actionsRender(defaultActionsNode, {
		current,
		total
	}) : defaultActionsNode))));
};
var panelRender_default = TourPanel;

//#endregion
//#region node_modules/antd/es/tour/style/index.js
var genBaseStyle$2 = (token$1) => {
	const { componentCls, padding, paddingXS, borderRadius, borderRadiusXS, colorPrimary, colorFill, indicatorHeight, indicatorWidth, boxShadowTertiary, zIndexPopup, colorBgElevated, fontWeightStrong, marginXS, colorTextLightSolid, tourBorderRadius, colorWhite, primaryNextBtnHoverBg, closeBtnSize, motionDurationSlow, antCls, primaryPrevBtnBg } = token$1;
	return [{
		[componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
			position: "absolute",
			zIndex: zIndexPopup,
			maxWidth: "fit-content",
			visibility: "visible",
			width: 520,
			"--antd-arrow-background-color": colorBgElevated,
			"&-pure": {
				maxWidth: "100%",
				position: "relative"
			},
			[`&${componentCls}-hidden`]: { display: "none" },
			[`${componentCls}-content`]: { position: "relative" },
			[`${componentCls}-inner`]: {
				textAlign: "start",
				textDecoration: "none",
				borderRadius: tourBorderRadius,
				boxShadow: boxShadowTertiary,
				position: "relative",
				backgroundColor: colorBgElevated,
				border: "none",
				backgroundClip: "padding-box",
				[`${componentCls}-close`]: Object.assign({
					position: "absolute",
					top: padding,
					insetInlineEnd: padding,
					color: token$1.colorIcon,
					background: "none",
					border: "none",
					width: closeBtnSize,
					height: closeBtnSize,
					borderRadius: token$1.borderRadiusSM,
					transition: `background-color ${token$1.motionDurationMid}, color ${token$1.motionDurationMid}`,
					display: "flex",
					alignItems: "center",
					justifyContent: "center",
					cursor: "pointer",
					"&:hover": {
						color: token$1.colorIconHover,
						backgroundColor: token$1.colorBgTextHover
					},
					"&:active": { backgroundColor: token$1.colorBgTextActive }
				}, genFocusStyle(token$1)),
				[`${componentCls}-cover`]: {
					textAlign: "center",
					padding: `${unit(token$1.calc(padding).add(closeBtnSize).add(paddingXS).equal())} ${unit(padding)} 0`,
					img: { width: "100%" }
				},
				[`${componentCls}-header`]: {
					padding: `${unit(padding)} ${unit(padding)} ${unit(paddingXS)}`,
					width: `calc(100% - ${unit(closeBtnSize)})`,
					wordBreak: "break-word",
					[`${componentCls}-title`]: { fontWeight: fontWeightStrong }
				},
				[`${componentCls}-description`]: {
					padding: `0 ${unit(padding)}`,
					wordWrap: "break-word"
				},
				[`${componentCls}-footer`]: {
					padding: `${unit(paddingXS)} ${unit(padding)} ${unit(padding)}`,
					textAlign: "end",
					borderRadius: `0 0 ${unit(borderRadiusXS)} ${unit(borderRadiusXS)}`,
					display: "flex",
					[`${componentCls}-indicators`]: {
						display: "inline-block",
						[`${componentCls}-indicator`]: {
							width: indicatorWidth,
							height: indicatorHeight,
							display: "inline-block",
							borderRadius: "50%",
							background: colorFill,
							"&:not(:last-child)": { marginInlineEnd: indicatorHeight },
							"&-active": { background: colorPrimary }
						}
					},
					[`${componentCls}-buttons`]: {
						marginInlineStart: "auto",
						[`${antCls}-btn`]: { marginInlineStart: marginXS }
					}
				}
			},
			[`${componentCls}-primary, &${componentCls}-primary`]: {
				"--antd-arrow-background-color": colorPrimary,
				[`${componentCls}-inner`]: {
					color: colorTextLightSolid,
					textAlign: "start",
					textDecoration: "none",
					backgroundColor: colorPrimary,
					borderRadius,
					boxShadow: boxShadowTertiary,
					[`${componentCls}-close`]: { color: colorTextLightSolid },
					[`${componentCls}-indicators`]: { [`${componentCls}-indicator`]: {
						background: primaryPrevBtnBg,
						"&-active": { background: colorTextLightSolid }
					} },
					[`${componentCls}-prev-btn`]: {
						color: colorTextLightSolid,
						borderColor: primaryPrevBtnBg,
						backgroundColor: colorPrimary,
						"&:hover": {
							backgroundColor: primaryPrevBtnBg,
							borderColor: "transparent"
						}
					},
					[`${componentCls}-next-btn`]: {
						color: colorPrimary,
						borderColor: "transparent",
						background: colorWhite,
						"&:hover": { background: primaryNextBtnHoverBg }
					}
				}
			}
		}),
		[`${componentCls}-mask`]: { [`${componentCls}-placeholder-animated`]: { transition: `all ${motionDurationSlow}` } },
		[[
			"&-placement-left",
			"&-placement-leftTop",
			"&-placement-leftBottom",
			"&-placement-right",
			"&-placement-rightTop",
			"&-placement-rightBottom"
		].join(",")]: { [`${componentCls}-inner`]: { borderRadius: token$1.min(tourBorderRadius, MAX_VERTICAL_CONTENT_RADIUS) } }
	}, getArrowStyle(token$1, "var(--antd-arrow-background-color)")];
};
const prepareComponentToken$4 = (token$1) => Object.assign(Object.assign({
	zIndexPopup: token$1.zIndexPopupBase + 70,
	closeBtnSize: token$1.fontSize * token$1.lineHeight,
	primaryPrevBtnBg: new FastColor(token$1.colorTextLightSolid).setA(.15).toRgbString(),
	primaryNextBtnHoverBg: new FastColor(token$1.colorBgTextHover).onBackground(token$1.colorWhite).toRgbString()
}, getArrowOffsetToken({
	contentRadius: token$1.borderRadiusLG,
	limitVerticalRadius: true
})), getArrowToken(token$1));
var style_default$5 = genStyleHooks("Tour", (token$1) => {
	const { borderRadiusLG } = token$1;
	const TourToken = merge(token$1, {
		indicatorWidth: 6,
		indicatorHeight: 6,
		tourBorderRadius: borderRadiusLG
	});
	return genBaseStyle$2(TourToken);
}, prepareComponentToken$4);

//#endregion
//#region node_modules/antd/es/tour/PurePanel.js
var import_classnames$18 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$9 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var PurePanel$1 = (props) => {
	const { prefixCls: customizePrefixCls, current = 0, total = 6, className, style: style$1, type: type$2, closable, closeIcon } = props, restProps = __rest$9(props, [
		"prefixCls",
		"current",
		"total",
		"className",
		"style",
		"type",
		"closable",
		"closeIcon"
	]);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("tour", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$5(prefixCls);
	const [mergedClosable, mergedCloseIcon] = useClosable({
		closable,
		closeIcon
	}, null, {
		closable: true,
		closeIconRender: (icon) => {
			var _a;
			return /* @__PURE__ */ import_react.isValidElement(icon) ? cloneElement(icon, { className: (0, import_classnames$18.default)((_a = icon.props) === null || _a === void 0 ? void 0 : _a.className, `${prefixCls}-close-icon`) }) : icon;
		}
	});
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(RawPurePanel, {
		prefixCls,
		hashId,
		className: (0, import_classnames$18.default)(className, `${prefixCls}-pure`, type$2 && `${prefixCls}-${type$2}`, cssVarCls),
		style: style$1
	}, /* @__PURE__ */ import_react.createElement(panelRender_default, {
		stepProps: Object.assign(Object.assign({}, restProps), {
			prefixCls,
			total,
			closable: mergedClosable ? { closeIcon: mergedCloseIcon } : void 0
		}),
		current,
		type: type$2
	})));
};
var PurePanel_default$1 = withPureRenderTheme(PurePanel$1);

//#endregion
//#region node_modules/antd/es/tour/index.js
var import_classnames$17 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$8 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Tour = (props) => {
	const { prefixCls: customizePrefixCls, type: type$2, rootClassName, indicatorsRender, actionsRender, steps, closeIcon } = props, restProps = __rest$8(props, [
		"prefixCls",
		"type",
		"rootClassName",
		"indicatorsRender",
		"actionsRender",
		"steps",
		"closeIcon"
	]);
	const { getPrefixCls, direction, tour } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("tour", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$5(prefixCls);
	const [, token$1] = useToken();
	const mergedSteps = import_react.useMemo(() => steps === null || steps === void 0 ? void 0 : steps.map((step) => {
		var _a;
		return Object.assign(Object.assign({}, step), { className: (0, import_classnames$17.default)(step.className, { [`${prefixCls}-primary`]: ((_a = step.type) !== null && _a !== void 0 ? _a : type$2) === "primary" }) });
	}), [steps, type$2]);
	const builtinPlacements = (config) => {
		var _a;
		return getPlacements({
			arrowPointAtCenter: (_a = config === null || config === void 0 ? void 0 : config.arrowPointAtCenter) !== null && _a !== void 0 ? _a : true,
			autoAdjustOverflow: true,
			offset: token$1.marginXXS,
			arrowWidth: token$1.sizePopupArrow,
			borderRadius: token$1.borderRadius
		});
	};
	const customClassName = (0, import_classnames$17.default)({ [`${prefixCls}-rtl`]: direction === "rtl" }, hashId, cssVarCls, rootClassName);
	const mergedRenderPanel = (stepProps, stepCurrent) => /* @__PURE__ */ import_react.createElement(panelRender_default, {
		type: type$2,
		stepProps,
		current: stepCurrent,
		indicatorsRender,
		actionsRender
	});
	const [zIndex, contextZIndex] = useZIndex("Tour", restProps.zIndex);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ import_react.createElement(es_default$5, Object.assign({}, restProps, {
		closeIcon: closeIcon !== null && closeIcon !== void 0 ? closeIcon : tour === null || tour === void 0 ? void 0 : tour.closeIcon,
		zIndex,
		rootClassName: customClassName,
		prefixCls,
		animated: true,
		renderPanel: mergedRenderPanel,
		builtinPlacements,
		steps: mergedSteps
	}))));
};
Tour.displayName = "Tour";
Tour._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default$1;
var tour_default = Tour;

//#endregion
//#region node_modules/antd/es/_util/transKeys.js
const groupKeysMap = (keys$1) => {
	const map = /* @__PURE__ */ new Map();
	keys$1.forEach((key, index$2) => {
		map.set(key, index$2);
	});
	return map;
};
const groupDisabledKeysMap = (dataSource) => {
	const map = /* @__PURE__ */ new Map();
	dataSource.forEach(({ disabled, key }, index$2) => {
		if (disabled) map.set(key, index$2);
	});
	return map;
};

//#endregion
//#region node_modules/antd/es/transfer/hooks/useData.js
var useData = (dataSource, rowKey, targetKeys) => {
	const mergedDataSource = import_react.useMemo(() => (dataSource || []).map((record) => {
		if (rowKey) return Object.assign(Object.assign({}, record), { key: rowKey(record) });
		return record;
	}), [dataSource, rowKey]);
	const [leftDataSource, rightDataSource] = import_react.useMemo(() => {
		var _a;
		const leftData = [];
		const rightData = Array.from({ length: (_a = targetKeys === null || targetKeys === void 0 ? void 0 : targetKeys.length) !== null && _a !== void 0 ? _a : 0 });
		const targetKeysMap = groupKeysMap(targetKeys || []);
		mergedDataSource.forEach((record) => {
			if (targetKeysMap.has(record.key)) {
				const idx = targetKeysMap.get(record.key);
				rightData[idx] = record;
			} else leftData.push(record);
		});
		return [leftData, rightData];
	}, [mergedDataSource, targetKeys]);
	return [
		mergedDataSource,
		leftDataSource.filter(Boolean),
		rightDataSource.filter(Boolean)
	];
};
var useData_default = useData;

//#endregion
//#region node_modules/antd/es/transfer/hooks/useSelection.js
var EMPTY_KEYS = [];
function filterKeys(keys$1, dataKeys) {
	const filteredKeys = keys$1.filter((key) => dataKeys.has(key));
	return keys$1.length === filteredKeys.length ? keys$1 : filteredKeys;
}
function flattenKeys(keys$1) {
	return Array.from(keys$1).join(";");
}
function useSelection(leftDataSource, rightDataSource, selectedKeys) {
	const [leftKeys, rightKeys] = import_react.useMemo(() => [new Set(leftDataSource.map((src) => src === null || src === void 0 ? void 0 : src.key)), new Set(rightDataSource.map((src) => src === null || src === void 0 ? void 0 : src.key))], [leftDataSource, rightDataSource]);
	const [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(EMPTY_KEYS, { value: selectedKeys });
	const sourceSelectedKeys = import_react.useMemo(() => filterKeys(mergedSelectedKeys, leftKeys), [mergedSelectedKeys, leftKeys]);
	const targetSelectedKeys = import_react.useMemo(() => filterKeys(mergedSelectedKeys, rightKeys), [mergedSelectedKeys, rightKeys]);
	import_react.useEffect(() => {
		setMergedSelectedKeys([].concat(_toConsumableArray(filterKeys(mergedSelectedKeys, leftKeys)), _toConsumableArray(filterKeys(mergedSelectedKeys, rightKeys))));
	}, [flattenKeys(leftKeys), flattenKeys(rightKeys)]);
	const setSourceSelectedKeys = useEvent((nextSrcKeys) => {
		setMergedSelectedKeys([].concat(_toConsumableArray(nextSrcKeys), _toConsumableArray(targetSelectedKeys)));
	});
	const setTargetSelectedKeys = useEvent((nextTargetKeys) => {
		setMergedSelectedKeys([].concat(_toConsumableArray(sourceSelectedKeys), _toConsumableArray(nextTargetKeys)));
	});
	return [
		sourceSelectedKeys,
		targetSelectedKeys,
		setSourceSelectedKeys,
		setTargetSelectedKeys
	];
}
var useSelection_default = useSelection;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/DeleteOutlined.js
var DeleteOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" }
		}]
	},
	"name": "delete",
	"theme": "outlined"
};
var DeleteOutlined_default$1 = DeleteOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/DeleteOutlined.js
/**![delete](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTM2MCAxODRoLThjNC40IDAgOC0zLjYgOC04djhoMzA0di04YzAgNC40IDMuNiA4IDggOGgtOHY3Mmg3MnYtODBjMC0zNS4zLTI4LjctNjQtNjQtNjRIMzUyYy0zNS4zIDAtNjQgMjguNy02NCA2NHY4MGg3MnYtNzJ6bTUwNCA3MkgxNjBjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjMyYzAgNC40IDMuNiA4IDggOGg2MC40bDI0LjcgNTIzYzEuNiAzNC4xIDI5LjggNjEgNjMuOSA2MWg0NTRjMzQuMiAwIDYyLjMtMjYuOCA2My45LTYxbDI0LjctNTIzSDg4OGM0LjQgMCA4LTMuNiA4LTh2LTMyYzAtMTcuNy0xNC4zLTMyLTMyLTMyek03MzEuMyA4NDBIMjkyLjdsLTI0LjItNTEyaDQ4N2wtMjQuMiA1MTJ6IiAvPjwvc3ZnPg==) */
var RefIcon$7 = /* @__PURE__ */ import_react.forwardRef(function DeleteOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: DeleteOutlined_default$1
	}));
});
RefIcon$7.displayName = "DeleteOutlined";
var DeleteOutlined_default = RefIcon$7;

//#endregion
//#region node_modules/antd/es/transfer/ListItem.js
var import_classnames$16 = /* @__PURE__ */ __toESM(require_classnames());
var ListItem$1 = (props) => {
	const { renderedText, renderedEl, item, checked, disabled, prefixCls, onClick, onRemove, showRemove } = props;
	const className = (0, import_classnames$16.default)(`${prefixCls}-content-item`, {
		[`${prefixCls}-content-item-disabled`]: disabled || item.disabled,
		[`${prefixCls}-content-item-checked`]: checked && !item.disabled
	});
	let title;
	if (typeof renderedText === "string" || typeof renderedText === "number") title = String(renderedText);
	const [contextLocale] = useLocale_default("Transfer", en_US_default.Transfer);
	const liProps = {
		className,
		title
	};
	const labelNode = /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-content-item-text` }, renderedEl);
	if (showRemove) return /* @__PURE__ */ import_react.createElement("li", Object.assign({}, liProps), labelNode, /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		disabled: disabled || item.disabled,
		className: `${prefixCls}-content-item-remove`,
		"aria-label": contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.remove,
		onClick: () => onRemove === null || onRemove === void 0 ? void 0 : onRemove(item)
	}, /* @__PURE__ */ import_react.createElement(DeleteOutlined_default, null)));
	liProps.onClick = disabled || item.disabled ? void 0 : (event) => onClick(item, event);
	return /* @__PURE__ */ import_react.createElement("li", Object.assign({}, liProps), /* @__PURE__ */ import_react.createElement(checkbox_default, {
		className: `${prefixCls}-checkbox`,
		checked,
		disabled: disabled || item.disabled
	}), labelNode);
};
var ListItem_default$1 = /* @__PURE__ */ import_react.memo(ListItem$1);

//#endregion
//#region node_modules/antd/es/transfer/ListBody.js
var import_classnames$15 = /* @__PURE__ */ __toESM(require_classnames());
const OmitProps = [
	"handleFilter",
	"handleClear",
	"checkedKeys"
];
var parsePagination = (pagination) => {
	return Object.assign(Object.assign({}, {
		simple: true,
		showSizeChanger: false,
		showLessItems: false
	}), pagination);
};
var TransferListBody = (props, ref) => {
	const { prefixCls, filteredRenderItems, selectedKeys, disabled: globalDisabled, showRemove, pagination, onScroll, onItemSelect, onItemRemove } = props;
	const [current, setCurrent] = import_react.useState(1);
	const mergedPagination = import_react.useMemo(() => {
		if (!pagination) return null;
		return parsePagination(typeof pagination === "object" ? pagination : {});
	}, [pagination]);
	const [pageSize, setPageSize] = useMergedState(10, { value: mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize });
	import_react.useEffect(() => {
		if (mergedPagination) {
			const maxPageCount = Math.ceil(filteredRenderItems.length / pageSize);
			setCurrent(Math.min(current, maxPageCount));
		}
	}, [
		filteredRenderItems,
		mergedPagination,
		pageSize
	]);
	const onInternalClick = (item, e$2) => {
		onItemSelect(item.key, !selectedKeys.includes(item.key), e$2);
	};
	const onRemove = (item) => {
		onItemRemove === null || onItemRemove === void 0 || onItemRemove([item.key]);
	};
	const onPageChange = (cur) => {
		setCurrent(cur);
	};
	const onSizeChange = (cur, size) => {
		setCurrent(cur);
		setPageSize(size);
	};
	const memoizedItems = import_react.useMemo(() => {
		return mergedPagination ? filteredRenderItems.slice((current - 1) * pageSize, current * pageSize) : filteredRenderItems;
	}, [
		current,
		filteredRenderItems,
		mergedPagination,
		pageSize
	]);
	import_react.useImperativeHandle(ref, () => ({ items: memoizedItems }));
	const paginationNode = mergedPagination ? /* @__PURE__ */ import_react.createElement(pagination_default, {
		size: "small",
		disabled: globalDisabled,
		simple: mergedPagination.simple,
		pageSize,
		showLessItems: mergedPagination.showLessItems,
		showSizeChanger: mergedPagination.showSizeChanger,
		className: `${prefixCls}-pagination`,
		total: filteredRenderItems.length,
		current,
		onChange: onPageChange,
		onShowSizeChange: onSizeChange
	}) : null;
	const cls$12 = (0, import_classnames$15.default)(`${prefixCls}-content`, { [`${prefixCls}-content-show-remove`]: showRemove });
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("ul", {
		className: cls$12,
		onScroll
	}, (memoizedItems || []).map(({ renderedEl, renderedText, item }) => /* @__PURE__ */ import_react.createElement(ListItem_default$1, {
		key: item.key,
		item,
		renderedText,
		renderedEl,
		prefixCls,
		showRemove,
		onClick: onInternalClick,
		onRemove,
		checked: selectedKeys.includes(item.key),
		disabled: globalDisabled || item.disabled
	}))), paginationNode);
};
TransferListBody.displayName = "TransferListBody";
var ListBody_default = /* @__PURE__ */ import_react.forwardRef(TransferListBody);

//#endregion
//#region node_modules/antd/es/transfer/search.js
var Search = (props) => {
	const { placeholder = "", value, prefixCls, disabled, onChange, handleClear } = props;
	const handleChange = import_react.useCallback((e$2) => {
		onChange === null || onChange === void 0 || onChange(e$2);
		if (e$2.target.value === "") handleClear === null || handleClear === void 0 || handleClear();
	}, [onChange]);
	return /* @__PURE__ */ import_react.createElement(Input_default, {
		placeholder,
		className: prefixCls,
		value,
		onChange: handleChange,
		disabled,
		allowClear: true,
		prefix: /* @__PURE__ */ import_react.createElement(SearchOutlined_default, null)
	});
};
Search.displayName = "Search";
var search_default = Search;

//#endregion
//#region node_modules/antd/es/transfer/list.js
var import_classnames$14 = /* @__PURE__ */ __toESM(require_classnames());
var defaultRender = () => null;
function isRenderResultPlainObject(result) {
	return !!(result && !/* @__PURE__ */ import_react.isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]");
}
function getEnabledItemKeys(items) {
	return items.filter((data) => !data.disabled).map((data) => data.key);
}
var isValidIcon = (icon) => icon !== void 0;
var getShowSearchOption = (showSearch) => {
	if (showSearch && typeof showSearch === "object") return Object.assign(Object.assign({}, showSearch), { defaultValue: showSearch.defaultValue || "" });
	return {
		defaultValue: "",
		placeholder: ""
	};
};
var TransferList = (props) => {
	const { prefixCls, dataSource = [], titleText = "", checkedKeys, disabled, showSearch = false, style: style$1, searchPlaceholder, notFoundContent, selectAll, deselectAll, selectCurrent, selectInvert, removeAll, removeCurrent, showSelectAll = true, showRemove, pagination, direction, itemsUnit, itemUnit, selectAllLabel, selectionsIcon, footer, renderList, onItemSelectAll, onItemRemove, handleFilter, handleClear, filterOption: filterOption$1, render: render$1 = defaultRender } = props;
	const searchOptions = getShowSearchOption(showSearch);
	const [filterValue, setFilterValue] = (0, import_react.useState)(searchOptions.defaultValue);
	const listBodyRef = (0, import_react.useRef)({});
	const internalHandleFilter = (e$2) => {
		setFilterValue(e$2.target.value);
		handleFilter(e$2);
	};
	const internalHandleClear = () => {
		setFilterValue("");
		handleClear();
	};
	const matchFilter = (text, item) => {
		if (filterOption$1) return filterOption$1(filterValue, item, direction);
		return text.includes(filterValue);
	};
	const renderListBody = (listProps) => {
		let bodyContent = renderList ? renderList(Object.assign(Object.assign({}, listProps), { onItemSelect: (key, check) => listProps.onItemSelect(key, check) })) : null;
		const customize = !!bodyContent;
		if (!customize) bodyContent = /* @__PURE__ */ import_react.createElement(ListBody_default, Object.assign({ ref: listBodyRef }, listProps));
		return {
			customize,
			bodyContent
		};
	};
	const renderItem$1 = (item) => {
		const renderResult = render$1(item);
		const isRenderResultPlain = isRenderResultPlainObject(renderResult);
		return {
			item,
			renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
			renderedText: isRenderResultPlain ? renderResult.value : renderResult
		};
	};
	const notFoundContentEle = (0, import_react.useMemo)(() => Array.isArray(notFoundContent) ? notFoundContent[direction === "left" ? 0 : 1] : notFoundContent, [notFoundContent, direction]);
	const [filteredItems, filteredRenderItems] = (0, import_react.useMemo)(() => {
		const filterItems = [];
		const filterRenderItems = [];
		dataSource.forEach((item) => {
			const renderedItem = renderItem$1(item);
			if (filterValue && !matchFilter(renderedItem.renderedText, item)) return;
			filterItems.push(item);
			filterRenderItems.push(renderedItem);
		});
		return [filterItems, filterRenderItems];
	}, [dataSource, filterValue]);
	const checkedActiveItems = (0, import_react.useMemo)(() => {
		return filteredItems.filter((item) => checkedKeys.includes(item.key) && !item.disabled);
	}, [checkedKeys, filteredItems]);
	const checkStatus = (0, import_react.useMemo)(() => {
		if (checkedActiveItems.length === 0) return "none";
		const checkedKeysMap = groupKeysMap(checkedKeys);
		if (filteredItems.every((item) => checkedKeysMap.has(item.key) || !!item.disabled)) return "all";
		return "part";
	}, [checkedKeys, checkedActiveItems]);
	const listBody = (0, import_react.useMemo)(() => {
		const search = showSearch ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-body-search-wrapper` }, /* @__PURE__ */ import_react.createElement(search_default, {
			prefixCls: `${prefixCls}-search`,
			onChange: internalHandleFilter,
			handleClear: internalHandleClear,
			placeholder: searchOptions.placeholder || searchPlaceholder,
			value: filterValue,
			disabled
		})) : null;
		const { customize, bodyContent } = renderListBody(Object.assign(Object.assign({}, omit(props, OmitProps)), {
			filteredItems,
			filteredRenderItems,
			selectedKeys: checkedKeys
		}));
		let bodyNode;
		if (customize) bodyNode = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-body-customize-wrapper` }, bodyContent);
		else bodyNode = filteredItems.length ? bodyContent : /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-body-not-found` }, notFoundContentEle);
		return /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$14.default)(`${prefixCls}-body`, { [`${prefixCls}-body-with-search`]: showSearch }) }, search, bodyNode);
	}, [
		showSearch,
		prefixCls,
		searchPlaceholder,
		filterValue,
		disabled,
		checkedKeys,
		filteredItems,
		filteredRenderItems,
		notFoundContentEle
	]);
	const checkBox = /* @__PURE__ */ import_react.createElement(checkbox_default, {
		disabled: dataSource.filter((d) => !d.disabled).length === 0 || disabled,
		checked: checkStatus === "all",
		indeterminate: checkStatus === "part",
		className: `${prefixCls}-checkbox`,
		onChange: () => {
			onItemSelectAll === null || onItemSelectAll === void 0 || onItemSelectAll(filteredItems.filter((item) => !item.disabled).map(({ key }) => key), checkStatus !== "all");
		}
	});
	const getSelectAllLabel = (selectedCount, totalCount) => {
		if (selectAllLabel) return typeof selectAllLabel === "function" ? selectAllLabel({
			selectedCount,
			totalCount
		}) : selectAllLabel;
		const unit$2 = totalCount > 1 ? itemsUnit : itemUnit;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, (selectedCount > 0 ? `${selectedCount}/` : "") + totalCount, " ", unit$2);
	};
	const footerDom = footer && (footer.length < 2 ? footer(props) : footer(props, { direction }));
	const listCls = (0, import_classnames$14.default)(prefixCls, {
		[`${prefixCls}-with-pagination`]: !!pagination,
		[`${prefixCls}-with-footer`]: !!footerDom
	});
	const listFooter = footerDom ? /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-footer` }, footerDom) : null;
	const checkAllCheckbox = !showRemove && !pagination && checkBox;
	let items;
	if (showRemove) items = [pagination ? {
		key: "removeCurrent",
		label: removeCurrent,
		onClick() {
			var _a;
			const pageKeys = getEnabledItemKeys((((_a = listBodyRef.current) === null || _a === void 0 ? void 0 : _a.items) || []).map((entity) => entity.item));
			onItemRemove === null || onItemRemove === void 0 || onItemRemove(pageKeys);
		}
	} : null, {
		key: "removeAll",
		label: removeAll,
		onClick() {
			onItemRemove === null || onItemRemove === void 0 || onItemRemove(getEnabledItemKeys(filteredItems));
		}
	}].filter(Boolean);
	else items = [
		{
			key: "selectAll",
			label: checkStatus === "all" ? deselectAll : selectAll,
			onClick() {
				const keys$1 = getEnabledItemKeys(filteredItems);
				onItemSelectAll === null || onItemSelectAll === void 0 || onItemSelectAll(keys$1, keys$1.length !== checkedKeys.length);
			}
		},
		pagination ? {
			key: "selectCurrent",
			label: selectCurrent,
			onClick() {
				var _a;
				const pageItems = ((_a = listBodyRef.current) === null || _a === void 0 ? void 0 : _a.items) || [];
				onItemSelectAll === null || onItemSelectAll === void 0 || onItemSelectAll(getEnabledItemKeys(pageItems.map((entity) => entity.item)), true);
			}
		} : null,
		{
			key: "selectInvert",
			label: selectInvert,
			onClick() {
				var _a;
				const availablePageItemKeys = getEnabledItemKeys((((_a = listBodyRef.current) === null || _a === void 0 ? void 0 : _a.items) || []).map((entity) => entity.item));
				const checkedKeySet = new Set(checkedKeys);
				const newCheckedKeysSet = new Set(checkedKeySet);
				availablePageItemKeys.forEach((key) => {
					if (checkedKeySet.has(key)) newCheckedKeysSet.delete(key);
					else newCheckedKeysSet.add(key);
				});
				onItemSelectAll === null || onItemSelectAll === void 0 || onItemSelectAll(Array.from(newCheckedKeysSet), "replace");
			}
		}
	];
	const dropdown = /* @__PURE__ */ import_react.createElement(dropdown_default, {
		className: `${prefixCls}-header-dropdown`,
		menu: { items },
		disabled
	}, isValidIcon(selectionsIcon) ? selectionsIcon : /* @__PURE__ */ import_react.createElement(DownOutlined_default, null));
	return /* @__PURE__ */ import_react.createElement("div", {
		className: listCls,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-header` }, showSelectAll ? /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, checkAllCheckbox, dropdown) : null, /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-header-selected` }, getSelectAllLabel(checkedActiveItems.length, filteredItems.length)), /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-header-title` }, titleText)), listBody, listFooter);
};
TransferList.displayName = "TransferList";
var list_default$2 = TransferList;

//#endregion
//#region node_modules/antd/es/transfer/operation.js
var Operation = (props) => {
	const { disabled, moveToLeft, moveToRight, leftArrowText = "", rightArrowText = "", leftActive, rightActive, className, style: style$1, direction, oneWay } = props;
	return /* @__PURE__ */ import_react.createElement("div", {
		className,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement(button_default, {
		type: "primary",
		size: "small",
		disabled: disabled || !rightActive,
		onClick: moveToRight,
		icon: direction !== "rtl" ? /* @__PURE__ */ import_react.createElement(RightOutlined_default, null) : /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null)
	}, rightArrowText), !oneWay && /* @__PURE__ */ import_react.createElement(button_default, {
		type: "primary",
		size: "small",
		disabled: disabled || !leftActive,
		onClick: moveToLeft,
		icon: direction !== "rtl" ? /* @__PURE__ */ import_react.createElement(LeftOutlined_default, null) : /* @__PURE__ */ import_react.createElement(RightOutlined_default, null)
	}, leftArrowText));
};
Operation.displayName = "Operation";
var operation_default = Operation;

//#endregion
//#region node_modules/antd/es/transfer/style/index.js
var genTransferCustomizeStyle = (token$1) => {
	const { antCls, componentCls, listHeight, controlHeightLG } = token$1;
	const tableCls = `${antCls}-table`;
	const inputCls = `${antCls}-input`;
	return { [`${componentCls}-customize-list`]: {
		[`${componentCls}-list`]: {
			flex: "1 1 50%",
			width: "auto",
			height: "auto",
			minHeight: listHeight,
			minWidth: 0
		},
		[`${tableCls}-wrapper`]: {
			[`${tableCls}-small`]: {
				border: 0,
				borderRadius: 0,
				[`${tableCls}-selection-column`]: {
					width: controlHeightLG,
					minWidth: controlHeightLG
				}
			},
			[`${tableCls}-pagination${tableCls}-pagination`]: {
				margin: 0,
				padding: token$1.paddingXS
			}
		},
		[`${inputCls}[disabled]`]: { backgroundColor: "transparent" }
	} };
};
var genTransferStatusColor = (token$1, color) => {
	const { componentCls, colorBorder } = token$1;
	return { [`${componentCls}-list`]: {
		borderColor: color,
		"&-search:not([disabled])": { borderColor: colorBorder }
	} };
};
var genTransferStatusStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`${componentCls}-status-error`]: Object.assign({}, genTransferStatusColor(token$1, token$1.colorError)),
		[`${componentCls}-status-warning`]: Object.assign({}, genTransferStatusColor(token$1, token$1.colorWarning))
	};
};
var genTransferListStyle = (token$1) => {
	const { componentCls, colorBorder, colorSplit, lineWidth, itemHeight, headerHeight, transferHeaderVerticalPadding, itemPaddingBlock, controlItemBgActive, colorTextDisabled, colorTextSecondary, listHeight, listWidth, listWidthLG, fontSizeIcon, marginXS, paddingSM, lineType, antCls, iconCls, motionDurationSlow, controlItemBgHover, borderRadiusLG, colorBgContainer, colorText, controlItemBgActiveHover } = token$1;
	const contentBorderRadius = unit(token$1.calc(borderRadiusLG).sub(lineWidth).equal());
	return {
		display: "flex",
		flexDirection: "column",
		width: listWidth,
		height: listHeight,
		border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
		borderRadius: token$1.borderRadiusLG,
		"&-with-pagination": {
			width: listWidthLG,
			height: "auto"
		},
		"&-search": { [`${iconCls}-search`]: { color: colorTextDisabled } },
		"&-header": {
			display: "flex",
			flex: "none",
			alignItems: "center",
			height: headerHeight,
			padding: `${unit(token$1.calc(transferHeaderVerticalPadding).sub(lineWidth).equal())} ${unit(paddingSM)} ${unit(transferHeaderVerticalPadding)}`,
			color: colorText,
			background: colorBgContainer,
			borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			borderRadius: `${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0 0`,
			"> *:not(:last-child)": { marginInlineEnd: 4 },
			"> *": { flex: "none" },
			"&-title": Object.assign(Object.assign({}, textEllipsis), {
				flex: "auto",
				textAlign: "end"
			}),
			"&-dropdown": Object.assign(Object.assign({}, resetIcon()), {
				fontSize: fontSizeIcon,
				transform: "translateY(10%)",
				cursor: "pointer",
				"&[disabled]": { cursor: "not-allowed" }
			})
		},
		"&-body": {
			display: "flex",
			flex: "auto",
			flexDirection: "column",
			fontSize: token$1.fontSize,
			minHeight: 0,
			"&-search-wrapper": {
				position: "relative",
				flex: "none",
				padding: paddingSM
			}
		},
		"&-content": {
			flex: "auto",
			margin: 0,
			padding: 0,
			overflow: "auto",
			listStyle: "none",
			borderRadius: `0 0 ${contentBorderRadius} ${contentBorderRadius}`,
			"&-item": {
				display: "flex",
				alignItems: "center",
				minHeight: itemHeight,
				padding: `${unit(itemPaddingBlock)} ${unit(paddingSM)}`,
				transition: `all ${motionDurationSlow}`,
				"> *:not(:last-child)": { marginInlineEnd: marginXS },
				"> *": { flex: "none" },
				"&-text": Object.assign(Object.assign({}, textEllipsis), { flex: "auto" }),
				"&-remove": Object.assign(Object.assign({}, operationUnit(token$1)), {
					color: colorBorder,
					"&:hover, &:focus": { color: colorTextSecondary }
				}),
				[`&:not(${componentCls}-list-content-item-disabled)`]: {
					"&:hover": {
						backgroundColor: controlItemBgHover,
						cursor: "pointer"
					},
					[`&${componentCls}-list-content-item-checked:hover`]: { backgroundColor: controlItemBgActiveHover }
				},
				"&-checked": { backgroundColor: controlItemBgActive },
				"&-disabled": {
					color: colorTextDisabled,
					cursor: "not-allowed"
				}
			},
			[`&-show-remove ${componentCls}-list-content-item:not(${componentCls}-list-content-item-disabled):hover`]: {
				background: "transparent",
				cursor: "default"
			}
		},
		"&-pagination": {
			padding: token$1.paddingXS,
			textAlign: "end",
			borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
			[`${antCls}-pagination-options`]: { paddingInlineEnd: token$1.paddingXS }
		},
		"&-body-not-found": {
			flex: "none",
			width: "100%",
			margin: "auto 0",
			color: colorTextDisabled,
			textAlign: "center"
		},
		"&-footer": { borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}` },
		"&-checkbox": { lineHeight: 1 }
	};
};
var genTransferStyle = (token$1) => {
	const { antCls, iconCls, componentCls, marginXS, marginXXS, fontSizeIcon, colorBgContainerDisabled } = token$1;
	return { [componentCls]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		position: "relative",
		display: "flex",
		alignItems: "stretch",
		[`${componentCls}-disabled`]: { [`${componentCls}-list`]: { background: colorBgContainerDisabled } },
		[`${componentCls}-list`]: genTransferListStyle(token$1),
		[`${componentCls}-operation`]: {
			display: "flex",
			flex: "none",
			flexDirection: "column",
			alignSelf: "center",
			margin: `0 ${unit(marginXS)}`,
			verticalAlign: "middle",
			gap: marginXXS,
			[`${antCls}-btn ${iconCls}`]: { fontSize: fontSizeIcon }
		}
	}) };
};
var genTransferRTLStyle = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-rtl`]: { direction: "rtl" } };
};
const prepareComponentToken$3 = (token$1) => {
	const { fontSize, lineHeight, controlHeight, controlHeightLG, lineWidth } = token$1;
	const fontHeight = Math.round(fontSize * lineHeight);
	return {
		listWidth: 180,
		listHeight: 200,
		listWidthLG: 250,
		headerHeight: controlHeightLG,
		itemHeight: controlHeight,
		itemPaddingBlock: (controlHeight - fontHeight) / 2,
		transferHeaderVerticalPadding: Math.ceil((controlHeightLG - lineWidth - fontHeight) / 2)
	};
};
var style_default$4 = genStyleHooks("Transfer", (token$1) => {
	const transferToken = merge(token$1);
	return [
		genTransferStyle(transferToken),
		genTransferCustomizeStyle(transferToken),
		genTransferStatusStyle(transferToken),
		genTransferRTLStyle(transferToken)
	];
}, prepareComponentToken$3);

//#endregion
//#region node_modules/antd/es/transfer/index.js
var import_classnames$13 = /* @__PURE__ */ __toESM(require_classnames());
var Transfer = (props) => {
	const { dataSource, targetKeys = [], selectedKeys, selectAllLabels = [], operations = [], style: style$1 = {}, listStyle = {}, locale: locale$5 = {}, titles, disabled, showSearch = false, operationStyle, showSelectAll, oneWay, pagination, status: customStatus, prefixCls: customizePrefixCls, className, rootClassName, selectionsIcon, filterOption: filterOption$1, render: render$1, footer, children, rowKey, onScroll, onChange, onSearch, onSelectChange } = props;
	const { getPrefixCls, renderEmpty, direction: dir, transfer } = (0, import_react.useContext)(ConfigContext);
	const prefixCls = getPrefixCls("transfer", customizePrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$4(prefixCls);
	const [mergedDataSource, leftDataSource, rightDataSource] = useData_default(dataSource, rowKey, targetKeys);
	const [sourceSelectedKeys, targetSelectedKeys, setSourceSelectedKeys, setTargetSelectedKeys] = useSelection_default(leftDataSource, rightDataSource, selectedKeys);
	const [leftMultipleSelect, updateLeftPrevSelectedIndex] = useMultipleSelect((item) => item.key);
	const [rightMultipleSelect, updateRightPrevSelectedIndex] = useMultipleSelect((item) => item.key);
	devUseWarning("Transfer")(!pagination || !children, "usage", "`pagination` not support customize render list.");
	const setStateKeys = (0, import_react.useCallback)((direction, keys$1) => {
		if (direction === "left") {
			const nextKeys = typeof keys$1 === "function" ? keys$1(sourceSelectedKeys || []) : keys$1;
			setSourceSelectedKeys(nextKeys);
		} else {
			const nextKeys = typeof keys$1 === "function" ? keys$1(targetSelectedKeys || []) : keys$1;
			setTargetSelectedKeys(nextKeys);
		}
	}, [sourceSelectedKeys, targetSelectedKeys]);
	const setPrevSelectedIndex = (direction, value) => {
		(direction === "left" ? updateLeftPrevSelectedIndex : updateRightPrevSelectedIndex)(value);
	};
	const handleSelectChange = (0, import_react.useCallback)((direction, holder) => {
		if (direction === "left") onSelectChange === null || onSelectChange === void 0 || onSelectChange(holder, targetSelectedKeys);
		else onSelectChange === null || onSelectChange === void 0 || onSelectChange(sourceSelectedKeys, holder);
	}, [sourceSelectedKeys, targetSelectedKeys]);
	const getTitles = (transferLocale) => {
		var _a;
		return (_a = titles !== null && titles !== void 0 ? titles : transferLocale.titles) !== null && _a !== void 0 ? _a : [];
	};
	const handleLeftScroll = (e$2) => {
		onScroll === null || onScroll === void 0 || onScroll("left", e$2);
	};
	const handleRightScroll = (e$2) => {
		onScroll === null || onScroll === void 0 || onScroll("right", e$2);
	};
	const moveTo = (direction) => {
		const moveKeys = direction === "right" ? sourceSelectedKeys : targetSelectedKeys;
		const dataSourceDisabledKeysMap = groupDisabledKeysMap(mergedDataSource);
		const newMoveKeys = moveKeys.filter((key) => !dataSourceDisabledKeysMap.has(key));
		const newMoveKeysMap = groupKeysMap(newMoveKeys);
		const newTargetKeys = direction === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter((targetKey) => !newMoveKeysMap.has(targetKey));
		const oppositeDirection = direction === "right" ? "left" : "right";
		setStateKeys(oppositeDirection, []);
		handleSelectChange(oppositeDirection, []);
		onChange === null || onChange === void 0 || onChange(newTargetKeys, direction, newMoveKeys);
	};
	const moveToLeft = () => {
		moveTo("left");
		setPrevSelectedIndex("left", null);
	};
	const moveToRight = () => {
		moveTo("right");
		setPrevSelectedIndex("right", null);
	};
	const onItemSelectAll = (direction, keys$1, checkAll) => {
		setStateKeys(direction, (prevKeys) => {
			let mergedCheckedKeys = [];
			if (checkAll === "replace") mergedCheckedKeys = keys$1;
			else if (checkAll) mergedCheckedKeys = Array.from(new Set([].concat(_toConsumableArray(prevKeys), _toConsumableArray(keys$1))));
			else {
				const selectedKeysMap = groupKeysMap(keys$1);
				mergedCheckedKeys = prevKeys.filter((key) => !selectedKeysMap.has(key));
			}
			handleSelectChange(direction, mergedCheckedKeys);
			return mergedCheckedKeys;
		});
		setPrevSelectedIndex(direction, null);
	};
	const onLeftItemSelectAll = (keys$1, checkAll) => {
		onItemSelectAll("left", keys$1, checkAll);
	};
	const onRightItemSelectAll = (keys$1, checkAll) => {
		onItemSelectAll("right", keys$1, checkAll);
	};
	const leftFilter = (e$2) => onSearch === null || onSearch === void 0 ? void 0 : onSearch("left", e$2.target.value);
	const rightFilter = (e$2) => onSearch === null || onSearch === void 0 ? void 0 : onSearch("right", e$2.target.value);
	const handleLeftClear = () => onSearch === null || onSearch === void 0 ? void 0 : onSearch("left", "");
	const handleRightClear = () => onSearch === null || onSearch === void 0 ? void 0 : onSearch("right", "");
	const handleSingleSelect = (direction, holder, selectedKey, checked, currentSelectedIndex) => {
		if (holder.has(selectedKey)) {
			holder.delete(selectedKey);
			setPrevSelectedIndex(direction, null);
		}
		if (checked) {
			holder.add(selectedKey);
			setPrevSelectedIndex(direction, currentSelectedIndex);
		}
	};
	const handleMultipleSelect = (direction, data, holder, currentSelectedIndex) => {
		(direction === "left" ? leftMultipleSelect : rightMultipleSelect)(currentSelectedIndex, data, holder);
	};
	const onItemSelect = (direction, selectedKey, checked, multiple) => {
		const isLeftDirection = direction === "left";
		const holder = _toConsumableArray(isLeftDirection ? sourceSelectedKeys : targetSelectedKeys);
		const holderSet = new Set(holder);
		const data = _toConsumableArray(isLeftDirection ? leftDataSource : rightDataSource).filter((item) => !(item === null || item === void 0 ? void 0 : item.disabled));
		const currentSelectedIndex = data.findIndex((item) => item.key === selectedKey);
		if (multiple && holder.length > 0) handleMultipleSelect(direction, data, holderSet, currentSelectedIndex);
		else handleSingleSelect(direction, holderSet, selectedKey, checked, currentSelectedIndex);
		const holderArr = Array.from(holderSet);
		handleSelectChange(direction, holderArr);
		if (!props.selectedKeys) setStateKeys(direction, holderArr);
	};
	const onLeftItemSelect = (selectedKey, checked, e$2) => {
		onItemSelect("left", selectedKey, checked, e$2 === null || e$2 === void 0 ? void 0 : e$2.shiftKey);
	};
	const onRightItemSelect = (selectedKey, checked, e$2) => {
		onItemSelect("right", selectedKey, checked, e$2 === null || e$2 === void 0 ? void 0 : e$2.shiftKey);
	};
	const onRightItemRemove = (keys$1) => {
		setStateKeys("right", []);
		onChange === null || onChange === void 0 || onChange(targetKeys.filter((key) => !keys$1.includes(key)), "left", _toConsumableArray(keys$1));
	};
	const handleListStyle = (direction) => {
		if (typeof listStyle === "function") return listStyle({ direction });
		return listStyle || {};
	};
	const { hasFeedback, status } = (0, import_react.useContext)(FormItemInputContext);
	const getLocale = (transferLocale) => Object.assign(Object.assign(Object.assign({}, transferLocale), { notFoundContent: (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Transfer")) || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Transfer" }) }), locale$5);
	const mergedStatus = getMergedStatus(status, customStatus);
	const mergedPagination = !children && pagination;
	const leftActive = rightDataSource.filter((d) => targetSelectedKeys.includes(d.key) && !d.disabled).length > 0;
	const rightActive = leftDataSource.filter((d) => sourceSelectedKeys.includes(d.key) && !d.disabled).length > 0;
	const cls$12 = (0, import_classnames$13.default)(prefixCls, {
		[`${prefixCls}-disabled`]: disabled,
		[`${prefixCls}-customize-list`]: !!children,
		[`${prefixCls}-rtl`]: dir === "rtl"
	}, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), transfer === null || transfer === void 0 ? void 0 : transfer.className, className, rootClassName, hashId, cssVarCls);
	const [contextLocale] = useLocale_default("Transfer", en_US_default.Transfer);
	const listLocale = getLocale(contextLocale);
	const [leftTitle, rightTitle] = getTitles(listLocale);
	const mergedSelectionsIcon = selectionsIcon !== null && selectionsIcon !== void 0 ? selectionsIcon : transfer === null || transfer === void 0 ? void 0 : transfer.selectionsIcon;
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
		className: cls$12,
		style: Object.assign(Object.assign({}, transfer === null || transfer === void 0 ? void 0 : transfer.style), style$1)
	}, /* @__PURE__ */ import_react.createElement(list_default$2, Object.assign({
		prefixCls: `${prefixCls}-list`,
		titleText: leftTitle,
		dataSource: leftDataSource,
		filterOption: filterOption$1,
		style: handleListStyle("left"),
		checkedKeys: sourceSelectedKeys,
		handleFilter: leftFilter,
		handleClear: handleLeftClear,
		onItemSelect: onLeftItemSelect,
		onItemSelectAll: onLeftItemSelectAll,
		render: render$1,
		showSearch,
		renderList: children,
		footer,
		onScroll: handleLeftScroll,
		disabled,
		direction: dir === "rtl" ? "right" : "left",
		showSelectAll,
		selectAllLabel: selectAllLabels[0],
		pagination: mergedPagination,
		selectionsIcon: mergedSelectionsIcon
	}, listLocale)), /* @__PURE__ */ import_react.createElement(operation_default, {
		className: `${prefixCls}-operation`,
		rightActive,
		rightArrowText: operations[0],
		moveToRight,
		leftActive,
		leftArrowText: operations[1],
		moveToLeft,
		style: operationStyle,
		disabled,
		direction: dir,
		oneWay
	}), /* @__PURE__ */ import_react.createElement(list_default$2, Object.assign({
		prefixCls: `${prefixCls}-list`,
		titleText: rightTitle,
		dataSource: rightDataSource,
		filterOption: filterOption$1,
		style: handleListStyle("right"),
		checkedKeys: targetSelectedKeys,
		handleFilter: rightFilter,
		handleClear: handleRightClear,
		onItemSelect: onRightItemSelect,
		onItemSelectAll: onRightItemSelectAll,
		onItemRemove: onRightItemRemove,
		render: render$1,
		showSearch,
		renderList: children,
		footer,
		onScroll: handleRightScroll,
		disabled,
		direction: dir === "rtl" ? "left" : "right",
		showSelectAll,
		selectAllLabel: selectAllLabels[1],
		showRemove: oneWay,
		pagination: mergedPagination,
		selectionsIcon: mergedSelectionsIcon
	}, listLocale))));
};
Transfer.displayName = "Transfer";
Transfer.List = list_default$2;
Transfer.Search = search_default;
Transfer.Operation = operation_default;
var transfer_default = Transfer;

//#endregion
//#region node_modules/rc-tree-select/es/hooks/useCache.js
/**
* This function will try to call requestIdleCallback if available to save performance.
* No need `getLabel` here since already fetch on `rawLabeledValue`.
*/
var useCache_default = (function(values) {
	var cacheRef = import_react.useRef({ valueLabels: /* @__PURE__ */ new Map() });
	return import_react.useMemo(function() {
		var valueLabels = cacheRef.current.valueLabels;
		var valueLabelsCache = /* @__PURE__ */ new Map();
		var filledValues = values.map(function(item) {
			var value = item.value, label = item.label;
			var mergedLabel = label !== null && label !== void 0 ? label : valueLabels.get(value);
			valueLabelsCache.set(value, mergedLabel);
			return _objectSpread2(_objectSpread2({}, item), {}, { label: mergedLabel });
		});
		cacheRef.current.valueLabels = valueLabelsCache;
		return [filledValues];
	}, [values]);
});

//#endregion
//#region node_modules/rc-tree-select/es/hooks/useCheckedKeys.js
var useCheckedKeys = function useCheckedKeys$1(rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities) {
	return import_react.useMemo(function() {
		var extractValues = function extractValues$1(values) {
			return values.map(function(_ref) {
				return _ref.value;
			});
		};
		var checkedKeys = extractValues(rawLabeledValues);
		var halfCheckedKeys = extractValues(rawHalfCheckedValues);
		var missingValues = checkedKeys.filter(function(key) {
			return !keyEntities[key];
		});
		var finalCheckedKeys = checkedKeys;
		var finalHalfCheckedKeys = halfCheckedKeys;
		if (treeConduction) {
			var conductResult = conductCheck(checkedKeys, true, keyEntities);
			finalCheckedKeys = conductResult.checkedKeys;
			finalHalfCheckedKeys = conductResult.halfCheckedKeys;
		}
		return [Array.from(new Set([].concat(_toConsumableArray(missingValues), _toConsumableArray(finalCheckedKeys)))), finalHalfCheckedKeys];
	}, [
		rawLabeledValues,
		rawHalfCheckedValues,
		treeConduction,
		keyEntities
	]);
};
var useCheckedKeys_default = useCheckedKeys;

//#endregion
//#region node_modules/rc-tree-select/es/utils/valueUtil.js
var toArray$1 = function toArray$9(value) {
	return Array.isArray(value) ? value : value !== void 0 ? [value] : [];
};
var fillFieldNames = function fillFieldNames$4(fieldNames) {
	var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, children = _ref.children;
	return {
		_title: label ? [label] : ["title", "label"],
		value: value || "value",
		key: value || "value",
		children: children || "children"
	};
};
var isCheckDisabled = function isCheckDisabled$2(node$1) {
	return !node$1 || node$1.disabled || node$1.disableCheckbox || node$1.checkable === false;
};
var getAllKeys = function getAllKeys$1(treeData, fieldNames) {
	var keys$1 = [];
	(function dig(list) {
		list.forEach(function(item) {
			var children = item[fieldNames.children];
			if (children) {
				keys$1.push(item[fieldNames.value]);
				dig(children);
			}
		});
	})(treeData);
	return keys$1;
};
var isNil = function isNil$1(val) {
	return val === null || val === void 0;
};

//#endregion
//#region node_modules/rc-tree-select/es/hooks/useDataEntities.js
var useDataEntities_default = (function(treeData, fieldNames) {
	return import_react.useMemo(function() {
		return convertDataToEntities(treeData, {
			fieldNames,
			initWrapper: function initWrapper(wrapper) {
				return _objectSpread2(_objectSpread2({}, wrapper), {}, { valueEntities: /* @__PURE__ */ new Map() });
			},
			processEntity: function processEntity(entity, wrapper) {
				var val = entity.node[fieldNames.value];
				var key = entity.node.key;
				warning_default(!isNil(val), "TreeNode `value` is invalidate: undefined");
				warning_default(!wrapper.valueEntities.has(val), "Same `value` exist in the tree: ".concat(val));
				warning_default(!key || String(key) === String(val), "`key` or `value` with TreeNode must be the same or you can remove one of them. key: ".concat(key, ", value: ").concat(val, "."));
				wrapper.valueEntities.set(val, entity);
			}
		});
	}, [treeData, fieldNames]);
});

//#endregion
//#region node_modules/rc-tree-select/es/TreeNode.js
/* istanbul ignore file */
/** This is a placeholder, not real render in dom */
var TreeNode = function TreeNode$2() {
	return null;
};
var TreeNode_default = TreeNode;

//#endregion
//#region node_modules/rc-tree-select/es/utils/legacyUtil.js
var _excluded$2 = ["children", "value"];
function convertChildrenToData(nodes) {
	return toArray(nodes).map(function(node$1) {
		if (!/* @__PURE__ */ import_react.isValidElement(node$1) || !node$1.type) return null;
		var _ref = node$1, key = _ref.key, _ref$props = _ref.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties(_ref$props, _excluded$2);
		var data = _objectSpread2({
			key,
			value
		}, restProps);
		var childData = convertChildrenToData(children);
		if (childData.length) data.children = childData;
		return data;
	}).filter(function(data) {
		return data;
	});
}
function fillLegacyProps(dataNode) {
	if (!dataNode) return dataNode;
	var cloneNode = _objectSpread2({}, dataNode);
	if (!("props" in cloneNode)) Object.defineProperty(cloneNode, "props", { get: function get$1() {
		warning_default(false, "New `rc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access.");
		return cloneNode;
	} });
	return cloneNode;
}
function fillAdditionalInfo(extra, triggerValue, checkedValues, treeData, showPosition, fieldNames) {
	var triggerNode = null;
	var nodeList = null;
	function generateMap() {
		function dig(list) {
			var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0";
			var parentIncluded = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
			return list.map(function(option, index$2) {
				var pos = "".concat(level, "-").concat(index$2);
				var value = option[fieldNames.value];
				var included = checkedValues.includes(value);
				var children = dig(option[fieldNames.children] || [], pos, included);
				var node$1 = /* @__PURE__ */ import_react.createElement(TreeNode_default, option, children.map(function(child) {
					return child.node;
				}));
				if (triggerValue === value) triggerNode = node$1;
				if (included) {
					var checkedNode = {
						pos,
						node: node$1,
						children
					};
					if (!parentIncluded) nodeList.push(checkedNode);
					return checkedNode;
				}
				return null;
			}).filter(function(node$1) {
				return node$1;
			});
		}
		if (!nodeList) {
			nodeList = [];
			dig(treeData);
			nodeList.sort(function(_ref2, _ref3) {
				var val1 = _ref2.node.props.value;
				var val2 = _ref3.node.props.value;
				var index1 = checkedValues.indexOf(val1);
				var index2 = checkedValues.indexOf(val2);
				return index1 - index2;
			});
		}
	}
	Object.defineProperty(extra, "triggerNode", { get: function get$1() {
		warning_default(false, "`triggerNode` is deprecated. Please consider decoupling data with node.");
		generateMap();
		return triggerNode;
	} });
	Object.defineProperty(extra, "allCheckedNodes", { get: function get$1() {
		warning_default(false, "`allCheckedNodes` is deprecated. Please consider decoupling data with node.");
		generateMap();
		if (showPosition) return nodeList;
		return nodeList.map(function(_ref4) {
			return _ref4.node;
		});
	} });
}

//#endregion
//#region node_modules/rc-tree-select/es/hooks/useFilterTreeData.js
var useFilterTreeData = function useFilterTreeData$1(treeData, searchValue, options) {
	var fieldNames = options.fieldNames, treeNodeFilterProp = options.treeNodeFilterProp, filterTreeNode = options.filterTreeNode;
	var fieldChildren = fieldNames.children;
	return import_react.useMemo(function() {
		if (!searchValue || filterTreeNode === false) return treeData;
		var filterOptionFunc = typeof filterTreeNode === "function" ? filterTreeNode : function(_, dataNode) {
			return String(dataNode[treeNodeFilterProp]).toUpperCase().includes(searchValue.toUpperCase());
		};
		return function filterTreeNodes(nodes) {
			var keepAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
			return nodes.reduce(function(filtered, node$1) {
				var children = node$1[fieldChildren];
				var isMatch = keepAll || filterOptionFunc(searchValue, fillLegacyProps(node$1));
				var filteredChildren = filterTreeNodes(children || [], isMatch);
				if (isMatch || filteredChildren.length) filtered.push(_objectSpread2(_objectSpread2({}, node$1), {}, _defineProperty({ isLeaf: void 0 }, fieldChildren, filteredChildren)));
				return filtered;
			}, []);
		}(treeData);
	}, [
		treeData,
		searchValue,
		fieldChildren,
		treeNodeFilterProp,
		filterTreeNode
	]);
};
var useFilterTreeData_default = useFilterTreeData;

//#endregion
//#region node_modules/rc-tree-select/es/hooks/useRefFunc.js
/**
* Same as `React.useCallback` but always return a memoized function
* but redirect to real function.
*/
function useRefFunc(callback) {
	var funcRef = import_react.useRef();
	funcRef.current = callback;
	return import_react.useCallback(function() {
		return funcRef.current.apply(funcRef, arguments);
	}, []);
}

//#endregion
//#region node_modules/rc-tree-select/es/hooks/useTreeData.js
function buildTreeStructure(nodes, config) {
	var id = config.id, pId = config.pId, rootPId = config.rootPId;
	var nodeMap = /* @__PURE__ */ new Map();
	var rootNodes = [];
	nodes.forEach(function(node$1) {
		var nodeKey = node$1[id];
		var clonedNode = _objectSpread2(_objectSpread2({}, node$1), {}, { key: node$1.key || nodeKey });
		nodeMap.set(nodeKey, clonedNode);
	});
	nodeMap.forEach(function(node$1) {
		var parentKey = node$1[pId];
		var parent = nodeMap.get(parentKey);
		if (parent) {
			parent.children = parent.children || [];
			parent.children.push(node$1);
		} else if (parentKey === rootPId || rootPId === null) rootNodes.push(node$1);
	});
	return rootNodes;
}
/**
*  `treeData`  `children`  `treeData`
*  `treeData`  `children` 
*/
function useTreeData(treeData, children, simpleMode) {
	return import_react.useMemo(function() {
		if (treeData) {
			if (simpleMode) {
				var config = _objectSpread2({
					id: "id",
					pId: "pId",
					rootPId: null
				}, _typeof(simpleMode) === "object" ? simpleMode : {});
				return buildTreeStructure(treeData, config);
			}
			return treeData;
		}
		return convertChildrenToData(children);
	}, [
		children,
		simpleMode,
		treeData
	]);
}

//#endregion
//#region node_modules/rc-tree-select/es/LegacyContext.js
var LegacySelectContext = /* @__PURE__ */ import_react.createContext(null);
var LegacyContext_default = LegacySelectContext;

//#endregion
//#region node_modules/rc-tree-select/es/TreeSelectContext.js
var TreeSelectContext = /* @__PURE__ */ import_react.createContext(null);
var TreeSelectContext_default = TreeSelectContext;

//#endregion
//#region node_modules/rc-tree-select/es/OptionList.js
var HIDDEN_STYLE = {
	width: 0,
	height: 0,
	display: "flex",
	overflow: "hidden",
	opacity: 0,
	border: 0,
	padding: 0,
	margin: 0
};
var RefOptionList = /* @__PURE__ */ import_react.forwardRef(function OptionList(_, ref) {
	var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, multiple = _useBaseProps.multiple, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, open$2 = _useBaseProps.open, notFoundContent = _useBaseProps.notFoundContent;
	var _React$useContext = import_react.useContext(TreeSelectContext_default), virtual = _React$useContext.virtual, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight, listItemScrollOffset = _React$useContext.listItemScrollOffset, treeData = _React$useContext.treeData, fieldNames = _React$useContext.fieldNames, onSelect = _React$useContext.onSelect, dropdownMatchSelectWidth = _React$useContext.dropdownMatchSelectWidth, treeExpandAction = _React$useContext.treeExpandAction, treeTitleRender = _React$useContext.treeTitleRender, onPopupScroll = _React$useContext.onPopupScroll, leftMaxCount = _React$useContext.leftMaxCount, leafCountOnly = _React$useContext.leafCountOnly, valueEntities = _React$useContext.valueEntities;
	var _React$useContext2 = import_react.useContext(LegacyContext_default), checkable = _React$useContext2.checkable, checkedKeys = _React$useContext2.checkedKeys, halfCheckedKeys = _React$useContext2.halfCheckedKeys, treeExpandedKeys = _React$useContext2.treeExpandedKeys, treeDefaultExpandAll = _React$useContext2.treeDefaultExpandAll, treeDefaultExpandedKeys = _React$useContext2.treeDefaultExpandedKeys, onTreeExpand = _React$useContext2.onTreeExpand, treeIcon = _React$useContext2.treeIcon, showTreeIcon = _React$useContext2.showTreeIcon, switcherIcon = _React$useContext2.switcherIcon, treeLine = _React$useContext2.treeLine, treeNodeFilterProp = _React$useContext2.treeNodeFilterProp, loadData = _React$useContext2.loadData, treeLoadedKeys = _React$useContext2.treeLoadedKeys, treeMotion = _React$useContext2.treeMotion, onTreeLoad = _React$useContext2.onTreeLoad, keyEntities = _React$useContext2.keyEntities;
	var treeRef = import_react.useRef();
	var memoTreeData = useMemo$1(function() {
		return treeData;
	}, [open$2, treeData], function(prev$1, next$1) {
		return next$1[0] && prev$1[1] !== next$1[1];
	});
	var mergedCheckedKeys = import_react.useMemo(function() {
		if (!checkable) return null;
		return {
			checked: checkedKeys,
			halfChecked: halfCheckedKeys
		};
	}, [
		checkable,
		checkedKeys,
		halfCheckedKeys
	]);
	import_react.useEffect(function() {
		if (open$2 && !multiple && checkedKeys.length) {
			var _treeRef$current;
			(_treeRef$current = treeRef.current) === null || _treeRef$current === void 0 || _treeRef$current.scrollTo({ key: checkedKeys[0] });
		}
	}, [open$2]);
	var onListMouseDown = function onListMouseDown$1(event) {
		event.preventDefault();
	};
	var onInternalSelect = function onInternalSelect$1(__, info) {
		var node$1 = info.node;
		if (checkable && isCheckDisabled(node$1)) return;
		onSelect(node$1.key, { selected: !checkedKeys.includes(node$1.key) });
		if (!multiple) toggleOpen(false);
	};
	var _React$useState = import_react.useState(treeDefaultExpandedKeys), _React$useState2 = _slicedToArray(_React$useState, 2), expandedKeys = _React$useState2[0], setExpandedKeys = _React$useState2[1];
	var _React$useState3 = import_react.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), searchExpandedKeys = _React$useState4[0], setSearchExpandedKeys = _React$useState4[1];
	var mergedExpandedKeys = import_react.useMemo(function() {
		if (treeExpandedKeys) return _toConsumableArray(treeExpandedKeys);
		return searchValue ? searchExpandedKeys : expandedKeys;
	}, [
		expandedKeys,
		searchExpandedKeys,
		treeExpandedKeys,
		searchValue
	]);
	var onInternalExpand = function onInternalExpand$1(keys$1) {
		setExpandedKeys(keys$1);
		setSearchExpandedKeys(keys$1);
		if (onTreeExpand) onTreeExpand(keys$1);
	};
	var lowerSearchValue = String(searchValue).toLowerCase();
	var filterTreeNode = function filterTreeNode$1(treeNode) {
		if (!lowerSearchValue) return false;
		return String(treeNode[treeNodeFilterProp]).toLowerCase().includes(lowerSearchValue);
	};
	import_react.useEffect(function() {
		if (searchValue) setSearchExpandedKeys(getAllKeys(treeData, fieldNames));
	}, [searchValue]);
	var _React$useState5 = import_react.useState(function() {
		return /* @__PURE__ */ new Map();
	}), _React$useState6 = _slicedToArray(_React$useState5, 2), disabledCache = _React$useState6[0], setDisabledCache = _React$useState6[1];
	import_react.useEffect(function() {
		if (leftMaxCount) setDisabledCache(/* @__PURE__ */ new Map());
	}, [leftMaxCount]);
	function getDisabledWithCache(node$1) {
		var value = node$1[fieldNames.value];
		if (!disabledCache.has(value)) {
			var entity = valueEntities.get(value);
			if (!((entity.children || []).length === 0)) {
				var checkableChildrenCount = entity.children.filter(function(childTreeNode) {
					return !childTreeNode.node.disabled && !childTreeNode.node.disableCheckbox && !checkedKeys.includes(childTreeNode.node[fieldNames.value]);
				}).length;
				disabledCache.set(value, checkableChildrenCount > leftMaxCount);
			} else disabledCache.set(value, false);
		}
		return disabledCache.get(value);
	}
	var nodeDisabled = useEvent(function(node$1) {
		var nodeValue = node$1[fieldNames.value];
		if (checkedKeys.includes(nodeValue)) return false;
		if (leftMaxCount === null) return false;
		if (leftMaxCount <= 0) return true;
		if (leafCountOnly && leftMaxCount) return getDisabledWithCache(node$1);
		return false;
	});
	var getFirstMatchingNode = function getFirstMatchingNode$1(nodes) {
		var _iterator = _createForOfIteratorHelper(nodes), _step;
		try {
			for (_iterator.s(); !(_step = _iterator.n()).done;) {
				var node$1 = _step.value;
				if (node$1.disabled || node$1.selectable === false) continue;
				if (searchValue) {
					if (filterTreeNode(node$1)) return node$1;
				} else return node$1;
				if (node$1[fieldNames.children]) {
					var matchInChildren = getFirstMatchingNode$1(node$1[fieldNames.children]);
					if (matchInChildren) return matchInChildren;
				}
			}
		} catch (err) {
			_iterator.e(err);
		} finally {
			_iterator.f();
		}
		return null;
	};
	var _React$useState7 = import_react.useState(null), _React$useState8 = _slicedToArray(_React$useState7, 2), activeKey = _React$useState8[0], setActiveKey = _React$useState8[1];
	var activeEntity = keyEntities[activeKey];
	import_react.useEffect(function() {
		if (!open$2) return;
		var nextActiveKey = null;
		var getFirstNode = function getFirstNode$1() {
			var firstNode = getFirstMatchingNode(memoTreeData);
			return firstNode ? firstNode[fieldNames.value] : null;
		};
		if (!multiple && checkedKeys.length && !searchValue) nextActiveKey = checkedKeys[0];
		else nextActiveKey = getFirstNode();
		setActiveKey(nextActiveKey);
	}, [open$2, searchValue]);
	import_react.useImperativeHandle(ref, function() {
		var _treeRef$current2;
		return {
			scrollTo: (_treeRef$current2 = treeRef.current) === null || _treeRef$current2 === void 0 ? void 0 : _treeRef$current2.scrollTo,
			onKeyDown: function onKeyDown$1(event) {
				var _treeRef$current3;
				switch (event.which) {
					case KeyCode_default.UP:
					case KeyCode_default.DOWN:
					case KeyCode_default.LEFT:
					case KeyCode_default.RIGHT:
						(_treeRef$current3 = treeRef.current) === null || _treeRef$current3 === void 0 || _treeRef$current3.onKeyDown(event);
						break;
					case KeyCode_default.ENTER:
						if (activeEntity) {
							var isNodeDisabled = nodeDisabled(activeEntity.node);
							var _ref = (activeEntity === null || activeEntity === void 0 ? void 0 : activeEntity.node) || {}, selectable = _ref.selectable, value = _ref.value, disabled = _ref.disabled;
							if (selectable !== false && !disabled && !isNodeDisabled) onInternalSelect(null, {
								node: { key: activeKey },
								selected: !checkedKeys.includes(value)
							});
						}
						break;
					case KeyCode_default.ESC: toggleOpen(false);
				}
			},
			onKeyUp: function onKeyUp() {}
		};
	});
	var syncLoadData = useMemo$1(function() {
		return searchValue ? false : true;
	}, [searchValue, treeExpandedKeys || expandedKeys], function(_ref2, _ref3) {
		var _ref4 = _slicedToArray(_ref2, 1), preSearchValue = _ref4[0];
		var _ref5 = _slicedToArray(_ref3, 2), nextSearchValue = _ref5[0], nextExcludeSearchExpandedKeys = _ref5[1];
		return preSearchValue !== nextSearchValue && !!(nextSearchValue || nextExcludeSearchExpandedKeys);
	}) ? loadData : null;
	if (memoTreeData.length === 0) return /* @__PURE__ */ import_react.createElement("div", {
		role: "listbox",
		className: "".concat(prefixCls, "-empty"),
		onMouseDown: onListMouseDown
	}, notFoundContent);
	var treeProps = { fieldNames };
	if (treeLoadedKeys) treeProps.loadedKeys = treeLoadedKeys;
	if (mergedExpandedKeys) treeProps.expandedKeys = mergedExpandedKeys;
	return /* @__PURE__ */ import_react.createElement("div", { onMouseDown: onListMouseDown }, activeEntity && open$2 && /* @__PURE__ */ import_react.createElement("span", {
		style: HIDDEN_STYLE,
		"aria-live": "assertive"
	}, activeEntity.node.value), /* @__PURE__ */ import_react.createElement(UnstableContext.Provider, { value: { nodeDisabled } }, /* @__PURE__ */ import_react.createElement(es_default$4, _extends({
		ref: treeRef,
		focusable: false,
		prefixCls: "".concat(prefixCls, "-tree"),
		treeData: memoTreeData,
		height: listHeight,
		itemHeight: listItemHeight,
		itemScrollOffset: listItemScrollOffset,
		virtual: virtual !== false && dropdownMatchSelectWidth !== false,
		multiple,
		icon: treeIcon,
		showIcon: showTreeIcon,
		switcherIcon,
		showLine: treeLine,
		loadData: syncLoadData,
		motion: treeMotion,
		activeKey,
		checkable,
		checkStrictly: true,
		checkedKeys: mergedCheckedKeys,
		selectedKeys: !checkable ? checkedKeys : [],
		defaultExpandAll: treeDefaultExpandAll,
		titleRender: treeTitleRender
	}, treeProps, {
		onActiveChange: setActiveKey,
		onSelect: onInternalSelect,
		onCheck: onInternalSelect,
		onExpand: onInternalExpand,
		onLoad: onTreeLoad,
		filterTreeNode,
		expandAction: treeExpandAction,
		onScroll: onPopupScroll
	}))));
});
RefOptionList.displayName = "OptionList";
var OptionList_default = RefOptionList;

//#endregion
//#region node_modules/rc-tree-select/es/utils/strategyUtil.js
var SHOW_ALL = "SHOW_ALL";
var SHOW_PARENT = "SHOW_PARENT";
var SHOW_CHILD = "SHOW_CHILD";
function formatStrategyValues(values, strategy, keyEntities, fieldNames) {
	var valueSet = new Set(values);
	if (strategy === SHOW_CHILD) return values.filter(function(key) {
		var entity = keyEntities[key];
		return !entity || !entity.children || !entity.children.some(function(_ref) {
			var node$1 = _ref.node;
			return valueSet.has(node$1[fieldNames.value]);
		}) || !entity.children.every(function(_ref2) {
			var node$1 = _ref2.node;
			return isCheckDisabled(node$1) || valueSet.has(node$1[fieldNames.value]);
		});
	});
	if (strategy === SHOW_PARENT) return values.filter(function(key) {
		var entity = keyEntities[key];
		var parent = entity ? entity.parent : null;
		return !parent || isCheckDisabled(parent.node) || !valueSet.has(parent.key);
	});
	return values;
}

//#endregion
//#region node_modules/rc-tree-select/es/utils/warningPropsUtil.js
function warningProps(props) {
	var searchPlaceholder = props.searchPlaceholder, treeCheckStrictly = props.treeCheckStrictly, treeCheckable = props.treeCheckable, labelInValue = props.labelInValue, value = props.value, multiple = props.multiple, showCheckedStrategy = props.showCheckedStrategy, maxCount = props.maxCount;
	warning_default(!searchPlaceholder, "`searchPlaceholder` has been removed.");
	if (treeCheckStrictly && labelInValue === false) warning_default(false, "`treeCheckStrictly` will force set `labelInValue` to `true`.");
	if (labelInValue || treeCheckStrictly) warning_default(toArray$1(value).every(function(val) {
		return val && _typeof(val) === "object" && "value" in val;
	}), "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead.");
	if (treeCheckStrictly || multiple || treeCheckable) warning_default(!value || Array.isArray(value), "`value` should be an array when `TreeSelect` is checkable or multiple.");
	else warning_default(!Array.isArray(value), "`value` should not be array when `TreeSelect` is single mode.");
	if (maxCount && (showCheckedStrategy === "SHOW_ALL" && !treeCheckStrictly || showCheckedStrategy === "SHOW_PARENT")) warning_default(false, "`maxCount` not work with `showCheckedStrategy=SHOW_ALL` (when `treeCheckStrictly=false`) or `showCheckedStrategy=SHOW_PARENT`.");
}
var warningPropsUtil_default = warningProps;

//#endregion
//#region node_modules/rc-tree-select/es/TreeSelect.js
var _excluded$1 = [
	"id",
	"prefixCls",
	"value",
	"defaultValue",
	"onChange",
	"onSelect",
	"onDeselect",
	"searchValue",
	"inputValue",
	"onSearch",
	"autoClearSearchValue",
	"filterTreeNode",
	"treeNodeFilterProp",
	"showCheckedStrategy",
	"treeNodeLabelProp",
	"multiple",
	"treeCheckable",
	"treeCheckStrictly",
	"labelInValue",
	"maxCount",
	"fieldNames",
	"treeDataSimpleMode",
	"treeData",
	"children",
	"loadData",
	"treeLoadedKeys",
	"onTreeLoad",
	"treeDefaultExpandAll",
	"treeExpandedKeys",
	"treeDefaultExpandedKeys",
	"onTreeExpand",
	"treeExpandAction",
	"virtual",
	"listHeight",
	"listItemHeight",
	"listItemScrollOffset",
	"onDropdownVisibleChange",
	"dropdownMatchSelectWidth",
	"treeLine",
	"treeIcon",
	"showTreeIcon",
	"switcherIcon",
	"treeMotion",
	"treeTitleRender",
	"onPopupScroll"
];
function isRawValue(value) {
	return !value || _typeof(value) !== "object";
}
var TreeSelect$1 = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var id = props.id, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tree-select" : _props$prefixCls, value = props.value, defaultValue = props.defaultValue, onChange = props.onChange, onSelect = props.onSelect, onDeselect = props.onDeselect, searchValue = props.searchValue, inputValue = props.inputValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, filterTreeNode = props.filterTreeNode, _props$treeNodeFilter = props.treeNodeFilterProp, treeNodeFilterProp = _props$treeNodeFilter === void 0 ? "value" : _props$treeNodeFilter, showCheckedStrategy = props.showCheckedStrategy, treeNodeLabelProp = props.treeNodeLabelProp, multiple = props.multiple, treeCheckable = props.treeCheckable, treeCheckStrictly = props.treeCheckStrictly, labelInValue = props.labelInValue, maxCount = props.maxCount, fieldNames = props.fieldNames, treeDataSimpleMode = props.treeDataSimpleMode, treeData = props.treeData, children = props.children, loadData = props.loadData, treeLoadedKeys = props.treeLoadedKeys, onTreeLoad = props.onTreeLoad, treeDefaultExpandAll = props.treeDefaultExpandAll, treeExpandedKeys = props.treeExpandedKeys, treeDefaultExpandedKeys = props.treeDefaultExpandedKeys, onTreeExpand = props.onTreeExpand, treeExpandAction = props.treeExpandAction, virtual = props.virtual, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, _props$listItemScroll = props.listItemScrollOffset, listItemScrollOffset = _props$listItemScroll === void 0 ? 0 : _props$listItemScroll, onDropdownVisibleChange = props.onDropdownVisibleChange, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, treeLine = props.treeLine, treeIcon = props.treeIcon, showTreeIcon = props.showTreeIcon, switcherIcon = props.switcherIcon, treeMotion = props.treeMotion, treeTitleRender = props.treeTitleRender, onPopupScroll = props.onPopupScroll, restProps = _objectWithoutProperties(props, _excluded$1);
	var mergedId = useId(id);
	var treeConduction = treeCheckable && !treeCheckStrictly;
	var mergedCheckable = treeCheckable || treeCheckStrictly;
	var mergedLabelInValue = treeCheckStrictly || labelInValue;
	var mergedMultiple = mergedCheckable || multiple;
	var _useMergedState = useMergedState(defaultValue, { value }), _useMergedState2 = _slicedToArray(_useMergedState, 2), internalValue = _useMergedState2[0], setInternalValue = _useMergedState2[1];
	var mergedShowCheckedStrategy = import_react.useMemo(function() {
		if (!treeCheckable) return SHOW_ALL;
		return showCheckedStrategy || SHOW_CHILD;
	}, [showCheckedStrategy, treeCheckable]);
	warningPropsUtil_default(props);
	var mergedFieldNames = import_react.useMemo(function() {
		return fillFieldNames(fieldNames);
	}, [JSON.stringify(fieldNames)]);
	var _useMergedState3 = useMergedState("", {
		value: searchValue !== void 0 ? searchValue : inputValue,
		postState: function postState(search) {
			return search || "";
		}
	}), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedSearchValue = _useMergedState4[0], setSearchValue = _useMergedState4[1];
	var onInternalSearch = function onInternalSearch$1(searchText) {
		setSearchValue(searchText);
		onSearch === null || onSearch === void 0 || onSearch(searchText);
	};
	var mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);
	var _useDataEntities = useDataEntities_default(mergedTreeData, mergedFieldNames), keyEntities = _useDataEntities.keyEntities, valueEntities = _useDataEntities.valueEntities;
	/** Get `missingRawValues` which not exist in the tree yet */
	var splitRawValues = import_react.useCallback(function(newRawValues) {
		var missingRawValues = [];
		var existRawValues = [];
		newRawValues.forEach(function(val) {
			if (valueEntities.has(val)) existRawValues.push(val);
			else missingRawValues.push(val);
		});
		return {
			missingRawValues,
			existRawValues
		};
	}, [valueEntities]);
	var filteredTreeData = useFilterTreeData_default(mergedTreeData, mergedSearchValue, {
		fieldNames: mergedFieldNames,
		treeNodeFilterProp,
		filterTreeNode
	});
	var getLabel = import_react.useCallback(function(item) {
		if (item) {
			if (treeNodeLabelProp) return item[treeNodeLabelProp];
			var titleList = mergedFieldNames._title;
			for (var i = 0; i < titleList.length; i += 1) {
				var title = item[titleList[i]];
				if (title !== void 0) return title;
			}
		}
	}, [mergedFieldNames, treeNodeLabelProp]);
	var toLabeledValues = import_react.useCallback(function(draftValues) {
		return toArray$1(draftValues).map(function(val) {
			if (isRawValue(val)) return { value: val };
			return val;
		});
	}, []);
	var convert2LabelValues = import_react.useCallback(function(draftValues) {
		return toLabeledValues(draftValues).map(function(item) {
			var rawLabel = item.label;
			var rawValue = item.value, rawHalfChecked = item.halfChecked;
			var rawDisabled;
			var entity = valueEntities.get(rawValue);
			if (entity) {
				var _rawLabel;
				rawLabel = treeTitleRender ? treeTitleRender(entity.node) : (_rawLabel = rawLabel) !== null && _rawLabel !== void 0 ? _rawLabel : getLabel(entity.node);
				rawDisabled = entity.node.disabled;
			} else if (rawLabel === void 0) rawLabel = toLabeledValues(internalValue).find(function(labeledItem) {
				return labeledItem.value === rawValue;
			}).label;
			return {
				label: rawLabel,
				value: rawValue,
				halfChecked: rawHalfChecked,
				disabled: rawDisabled
			};
		});
	}, [
		valueEntities,
		getLabel,
		toLabeledValues,
		internalValue
	]);
	var rawMixedLabeledValues = import_react.useMemo(function() {
		return toLabeledValues(internalValue === null ? [] : internalValue);
	}, [toLabeledValues, internalValue]);
	var _React$useMemo = import_react.useMemo(function() {
		var fullCheckValues = [];
		var halfCheckValues = [];
		rawMixedLabeledValues.forEach(function(item) {
			if (item.halfChecked) halfCheckValues.push(item);
			else fullCheckValues.push(item);
		});
		return [fullCheckValues, halfCheckValues];
	}, [rawMixedLabeledValues]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), rawLabeledValues = _React$useMemo2[0], rawHalfLabeledValues = _React$useMemo2[1];
	var rawValues = import_react.useMemo(function() {
		return rawLabeledValues.map(function(item) {
			return item.value;
		});
	}, [rawLabeledValues]);
	var _useCheckedKeys = useCheckedKeys_default(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities), _useCheckedKeys2 = _slicedToArray(_useCheckedKeys, 2), rawCheckedValues = _useCheckedKeys2[0], rawHalfCheckedValues = _useCheckedKeys2[1];
	var displayValues = import_react.useMemo(function() {
		var labeledValues = formatStrategyValues(rawCheckedValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames).map(function(key) {
			var _keyEntities$key$node, _keyEntities$key;
			return (_keyEntities$key$node = (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.node) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key[mergedFieldNames.value]) !== null && _keyEntities$key$node !== void 0 ? _keyEntities$key$node : key;
		}).map(function(val) {
			var targetItem = rawLabeledValues.find(function(item) {
				return item.value === val;
			});
			var label = labelInValue ? targetItem === null || targetItem === void 0 ? void 0 : targetItem.label : treeTitleRender === null || treeTitleRender === void 0 ? void 0 : treeTitleRender(targetItem);
			return {
				value: val,
				label
			};
		});
		var rawDisplayValues = convert2LabelValues(labeledValues);
		var firstVal = rawDisplayValues[0];
		if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) return [];
		return rawDisplayValues.map(function(item) {
			var _item$label;
			return _objectSpread2(_objectSpread2({}, item), {}, { label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value });
		});
	}, [
		mergedFieldNames,
		mergedMultiple,
		rawCheckedValues,
		rawLabeledValues,
		convert2LabelValues,
		mergedShowCheckedStrategy,
		keyEntities
	]);
	var _useCache = useCache_default(displayValues), _useCache2 = _slicedToArray(_useCache, 1), cachedDisplayValues = _useCache2[0];
	var mergedMaxCount = import_react.useMemo(function() {
		if (mergedMultiple && (mergedShowCheckedStrategy === "SHOW_CHILD" || treeCheckStrictly || !treeCheckable)) return maxCount;
		return null;
	}, [
		maxCount,
		mergedMultiple,
		treeCheckStrictly,
		mergedShowCheckedStrategy,
		treeCheckable
	]);
	var triggerChange = useRefFunc(function(newRawValues, extra, source) {
		var formattedKeyList = formatStrategyValues(newRawValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);
		if (mergedMaxCount && formattedKeyList.length > mergedMaxCount) return;
		var labeledValues = convert2LabelValues(newRawValues);
		setInternalValue(labeledValues);
		if (autoClearSearchValue) setSearchValue("");
		if (onChange) {
			var eventValues = newRawValues;
			if (treeConduction) eventValues = formattedKeyList.map(function(key) {
				var entity = valueEntities.get(key);
				return entity ? entity.node[mergedFieldNames.value] : key;
			});
			var _ref = extra || {
				triggerValue: void 0,
				selected: void 0
			}, triggerValue = _ref.triggerValue, selected = _ref.selected;
			var returnRawValues = eventValues;
			if (treeCheckStrictly) {
				var halfValues = rawHalfLabeledValues.filter(function(item) {
					return !eventValues.includes(item.value);
				});
				returnRawValues = [].concat(_toConsumableArray(returnRawValues), _toConsumableArray(halfValues));
			}
			var returnLabeledValues = convert2LabelValues(returnRawValues);
			var additionalInfo = {
				preValue: rawLabeledValues,
				triggerValue
			};
			var showPosition = true;
			if (treeCheckStrictly || source === "selection" && !selected) showPosition = false;
			fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData, showPosition, mergedFieldNames);
			if (mergedCheckable) additionalInfo.checked = selected;
			else additionalInfo.selected = selected;
			var returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map(function(item) {
				return item.value;
			});
			onChange(mergedMultiple ? returnValues : returnValues[0], mergedLabelInValue ? null : returnLabeledValues.map(function(item) {
				return item.label;
			}), additionalInfo);
		}
	});
	/** Trigger by option list */
	var onOptionSelect = import_react.useCallback(function(selectedKey, _ref2) {
		var _node$mergedFieldName;
		var selected = _ref2.selected, source = _ref2.source;
		var entity = keyEntities[selectedKey];
		var node$1 = entity === null || entity === void 0 ? void 0 : entity.node;
		var selectedValue = (_node$mergedFieldName = node$1 === null || node$1 === void 0 ? void 0 : node$1[mergedFieldNames.value]) !== null && _node$mergedFieldName !== void 0 ? _node$mergedFieldName : selectedKey;
		if (!mergedMultiple) triggerChange([selectedValue], {
			selected: true,
			triggerValue: selectedValue
		}, "option");
		else {
			var newRawValues = selected ? [].concat(_toConsumableArray(rawValues), [selectedValue]) : rawCheckedValues.filter(function(v) {
				return v !== selectedValue;
			});
			if (treeConduction) {
				var _splitRawValues = splitRawValues(newRawValues), missingRawValues = _splitRawValues.missingRawValues;
				var keyList = _splitRawValues.existRawValues.map(function(val) {
					return valueEntities.get(val).key;
				});
				var checkedKeys;
				if (selected) checkedKeys = conductCheck(keyList, true, keyEntities).checkedKeys;
				else checkedKeys = conductCheck(keyList, {
					checked: false,
					halfCheckedKeys: rawHalfCheckedValues
				}, keyEntities).checkedKeys;
				newRawValues = [].concat(_toConsumableArray(missingRawValues), _toConsumableArray(checkedKeys.map(function(key) {
					return keyEntities[key].node[mergedFieldNames.value];
				})));
			}
			triggerChange(newRawValues, {
				selected,
				triggerValue: selectedValue
			}, source || "option");
		}
		if (selected || !mergedMultiple) onSelect === null || onSelect === void 0 || onSelect(selectedValue, fillLegacyProps(node$1));
		else onDeselect === null || onDeselect === void 0 || onDeselect(selectedValue, fillLegacyProps(node$1));
	}, [
		splitRawValues,
		valueEntities,
		keyEntities,
		mergedFieldNames,
		mergedMultiple,
		rawValues,
		triggerChange,
		treeConduction,
		onSelect,
		onDeselect,
		rawCheckedValues,
		rawHalfCheckedValues,
		maxCount
	]);
	var onInternalDropdownVisibleChange = import_react.useCallback(function(open$2) {
		if (onDropdownVisibleChange) {
			var legacyParam = {};
			Object.defineProperty(legacyParam, "documentClickClose", { get: function get$1() {
				warning_default(false, "Second param of `onDropdownVisibleChange` has been removed.");
				return false;
			} });
			onDropdownVisibleChange(open$2, legacyParam);
		}
	}, [onDropdownVisibleChange]);
	var onDisplayValuesChange = useRefFunc(function(newValues, info) {
		var newRawValues = newValues.map(function(item) {
			return item.value;
		});
		if (info.type === "clear") {
			triggerChange(newRawValues, {}, "selection");
			return;
		}
		if (info.values.length) onOptionSelect(info.values[0].value, {
			selected: false,
			source: "selection"
		});
	});
	var treeSelectContext = import_react.useMemo(function() {
		return {
			virtual,
			dropdownMatchSelectWidth,
			listHeight,
			listItemHeight,
			listItemScrollOffset,
			treeData: filteredTreeData,
			fieldNames: mergedFieldNames,
			onSelect: onOptionSelect,
			treeExpandAction,
			treeTitleRender,
			onPopupScroll,
			leftMaxCount: maxCount === void 0 ? null : maxCount - cachedDisplayValues.length,
			leafCountOnly: mergedShowCheckedStrategy === "SHOW_CHILD" && !treeCheckStrictly && !!treeCheckable,
			valueEntities
		};
	}, [
		virtual,
		dropdownMatchSelectWidth,
		listHeight,
		listItemHeight,
		listItemScrollOffset,
		filteredTreeData,
		mergedFieldNames,
		onOptionSelect,
		treeExpandAction,
		treeTitleRender,
		onPopupScroll,
		maxCount,
		cachedDisplayValues.length,
		mergedShowCheckedStrategy,
		treeCheckStrictly,
		treeCheckable,
		valueEntities
	]);
	var legacyContext = import_react.useMemo(function() {
		return {
			checkable: mergedCheckable,
			loadData,
			treeLoadedKeys,
			onTreeLoad,
			checkedKeys: rawCheckedValues,
			halfCheckedKeys: rawHalfCheckedValues,
			treeDefaultExpandAll,
			treeExpandedKeys,
			treeDefaultExpandedKeys,
			onTreeExpand,
			treeIcon,
			treeMotion,
			showTreeIcon,
			switcherIcon,
			treeLine,
			treeNodeFilterProp,
			keyEntities
		};
	}, [
		mergedCheckable,
		loadData,
		treeLoadedKeys,
		onTreeLoad,
		rawCheckedValues,
		rawHalfCheckedValues,
		treeDefaultExpandAll,
		treeExpandedKeys,
		treeDefaultExpandedKeys,
		onTreeExpand,
		treeIcon,
		treeMotion,
		showTreeIcon,
		switcherIcon,
		treeLine,
		treeNodeFilterProp,
		keyEntities
	]);
	return /* @__PURE__ */ import_react.createElement(TreeSelectContext_default.Provider, { value: treeSelectContext }, /* @__PURE__ */ import_react.createElement(LegacyContext_default.Provider, { value: legacyContext }, /* @__PURE__ */ import_react.createElement(BaseSelect_default, _extends({ ref }, restProps, {
		id: mergedId,
		prefixCls,
		mode: mergedMultiple ? "multiple" : void 0,
		displayValues: cachedDisplayValues,
		onDisplayValuesChange,
		searchValue: mergedSearchValue,
		onSearch: onInternalSearch,
		OptionList: OptionList_default,
		emptyOptions: !mergedTreeData.length,
		onDropdownVisibleChange: onInternalDropdownVisibleChange,
		dropdownMatchSelectWidth
	}))));
});
TreeSelect$1.displayName = "TreeSelect";
var GenericTreeSelect = TreeSelect$1;
GenericTreeSelect.TreeNode = TreeNode_default;
GenericTreeSelect.SHOW_ALL = SHOW_ALL;
GenericTreeSelect.SHOW_PARENT = SHOW_PARENT;
GenericTreeSelect.SHOW_CHILD = SHOW_CHILD;
var TreeSelect_default = GenericTreeSelect;

//#endregion
//#region node_modules/rc-tree-select/es/index.js
var es_default$3 = TreeSelect_default;

//#endregion
//#region node_modules/antd/es/tree-select/style/index.js
var genBaseStyle$1 = (token$1) => {
	const { componentCls, treePrefixCls, colorBgElevated } = token$1;
	const treeCls = `.${treePrefixCls}`;
	return [{ [`${componentCls}-dropdown`]: [
		{ padding: `${unit(token$1.paddingXS)} ${unit(token$1.calc(token$1.paddingXS).div(2).equal())}` },
		genTreeStyle(treePrefixCls, merge(token$1, { colorBgContainer: colorBgElevated }), false),
		{ [treeCls]: {
			borderRadius: 0,
			[`${treeCls}-list-holder-inner`]: {
				alignItems: "stretch",
				[`${treeCls}-treenode`]: { [`${treeCls}-node-content-wrapper`]: { flex: "auto" } }
			}
		} },
		getStyle(`${treePrefixCls}-checkbox`, token$1),
		{ "&-rtl": {
			direction: "rtl",
			[`${treeCls}-switcher${treeCls}-switcher_close`]: { [`${treeCls}-switcher-icon svg`]: { transform: "rotate(90deg)" } }
		} }
	] }];
};
function useTreeSelectStyle(prefixCls, treePrefixCls, rootCls) {
	return genStyleHooks("TreeSelect", (token$1) => {
		const treeSelectToken = merge(token$1, { treePrefixCls });
		return genBaseStyle$1(treeSelectToken);
	}, initComponentToken)(prefixCls, rootCls);
}

//#endregion
//#region node_modules/antd/es/tree-select/index.js
var import_classnames$12 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$7 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var InternalTreeSelect = (props, ref) => {
	var _a, _b, _c, _d, _e;
	const { prefixCls: customizePrefixCls, size: customizeSize, disabled: customDisabled, bordered = true, style: style$1, className, rootClassName, treeCheckable, multiple, listHeight = 256, listItemHeight: customListItemHeight, placement, notFoundContent, switcherIcon, treeLine, getPopupContainer, popupClassName, dropdownClassName, treeIcon = false, transitionName, choiceTransitionName = "", status: customStatus, treeExpandAction, builtinPlacements, dropdownMatchSelectWidth, popupMatchSelectWidth, allowClear, variant: customVariant, dropdownStyle, dropdownRender, popupRender, onDropdownVisibleChange, onOpenChange, tagRender, maxCount, showCheckedStrategy, treeCheckStrictly, styles, classNames: classNames$252 } = props, restProps = __rest$7(props, [
		"prefixCls",
		"size",
		"disabled",
		"bordered",
		"style",
		"className",
		"rootClassName",
		"treeCheckable",
		"multiple",
		"listHeight",
		"listItemHeight",
		"placement",
		"notFoundContent",
		"switcherIcon",
		"treeLine",
		"getPopupContainer",
		"popupClassName",
		"dropdownClassName",
		"treeIcon",
		"transitionName",
		"choiceTransitionName",
		"status",
		"treeExpandAction",
		"builtinPlacements",
		"dropdownMatchSelectWidth",
		"popupMatchSelectWidth",
		"allowClear",
		"variant",
		"dropdownStyle",
		"dropdownRender",
		"popupRender",
		"onDropdownVisibleChange",
		"onOpenChange",
		"tagRender",
		"maxCount",
		"showCheckedStrategy",
		"treeCheckStrictly",
		"styles",
		"classNames"
	]);
	const { getPopupContainer: getContextPopupContainer, getPrefixCls, renderEmpty, direction, virtual, popupMatchSelectWidth: contextPopupMatchSelectWidth, popupOverflow } = import_react.useContext(ConfigContext);
	const { styles: contextStyles, classNames: contextClassNames } = useComponentConfig("treeSelect");
	const [, token$1] = useToken();
	const listItemHeight = customListItemHeight !== null && customListItemHeight !== void 0 ? customListItemHeight : (token$1 === null || token$1 === void 0 ? void 0 : token$1.controlHeightSM) + (token$1 === null || token$1 === void 0 ? void 0 : token$1.paddingXXS);
	{
		const warning$4 = devUseWarning("TreeSelect");
		Object.entries({
			dropdownMatchSelectWidth: "popupMatchSelectWidth",
			dropdownStyle: "styles.popup.root",
			dropdownClassName: "classNames.popup.root",
			popupClassName: "classNames.popup.root",
			dropdownRender: "popupRender",
			onDropdownVisibleChange: "onOpenChange",
			bordered: "variant"
		}).forEach(([oldProp, newProp]) => {
			warning$4.deprecated(!(oldProp in props), oldProp, newProp);
		});
		warning$4(multiple !== false || !treeCheckable, "usage", "`multiple` will always be `true` when `treeCheckable` is true");
		warning$4(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.");
	}
	const rootPrefixCls = getPrefixCls();
	const prefixCls = getPrefixCls("select", customizePrefixCls);
	const treePrefixCls = getPrefixCls("select-tree", customizePrefixCls);
	const treeSelectPrefixCls = getPrefixCls("tree-select", customizePrefixCls);
	const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
	const rootCls = useCSSVarCls_default(prefixCls);
	const treeSelectRootCls = useCSSVarCls_default(treeSelectPrefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default$3(prefixCls, rootCls);
	const [treeSelectWrapCSSVar] = useTreeSelectStyle(treeSelectPrefixCls, treePrefixCls, treeSelectRootCls);
	const [variant, enableVariantCls] = useVariants_default("treeSelect", customVariant, bordered);
	const mergedPopupClassName = (0, import_classnames$12.default)(((_a = classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.popup) === null || _a === void 0 ? void 0 : _a.root) || ((_b = contextClassNames === null || contextClassNames === void 0 ? void 0 : contextClassNames.popup) === null || _b === void 0 ? void 0 : _b.root) || popupClassName || dropdownClassName, `${treeSelectPrefixCls}-dropdown`, { [`${treeSelectPrefixCls}-dropdown-rtl`]: direction === "rtl" }, rootClassName, contextClassNames.root, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.root, cssVarCls, rootCls, treeSelectRootCls, hashId);
	const mergedPopupStyle = ((_c = styles === null || styles === void 0 ? void 0 : styles.popup) === null || _c === void 0 ? void 0 : _c.root) || ((_d = contextStyles === null || contextStyles === void 0 ? void 0 : contextStyles.popup) === null || _d === void 0 ? void 0 : _d.root) || dropdownStyle;
	const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
	const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
	const isMultiple$1 = !!(treeCheckable || multiple);
	const mergedMaxCount = import_react.useMemo(() => {
		if (maxCount && (showCheckedStrategy === "SHOW_ALL" && !treeCheckStrictly || showCheckedStrategy === "SHOW_PARENT")) return;
		return maxCount;
	}, [
		maxCount,
		showCheckedStrategy,
		treeCheckStrictly
	]);
	const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
	const mergedPopupMatchSelectWidth = (_e = popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth) !== null && _e !== void 0 ? _e : contextPopupMatchSelectWidth;
	const { status: contextStatus, hasFeedback, isFormItemInput, feedbackIcon } = import_react.useContext(FormItemInputContext);
	const mergedStatus = getMergedStatus(contextStatus, customStatus);
	const { suffixIcon, removeIcon, clearIcon } = useIcons(Object.assign(Object.assign({}, restProps), {
		multiple: isMultiple$1,
		showSuffixIcon,
		hasFeedback,
		feedbackIcon,
		prefixCls,
		componentName: "TreeSelect"
	}));
	const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
	let mergedNotFound;
	if (notFoundContent !== void 0) mergedNotFound = notFoundContent;
	else mergedNotFound = (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ import_react.createElement(defaultRenderEmpty_default, { componentName: "Select" });
	const selectProps = omit(restProps, [
		"suffixIcon",
		"removeIcon",
		"clearIcon",
		"itemIcon",
		"switcherIcon",
		"style"
	]);
	const memoizedPlacement = import_react.useMemo(() => {
		if (placement !== void 0) return placement;
		return direction === "rtl" ? "bottomRight" : "bottomLeft";
	}, [placement, direction]);
	const mergedSize = useSize_default((ctx) => {
		var _a$1;
		return (_a$1 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a$1 !== void 0 ? _a$1 : ctx;
	});
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const mergedClassName = (0, import_classnames$12.default)(!customizePrefixCls && treeSelectPrefixCls, {
		[`${prefixCls}-lg`]: mergedSize === "large",
		[`${prefixCls}-sm`]: mergedSize === "small",
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${variant}`]: enableVariantCls,
		[`${prefixCls}-in-form-item`]: isFormItemInput
	}, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, className, rootClassName, contextClassNames.root, classNames$252 === null || classNames$252 === void 0 ? void 0 : classNames$252.root, cssVarCls, rootCls, treeSelectRootCls, hashId);
	const renderSwitcherIcon = (nodeProps) => /* @__PURE__ */ import_react.createElement(iconUtil_default, {
		prefixCls: treePrefixCls,
		switcherIcon,
		treeNodeProps: nodeProps,
		showLine: treeLine
	});
	const [zIndex] = useZIndex("SelectLike", mergedPopupStyle === null || mergedPopupStyle === void 0 ? void 0 : mergedPopupStyle.zIndex);
	const returnNode = /* @__PURE__ */ import_react.createElement(es_default$3, Object.assign({
		virtual,
		disabled: mergedDisabled
	}, selectProps, {
		dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
		builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
		ref,
		prefixCls,
		className: mergedClassName,
		style: Object.assign(Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.root), style$1),
		listHeight,
		listItemHeight,
		treeCheckable: treeCheckable ? /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-tree-checkbox-inner` }) : treeCheckable,
		treeLine: !!treeLine,
		suffixIcon,
		multiple: isMultiple$1,
		placement: memoizedPlacement,
		removeIcon,
		allowClear: mergedAllowClear,
		switcherIcon: renderSwitcherIcon,
		showTreeIcon: treeIcon,
		notFoundContent: mergedNotFound,
		getPopupContainer: getPopupContainer || getContextPopupContainer,
		treeMotion: null,
		dropdownClassName: mergedPopupClassName,
		dropdownStyle: Object.assign(Object.assign({}, mergedPopupStyle), { zIndex }),
		dropdownRender: mergedPopupRender,
		onDropdownVisibleChange: mergedOnOpenChange,
		choiceTransitionName: getTransitionName(rootPrefixCls, "", choiceTransitionName),
		transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
		treeExpandAction,
		tagRender: isMultiple$1 ? tagRender : void 0,
		maxCount: mergedMaxCount,
		showCheckedStrategy,
		treeCheckStrictly
	}));
	return wrapCSSVar(treeSelectWrapCSSVar(returnNode));
};
var TreeSelect = /* @__PURE__ */ import_react.forwardRef(InternalTreeSelect);
/* istanbul ignore next */
var PurePanel = PurePanel_default(TreeSelect, "dropdownAlign", (props) => omit(props, ["visible"]));
TreeSelect.TreeNode = TreeNode_default;
TreeSelect.SHOW_ALL = SHOW_ALL;
TreeSelect.SHOW_PARENT = SHOW_PARENT;
TreeSelect.SHOW_CHILD = SHOW_CHILD;
TreeSelect._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
TreeSelect.displayName = "TreeSelect";
var tree_select_default = TreeSelect;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/EditOutlined.js
var EditOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" }
		}]
	},
	"name": "edit",
	"theme": "outlined"
};
var EditOutlined_default$1 = EditOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/EditOutlined.js
/**![edit](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTI1Ny43IDc1MmMyIDAgNC0uMiA2LS41TDQzMS45IDcyMmMyLS40IDMuOS0xLjMgNS4zLTIuOGw0MjMuOS00MjMuOWE5Ljk2IDkuOTYgMCAwMDAtMTQuMUw2OTQuOSAxMTQuOWMtMS45LTEuOS00LjQtMi45LTcuMS0yLjlzLTUuMiAxLTcuMSAyLjlMMjU2LjggNTM4LjhjLTEuNSAxLjUtMi40IDMuMy0yLjggNS4zbC0yOS41IDE2OC4yYTMzLjUgMzMuNSAwIDAwOS40IDI5LjhjNi42IDYuNCAxNC45IDkuOSAyMy44IDkuOXptNjcuNC0xNzQuNEw2ODcuOCAyMTVsNzMuMyA3My4zLTM2Mi43IDM2Mi42LTg4LjkgMTUuNyAxNS42LTg5ek04ODAgODM2SDE0NGMtMTcuNyAwLTMyIDE0LjMtMzIgMzJ2MzZjMCA0LjQgMy42IDggOCA4aDc4NGM0LjQgMCA4LTMuNiA4LTh2LTM2YzAtMTcuNy0xNC4zLTMyLTMyLTMyeiIgLz48L3N2Zz4=) */
var RefIcon$6 = /* @__PURE__ */ import_react.forwardRef(function EditOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: EditOutlined_default$1
	}));
});
RefIcon$6.displayName = "EditOutlined";
var EditOutlined_default = RefIcon$6;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/EnterOutlined.js
var EnterOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" }
		}]
	},
	"name": "enter",
	"theme": "outlined"
};
var EnterOutlined_default$1 = EnterOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/EnterOutlined.js
/**![enter](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg2NCAxNzBoLTYwYy00LjQgMC04IDMuNi04IDh2NTE4SDMxMHYtNzNjMC02LjctNy44LTEwLjUtMTMtNi4zbC0xNDEuOSAxMTJhOCA4IDAgMDAwIDEyLjZsMTQxLjkgMTEyYzUuMyA0LjIgMTMgLjQgMTMtNi4zdi03NWg0OThjMzUuMyAwIDY0LTI4LjcgNjQtNjRWMTc4YzAtNC40LTMuNi04LTgtOHoiIC8+PC9zdmc+) */
var RefIcon$5 = /* @__PURE__ */ import_react.forwardRef(function EnterOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: EnterOutlined_default$1
	}));
});
RefIcon$5.displayName = "EnterOutlined";
var EnterOutlined_default = RefIcon$5;

//#endregion
//#region node_modules/antd/es/typography/style/mixins.js
var getTitleStyle = (fontSize, lineHeight, color, token$1) => {
	const { titleMarginBottom, fontWeightStrong } = token$1;
	return {
		marginBottom: titleMarginBottom,
		color,
		fontWeight: fontWeightStrong,
		fontSize,
		lineHeight
	};
};
const getTitleStyles = (token$1) => {
	const headings = [
		1,
		2,
		3,
		4,
		5
	];
	const styles = {};
	headings.forEach((headingLevel) => {
		styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token$1[`fontSizeHeading${headingLevel}`], token$1[`lineHeightHeading${headingLevel}`], token$1.colorTextHeading, token$1);
	});
	return styles;
};
const getLinkStyles = (token$1) => {
	const { componentCls } = token$1;
	return { "a&, a": Object.assign(Object.assign({}, operationUnit(token$1)), {
		userSelect: "text",
		[`&[disabled], &${componentCls}-disabled`]: {
			color: token$1.colorTextDisabled,
			cursor: "not-allowed",
			"&:active, &:hover": { color: token$1.colorTextDisabled },
			"&:active": { pointerEvents: "none" }
		}
	}) };
};
const getResetStyles = (token$1) => ({
	code: {
		margin: "0 0.2em",
		paddingInline: "0.4em",
		paddingBlock: "0.2em 0.1em",
		fontSize: "85%",
		fontFamily: token$1.fontFamilyCode,
		background: "rgba(150, 150, 150, 0.1)",
		border: "1px solid rgba(100, 100, 100, 0.2)",
		borderRadius: 3
	},
	kbd: {
		margin: "0 0.2em",
		paddingInline: "0.4em",
		paddingBlock: "0.15em 0.1em",
		fontSize: "90%",
		fontFamily: token$1.fontFamilyCode,
		background: "rgba(150, 150, 150, 0.06)",
		border: "1px solid rgba(100, 100, 100, 0.2)",
		borderBottomWidth: 2,
		borderRadius: 3
	},
	mark: {
		padding: 0,
		backgroundColor: gold[2]
	},
	"u, ins": {
		textDecoration: "underline",
		textDecorationSkipInk: "auto"
	},
	"s, del": { textDecoration: "line-through" },
	strong: { fontWeight: token$1.fontWeightStrong },
	"ul, ol": {
		marginInline: 0,
		marginBlock: "0 1em",
		padding: 0,
		li: {
			marginInline: "20px 0",
			marginBlock: 0,
			paddingInline: "4px 0",
			paddingBlock: 0
		}
	},
	ul: {
		listStyleType: "circle",
		ul: { listStyleType: "disc" }
	},
	ol: { listStyleType: "decimal" },
	"pre, blockquote": { margin: "1em 0" },
	pre: {
		padding: "0.4em 0.6em",
		whiteSpace: "pre-wrap",
		wordWrap: "break-word",
		background: "rgba(150, 150, 150, 0.1)",
		border: "1px solid rgba(100, 100, 100, 0.2)",
		borderRadius: 3,
		fontFamily: token$1.fontFamilyCode,
		code: {
			display: "inline",
			margin: 0,
			padding: 0,
			fontSize: "inherit",
			fontFamily: "inherit",
			background: "transparent",
			border: 0
		}
	},
	blockquote: {
		paddingInline: "0.6em 0",
		paddingBlock: 0,
		borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
		opacity: .85
	}
});
const getEditableStyles = (token$1) => {
	const { componentCls, paddingSM } = token$1;
	const inputShift = paddingSM;
	return { "&-edit-content": {
		position: "relative",
		"div&": {
			insetInlineStart: token$1.calc(token$1.paddingSM).mul(-1).equal(),
			insetBlockStart: token$1.calc(inputShift).div(-2).add(1).equal(),
			marginBottom: token$1.calc(inputShift).div(2).sub(2).equal()
		},
		[`${componentCls}-edit-content-confirm`]: {
			position: "absolute",
			insetInlineEnd: token$1.calc(token$1.marginXS).add(2).equal(),
			insetBlockEnd: token$1.marginXS,
			color: token$1.colorIcon,
			fontWeight: "normal",
			fontSize: token$1.fontSize,
			fontStyle: "normal",
			pointerEvents: "none"
		},
		textarea: {
			margin: "0!important",
			MozTransition: "none",
			height: "1em"
		}
	} };
};
const getCopyableStyles = (token$1) => ({
	[`${token$1.componentCls}-copy-success`]: { [`
    &,
    &:hover,
    &:focus`]: { color: token$1.colorSuccess } },
	[`${token$1.componentCls}-copy-icon-only`]: { marginInlineStart: 0 }
});
const getEllipsisStyles = () => ({
	[`
  a&-ellipsis,
  span&-ellipsis
  `]: {
		display: "inline-block",
		maxWidth: "100%"
	},
	"&-ellipsis-single-line": {
		whiteSpace: "nowrap",
		overflow: "hidden",
		textOverflow: "ellipsis",
		"a&, span&": { verticalAlign: "bottom" },
		"> code": {
			paddingBlock: 0,
			maxWidth: "calc(100% - 1.2em)",
			display: "inline-block",
			overflow: "hidden",
			textOverflow: "ellipsis",
			verticalAlign: "bottom",
			boxSizing: "content-box"
		}
	},
	"&-ellipsis-multiple-line": {
		display: "-webkit-box",
		overflow: "hidden",
		WebkitLineClamp: 3,
		WebkitBoxOrient: "vertical"
	}
});

//#endregion
//#region node_modules/antd/es/typography/style/index.js
var genTypographyStyle = (token$1) => {
	const { componentCls, titleMarginTop } = token$1;
	return { [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
		color: token$1.colorText,
		wordBreak: "break-word",
		lineHeight: token$1.lineHeight,
		[`&${componentCls}-secondary`]: { color: token$1.colorTextDescription },
		[`&${componentCls}-success`]: { color: token$1.colorSuccessText },
		[`&${componentCls}-warning`]: { color: token$1.colorWarningText },
		[`&${componentCls}-danger`]: {
			color: token$1.colorErrorText,
			"a&:active, a&:focus": { color: token$1.colorErrorTextActive },
			"a&:hover": { color: token$1.colorErrorTextHover }
		},
		[`&${componentCls}-disabled`]: {
			color: token$1.colorTextDisabled,
			cursor: "not-allowed",
			userSelect: "none"
		},
		[`
        div&,
        p
      `]: { marginBottom: "1em" }
	}, getTitleStyles(token$1)), {
		[`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: { marginTop: titleMarginTop },
		[`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: { [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: { marginTop: titleMarginTop } }
	}), getResetStyles(token$1)), getLinkStyles(token$1)), { [`
        ${componentCls}-expand,
        ${componentCls}-collapse,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: Object.assign(Object.assign({}, operationUnit(token$1)), { marginInlineStart: token$1.marginXXS }) }), getEditableStyles(token$1)), getCopyableStyles(token$1)), getEllipsisStyles()), { "&-rtl": { direction: "rtl" } }) };
};
const prepareComponentToken$2 = () => ({
	titleMarginTop: "1.2em",
	titleMarginBottom: "0.5em"
});
var style_default$2 = genStyleHooks("Typography", genTypographyStyle, prepareComponentToken$2);

//#endregion
//#region node_modules/antd/es/typography/Editable.js
var import_classnames$11 = /* @__PURE__ */ __toESM(require_classnames());
var Editable = (props) => {
	const { prefixCls, "aria-label": ariaLabel, className, style: style$1, direction, maxLength, autoSize = true, value, onSave, onCancel, onEnd, component, enterIcon = /* @__PURE__ */ import_react.createElement(EnterOutlined_default, null) } = props;
	const ref = import_react.useRef(null);
	const inComposition = import_react.useRef(false);
	const lastKeyCode = import_react.useRef(null);
	const [current, setCurrent] = import_react.useState(value);
	import_react.useEffect(() => {
		setCurrent(value);
	}, [value]);
	import_react.useEffect(() => {
		var _a;
		if ((_a = ref.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea) {
			const { textArea } = ref.current.resizableTextArea;
			textArea.focus();
			const { length: length$1 } = textArea.value;
			textArea.setSelectionRange(length$1, length$1);
		}
	}, []);
	const onChange = ({ target }) => {
		setCurrent(target.value.replace(/[\n\r]/g, ""));
	};
	const onCompositionStart = () => {
		inComposition.current = true;
	};
	const onCompositionEnd = () => {
		inComposition.current = false;
	};
	const onKeyDown$1 = ({ keyCode }) => {
		if (inComposition.current) return;
		lastKeyCode.current = keyCode;
	};
	const confirmChange = () => {
		onSave(current.trim());
	};
	const onKeyUp = ({ keyCode, ctrlKey, altKey, metaKey, shiftKey }) => {
		if (lastKeyCode.current !== keyCode || inComposition.current || ctrlKey || altKey || metaKey || shiftKey) return;
		if (keyCode === KeyCode_default.ENTER) {
			confirmChange();
			onEnd === null || onEnd === void 0 || onEnd();
		} else if (keyCode === KeyCode_default.ESC) onCancel();
	};
	const onBlur = () => {
		confirmChange();
	};
	const [wrapCSSVar, hashId, cssVarCls] = style_default$2(prefixCls);
	const textAreaClassName = (0, import_classnames$11.default)(prefixCls, `${prefixCls}-edit-content`, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-${component}`]: !!component
	}, className, hashId, cssVarCls);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("div", {
		className: textAreaClassName,
		style: style$1
	}, /* @__PURE__ */ import_react.createElement(TextArea_default, {
		ref,
		maxLength,
		value: current,
		onChange,
		onKeyDown: onKeyDown$1,
		onKeyUp,
		onCompositionStart,
		onCompositionEnd,
		onBlur,
		"aria-label": ariaLabel,
		rows: 1,
		autoSize
	}), enterIcon !== null ? cloneElement(enterIcon, { className: `${prefixCls}-edit-content-confirm` }) : null));
};
var Editable_default = Editable;

//#endregion
//#region node_modules/toggle-selection/index.js
var require_toggle_selection = /* @__PURE__ */ __commonJS({ "node_modules/toggle-selection/index.js": ((exports, module) => {
	module.exports = function() {
		var selection = document.getSelection();
		if (!selection.rangeCount) return function() {};
		var active = document.activeElement;
		var ranges = [];
		for (var i = 0; i < selection.rangeCount; i++) ranges.push(selection.getRangeAt(i));
		switch (active.tagName.toUpperCase()) {
			case "INPUT":
			case "TEXTAREA":
				active.blur();
				break;
			default:
				active = null;
				break;
		}
		selection.removeAllRanges();
		return function() {
			selection.type === "Caret" && selection.removeAllRanges();
			if (!selection.rangeCount) ranges.forEach(function(range$1) {
				selection.addRange(range$1);
			});
			active && active.focus();
		};
	};
}) });

//#endregion
//#region node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = /* @__PURE__ */ __commonJS({ "node_modules/copy-to-clipboard/index.js": ((exports, module) => {
	var deselectCurrent = require_toggle_selection();
	var clipboardToIE11Formatting = {
		"text/plain": "Text",
		"text/html": "Url",
		"default": "Text"
	};
	var defaultMessage = "Copy to clipboard: #{key}, Enter";
	function format(message$1) {
		var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
		return message$1.replace(/#{\s*key\s*}/g, copyKey);
	}
	function copy$1(text, options) {
		var debug, message$1, reselectPrevious, range$1, selection, mark, success = false;
		if (!options) options = {};
		debug = options.debug || false;
		try {
			reselectPrevious = deselectCurrent();
			range$1 = document.createRange();
			selection = document.getSelection();
			mark = document.createElement("span");
			mark.textContent = text;
			mark.ariaHidden = "true";
			mark.style.all = "unset";
			mark.style.position = "fixed";
			mark.style.top = 0;
			mark.style.clip = "rect(0, 0, 0, 0)";
			mark.style.whiteSpace = "pre";
			mark.style.webkitUserSelect = "text";
			mark.style.MozUserSelect = "text";
			mark.style.msUserSelect = "text";
			mark.style.userSelect = "text";
			mark.addEventListener("copy", function(e$2) {
				e$2.stopPropagation();
				if (options.format) {
					e$2.preventDefault();
					if (typeof e$2.clipboardData === "undefined") {
						debug && console.warn("unable to use e.clipboardData");
						debug && console.warn("trying IE specific stuff");
						window.clipboardData.clearData();
						var format$2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
						window.clipboardData.setData(format$2, text);
					} else {
						e$2.clipboardData.clearData();
						e$2.clipboardData.setData(options.format, text);
					}
				}
				if (options.onCopy) {
					e$2.preventDefault();
					options.onCopy(e$2.clipboardData);
				}
			});
			document.body.appendChild(mark);
			range$1.selectNodeContents(mark);
			selection.addRange(range$1);
			if (!document.execCommand("copy")) throw new Error("copy command was unsuccessful");
			success = true;
		} catch (err) {
			debug && console.error("unable to copy using execCommand: ", err);
			debug && console.warn("trying IE specific stuff");
			try {
				window.clipboardData.setData(options.format || "text", text);
				options.onCopy && options.onCopy(window.clipboardData);
				success = true;
			} catch (err$1) {
				debug && console.error("unable to copy using clipboardData: ", err$1);
				debug && console.error("falling back to prompt");
				message$1 = format("message" in options ? options.message : defaultMessage);
				window.prompt(message$1, text);
			}
		} finally {
			if (selection) if (typeof selection.removeRange == "function") selection.removeRange(range$1);
			else selection.removeAllRanges();
			if (mark) document.body.removeChild(mark);
			reselectPrevious();
		}
		return success;
	}
	module.exports = copy$1;
}) });

//#endregion
//#region node_modules/antd/es/typography/hooks/useCopyClick.js
var import_copy_to_clipboard = /* @__PURE__ */ __toESM(require_copy_to_clipboard());
var __awaiter$1 = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator$1) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator$1.next(value));
			} catch (e$2) {
				reject(e$2);
			}
		}
		function rejected(value) {
			try {
				step(generator$1["throw"](value));
			} catch (e$2) {
				reject(e$2);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator$1 = generator$1.apply(thisArg, _arguments || [])).next());
	});
};
var useCopyClick = ({ copyConfig, children }) => {
	const [copied, setCopied] = import_react.useState(false);
	const [copyLoading, setCopyLoading] = import_react.useState(false);
	const copyIdRef = import_react.useRef(null);
	const cleanCopyId = () => {
		if (copyIdRef.current) clearTimeout(copyIdRef.current);
	};
	const copyOptions = {};
	if (copyConfig.format) copyOptions.format = copyConfig.format;
	import_react.useEffect(() => cleanCopyId, []);
	const onClick = useEvent((e$2) => __awaiter$1(void 0, void 0, void 0, function* () {
		var _a;
		e$2 === null || e$2 === void 0 || e$2.preventDefault();
		e$2 === null || e$2 === void 0 || e$2.stopPropagation();
		setCopyLoading(true);
		try {
			const text = typeof copyConfig.text === "function" ? yield copyConfig.text() : copyConfig.text;
			(0, import_copy_to_clipboard.default)(text || toList_default(children, true).join("") || "", copyOptions);
			setCopyLoading(false);
			setCopied(true);
			cleanCopyId();
			copyIdRef.current = setTimeout(() => {
				setCopied(false);
			}, 3e3);
			(_a = copyConfig.onCopy) === null || _a === void 0 || _a.call(copyConfig, e$2);
		} catch (error) {
			setCopyLoading(false);
			throw error;
		}
	}));
	return {
		copied,
		copyLoading,
		onClick
	};
};
var useCopyClick_default = useCopyClick;

//#endregion
//#region node_modules/antd/es/typography/hooks/useMergedConfig.js
function useMergedConfig(propConfig, templateConfig) {
	return import_react.useMemo(() => {
		const support = !!propConfig;
		return [support, Object.assign(Object.assign({}, templateConfig), support && typeof propConfig === "object" ? propConfig : null)];
	}, [propConfig]);
}

//#endregion
//#region node_modules/antd/es/typography/hooks/usePrevious.js
var usePrevious = (value) => {
	const ref = (0, import_react.useRef)(void 0);
	(0, import_react.useEffect)(() => {
		ref.current = value;
	});
	return ref.current;
};
var usePrevious_default = usePrevious;

//#endregion
//#region node_modules/antd/es/typography/hooks/useTooltipProps.js
var useTooltipProps = (tooltip, editConfigText, children) => (0, import_react.useMemo)(() => {
	if (tooltip === true) return { title: editConfigText !== null && editConfigText !== void 0 ? editConfigText : children };
	if (/* @__PURE__ */ (0, import_react.isValidElement)(tooltip)) return { title: tooltip };
	if (typeof tooltip === "object") return Object.assign({ title: editConfigText !== null && editConfigText !== void 0 ? editConfigText : children }, tooltip);
	return { title: tooltip };
}, [
	tooltip,
	editConfigText,
	children
]);
var useTooltipProps_default = useTooltipProps;

//#endregion
//#region node_modules/antd/es/typography/Typography.js
var import_classnames$10 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$6 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Typography$1 = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { prefixCls: customizePrefixCls, component: Component$2 = "article", className, rootClassName, setContentRef, children, direction: typographyDirection, style: style$1 } = props, restProps = __rest$6(props, [
		"prefixCls",
		"component",
		"className",
		"rootClassName",
		"setContentRef",
		"children",
		"direction",
		"style"
	]);
	const { getPrefixCls, direction: contextDirection, className: contextClassName, style: contextStyle } = useComponentConfig("typography");
	const direction = typographyDirection !== null && typographyDirection !== void 0 ? typographyDirection : contextDirection;
	const mergedRef = setContentRef ? composeRef(ref, setContentRef) : ref;
	const prefixCls = getPrefixCls("typography", customizePrefixCls);
	devUseWarning("Typography").deprecated(!setContentRef, "setContentRef", "ref");
	const [wrapCSSVar, hashId, cssVarCls] = style_default$2(prefixCls);
	const componentClassName = (0, import_classnames$10.default)(prefixCls, contextClassName, { [`${prefixCls}-rtl`]: direction === "rtl" }, className, rootClassName, hashId, cssVarCls);
	const mergedStyle = Object.assign(Object.assign({}, contextStyle), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(Component$2, Object.assign({
		className: componentClassName,
		style: mergedStyle,
		ref: mergedRef
	}, restProps), children));
});
Typography$1.displayName = "Typography";
var Typography_default = Typography$1;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/CopyOutlined.js
var CopyOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" }
		}]
	},
	"name": "copy",
	"theme": "outlined"
};
var CopyOutlined_default$1 = CopyOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/CopyOutlined.js
/**![copy](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTgzMiA2NEgyOTZjLTQuNCAwLTggMy42LTggOHY1NmMwIDQuNCAzLjYgOCA4IDhoNDk2djY4OGMwIDQuNCAzLjYgOCA4IDhoNTZjNC40IDAgOC0zLjYgOC04Vjk2YzAtMTcuNy0xNC4zLTMyLTMyLTMyek03MDQgMTkySDE5MmMtMTcuNyAwLTMyIDE0LjMtMzIgMzJ2NTMwLjdjMCA4LjUgMy40IDE2LjYgOS40IDIyLjZsMTczLjMgMTczLjNjMi4yIDIuMiA0LjcgNCA3LjQgNS41djEuOWg0LjJjMy41IDEuMyA3LjIgMiAxMSAySDcwNGMxNy43IDAgMzItMTQuMyAzMi0zMlYyMjRjMC0xNy43LTE0LjMtMzItMzItMzJ6TTM1MCA4NTYuMkwyNjMuOSA3NzBIMzUwdjg2LjJ6TTY2NCA4ODhINDE0Vjc0NmMwLTIyLjEtMTcuOS00MC00MC00MEgyMzJWMjY0aDQzMnY2MjR6IiAvPjwvc3ZnPg==) */
var RefIcon$4 = /* @__PURE__ */ import_react.forwardRef(function CopyOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: CopyOutlined_default$1
	}));
});
RefIcon$4.displayName = "CopyOutlined";
var CopyOutlined_default = RefIcon$4;

//#endregion
//#region node_modules/antd/es/typography/Base/util.js
function toList(val) {
	if (val === false) return [false, false];
	return Array.isArray(val) ? val : [val];
}
function getNode(dom, defaultNode, needDom) {
	if (dom === true || dom === void 0) return defaultNode;
	return dom || needDom && defaultNode;
}
/**
* Check for element is native ellipsis
* ref:
* - https://github.com/ant-design/ant-design/issues/50143
* - https://github.com/ant-design/ant-design/issues/50414
*/
function isEleEllipsis(ele) {
	const childDiv = document.createElement("em");
	ele.appendChild(childDiv);
	childDiv.className = "ant-typography-css-ellipsis-content-measure";
	const rect = ele.getBoundingClientRect();
	const childRect = childDiv.getBoundingClientRect();
	ele.removeChild(childDiv);
	return rect.left > childRect.left || childRect.right > rect.right || rect.top > childRect.top || childRect.bottom > rect.bottom;
}
const isValidText = (val) => ["string", "number"].includes(typeof val);

//#endregion
//#region node_modules/antd/es/typography/Base/CopyBtn.js
var import_classnames$9 = /* @__PURE__ */ __toESM(require_classnames());
var CopyBtn = ({ prefixCls, copied, locale: locale$5, iconOnly, tooltips, icon, tabIndex, onCopy, loading: btnLoading }) => {
	const tooltipNodes = toList(tooltips);
	const iconNodes = toList(icon);
	const { copied: copiedText, copy: copyText } = locale$5 !== null && locale$5 !== void 0 ? locale$5 : {};
	const systemStr = copied ? copiedText : copyText;
	const copyTitle = getNode(tooltipNodes[copied ? 1 : 0], systemStr);
	const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
	return /* @__PURE__ */ import_react.createElement(tooltip_default, { title: copyTitle }, /* @__PURE__ */ import_react.createElement("button", {
		type: "button",
		className: (0, import_classnames$9.default)(`${prefixCls}-copy`, {
			[`${prefixCls}-copy-success`]: copied,
			[`${prefixCls}-copy-icon-only`]: iconOnly
		}),
		onClick: onCopy,
		"aria-label": ariaLabel,
		tabIndex
	}, copied ? getNode(iconNodes[1], /* @__PURE__ */ import_react.createElement(CheckOutlined_default, null), true) : getNode(iconNodes[0], btnLoading ? /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null) : /* @__PURE__ */ import_react.createElement(CopyOutlined_default, null), true)));
};
var CopyBtn_default = CopyBtn;

//#endregion
//#region node_modules/antd/es/typography/Base/Ellipsis.js
var MeasureText = /* @__PURE__ */ import_react.forwardRef(({ style: style$1, children }, ref) => {
	const spanRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => ({
		isExceed: () => {
			const span = spanRef.current;
			return span.scrollHeight > span.clientHeight;
		},
		getHeight: () => spanRef.current.clientHeight
	}));
	return /* @__PURE__ */ import_react.createElement("span", {
		"aria-hidden": true,
		ref: spanRef,
		style: Object.assign({
			position: "fixed",
			display: "block",
			left: 0,
			top: 0,
			pointerEvents: "none",
			backgroundColor: "rgba(255, 0, 0, 0.65)"
		}, style$1)
	}, children);
});
var getNodesLen = (nodeList) => nodeList.reduce((totalLen, node$1) => totalLen + (isValidText(node$1) ? String(node$1).length : 1), 0);
function sliceNodes(nodeList, len) {
	let currLen = 0;
	const currentNodeList = [];
	for (let i = 0; i < nodeList.length; i += 1) {
		if (currLen === len) return currentNodeList;
		const node$1 = nodeList[i];
		const nodeLen = isValidText(node$1) ? String(node$1).length : 1;
		const nextLen = currLen + nodeLen;
		if (nextLen > len) {
			const restLen = len - currLen;
			currentNodeList.push(String(node$1).slice(0, restLen));
			return currentNodeList;
		}
		currentNodeList.push(node$1);
		currLen = nextLen;
	}
	return nodeList;
}
var STATUS_MEASURE_NONE = 0;
var STATUS_MEASURE_PREPARE = 1;
var STATUS_MEASURE_START = 2;
var STATUS_MEASURE_NEED_ELLIPSIS = 3;
var STATUS_MEASURE_NO_NEED_ELLIPSIS = 4;
var lineClipStyle = {
	display: "-webkit-box",
	overflow: "hidden",
	WebkitBoxOrient: "vertical"
};
function EllipsisMeasure(props) {
	const { enableMeasure, width, text, children, rows, expanded, miscDeps, onEllipsis } = props;
	const nodeList = import_react.useMemo(() => toArray(text), [text]);
	const nodeLen = import_react.useMemo(() => getNodesLen(nodeList), [text]);
	const fullContent = import_react.useMemo(() => children(nodeList, false), [text]);
	const [ellipsisCutIndex, setEllipsisCutIndex] = import_react.useState(null);
	const cutMidRef = import_react.useRef(null);
	const measureWhiteSpaceRef = import_react.useRef(null);
	const needEllipsisRef = import_react.useRef(null);
	const descRowsEllipsisRef = import_react.useRef(null);
	const symbolRowEllipsisRef = import_react.useRef(null);
	const [canEllipsis, setCanEllipsis] = import_react.useState(false);
	const [needEllipsis, setNeedEllipsis] = import_react.useState(STATUS_MEASURE_NONE);
	const [ellipsisHeight, setEllipsisHeight] = import_react.useState(0);
	const [parentWhiteSpace, setParentWhiteSpace] = import_react.useState(null);
	useLayoutEffect_default(() => {
		if (enableMeasure && width && nodeLen) setNeedEllipsis(STATUS_MEASURE_PREPARE);
		else setNeedEllipsis(STATUS_MEASURE_NONE);
	}, [
		width,
		text,
		rows,
		enableMeasure,
		nodeList
	]);
	useLayoutEffect_default(() => {
		var _a, _b, _c, _d;
		if (needEllipsis === STATUS_MEASURE_PREPARE) {
			setNeedEllipsis(STATUS_MEASURE_START);
			const nextWhiteSpace = measureWhiteSpaceRef.current && getComputedStyle(measureWhiteSpaceRef.current).whiteSpace;
			setParentWhiteSpace(nextWhiteSpace);
		} else if (needEllipsis === STATUS_MEASURE_START) {
			const isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());
			setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);
			setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);
			setCanEllipsis(isOverflow);
			const baseRowsEllipsisHeight = ((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0;
			const descRowsEllipsisHeight = rows === 1 ? 0 : ((_c = descRowsEllipsisRef.current) === null || _c === void 0 ? void 0 : _c.getHeight()) || 0;
			const symbolRowEllipsisHeight = ((_d = symbolRowEllipsisRef.current) === null || _d === void 0 ? void 0 : _d.getHeight()) || 0;
			const maxRowsHeight = Math.max(baseRowsEllipsisHeight, descRowsEllipsisHeight + symbolRowEllipsisHeight);
			setEllipsisHeight(maxRowsHeight + 1);
			onEllipsis(isOverflow);
		}
	}, [needEllipsis]);
	const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;
	useLayoutEffect_default(() => {
		var _a;
		const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];
		if (minIndex !== maxIndex) {
			const isOverflow = (((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0) > ellipsisHeight;
			let targetMidIndex = cutMidIndex;
			if (maxIndex - minIndex === 1) targetMidIndex = isOverflow ? minIndex : maxIndex;
			setEllipsisCutIndex(isOverflow ? [minIndex, targetMidIndex] : [targetMidIndex, maxIndex]);
		}
	}, [ellipsisCutIndex, cutMidIndex]);
	const finalContent = import_react.useMemo(() => {
		if (!enableMeasure) return children(nodeList, false);
		if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {
			const content = children(nodeList, false);
			if ([STATUS_MEASURE_NO_NEED_ELLIPSIS, STATUS_MEASURE_NONE].includes(needEllipsis)) return content;
			return /* @__PURE__ */ import_react.createElement("span", { style: Object.assign(Object.assign({}, lineClipStyle), { WebkitLineClamp: rows }) }, content);
		}
		return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);
	}, [
		expanded,
		needEllipsis,
		ellipsisCutIndex,
		nodeList
	].concat(_toConsumableArray(miscDeps)));
	const measureStyle = {
		width,
		margin: 0,
		padding: 0,
		whiteSpace: parentWhiteSpace === "nowrap" ? "normal" : "inherit"
	};
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(MeasureText, {
		style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), { WebkitLineClamp: rows }),
		ref: needEllipsisRef
	}, fullContent), /* @__PURE__ */ import_react.createElement(MeasureText, {
		style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), { WebkitLineClamp: rows - 1 }),
		ref: descRowsEllipsisRef
	}, fullContent), /* @__PURE__ */ import_react.createElement(MeasureText, {
		style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), { WebkitLineClamp: 1 }),
		ref: symbolRowEllipsisRef
	}, children([], true))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && /* @__PURE__ */ import_react.createElement(MeasureText, {
		style: Object.assign(Object.assign({}, measureStyle), { top: 400 }),
		ref: cutMidRef
	}, children(sliceNodes(nodeList, cutMidIndex), true)), needEllipsis === STATUS_MEASURE_PREPARE && /* @__PURE__ */ import_react.createElement("span", {
		style: { whiteSpace: "inherit" },
		ref: measureWhiteSpaceRef
	}));
}

//#endregion
//#region node_modules/antd/es/typography/Base/EllipsisTooltip.js
var EllipsisTooltip = ({ enableEllipsis, isEllipsis, children, tooltipProps }) => {
	if (!(tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.title) || !enableEllipsis) return children;
	return /* @__PURE__ */ import_react.createElement(tooltip_default, Object.assign({ open: isEllipsis ? void 0 : false }, tooltipProps), children);
};
EllipsisTooltip.displayName = "EllipsisTooltip";
var EllipsisTooltip_default = EllipsisTooltip;

//#endregion
//#region node_modules/antd/es/typography/Base/index.js
var import_classnames$8 = /* @__PURE__ */ __toESM(require_classnames());
var __rest$5 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function wrapperDecorations({ mark, code, underline, delete: del, strong, keyboard, italic }, content) {
	let currentContent = content;
	function wrap(tag, needed) {
		if (!needed) return;
		currentContent = /* @__PURE__ */ import_react.createElement(tag, {}, currentContent);
	}
	wrap("strong", strong);
	wrap("u", underline);
	wrap("del", del);
	wrap("code", code);
	wrap("mark", mark);
	wrap("kbd", keyboard);
	wrap("i", italic);
	return currentContent;
}
var ELLIPSIS_STR = "...";
var DECORATION_PROPS = [
	"delete",
	"mark",
	"code",
	"underline",
	"strong",
	"keyboard",
	"italic"
];
var Base = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var _a;
	const { prefixCls: customizePrefixCls, className, style: style$1, type: type$2, disabled, children, ellipsis, editable, copyable, component, title } = props, restProps = __rest$5(props, [
		"prefixCls",
		"className",
		"style",
		"type",
		"disabled",
		"children",
		"ellipsis",
		"editable",
		"copyable",
		"component",
		"title"
	]);
	const { getPrefixCls, direction } = import_react.useContext(ConfigContext);
	const [textLocale] = useLocale_default("Text");
	const typographyRef = import_react.useRef(null);
	const editIconRef = import_react.useRef(null);
	const prefixCls = getPrefixCls("typography", customizePrefixCls);
	const textProps = omit(restProps, DECORATION_PROPS);
	const [enableEdit, editConfig] = useMergedConfig(editable);
	const [editing, setEditing] = useMergedState(false, { value: editConfig.editing });
	const { triggerType = ["icon"] } = editConfig;
	const triggerEdit = (edit) => {
		var _a$1;
		if (edit) (_a$1 = editConfig.onStart) === null || _a$1 === void 0 || _a$1.call(editConfig);
		setEditing(edit);
	};
	const prevEditing = usePrevious_default(editing);
	useLayoutEffect_default(() => {
		var _a$1;
		if (!editing && prevEditing) (_a$1 = editIconRef.current) === null || _a$1 === void 0 || _a$1.focus();
	}, [editing]);
	const onEditClick = (e$2) => {
		e$2 === null || e$2 === void 0 || e$2.preventDefault();
		triggerEdit(true);
	};
	const onEditChange = (value) => {
		var _a$1;
		(_a$1 = editConfig.onChange) === null || _a$1 === void 0 || _a$1.call(editConfig, value);
		triggerEdit(false);
	};
	const onEditCancel = () => {
		var _a$1;
		(_a$1 = editConfig.onCancel) === null || _a$1 === void 0 || _a$1.call(editConfig);
		triggerEdit(false);
	};
	const [enableCopy, copyConfig] = useMergedConfig(copyable);
	const { copied, copyLoading, onClick: onCopyClick } = useCopyClick_default({
		copyConfig,
		children
	});
	const [isLineClampSupport, setIsLineClampSupport] = import_react.useState(false);
	const [isTextOverflowSupport, setIsTextOverflowSupport] = import_react.useState(false);
	const [isJsEllipsis, setIsJsEllipsis] = import_react.useState(false);
	const [isNativeEllipsis, setIsNativeEllipsis] = import_react.useState(false);
	const [isNativeVisible, setIsNativeVisible] = import_react.useState(true);
	const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
		expandable: false,
		symbol: (isExpanded) => isExpanded ? textLocale === null || textLocale === void 0 ? void 0 : textLocale.collapse : textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand
	});
	const [expanded, setExpanded] = useMergedState(ellipsisConfig.defaultExpanded || false, { value: ellipsisConfig.expanded });
	const mergedEnableEllipsis = enableEllipsis && (!expanded || ellipsisConfig.expandable === "collapsible");
	const { rows = 1 } = ellipsisConfig;
	const needMeasureEllipsis = import_react.useMemo(() => mergedEnableEllipsis && (ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || ellipsisConfig.expandable || enableEdit || enableCopy), [
		mergedEnableEllipsis,
		ellipsisConfig,
		enableEdit,
		enableCopy
	]);
	useLayoutEffect_default(() => {
		if (enableEllipsis && !needMeasureEllipsis) {
			setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
			setIsTextOverflowSupport(isStyleSupport("textOverflow"));
		}
	}, [needMeasureEllipsis, enableEllipsis]);
	const [cssEllipsis, setCssEllipsis] = import_react.useState(mergedEnableEllipsis);
	const canUseCssEllipsis = import_react.useMemo(() => {
		if (needMeasureEllipsis) return false;
		if (rows === 1) return isTextOverflowSupport;
		return isLineClampSupport;
	}, [
		needMeasureEllipsis,
		isTextOverflowSupport,
		isLineClampSupport
	]);
	useLayoutEffect_default(() => {
		setCssEllipsis(canUseCssEllipsis && mergedEnableEllipsis);
	}, [canUseCssEllipsis, mergedEnableEllipsis]);
	const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
	const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
	const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
	const onExpandClick = (e$2, info) => {
		var _a$1;
		setExpanded(info.expanded);
		(_a$1 = ellipsisConfig.onExpand) === null || _a$1 === void 0 || _a$1.call(ellipsisConfig, e$2, info);
	};
	const [ellipsisWidth, setEllipsisWidth] = import_react.useState(0);
	const onResize$1 = ({ offsetWidth }) => {
		setEllipsisWidth(offsetWidth);
	};
	const onJsEllipsis = (jsEllipsis) => {
		var _a$1;
		setIsJsEllipsis(jsEllipsis);
		if (isJsEllipsis !== jsEllipsis) (_a$1 = ellipsisConfig.onEllipsis) === null || _a$1 === void 0 || _a$1.call(ellipsisConfig, jsEllipsis);
	};
	import_react.useEffect(() => {
		const textEle = typographyRef.current;
		if (enableEllipsis && cssEllipsis && textEle) {
			const currentEllipsis = isEleEllipsis(textEle);
			if (isNativeEllipsis !== currentEllipsis) setIsNativeEllipsis(currentEllipsis);
		}
	}, [
		enableEllipsis,
		cssEllipsis,
		children,
		cssLineClamp,
		isNativeVisible,
		ellipsisWidth
	]);
	import_react.useEffect(() => {
		const textEle = typographyRef.current;
		if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) return;
		const observer = new IntersectionObserver(() => {
			setIsNativeVisible(!!textEle.offsetParent);
		});
		observer.observe(textEle);
		return () => {
			observer.disconnect();
		};
	}, [cssEllipsis, mergedEnableEllipsis]);
	const tooltipProps = useTooltipProps_default(ellipsisConfig.tooltip, editConfig.text, children);
	const topAriaLabel = import_react.useMemo(() => {
		if (!enableEllipsis || cssEllipsis) return;
		return [
			editConfig.text,
			children,
			title,
			tooltipProps.title
		].find(isValidText);
	}, [
		enableEllipsis,
		cssEllipsis,
		title,
		tooltipProps.title,
		isMergedEllipsis
	]);
	if (editing) return /* @__PURE__ */ import_react.createElement(Editable_default, {
		value: (_a = editConfig.text) !== null && _a !== void 0 ? _a : typeof children === "string" ? children : "",
		onSave: onEditChange,
		onCancel: onEditCancel,
		onEnd: editConfig.onEnd,
		prefixCls,
		className,
		style: style$1,
		direction,
		component,
		maxLength: editConfig.maxLength,
		autoSize: editConfig.autoSize,
		enterIcon: editConfig.enterIcon
	});
	const renderExpand = () => {
		const { expandable, symbol } = ellipsisConfig;
		return expandable ? /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			key: "expand",
			className: `${prefixCls}-${expanded ? "collapse" : "expand"}`,
			onClick: (e$2) => onExpandClick(e$2, { expanded: !expanded }),
			"aria-label": expanded ? textLocale.collapse : textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand
		}, typeof symbol === "function" ? symbol(expanded) : symbol) : null;
	};
	const renderEdit = () => {
		if (!enableEdit) return;
		const { icon, tooltip, tabIndex } = editConfig;
		const editTitle = toArray(tooltip)[0] || (textLocale === null || textLocale === void 0 ? void 0 : textLocale.edit);
		const ariaLabel = typeof editTitle === "string" ? editTitle : "";
		return triggerType.includes("icon") ? /* @__PURE__ */ import_react.createElement(tooltip_default, {
			key: "edit",
			title: tooltip === false ? "" : editTitle
		}, /* @__PURE__ */ import_react.createElement("button", {
			type: "button",
			ref: editIconRef,
			className: `${prefixCls}-edit`,
			onClick: onEditClick,
			"aria-label": ariaLabel,
			tabIndex
		}, icon || /* @__PURE__ */ import_react.createElement(EditOutlined_default, { role: "button" }))) : null;
	};
	const renderCopy = () => {
		if (!enableCopy) return null;
		return /* @__PURE__ */ import_react.createElement(CopyBtn_default, Object.assign({ key: "copy" }, copyConfig, {
			prefixCls,
			copied,
			locale: textLocale,
			onCopy: onCopyClick,
			loading: copyLoading,
			iconOnly: children === null || children === void 0
		}));
	};
	const renderOperations = (canEllipsis) => [
		canEllipsis && renderExpand(),
		renderEdit(),
		renderCopy()
	];
	const renderEllipsis = (canEllipsis) => [
		canEllipsis && !expanded && /* @__PURE__ */ import_react.createElement("span", {
			"aria-hidden": true,
			key: "ellipsis"
		}, ELLIPSIS_STR),
		ellipsisConfig.suffix,
		renderOperations(canEllipsis)
	];
	return /* @__PURE__ */ import_react.createElement(es_default, {
		onResize: onResize$1,
		disabled: !mergedEnableEllipsis
	}, (resizeRef) => /* @__PURE__ */ import_react.createElement(EllipsisTooltip_default, {
		tooltipProps,
		enableEllipsis: mergedEnableEllipsis,
		isEllipsis: isMergedEllipsis
	}, /* @__PURE__ */ import_react.createElement(Typography_default, Object.assign({
		className: (0, import_classnames$8.default)({
			[`${prefixCls}-${type$2}`]: type$2,
			[`${prefixCls}-disabled`]: disabled,
			[`${prefixCls}-ellipsis`]: enableEllipsis,
			[`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
			[`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
		}, className),
		prefixCls: customizePrefixCls,
		style: Object.assign(Object.assign({}, style$1), { WebkitLineClamp: cssLineClamp ? rows : void 0 }),
		component,
		ref: composeRef(resizeRef, typographyRef, ref),
		direction,
		onClick: triggerType.includes("text") ? onEditClick : void 0,
		"aria-label": topAriaLabel === null || topAriaLabel === void 0 ? void 0 : topAriaLabel.toString(),
		title
	}, textProps), /* @__PURE__ */ import_react.createElement(EllipsisMeasure, {
		enableMeasure: mergedEnableEllipsis && !cssEllipsis,
		text: children,
		rows,
		width: ellipsisWidth,
		onEllipsis: onJsEllipsis,
		expanded,
		miscDeps: [
			copied,
			expanded,
			copyLoading,
			enableEdit,
			enableCopy,
			textLocale
		].concat(_toConsumableArray(DECORATION_PROPS.map((key) => props[key])))
	}, (node$1, canEllipsis) => wrapperDecorations(props, /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, node$1.length > 0 && canEllipsis && !expanded && topAriaLabel ? /* @__PURE__ */ import_react.createElement("span", {
		key: "show-content",
		"aria-hidden": true
	}, node$1) : node$1, renderEllipsis(canEllipsis)))))));
});
var Base_default = Base;

//#endregion
//#region node_modules/antd/es/typography/Link.js
var __rest$4 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Link = /* @__PURE__ */ import_react.forwardRef((_a, ref) => {
	var { ellipsis, rel } = _a, restProps = __rest$4(_a, ["ellipsis", "rel"]);
	devUseWarning("Typography.Link")(typeof ellipsis !== "object", "usage", "`ellipsis` only supports boolean value.");
	const mergedProps = Object.assign(Object.assign({}, restProps), { rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel });
	delete mergedProps.navigate;
	return /* @__PURE__ */ import_react.createElement(Base_default, Object.assign({}, mergedProps, {
		ref,
		ellipsis: !!ellipsis,
		component: "a"
	}));
});
var Link_default = Link;

//#endregion
//#region node_modules/antd/es/typography/Paragraph.js
var Paragraph = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ import_react.createElement(Base_default, Object.assign({ ref }, props, { component: "div" })));
var Paragraph_default = Paragraph;

//#endregion
//#region node_modules/antd/es/typography/Text.js
var __rest$3 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Text = (_a, ref) => {
	var { ellipsis } = _a, restProps = __rest$3(_a, ["ellipsis"]);
	const mergedEllipsis = import_react.useMemo(() => {
		if (ellipsis && typeof ellipsis === "object") return omit(ellipsis, ["expandable", "rows"]);
		return ellipsis;
	}, [ellipsis]);
	devUseWarning("Typography.Text")(typeof ellipsis !== "object" || !ellipsis || !("expandable" in ellipsis) && !("rows" in ellipsis), "usage", "`ellipsis` do not support `expandable` or `rows` props.");
	return /* @__PURE__ */ import_react.createElement(Base_default, Object.assign({ ref }, restProps, {
		ellipsis: mergedEllipsis,
		component: "span"
	}));
};
var Text_default = /* @__PURE__ */ import_react.forwardRef(Text);

//#endregion
//#region node_modules/antd/es/typography/Title.js
var __rest$2 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var TITLE_ELE_LIST = [
	1,
	2,
	3,
	4,
	5
];
var Title = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { level = 1 } = props, restProps = __rest$2(props, ["level"]);
	devUseWarning("Typography.Title")(TITLE_ELE_LIST.includes(level), "usage", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version.");
	const component = TITLE_ELE_LIST.includes(level) ? `h${level}` : `h1`;
	return /* @__PURE__ */ import_react.createElement(Base_default, Object.assign({ ref }, restProps, { component }));
});
var Title_default = Title;

//#endregion
//#region node_modules/antd/es/typography/index.js
var Typography = Typography_default;
Typography.Text = Text_default;
Typography.Link = Link_default;
Typography.Title = Title_default;
Typography.Paragraph = Paragraph_default;
var typography_default = Typography;

//#endregion
//#region node_modules/rc-upload/es/attr-accept.js
var attr_accept_default = (function(file, acceptedFiles) {
	if (file && acceptedFiles) {
		var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
		var fileName = file.name || "";
		var mimeType = file.type || "";
		var baseMimeType = mimeType.replace(/\/.*$/, "");
		return acceptedFilesArray.some(function(type$2) {
			var validType = type$2.trim();
			if (/^\*(\/\*)?$/.test(type$2)) return true;
			if (validType.charAt(0) === ".") {
				var lowerFileName = fileName.toLowerCase();
				var lowerType = validType.toLowerCase();
				var affixList = [lowerType];
				if (lowerType === ".jpg" || lowerType === ".jpeg") affixList = [".jpg", ".jpeg"];
				return affixList.some(function(affix) {
					return lowerFileName.endsWith(affix);
				});
			}
			if (/\/\*$/.test(validType)) return baseMimeType === validType.replace(/\/.*$/, "");
			if (mimeType === validType) return true;
			if (/^\w+$/.test(validType)) {
				warning_default(false, "Upload takes an invalidate 'accept' type '".concat(validType, "'.Skip for check."));
				return true;
			}
			return false;
		});
	}
	return true;
});

//#endregion
//#region node_modules/rc-upload/es/request.js
function getError(option, xhr) {
	var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr.status, "'");
	var err = new Error(msg);
	err.status = xhr.status;
	err.method = option.method;
	err.url = option.action;
	return err;
}
function getBody(xhr) {
	var text = xhr.responseText || xhr.response;
	if (!text) return text;
	try {
		return JSON.parse(text);
	} catch (e$2) {
		return text;
	}
}
function upload(option) {
	var xhr = new XMLHttpRequest();
	if (option.onProgress && xhr.upload) xhr.upload.onprogress = function progress(e$2) {
		if (e$2.total > 0) e$2.percent = e$2.loaded / e$2.total * 100;
		option.onProgress(e$2);
	};
	var formData = new FormData();
	if (option.data) Object.keys(option.data).forEach(function(key) {
		var value = option.data[key];
		if (Array.isArray(value)) {
			value.forEach(function(item) {
				formData.append("".concat(key, "[]"), item);
			});
			return;
		}
		formData.append(key, value);
	});
	if (option.file instanceof Blob) formData.append(option.filename, option.file, option.file.name);
	else formData.append(option.filename, option.file);
	xhr.onerror = function error(e$2) {
		option.onError(e$2);
	};
	xhr.onload = function onload() {
		if (xhr.status < 200 || xhr.status >= 300) return option.onError(getError(option, xhr), getBody(xhr));
		return option.onSuccess(getBody(xhr), xhr);
	};
	xhr.open(option.method, option.action, true);
	if (option.withCredentials && "withCredentials" in xhr) xhr.withCredentials = true;
	var headers = option.headers || {};
	if (headers["X-Requested-With"] !== null) xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
	Object.keys(headers).forEach(function(h) {
		if (headers[h] !== null) xhr.setRequestHeader(h, headers[h]);
	});
	xhr.send(formData);
	return { abort: function abort() {
		xhr.abort();
	} };
}

//#endregion
//#region node_modules/rc-upload/es/traverseFileTree.js
var traverseFileTree = /* @__PURE__ */ function() {
	var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(files, isAccepted) {
		var flattenFileList, progressFileList, readDirectory, _readDirectory, readFile, _readFile, _traverseFileTree, wipIndex;
		return _regeneratorRuntime().wrap(function _callee4$(_context4) {
			while (1) switch (_context4.prev = _context4.next) {
				case 0:
					_readFile = function _readFile3() {
						_readFile = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(item) {
							return _regeneratorRuntime().wrap(function _callee3$(_context3) {
								while (1) switch (_context3.prev = _context3.next) {
									case 0: return _context3.abrupt("return", new Promise(function(reslove) {
										item.file(function(file) {
											if (isAccepted(file)) {
												if (item.fullPath && !file.webkitRelativePath) {
													Object.defineProperties(file, { webkitRelativePath: { writable: true } });
													file.webkitRelativePath = item.fullPath.replace(/^\//, "");
													Object.defineProperties(file, { webkitRelativePath: { writable: false } });
												}
												reslove(file);
											} else reslove(null);
										});
									}));
									case 1:
									case "end": return _context3.stop();
								}
							}, _callee3);
						}));
						return _readFile.apply(this, arguments);
					};
					readFile = function _readFile2(_x4) {
						return _readFile.apply(this, arguments);
					};
					_readDirectory = function _readDirectory3() {
						_readDirectory = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(directory) {
							var dirReader, entries, results, n$1, i;
							return _regeneratorRuntime().wrap(function _callee2$(_context2) {
								while (1) switch (_context2.prev = _context2.next) {
									case 0:
										dirReader = directory.createReader();
										entries = [];
									case 2:
										_context2.next = 5;
										return new Promise(function(resolve) {
											dirReader.readEntries(resolve, function() {
												return resolve([]);
											});
										});
									case 5:
										results = _context2.sent;
										n$1 = results.length;
										if (n$1) {
											_context2.next = 9;
											break;
										}
										return _context2.abrupt("break", 12);
									case 9:
										for (i = 0; i < n$1; i++) entries.push(results[i]);
										_context2.next = 2;
										break;
									case 12: return _context2.abrupt("return", entries);
									case 13:
									case "end": return _context2.stop();
								}
							}, _callee2);
						}));
						return _readDirectory.apply(this, arguments);
					};
					readDirectory = function _readDirectory2(_x3) {
						return _readDirectory.apply(this, arguments);
					};
					flattenFileList = [];
					progressFileList = [];
					files.forEach(function(file) {
						return progressFileList.push(file.webkitGetAsEntry());
					});
					_traverseFileTree = /* @__PURE__ */ function() {
						var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(item, path$1) {
							var _file, entries;
							return _regeneratorRuntime().wrap(function _callee$(_context) {
								while (1) switch (_context.prev = _context.next) {
									case 0:
										if (item) {
											_context.next = 2;
											break;
										}
										return _context.abrupt("return");
									case 2:
										item.path = path$1 || "";
										if (!item.isFile) {
											_context.next = 10;
											break;
										}
										_context.next = 6;
										return readFile(item);
									case 6:
										_file = _context.sent;
										if (_file) flattenFileList.push(_file);
										_context.next = 15;
										break;
									case 10:
										if (!item.isDirectory) {
											_context.next = 15;
											break;
										}
										_context.next = 13;
										return readDirectory(item);
									case 13:
										entries = _context.sent;
										progressFileList.push.apply(progressFileList, _toConsumableArray(entries));
									case 15:
									case "end": return _context.stop();
								}
							}, _callee);
						}));
						return function _traverseFileTree$1(_x5, _x6) {
							return _ref2.apply(this, arguments);
						};
					}();
					wipIndex = 0;
				case 9:
					if (!(wipIndex < progressFileList.length)) {
						_context4.next = 15;
						break;
					}
					_context4.next = 12;
					return _traverseFileTree(progressFileList[wipIndex]);
				case 12:
					wipIndex++;
					_context4.next = 9;
					break;
				case 15: return _context4.abrupt("return", flattenFileList);
				case 16:
				case "end": return _context4.stop();
			}
		}, _callee4);
	}));
	return function traverseFileTree$1(_x, _x2) {
		return _ref.apply(this, arguments);
	};
}();
var traverseFileTree_default = traverseFileTree;

//#endregion
//#region node_modules/rc-upload/es/uid.js
var now = +/* @__PURE__ */ new Date();
var index = 0;
function uid() {
	return "rc-upload-".concat(now, "-").concat(++index);
}

//#endregion
//#region node_modules/rc-upload/es/AjaxUploader.js
var import_classnames$7 = /* @__PURE__ */ __toESM(require_classnames());
var _excluded = [
	"component",
	"prefixCls",
	"className",
	"classNames",
	"disabled",
	"id",
	"name",
	"style",
	"styles",
	"multiple",
	"accept",
	"capture",
	"children",
	"directory",
	"openFileDialogOnClick",
	"onMouseEnter",
	"onMouseLeave",
	"hasControlInside"
];
var AjaxUploader = /* @__PURE__ */ function(_Component) {
	_inherits(AjaxUploader$1, _Component);
	var _super = _createSuper(AjaxUploader$1);
	function AjaxUploader$1() {
		var _this;
		_classCallCheck(this, AjaxUploader$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _super.call.apply(_super, [this].concat(args));
		_defineProperty(_assertThisInitialized(_this), "state", { uid: uid() });
		_defineProperty(_assertThisInitialized(_this), "reqs", {});
		_defineProperty(_assertThisInitialized(_this), "fileInput", void 0);
		_defineProperty(_assertThisInitialized(_this), "_isMounted", void 0);
		_defineProperty(_assertThisInitialized(_this), "onChange", function(e$2) {
			var _this$props = _this.props, accept = _this$props.accept, directory = _this$props.directory;
			var files = e$2.target.files;
			var acceptedFiles = _toConsumableArray(files).filter(function(file) {
				return !directory || attr_accept_default(file, accept);
			});
			_this.uploadFiles(acceptedFiles);
			_this.reset();
		});
		_defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
			var el = _this.fileInput;
			if (!el) return;
			var target = event.target;
			var onClick = _this.props.onClick;
			if (target && target.tagName === "BUTTON") {
				el.parentNode.focus();
				target.blur();
			}
			el.click();
			if (onClick) onClick(event);
		});
		_defineProperty(_assertThisInitialized(_this), "onKeyDown", function(e$2) {
			if (e$2.key === "Enter") _this.onClick(e$2);
		});
		_defineProperty(_assertThisInitialized(_this), "onDataTransferFiles", /* @__PURE__ */ function() {
			var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(dataTransfer, existFileCallback) {
				var _this$props2, multiple, accept, directory, items, files, acceptFiles;
				return _regeneratorRuntime().wrap(function _callee$(_context) {
					while (1) switch (_context.prev = _context.next) {
						case 0:
							_this$props2 = _this.props, multiple = _this$props2.multiple, accept = _this$props2.accept, directory = _this$props2.directory;
							items = _toConsumableArray(dataTransfer.items || []);
							files = _toConsumableArray(dataTransfer.files || []);
							if (files.length > 0 || items.some(function(item) {
								return item.kind === "file";
							})) existFileCallback === null || existFileCallback === void 0 || existFileCallback();
							if (!directory) {
								_context.next = 11;
								break;
							}
							_context.next = 7;
							return traverseFileTree_default(Array.prototype.slice.call(items), function(_file) {
								return attr_accept_default(_file, _this.props.accept);
							});
						case 7:
							files = _context.sent;
							_this.uploadFiles(files);
							_context.next = 14;
							break;
						case 11:
							acceptFiles = _toConsumableArray(files).filter(function(file) {
								return attr_accept_default(file, accept);
							});
							if (multiple === false) acceptFiles = files.slice(0, 1);
							_this.uploadFiles(acceptFiles);
						case 14:
						case "end": return _context.stop();
					}
				}, _callee);
			}));
			return function(_x, _x2) {
				return _ref.apply(this, arguments);
			};
		}());
		_defineProperty(_assertThisInitialized(_this), "onFilePaste", /* @__PURE__ */ function() {
			var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(e$2) {
				var pastable, clipboardData;
				return _regeneratorRuntime().wrap(function _callee2$(_context2) {
					while (1) switch (_context2.prev = _context2.next) {
						case 0:
							pastable = _this.props.pastable;
							if (pastable) {
								_context2.next = 3;
								break;
							}
							return _context2.abrupt("return");
						case 3:
							if (!(e$2.type === "paste")) {
								_context2.next = 6;
								break;
							}
							clipboardData = e$2.clipboardData;
							return _context2.abrupt("return", _this.onDataTransferFiles(clipboardData, function() {
								e$2.preventDefault();
							}));
						case 6:
						case "end": return _context2.stop();
					}
				}, _callee2);
			}));
			return function(_x3) {
				return _ref2.apply(this, arguments);
			};
		}());
		_defineProperty(_assertThisInitialized(_this), "onFileDragOver", function(e$2) {
			e$2.preventDefault();
		});
		_defineProperty(_assertThisInitialized(_this), "onFileDrop", /* @__PURE__ */ function() {
			var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(e$2) {
				var dataTransfer;
				return _regeneratorRuntime().wrap(function _callee3$(_context3) {
					while (1) switch (_context3.prev = _context3.next) {
						case 0:
							e$2.preventDefault();
							if (!(e$2.type === "drop")) {
								_context3.next = 4;
								break;
							}
							dataTransfer = e$2.dataTransfer;
							return _context3.abrupt("return", _this.onDataTransferFiles(dataTransfer));
						case 4:
						case "end": return _context3.stop();
					}
				}, _callee3);
			}));
			return function(_x4) {
				return _ref3.apply(this, arguments);
			};
		}());
		_defineProperty(_assertThisInitialized(_this), "uploadFiles", function(files) {
			var originFiles = _toConsumableArray(files);
			var postFiles = originFiles.map(function(file) {
				file.uid = uid();
				return _this.processFile(file, originFiles);
			});
			Promise.all(postFiles).then(function(fileList) {
				var onBatchStart = _this.props.onBatchStart;
				onBatchStart === null || onBatchStart === void 0 || onBatchStart(fileList.map(function(_ref4) {
					var origin = _ref4.origin, parsedFile = _ref4.parsedFile;
					return {
						file: origin,
						parsedFile
					};
				}));
				fileList.filter(function(file) {
					return file.parsedFile !== null;
				}).forEach(function(file) {
					_this.post(file);
				});
			});
		});
		/**
		* Process file before upload. When all the file is ready, we start upload.
		*/
		_defineProperty(_assertThisInitialized(_this), "processFile", /* @__PURE__ */ function() {
			var _ref5 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(file, fileList) {
				var beforeUpload, transformedFile, action, mergedAction, data, mergedData, parsedData, parsedFile, mergedParsedFile;
				return _regeneratorRuntime().wrap(function _callee4$(_context4) {
					while (1) switch (_context4.prev = _context4.next) {
						case 0:
							beforeUpload = _this.props.beforeUpload;
							transformedFile = file;
							if (!beforeUpload) {
								_context4.next = 14;
								break;
							}
							_context4.prev = 3;
							_context4.next = 6;
							return beforeUpload(file, fileList);
						case 6:
							transformedFile = _context4.sent;
							_context4.next = 12;
							break;
						case 9:
							_context4.prev = 9;
							_context4.t0 = _context4["catch"](3);
							transformedFile = false;
						case 12:
							if (!(transformedFile === false)) {
								_context4.next = 14;
								break;
							}
							return _context4.abrupt("return", {
								origin: file,
								parsedFile: null,
								action: null,
								data: null
							});
						case 14:
							action = _this.props.action;
							if (!(typeof action === "function")) {
								_context4.next = 21;
								break;
							}
							_context4.next = 18;
							return action(file);
						case 18:
							mergedAction = _context4.sent;
							_context4.next = 22;
							break;
						case 21: mergedAction = action;
						case 22:
							data = _this.props.data;
							if (!(typeof data === "function")) {
								_context4.next = 29;
								break;
							}
							_context4.next = 26;
							return data(file);
						case 26:
							mergedData = _context4.sent;
							_context4.next = 30;
							break;
						case 29: mergedData = data;
						case 30:
							parsedData = (_typeof(transformedFile) === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file;
							if (parsedData instanceof File) parsedFile = parsedData;
							else parsedFile = new File([parsedData], file.name, { type: file.type });
							mergedParsedFile = parsedFile;
							mergedParsedFile.uid = file.uid;
							return _context4.abrupt("return", {
								origin: file,
								data: mergedData,
								parsedFile: mergedParsedFile,
								action: mergedAction
							});
						case 35:
						case "end": return _context4.stop();
					}
				}, _callee4, null, [[3, 9]]);
			}));
			return function(_x5, _x6) {
				return _ref5.apply(this, arguments);
			};
		}());
		_defineProperty(_assertThisInitialized(_this), "saveFileInput", function(node$1) {
			_this.fileInput = node$1;
		});
		return _this;
	}
	_createClass(AjaxUploader$1, [
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				this._isMounted = true;
				if (this.props.pastable) document.addEventListener("paste", this.onFilePaste);
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				this._isMounted = false;
				this.abort();
				document.removeEventListener("paste", this.onFilePaste);
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate(prevProps) {
				var pastable = this.props.pastable;
				if (pastable && !prevProps.pastable) document.addEventListener("paste", this.onFilePaste);
				else if (!pastable && prevProps.pastable) document.removeEventListener("paste", this.onFilePaste);
			}
		},
		{
			key: "post",
			value: function post(_ref6) {
				var _this2 = this;
				var data = _ref6.data, origin = _ref6.origin, action = _ref6.action, parsedFile = _ref6.parsedFile;
				if (!this._isMounted) return;
				var _this$props3 = this.props, onStart = _this$props3.onStart, customRequest = _this$props3.customRequest, name = _this$props3.name, headers = _this$props3.headers, withCredentials = _this$props3.withCredentials, method$1 = _this$props3.method;
				var uid$2 = origin.uid;
				var request = customRequest || upload;
				var requestOption = {
					action,
					filename: name,
					data,
					file: parsedFile,
					headers,
					withCredentials,
					method: method$1 || "post",
					onProgress: function onProgress(e$2) {
						var onProgress$1 = _this2.props.onProgress;
						onProgress$1 === null || onProgress$1 === void 0 || onProgress$1(e$2, parsedFile);
					},
					onSuccess: function onSuccess(ret, xhr) {
						var onSuccess$1 = _this2.props.onSuccess;
						onSuccess$1 === null || onSuccess$1 === void 0 || onSuccess$1(ret, parsedFile, xhr);
						delete _this2.reqs[uid$2];
					},
					onError: function onError(err, ret) {
						var onError$1 = _this2.props.onError;
						onError$1 === null || onError$1 === void 0 || onError$1(err, ret, parsedFile);
						delete _this2.reqs[uid$2];
					}
				};
				onStart(origin);
				this.reqs[uid$2] = request(requestOption);
			}
		},
		{
			key: "reset",
			value: function reset() {
				this.setState({ uid: uid() });
			}
		},
		{
			key: "abort",
			value: function abort(file) {
				var reqs = this.reqs;
				if (file) {
					var uid$2 = file.uid ? file.uid : file;
					if (reqs[uid$2] && reqs[uid$2].abort) reqs[uid$2].abort();
					delete reqs[uid$2];
				} else Object.keys(reqs).forEach(function(uid$3) {
					if (reqs[uid$3] && reqs[uid$3].abort) reqs[uid$3].abort();
					delete reqs[uid$3];
				});
			}
		},
		{
			key: "render",
			value: function render$1() {
				var _this$props4 = this.props, Tag$1 = _this$props4.component, prefixCls = _this$props4.prefixCls, className = _this$props4.className, _this$props4$classNam = _this$props4.classNames, classNames$252 = _this$props4$classNam === void 0 ? {} : _this$props4$classNam, disabled = _this$props4.disabled, id = _this$props4.id, name = _this$props4.name, style$1 = _this$props4.style, _this$props4$styles = _this$props4.styles, styles = _this$props4$styles === void 0 ? {} : _this$props4$styles, multiple = _this$props4.multiple, accept = _this$props4.accept, capture = _this$props4.capture, children = _this$props4.children, directory = _this$props4.directory, openFileDialogOnClick = _this$props4.openFileDialogOnClick, onMouseEnter = _this$props4.onMouseEnter, onMouseLeave = _this$props4.onMouseLeave, hasControlInside = _this$props4.hasControlInside, otherProps = _objectWithoutProperties(_this$props4, _excluded);
				var cls$12 = (0, import_classnames$7.default)(_defineProperty(_defineProperty(_defineProperty({}, prefixCls, true), "".concat(prefixCls, "-disabled"), disabled), className, className));
				var dirProps = directory ? {
					directory: "directory",
					webkitdirectory: "webkitdirectory"
				} : {};
				var events = disabled ? {} : {
					onClick: openFileDialogOnClick ? this.onClick : function() {},
					onKeyDown: openFileDialogOnClick ? this.onKeyDown : function() {},
					onMouseEnter,
					onMouseLeave,
					onDrop: this.onFileDrop,
					onDragOver: this.onFileDragOver,
					tabIndex: hasControlInside ? void 0 : "0"
				};
				return /* @__PURE__ */ import_react.createElement(Tag$1, _extends({}, events, {
					className: cls$12,
					role: hasControlInside ? void 0 : "button",
					style: style$1
				}), /* @__PURE__ */ import_react.createElement("input", _extends({}, pickAttrs(otherProps, {
					aria: true,
					data: true
				}), {
					id,
					name,
					disabled,
					type: "file",
					ref: this.saveFileInput,
					onClick: function onClick(e$2) {
						return e$2.stopPropagation();
					},
					key: this.state.uid,
					style: _objectSpread2({ display: "none" }, styles.input),
					className: classNames$252.input,
					accept
				}, dirProps, {
					multiple,
					onChange: this.onChange
				}, capture != null ? { capture } : {})), children);
			}
		}
	]);
	return AjaxUploader$1;
}(import_react.Component);
var AjaxUploader_default = AjaxUploader;

//#endregion
//#region node_modules/rc-upload/es/Upload.js
function empty() {}
var Upload$2 = /* @__PURE__ */ function(_Component) {
	_inherits(Upload$3, _Component);
	var _super = _createSuper(Upload$3);
	function Upload$3() {
		var _this;
		_classCallCheck(this, Upload$3);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _super.call.apply(_super, [this].concat(args));
		_defineProperty(_assertThisInitialized(_this), "uploader", void 0);
		_defineProperty(_assertThisInitialized(_this), "saveUploader", function(node$1) {
			_this.uploader = node$1;
		});
		return _this;
	}
	_createClass(Upload$3, [{
		key: "abort",
		value: function abort(file) {
			this.uploader.abort(file);
		}
	}, {
		key: "render",
		value: function render$1() {
			return /* @__PURE__ */ import_react.createElement(AjaxUploader_default, _extends({}, this.props, { ref: this.saveUploader }));
		}
	}]);
	return Upload$3;
}(import_react.Component);
_defineProperty(Upload$2, "defaultProps", {
	component: "span",
	prefixCls: "rc-upload",
	data: {},
	headers: {},
	name: "file",
	multipart: false,
	onStart: empty,
	onError: empty,
	onSuccess: empty,
	multiple: false,
	beforeUpload: null,
	customRequest: null,
	withCredentials: false,
	openFileDialogOnClick: true,
	hasControlInside: false
});
var Upload_default$1 = Upload$2;

//#endregion
//#region node_modules/rc-upload/es/index.js
var es_default$1 = Upload_default$1;

//#endregion
//#region node_modules/antd/es/upload/style/dragger.js
var genDraggerStyle = (token$1) => {
	const { componentCls, iconCls } = token$1;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-drag`]: {
		position: "relative",
		width: "100%",
		height: "100%",
		textAlign: "center",
		background: token$1.colorFillAlter,
		border: `${unit(token$1.lineWidth)} dashed ${token$1.colorBorder}`,
		borderRadius: token$1.borderRadiusLG,
		cursor: "pointer",
		transition: `border-color ${token$1.motionDurationSlow}`,
		[componentCls]: { padding: token$1.padding },
		[`${componentCls}-btn`]: {
			display: "table",
			width: "100%",
			height: "100%",
			outline: "none",
			borderRadius: token$1.borderRadiusLG,
			"&:focus-visible": { outline: `${unit(token$1.lineWidthFocus)} solid ${token$1.colorPrimaryBorder}` }
		},
		[`${componentCls}-drag-container`]: {
			display: "table-cell",
			verticalAlign: "middle"
		},
		[`
          &:not(${componentCls}-disabled):hover,
          &-hover:not(${componentCls}-disabled)
        `]: { borderColor: token$1.colorPrimaryHover },
		[`p${componentCls}-drag-icon`]: {
			marginBottom: token$1.margin,
			[iconCls]: {
				color: token$1.colorPrimary,
				fontSize: token$1.uploadThumbnailSize
			}
		},
		[`p${componentCls}-text`]: {
			margin: `0 0 ${unit(token$1.marginXXS)}`,
			color: token$1.colorTextHeading,
			fontSize: token$1.fontSizeLG
		},
		[`p${componentCls}-hint`]: {
			color: token$1.colorTextDescription,
			fontSize: token$1.fontSize
		},
		[`&${componentCls}-disabled`]: { [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: { color: token$1.colorTextDisabled } }
	} } };
};
var dragger_default = genDraggerStyle;

//#endregion
//#region node_modules/antd/es/upload/style/list.js
var genListStyle = (token$1) => {
	const { componentCls, iconCls, fontSize, lineHeight, calc } = token$1;
	const itemCls = `${componentCls}-list-item`;
	const actionsCls = `${itemCls}-actions`;
	const actionCls = `${itemCls}-action`;
	return { [`${componentCls}-wrapper`]: { [`${componentCls}-list`]: Object.assign(Object.assign({}, clearFix()), {
		lineHeight: token$1.lineHeight,
		[itemCls]: {
			position: "relative",
			height: calc(token$1.lineHeight).mul(fontSize).equal(),
			marginTop: token$1.marginXS,
			fontSize,
			display: "flex",
			alignItems: "center",
			transition: `background-color ${token$1.motionDurationSlow}`,
			borderRadius: token$1.borderRadiusSM,
			"&:hover": { backgroundColor: token$1.controlItemBgHover },
			[`${itemCls}-name`]: Object.assign(Object.assign({}, textEllipsis), {
				padding: `0 ${unit(token$1.paddingXS)}`,
				lineHeight,
				flex: "auto",
				transition: `all ${token$1.motionDurationSlow}`
			}),
			[actionsCls]: {
				whiteSpace: "nowrap",
				[actionCls]: { opacity: 0 },
				[iconCls]: {
					color: token$1.actionsColor,
					transition: `all ${token$1.motionDurationSlow}`
				},
				[`
              ${actionCls}:focus-visible,
              &.picture ${actionCls}
            `]: { opacity: 1 }
			},
			[`${componentCls}-icon ${iconCls}`]: {
				color: token$1.colorIcon,
				fontSize
			},
			[`${itemCls}-progress`]: {
				position: "absolute",
				bottom: token$1.calc(token$1.uploadProgressOffset).mul(-1).equal(),
				width: "100%",
				paddingInlineStart: calc(fontSize).add(token$1.paddingXS).equal(),
				fontSize,
				lineHeight: 0,
				pointerEvents: "none",
				"> div": { margin: 0 }
			}
		},
		[`${itemCls}:hover ${actionCls}`]: { opacity: 1 },
		[`${itemCls}-error`]: {
			color: token$1.colorError,
			[`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: { color: token$1.colorError },
			[actionsCls]: {
				[`${iconCls}, ${iconCls}:hover`]: { color: token$1.colorError },
				[actionCls]: { opacity: 1 }
			}
		},
		[`${componentCls}-list-item-container`]: {
			transition: `opacity ${token$1.motionDurationSlow}, height ${token$1.motionDurationSlow}`,
			"&::before": {
				display: "table",
				width: 0,
				height: 0,
				content: "\"\""
			}
		}
	}) } };
};
var list_default$1 = genListStyle;

//#endregion
//#region node_modules/antd/es/upload/style/motion.js
var genMotionStyle = (token$1) => {
	const { componentCls } = token$1;
	const uploadAnimateInlineIn = new Keyframes_default("uploadAnimateInlineIn", { from: {
		width: 0,
		height: 0,
		padding: 0,
		opacity: 0,
		margin: token$1.calc(token$1.marginXS).div(-2).equal()
	} });
	const uploadAnimateInlineOut = new Keyframes_default("uploadAnimateInlineOut", { to: {
		width: 0,
		height: 0,
		padding: 0,
		opacity: 0,
		margin: token$1.calc(token$1.marginXS).div(-2).equal()
	} });
	const inlineCls = `${componentCls}-animate-inline`;
	return [
		{ [`${componentCls}-wrapper`]: {
			[`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
				animationDuration: token$1.motionDurationSlow,
				animationTimingFunction: token$1.motionEaseInOutCirc,
				animationFillMode: "forwards"
			},
			[`${inlineCls}-appear, ${inlineCls}-enter`]: { animationName: uploadAnimateInlineIn },
			[`${inlineCls}-leave`]: { animationName: uploadAnimateInlineOut }
		} },
		{ [`${componentCls}-wrapper`]: initFadeMotion(token$1) },
		uploadAnimateInlineIn,
		uploadAnimateInlineOut
	];
};
var motion_default$1 = genMotionStyle;

//#endregion
//#region node_modules/antd/es/upload/style/picture.js
var genPictureStyle = (token$1) => {
	const { componentCls, iconCls, uploadThumbnailSize, uploadProgressOffset, calc } = token$1;
	const listCls = `${componentCls}-list`;
	const itemCls = `${listCls}-item`;
	return { [`${componentCls}-wrapper`]: {
		[`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
			[itemCls]: {
				position: "relative",
				height: calc(uploadThumbnailSize).add(calc(token$1.lineWidth).mul(2)).add(calc(token$1.paddingXS).mul(2)).equal(),
				padding: token$1.paddingXS,
				border: `${unit(token$1.lineWidth)} ${token$1.lineType} ${token$1.colorBorder}`,
				borderRadius: token$1.borderRadiusLG,
				"&:hover": { background: "transparent" },
				[`${itemCls}-thumbnail`]: Object.assign(Object.assign({}, textEllipsis), {
					width: uploadThumbnailSize,
					height: uploadThumbnailSize,
					lineHeight: unit(calc(uploadThumbnailSize).add(token$1.paddingSM).equal()),
					textAlign: "center",
					flex: "none",
					[iconCls]: {
						fontSize: token$1.fontSizeHeading2,
						color: token$1.colorPrimary
					},
					img: {
						display: "block",
						width: "100%",
						height: "100%",
						overflow: "hidden"
					}
				}),
				[`${itemCls}-progress`]: {
					bottom: uploadProgressOffset,
					width: `calc(100% - ${unit(calc(token$1.paddingSM).mul(2).equal())})`,
					marginTop: 0,
					paddingInlineStart: calc(uploadThumbnailSize).add(token$1.paddingXS).equal()
				}
			},
			[`${itemCls}-error`]: {
				borderColor: token$1.colorError,
				[`${itemCls}-thumbnail ${iconCls}`]: {
					[`svg path[fill='${blue[0]}']`]: { fill: token$1.colorErrorBg },
					[`svg path[fill='${blue.primary}']`]: { fill: token$1.colorError }
				}
			},
			[`${itemCls}-uploading`]: {
				borderStyle: "dashed",
				[`${itemCls}-name`]: { marginBottom: uploadProgressOffset }
			}
		},
		[`${listCls}${listCls}-picture-circle ${itemCls}`]: { [`&, &::before, ${itemCls}-thumbnail`]: { borderRadius: "50%" } }
	} };
};
var genPictureCardStyle = (token$1) => {
	const { componentCls, iconCls, fontSizeLG, colorTextLightSolid, calc } = token$1;
	const listCls = `${componentCls}-list`;
	const itemCls = `${listCls}-item`;
	const uploadPictureCardSize = token$1.uploadPicCardSize;
	return {
		[`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: Object.assign(Object.assign({}, clearFix()), {
			display: "block",
			[`${componentCls}${componentCls}-select`]: {
				width: uploadPictureCardSize,
				height: uploadPictureCardSize,
				textAlign: "center",
				verticalAlign: "top",
				backgroundColor: token$1.colorFillAlter,
				border: `${unit(token$1.lineWidth)} dashed ${token$1.colorBorder}`,
				borderRadius: token$1.borderRadiusLG,
				cursor: "pointer",
				transition: `border-color ${token$1.motionDurationSlow}`,
				[`> ${componentCls}`]: {
					display: "flex",
					alignItems: "center",
					justifyContent: "center",
					height: "100%",
					textAlign: "center"
				},
				[`&:not(${componentCls}-disabled):hover`]: { borderColor: token$1.colorPrimary }
			},
			[`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
				display: "flex",
				flexWrap: "wrap",
				"@supports not (gap: 1px)": { "& > *": {
					marginBlockEnd: token$1.marginXS,
					marginInlineEnd: token$1.marginXS
				} },
				"@supports (gap: 1px)": { gap: token$1.marginXS },
				[`${listCls}-item-container`]: {
					display: "inline-block",
					width: uploadPictureCardSize,
					height: uploadPictureCardSize,
					verticalAlign: "top"
				},
				"&::after": { display: "none" },
				"&::before": { display: "none" },
				[itemCls]: {
					height: "100%",
					margin: 0,
					"&::before": {
						position: "absolute",
						zIndex: 1,
						width: `calc(100% - ${unit(calc(token$1.paddingXS).mul(2).equal())})`,
						height: `calc(100% - ${unit(calc(token$1.paddingXS).mul(2).equal())})`,
						backgroundColor: token$1.colorBgMask,
						opacity: 0,
						transition: `all ${token$1.motionDurationSlow}`,
						content: "\" \""
					}
				},
				[`${itemCls}:hover`]: { [`&::before, ${itemCls}-actions`]: { opacity: 1 } },
				[`${itemCls}-actions`]: {
					position: "absolute",
					insetInlineStart: 0,
					zIndex: 10,
					width: "100%",
					whiteSpace: "nowrap",
					textAlign: "center",
					opacity: 0,
					transition: `all ${token$1.motionDurationSlow}`,
					[`
            ${iconCls}-eye,
            ${iconCls}-download,
            ${iconCls}-delete
          `]: {
						zIndex: 10,
						width: fontSizeLG,
						margin: `0 ${unit(token$1.marginXXS)}`,
						fontSize: fontSizeLG,
						cursor: "pointer",
						transition: `all ${token$1.motionDurationSlow}`,
						color: colorTextLightSolid,
						"&:hover": { color: colorTextLightSolid },
						svg: { verticalAlign: "baseline" }
					}
				},
				[`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
					position: "static",
					display: "block",
					width: "100%",
					height: "100%",
					objectFit: "contain"
				},
				[`${itemCls}-name`]: {
					display: "none",
					textAlign: "center"
				},
				[`${itemCls}-file + ${itemCls}-name`]: {
					position: "absolute",
					bottom: token$1.margin,
					display: "block",
					width: `calc(100% - ${unit(calc(token$1.paddingXS).mul(2).equal())})`
				},
				[`${itemCls}-uploading`]: {
					[`&${itemCls}`]: { backgroundColor: token$1.colorFillAlter },
					[`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: { display: "none" }
				},
				[`${itemCls}-progress`]: {
					bottom: token$1.marginXL,
					width: `calc(100% - ${unit(calc(token$1.paddingXS).mul(2).equal())})`,
					paddingInlineStart: 0
				}
			}
		}),
		[`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: { [`${componentCls}${componentCls}-select`]: { borderRadius: "50%" } }
	};
};

//#endregion
//#region node_modules/antd/es/upload/style/rtl.js
var genRtlStyle$1 = (token$1) => {
	const { componentCls } = token$1;
	return { [`${componentCls}-rtl`]: { direction: "rtl" } };
};
var rtl_default = genRtlStyle$1;

//#endregion
//#region node_modules/antd/es/upload/style/index.js
var genBaseStyle = (token$1) => {
	const { componentCls, colorTextDisabled } = token$1;
	return { [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token$1)), {
		[componentCls]: {
			outline: 0,
			"input[type='file']": { cursor: "pointer" }
		},
		[`${componentCls}-select`]: { display: "inline-block" },
		[`${componentCls}-hidden`]: { display: "none" },
		[`${componentCls}-disabled`]: {
			color: colorTextDisabled,
			cursor: "not-allowed"
		}
	}) };
};
const prepareComponentToken$1 = (token$1) => ({ actionsColor: token$1.colorIcon });
var style_default$1 = genStyleHooks("Upload", (token$1) => {
	const { fontSizeHeading3, fontHeight, lineWidth, controlHeightLG, calc } = token$1;
	const uploadToken = merge(token$1, {
		uploadThumbnailSize: calc(fontSizeHeading3).mul(2).equal(),
		uploadProgressOffset: calc(calc(fontHeight).div(2)).add(lineWidth).equal(),
		uploadPicCardSize: calc(controlHeightLG).mul(2.55).equal()
	});
	return [
		genBaseStyle(uploadToken),
		dragger_default(uploadToken),
		genPictureStyle(uploadToken),
		genPictureCardStyle(uploadToken),
		list_default$1(uploadToken),
		motion_default$1(uploadToken),
		rtl_default(uploadToken),
		collapse_default$1(uploadToken)
	];
}, prepareComponentToken$1);

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/FileTwoTone.js
var FileTwoTone = {
	"icon": function render$1(primaryColor, secondaryColor) {
		return {
			"tag": "svg",
			"attrs": {
				"viewBox": "64 64 896 896",
				"focusable": "false"
			},
			"children": [{
				"tag": "path",
				"attrs": {
					"d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z",
					"fill": secondaryColor
				}
			}, {
				"tag": "path",
				"attrs": {
					"d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z",
					"fill": primaryColor
				}
			}]
		};
	},
	"name": "file",
	"theme": "twotone"
};
var FileTwoTone_default$1 = FileTwoTone;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/FileTwoTone.js
/**![file](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUzNCAzNTJWMTM2SDIzMnY3NTJoNTYwVjM5NEg1NzZhNDIgNDIgMCAwMS00Mi00MnoiIGZpbGw9IiNlNmY0ZmYiIC8+PHBhdGggZD0iTTg1NC42IDI4OC42TDYzOS40IDczLjRjLTYtNi0xNC4xLTkuNC0yMi42LTkuNEgxOTJjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjgzMmMwIDE3LjcgMTQuMyAzMiAzMiAzMmg2NDBjMTcuNyAwIDMyLTE0LjMgMzItMzJWMzExLjNjMC04LjUtMy40LTE2LjctOS40LTIyLjd6TTYwMiAxMzcuOEw3OTAuMiAzMjZINjAyVjEzNy44ek03OTIgODg4SDIzMlYxMzZoMzAydjIxNmE0MiA0MiAwIDAwNDIgNDJoMjE2djQ5NHoiIGZpbGw9IiMxNjc3ZmYiIC8+PC9zdmc+) */
var RefIcon$3 = /* @__PURE__ */ import_react.forwardRef(function FileTwoTone$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: FileTwoTone_default$1
	}));
});
RefIcon$3.displayName = "FileTwoTone";
var FileTwoTone_default = RefIcon$3;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/PaperClipOutlined.js
var PaperClipOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" }
		}]
	},
	"name": "paper-clip",
	"theme": "outlined"
};
var PaperClipOutlined_default$1 = PaperClipOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/PaperClipOutlined.js
/**![paper-clip](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTc3OS4zIDE5Ni42Yy05NC4yLTk0LjItMjQ3LjYtOTQuMi0zNDEuNyAwbC0yNjEgMjYwLjhjLTEuNyAxLjctMi42IDQtMi42IDYuNHMuOSA0LjcgMi42IDYuNGwzNi45IDM2LjlhOSA5IDAgMDAxMi43IDBsMjYxLTI2MC44YzMyLjQtMzIuNCA3NS41LTUwLjIgMTIxLjMtNTAuMnM4OC45IDE3LjggMTIxLjIgNTAuMmMzMi40IDMyLjQgNTAuMiA3NS41IDUwLjIgMTIxLjIgMCA0NS44LTE3LjggODguOC01MC4yIDEyMS4ybC0yNjYgMjY1LjktNDMuMSA0My4xYy00MC4zIDQwLjMtMTA1LjggNDAuMy0xNDYuMSAwLTE5LjUtMTkuNS0zMC4yLTQ1LjQtMzAuMi03M3MxMC43LTUzLjUgMzAuMi03M2wyNjMuOS0yNjMuOGM2LjctNi42IDE1LjUtMTAuMyAyNC45LTEwLjNoLjFjOS40IDAgMTguMSAzLjcgMjQuNyAxMC4zIDYuNyA2LjcgMTAuMyAxNS41IDEwLjMgMjQuOSAwIDkuMy0zLjcgMTguMS0xMC4zIDI0LjdMMzcyLjQgNjUzYy0xLjcgMS43LTIuNiA0LTIuNiA2LjRzLjkgNC43IDIuNiA2LjRsMzYuOSAzNi45YTkgOSAwIDAwMTIuNyAwbDIxNS42LTIxNS42YzE5LjktMTkuOSAzMC44LTQ2LjMgMzAuOC03NC40cy0xMS01NC42LTMwLjgtNzQuNGMtNDEuMS00MS4xLTEwNy45LTQxLTE0OSAwTDQ2MyAzNjQgMjI0LjggNjAyLjFBMTcyLjIyIDE3Mi4yMiAwIDAwMTc0IDcyNC44YzAgNDYuMyAxOC4xIDg5LjggNTAuOCAxMjIuNSAzMy45IDMzLjggNzguMyA1MC43IDEyMi43IDUwLjcgNDQuNCAwIDg4LjgtMTYuOSAxMjIuNi01MC43bDMwOS4yLTMwOUM4MjQuOCA0OTIuNyA4NTAgNDMyIDg1MCAzNjcuNWMuMS02NC42LTI1LjEtMTI1LjMtNzAuNy0xNzAuOXoiIC8+PC9zdmc+) */
var RefIcon$2 = /* @__PURE__ */ import_react.forwardRef(function PaperClipOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: PaperClipOutlined_default$1
	}));
});
RefIcon$2.displayName = "PaperClipOutlined";
var PaperClipOutlined_default = RefIcon$2;

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/PictureTwoTone.js
var PictureTwoTone = {
	"icon": function render$1(primaryColor, secondaryColor) {
		return {
			"tag": "svg",
			"attrs": {
				"viewBox": "64 64 896 896",
				"focusable": "false"
			},
			"children": [
				{
					"tag": "path",
					"attrs": {
						"d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z",
						"fill": primaryColor
					}
				},
				{
					"tag": "path",
					"attrs": {
						"d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z",
						"fill": secondaryColor
					}
				},
				{
					"tag": "path",
					"attrs": {
						"d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z",
						"fill": secondaryColor
					}
				},
				{
					"tag": "path",
					"attrs": {
						"d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z",
						"fill": secondaryColor
					}
				},
				{
					"tag": "path",
					"attrs": {
						"d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z",
						"fill": primaryColor
					}
				}
			]
		};
	},
	"name": "picture",
	"theme": "twotone"
};
var PictureTwoTone_default$1 = PictureTwoTone;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/PictureTwoTone.js
/**![picture](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkyOCAxNjBIOTZjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjY0MGMwIDE3LjcgMTQuMyAzMiAzMiAzMmg4MzJjMTcuNyAwIDMyLTE0LjMgMzItMzJWMTkyYzAtMTcuNy0xNC4zLTMyLTMyLTMyem0tNDAgNjMySDEzNnYtMzkuOWwxMzguNS0xNjQuMyAxNTAuMSAxNzhMNjU4LjEgNDg5IDg4OCA3NjEuNlY3OTJ6bTAtMTI5LjhMNjY0LjIgMzk2LjhjLTMuMi0zLjgtOS0zLjgtMTIuMiAwTDQyNC42IDY2Ni40bC0xNDQtMTcwLjdjLTMuMi0zLjgtOS0zLjgtMTIuMiAwTDEzNiA2NTIuN1YyMzJoNzUydjQzMC4yeiIgZmlsbD0iIzE2NzdmZiIgLz48cGF0aCBkPSJNNDI0LjYgNzY1LjhsLTE1MC4xLTE3OEwxMzYgNzUyLjFWNzkyaDc1MnYtMzAuNEw2NTguMSA0ODl6IiBmaWxsPSIjZTZmNGZmIiAvPjxwYXRoIGQ9Ik0xMzYgNjUyLjdsMTMyLjQtMTU3YzMuMi0zLjggOS0zLjggMTIuMiAwbDE0NCAxNzAuN0w2NTIgMzk2LjhjMy4yLTMuOCA5LTMuOCAxMi4yIDBMODg4IDY2Mi4yVjIzMkgxMzZ2NDIwLjd6TTMwNCAyODBhODggODggMCAxMTAgMTc2IDg4IDg4IDAgMDEwLTE3NnoiIGZpbGw9IiNlNmY0ZmYiIC8+PHBhdGggZD0iTTI3NiAzNjhhMjggMjggMCAxMDU2IDAgMjggMjggMCAxMC01NiAweiIgZmlsbD0iI2U2ZjRmZiIgLz48cGF0aCBkPSJNMzA0IDQ1NmE4OCA4OCAwIDEwMC0xNzYgODggODggMCAwMDAgMTc2em0wLTExNmMxNS41IDAgMjggMTIuNSAyOCAyOHMtMTIuNSAyOC0yOCAyOC0yOC0xMi41LTI4LTI4IDEyLjUtMjggMjgtMjh6IiBmaWxsPSIjMTY3N2ZmIiAvPjwvc3ZnPg==) */
var RefIcon$1 = /* @__PURE__ */ import_react.forwardRef(function PictureTwoTone$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: PictureTwoTone_default$1
	}));
});
RefIcon$1.displayName = "PictureTwoTone";
var PictureTwoTone_default = RefIcon$1;

//#endregion
//#region node_modules/antd/es/upload/utils.js
function file2Obj(file) {
	return Object.assign(Object.assign({}, file), {
		lastModified: file.lastModified,
		lastModifiedDate: file.lastModifiedDate,
		name: file.name,
		size: file.size,
		type: file.type,
		uid: file.uid,
		percent: 0,
		originFileObj: file
	});
}
/** Upload fileList. Replace file if exist or just push into it. */
function updateFileList(file, fileList) {
	const nextFileList = _toConsumableArray(fileList);
	const fileIndex = nextFileList.findIndex(({ uid: uid$2 }) => uid$2 === file.uid);
	if (fileIndex === -1) nextFileList.push(file);
	else nextFileList[fileIndex] = file;
	return nextFileList;
}
function getFileItem(file, fileList) {
	const matchKey = file.uid !== void 0 ? "uid" : "name";
	return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
}
function removeFileItem(file, fileList) {
	const matchKey = file.uid !== void 0 ? "uid" : "name";
	const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
	if (removed.length === fileList.length) return null;
	return removed;
}
var extname = (url = "") => {
	const temp = url.split("/");
	const filenameWithoutSuffix = temp[temp.length - 1].split(/#|\?/)[0];
	return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
};
var isImageFileType = (type$2) => type$2.indexOf("image/") === 0;
const isImageUrl = (file) => {
	if (file.type && !file.thumbUrl) return isImageFileType(file.type);
	const url = file.thumbUrl || file.url || "";
	const extension = extname(url);
	if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension)) return true;
	if (/^data:/.test(url)) return false;
	if (extension) return false;
	return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
	return new Promise((resolve) => {
		if (!file.type || !isImageFileType(file.type)) {
			resolve("");
			return;
		}
		const canvas = document.createElement("canvas");
		canvas.width = MEASURE_SIZE;
		canvas.height = MEASURE_SIZE;
		canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
		document.body.appendChild(canvas);
		const ctx = canvas.getContext("2d");
		const img = new Image();
		img.onload = () => {
			const { width, height } = img;
			let drawWidth = MEASURE_SIZE;
			let drawHeight = MEASURE_SIZE;
			let offsetX = 0;
			let offsetY = 0;
			if (width > height) {
				drawHeight = height * (MEASURE_SIZE / width);
				offsetY = -(drawHeight - drawWidth) / 2;
			} else {
				drawWidth = width * (MEASURE_SIZE / height);
				offsetX = -(drawWidth - drawHeight) / 2;
			}
			ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
			const dataURL = canvas.toDataURL();
			document.body.removeChild(canvas);
			window.URL.revokeObjectURL(img.src);
			resolve(dataURL);
		};
		img.crossOrigin = "anonymous";
		if (file.type.startsWith("image/svg+xml")) {
			const reader = new FileReader();
			reader.onload = () => {
				if (reader.result && typeof reader.result === "string") img.src = reader.result;
			};
			reader.readAsDataURL(file);
		} else if (file.type.startsWith("image/gif")) {
			const reader = new FileReader();
			reader.onload = () => {
				if (reader.result) resolve(reader.result);
			};
			reader.readAsDataURL(file);
		} else img.src = window.URL.createObjectURL(file);
	});
}

//#endregion
//#region node_modules/@ant-design/icons-svg/es/asn/DownloadOutlined.js
var DownloadOutlined = {
	"icon": {
		"tag": "svg",
		"attrs": {
			"viewBox": "64 64 896 896",
			"focusable": "false"
		},
		"children": [{
			"tag": "path",
			"attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" }
		}]
	},
	"name": "download",
	"theme": "outlined"
};
var DownloadOutlined_default$1 = DownloadOutlined;

//#endregion
//#region node_modules/antd/node_modules/@ant-design/icons/es/icons/DownloadOutlined.js
/**![download](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUwNS43IDY2MWE4IDggMCAwMDEyLjYgMGwxMTItMTQxLjdjNC4xLTUuMi40LTEyLjktNi4zLTEyLjloLTc0LjFWMTY4YzAtNC40LTMuNi04LTgtOGgtNjBjLTQuNCAwLTggMy42LTggOHYzMzguM0g0MDBjLTYuNyAwLTEwLjQgNy43LTYuMyAxMi45bDExMiAxNDEuOHpNODc4IDYyNmgtNjBjLTQuNCAwLTggMy42LTggOHYxNTRIMjE0VjYzNGMwLTQuNC0zLjYtOC04LThoLTYwYy00LjQgMC04IDMuNi04IDh2MTk4YzAgMTcuNyAxNC4zIDMyIDMyIDMyaDY4NGMxNy43IDAgMzItMTQuMyAzMi0zMlY2MzRjMC00LjQtMy42LTgtOC04eiIgLz48L3N2Zz4=) */
var RefIcon = /* @__PURE__ */ import_react.forwardRef(function DownloadOutlined$1(props, ref) {
	return /* @__PURE__ */ import_react.createElement(AntdIcon_default, _extends({}, props, {
		ref,
		icon: DownloadOutlined_default$1
	}));
});
RefIcon.displayName = "DownloadOutlined";
var DownloadOutlined_default = RefIcon;

//#endregion
//#region node_modules/antd/es/upload/UploadList/ListItem.js
var import_classnames$6 = /* @__PURE__ */ __toESM(require_classnames());
var ListItem = /* @__PURE__ */ import_react.forwardRef(({ prefixCls, className, style: style$1, locale: locale$5, listType, file, items, progress: progressProps, iconRender, actionIconRender, itemRender, isImgUrl, showPreviewIcon, showRemoveIcon, showDownloadIcon, previewIcon: customPreviewIcon, removeIcon: customRemoveIcon, downloadIcon: customDownloadIcon, extra: customExtra, onPreview, onDownload, onClose }, ref) => {
	var _a, _b;
	const { status } = file;
	const [mergedStatus, setMergedStatus] = import_react.useState(status);
	import_react.useEffect(() => {
		if (status !== "removed") setMergedStatus(status);
	}, [status]);
	const [showProgress, setShowProgress] = import_react.useState(false);
	import_react.useEffect(() => {
		const timer = setTimeout(() => {
			setShowProgress(true);
		}, 300);
		return () => {
			clearTimeout(timer);
		};
	}, []);
	const iconNode = iconRender(file);
	let icon = /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-icon` }, iconNode);
	if (listType === "picture" || listType === "picture-card" || listType === "picture-circle") if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
		const uploadingClassName = (0, import_classnames$6.default)(`${prefixCls}-list-item-thumbnail`, { [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading" });
		icon = /* @__PURE__ */ import_react.createElement("div", { className: uploadingClassName }, iconNode);
	} else {
		const thumbnail = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? /* @__PURE__ */ import_react.createElement("img", {
			src: file.thumbUrl || file.url,
			alt: file.name,
			className: `${prefixCls}-list-item-image`,
			crossOrigin: file.crossOrigin
		}) : iconNode;
		const aClassName = (0, import_classnames$6.default)(`${prefixCls}-list-item-thumbnail`, { [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file) });
		icon = /* @__PURE__ */ import_react.createElement("a", {
			className: aClassName,
			onClick: (e$2) => onPreview(file, e$2),
			href: file.url || file.thumbUrl,
			target: "_blank",
			rel: "noopener noreferrer"
		}, thumbnail);
	}
	const listItemClassName = (0, import_classnames$6.default)(`${prefixCls}-list-item`, `${prefixCls}-list-item-${mergedStatus}`);
	const linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
	const removeIcon = (typeof showRemoveIcon === "function" ? showRemoveIcon(file) : showRemoveIcon) ? actionIconRender((typeof customRemoveIcon === "function" ? customRemoveIcon(file) : customRemoveIcon) || /* @__PURE__ */ import_react.createElement(DeleteOutlined_default, null), () => onClose(file), prefixCls, locale$5.removeFile, true) : null;
	const downloadIcon = (typeof showDownloadIcon === "function" ? showDownloadIcon(file) : showDownloadIcon) && mergedStatus === "done" ? actionIconRender((typeof customDownloadIcon === "function" ? customDownloadIcon(file) : customDownloadIcon) || /* @__PURE__ */ import_react.createElement(DownloadOutlined_default, null), () => onDownload(file), prefixCls, locale$5.downloadFile) : null;
	const downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && /* @__PURE__ */ import_react.createElement("span", {
		key: "download-delete",
		className: (0, import_classnames$6.default)(`${prefixCls}-list-item-actions`, { picture: listType === "picture" })
	}, downloadIcon, removeIcon);
	const extraContent = typeof customExtra === "function" ? customExtra(file) : customExtra;
	const extra = extraContent && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-list-item-extra` }, extraContent);
	const listItemNameClass = (0, import_classnames$6.default)(`${prefixCls}-list-item-name`);
	const fileName = file.url ? /* @__PURE__ */ import_react.createElement("a", Object.assign({
		key: "view",
		target: "_blank",
		rel: "noopener noreferrer",
		className: listItemNameClass,
		title: file.name
	}, linkProps, {
		href: file.url,
		onClick: (e$2) => onPreview(file, e$2)
	}), file.name, extra) : /* @__PURE__ */ import_react.createElement("span", {
		key: "view",
		className: listItemNameClass,
		onClick: (e$2) => onPreview(file, e$2),
		title: file.name
	}, file.name, extra);
	const previewIcon = (typeof showPreviewIcon === "function" ? showPreviewIcon(file) : showPreviewIcon) && (file.url || file.thumbUrl) ? /* @__PURE__ */ import_react.createElement("a", {
		href: file.url || file.thumbUrl,
		target: "_blank",
		rel: "noopener noreferrer",
		onClick: (e$2) => onPreview(file, e$2),
		title: locale$5.previewFile
	}, typeof customPreviewIcon === "function" ? customPreviewIcon(file) : customPreviewIcon || /* @__PURE__ */ import_react.createElement(EyeOutlined_default, null)) : null;
	const pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && /* @__PURE__ */ import_react.createElement("span", { className: `${prefixCls}-list-item-actions` }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon);
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const rootPrefixCls = getPrefixCls();
	const dom = /* @__PURE__ */ import_react.createElement("div", { className: listItemClassName }, icon, fileName, downloadOrDelete, pictureCardActions, showProgress && /* @__PURE__ */ import_react.createElement(es_default$2, {
		motionName: `${rootPrefixCls}-fade`,
		visible: mergedStatus === "uploading",
		motionDeadline: 2e3
	}, ({ className: motionClassName }) => {
		const loadingProgress = "percent" in file ? /* @__PURE__ */ import_react.createElement(progress_default, Object.assign({
			type: "line",
			percent: file.percent,
			"aria-label": file["aria-label"],
			"aria-labelledby": file["aria-labelledby"]
		}, progressProps)) : null;
		return /* @__PURE__ */ import_react.createElement("div", { className: (0, import_classnames$6.default)(`${prefixCls}-list-item-progress`, motionClassName) }, loadingProgress);
	}));
	const message$1 = file.response && typeof file.response === "string" ? file.response : ((_a = file.error) === null || _a === void 0 ? void 0 : _a.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale$5.uploadError;
	const item = mergedStatus === "error" ? /* @__PURE__ */ import_react.createElement(tooltip_default, {
		title: message$1,
		getPopupContainer: (node$1) => node$1.parentNode
	}, dom) : dom;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$6.default)(`${prefixCls}-list-item-container`, className),
		style: style$1,
		ref
	}, itemRender ? itemRender(item, file, items, {
		download: onDownload.bind(null, file),
		preview: onPreview.bind(null, file),
		remove: onClose.bind(null, file)
	}) : item);
});
var ListItem_default = ListItem;

//#endregion
//#region node_modules/antd/es/upload/UploadList/index.js
var import_classnames$5 = /* @__PURE__ */ __toESM(require_classnames());
var InternalUploadList = (props, ref) => {
	const { listType = "text", previewFile = previewImage, onPreview, onDownload, onRemove, locale: locale$5, iconRender, isImageUrl: isImgUrl = isImageUrl, prefixCls: customizePrefixCls, items = [], showPreviewIcon = true, showRemoveIcon = true, showDownloadIcon = false, removeIcon, previewIcon, downloadIcon, extra, progress = {
		size: [-1, 2],
		showInfo: false
	}, appendAction, appendActionVisible = true, itemRender, disabled } = props;
	const forceUpdate = useForceUpdate();
	const [motionAppear, setMotionAppear] = import_react.useState(false);
	const isPictureCardOrCirle = ["picture-card", "picture-circle"].includes(listType);
	import_react.useEffect(() => {
		if (!listType.startsWith("picture")) return;
		(items || []).forEach((file) => {
			if (!(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) return;
			file.thumbUrl = "";
			previewFile === null || previewFile === void 0 || previewFile(file.originFileObj).then((previewDataUrl) => {
				file.thumbUrl = previewDataUrl || "";
				forceUpdate();
			});
		});
	}, [
		listType,
		items,
		previewFile
	]);
	import_react.useEffect(() => {
		setMotionAppear(true);
	}, []);
	const onInternalPreview = (file, e$2) => {
		if (!onPreview) return;
		e$2 === null || e$2 === void 0 || e$2.preventDefault();
		return onPreview(file);
	};
	const onInternalDownload = (file) => {
		if (typeof onDownload === "function") onDownload(file);
		else if (file.url) window.open(file.url);
	};
	const onInternalClose = (file) => {
		onRemove === null || onRemove === void 0 || onRemove(file);
	};
	const internalIconRender = (file) => {
		if (iconRender) return iconRender(file, listType);
		const isLoading = file.status === "uploading";
		if (listType.startsWith("picture")) {
			const loadingIcon = listType === "picture" ? /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null) : locale$5.uploading;
			const fileIcon = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? /* @__PURE__ */ import_react.createElement(PictureTwoTone_default, null) : /* @__PURE__ */ import_react.createElement(FileTwoTone_default, null);
			return isLoading ? loadingIcon : fileIcon;
		}
		return isLoading ? /* @__PURE__ */ import_react.createElement(LoadingOutlined_default, null) : /* @__PURE__ */ import_react.createElement(PaperClipOutlined_default, null);
	};
	const actionIconRender = (customIcon, callback, prefixCls$1, title, acceptUploadDisabled) => {
		const btnProps = {
			type: "text",
			size: "small",
			title,
			onClick: (e$2) => {
				var _a, _b;
				callback();
				if (/* @__PURE__ */ import_react.isValidElement(customIcon)) (_b = (_a = customIcon.props).onClick) === null || _b === void 0 || _b.call(_a, e$2);
			},
			className: `${prefixCls$1}-list-item-action`,
			disabled: acceptUploadDisabled ? disabled : false
		};
		return /* @__PURE__ */ import_react.isValidElement(customIcon) ? /* @__PURE__ */ import_react.createElement(button_default, Object.assign({}, btnProps, { icon: cloneElement(customIcon, Object.assign(Object.assign({}, customIcon.props), { onClick: () => {} })) })) : /* @__PURE__ */ import_react.createElement(button_default, Object.assign({}, btnProps), /* @__PURE__ */ import_react.createElement("span", null, customIcon));
	};
	import_react.useImperativeHandle(ref, () => ({
		handlePreview: onInternalPreview,
		handleDownload: onInternalDownload
	}));
	const { getPrefixCls } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("upload", customizePrefixCls);
	const rootPrefixCls = getPrefixCls();
	const listClassNames = (0, import_classnames$5.default)(`${prefixCls}-list`, `${prefixCls}-list-${listType}`);
	const listItemMotion = import_react.useMemo(() => omit(motion_default(rootPrefixCls), [
		"onAppearEnd",
		"onEnterEnd",
		"onLeaveEnd"
	]), [rootPrefixCls]);
	const motionConfig = Object.assign(Object.assign({}, isPictureCardOrCirle ? {} : listItemMotion), {
		motionDeadline: 2e3,
		motionName: `${prefixCls}-${isPictureCardOrCirle ? "animate-inline" : "animate"}`,
		keys: _toConsumableArray(items.map((file) => ({
			key: file.uid,
			file
		}))),
		motionAppear
	});
	return /* @__PURE__ */ import_react.createElement("div", { className: listClassNames }, /* @__PURE__ */ import_react.createElement(CSSMotionList_default, Object.assign({}, motionConfig, { component: false }), ({ key, file, className: motionClassName, style: motionStyle }) => /* @__PURE__ */ import_react.createElement(ListItem_default, {
		key,
		locale: locale$5,
		prefixCls,
		className: motionClassName,
		style: motionStyle,
		file,
		items,
		progress,
		listType,
		isImgUrl,
		showPreviewIcon,
		showRemoveIcon,
		showDownloadIcon,
		removeIcon,
		previewIcon,
		downloadIcon,
		extra,
		iconRender: internalIconRender,
		actionIconRender,
		itemRender,
		onPreview: onInternalPreview,
		onDownload: onInternalDownload,
		onClose: onInternalClose
	})), appendAction && /* @__PURE__ */ import_react.createElement(es_default$2, Object.assign({}, motionConfig, {
		visible: appendActionVisible,
		forceRender: true
	}), ({ className: motionClassName, style: motionStyle }) => cloneElement(appendAction, (oriProps) => ({
		className: (0, import_classnames$5.default)(oriProps.className, motionClassName),
		style: Object.assign(Object.assign(Object.assign({}, motionStyle), { pointerEvents: motionClassName ? "none" : void 0 }), oriProps.style)
	}))));
};
var UploadList = /* @__PURE__ */ import_react.forwardRef(InternalUploadList);
UploadList.displayName = "UploadList";
var UploadList_default = UploadList;

//#endregion
//#region node_modules/antd/es/upload/Upload.js
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom());
var import_classnames$4 = /* @__PURE__ */ __toESM(require_classnames());
var __awaiter = void 0 && (void 0).__awaiter || function(thisArg, _arguments, P, generator$1) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator$1.next(value));
			} catch (e$2) {
				reject(e$2);
			}
		}
		function rejected(value) {
			try {
				step(generator$1["throw"](value));
			} catch (e$2) {
				reject(e$2);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator$1 = generator$1.apply(thisArg, _arguments || [])).next());
	});
};
const LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
var InternalUpload = (props, ref) => {
	const config = useComponentConfig("upload");
	const { fileList, defaultFileList, onRemove, showUploadList = true, listType = "text", onPreview, onDownload, onChange, onDrop, previewFile, disabled: customDisabled, locale: propLocale, iconRender, isImageUrl: isImageUrl$1, progress, prefixCls: customizePrefixCls, className, type: type$2 = "select", children, style: style$1, itemRender, maxCount, data = {}, multiple = false, hasControlInside = true, action = "", accept = "", supportServerRender = true, rootClassName } = props;
	const disabled = import_react.useContext(DisabledContext_default);
	const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
	const customRequest = props.customRequest || config.customRequest;
	const [mergedFileList, setMergedFileList] = useMergedState(defaultFileList || [], {
		value: fileList,
		postState: (list) => list !== null && list !== void 0 ? list : []
	});
	const [dragState, setDragState] = import_react.useState("drop");
	const upload$1 = import_react.useRef(null);
	const wrapRef = import_react.useRef(null);
	{
		const warning$4 = devUseWarning("Upload");
		warning$4("fileList" in props || !("value" in props), "usage", "`value` is not a valid prop, do you mean `fileList`?");
		warning$4.deprecated(!("transformFile" in props), "transformFile", "beforeUpload");
	}
	import_react.useMemo(() => {
		const timestamp = Date.now();
		(fileList || []).forEach((file, index$2) => {
			if (!file.uid && !Object.isFrozen(file)) file.uid = `__AUTO__${timestamp}_${index$2}__`;
		});
	}, [fileList]);
	const onInternalChange = (file, changedFileList, event) => {
		let cloneList = _toConsumableArray(changedFileList);
		let exceedMaxCount = false;
		if (maxCount === 1) cloneList = cloneList.slice(-1);
		else if (maxCount) {
			exceedMaxCount = cloneList.length > maxCount;
			cloneList = cloneList.slice(0, maxCount);
		}
		(0, import_react_dom.flushSync)(() => {
			setMergedFileList(cloneList);
		});
		const changeInfo = {
			file,
			fileList: cloneList
		};
		if (event) changeInfo.event = event;
		if (!exceedMaxCount || file.status === "removed" || cloneList.some((f) => f.uid === file.uid)) (0, import_react_dom.flushSync)(() => {
			onChange === null || onChange === void 0 || onChange(changeInfo);
		});
	};
	const mergedBeforeUpload = (file, fileListArgs) => __awaiter(void 0, void 0, void 0, function* () {
		const { beforeUpload, transformFile } = props;
		let parsedFile = file;
		if (beforeUpload) {
			const result = yield beforeUpload(file, fileListArgs);
			if (result === false) return false;
			delete file[LIST_IGNORE];
			if (result === LIST_IGNORE) {
				Object.defineProperty(file, LIST_IGNORE, {
					value: true,
					configurable: true
				});
				return false;
			}
			if (typeof result === "object" && result) parsedFile = result;
		}
		if (transformFile) parsedFile = yield transformFile(parsedFile);
		return parsedFile;
	});
	const onBatchStart = (batchFileInfoList) => {
		const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
		if (!filteredFileInfoList.length) return;
		const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
		let newFileList = _toConsumableArray(mergedFileList);
		objectFileList.forEach((fileObj) => {
			newFileList = updateFileList(fileObj, newFileList);
		});
		objectFileList.forEach((fileObj, index$2) => {
			let triggerFileObj = fileObj;
			if (!filteredFileInfoList[index$2].parsedFile) {
				const { originFileObj } = fileObj;
				let clone;
				try {
					clone = new File([originFileObj], originFileObj.name, { type: originFileObj.type });
				} catch (_a) {
					clone = new Blob([originFileObj], { type: originFileObj.type });
					clone.name = originFileObj.name;
					clone.lastModifiedDate = /* @__PURE__ */ new Date();
					clone.lastModified = (/* @__PURE__ */ new Date()).getTime();
				}
				clone.uid = fileObj.uid;
				triggerFileObj = clone;
			} else fileObj.status = "uploading";
			onInternalChange(triggerFileObj, newFileList);
		});
	};
	const onSuccess = (response, file, xhr) => {
		try {
			if (typeof response === "string") response = JSON.parse(response);
		} catch (_a) {}
		if (!getFileItem(file, mergedFileList)) return;
		const targetItem = file2Obj(file);
		targetItem.status = "done";
		targetItem.percent = 100;
		targetItem.response = response;
		targetItem.xhr = xhr;
		const nextFileList = updateFileList(targetItem, mergedFileList);
		onInternalChange(targetItem, nextFileList);
	};
	const onProgress = (e$2, file) => {
		if (!getFileItem(file, mergedFileList)) return;
		const targetItem = file2Obj(file);
		targetItem.status = "uploading";
		targetItem.percent = e$2.percent;
		const nextFileList = updateFileList(targetItem, mergedFileList);
		onInternalChange(targetItem, nextFileList, e$2);
	};
	const onError = (error, response, file) => {
		if (!getFileItem(file, mergedFileList)) return;
		const targetItem = file2Obj(file);
		targetItem.error = error;
		targetItem.response = response;
		targetItem.status = "error";
		const nextFileList = updateFileList(targetItem, mergedFileList);
		onInternalChange(targetItem, nextFileList);
	};
	const handleRemove = (file) => {
		let currentFile;
		Promise.resolve(typeof onRemove === "function" ? onRemove(file) : onRemove).then((ret) => {
			var _a;
			if (ret === false) return;
			const removedFileList = removeFileItem(file, mergedFileList);
			if (removedFileList) {
				currentFile = Object.assign(Object.assign({}, file), { status: "removed" });
				mergedFileList === null || mergedFileList === void 0 || mergedFileList.forEach((item) => {
					const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
					if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) item.status = "removed";
				});
				(_a = upload$1.current) === null || _a === void 0 || _a.abort(currentFile);
				onInternalChange(currentFile, removedFileList);
			}
		});
	};
	const onFileDrop = (e$2) => {
		setDragState(e$2.type);
		if (e$2.type === "drop") onDrop === null || onDrop === void 0 || onDrop(e$2);
	};
	import_react.useImperativeHandle(ref, () => ({
		onBatchStart,
		onSuccess,
		onProgress,
		onError,
		fileList: mergedFileList,
		upload: upload$1.current,
		nativeElement: wrapRef.current
	}));
	const { getPrefixCls, direction, upload: ctxUpload } = import_react.useContext(ConfigContext);
	const prefixCls = getPrefixCls("upload", customizePrefixCls);
	const rcUploadProps = Object.assign(Object.assign({
		onBatchStart,
		onError,
		onProgress,
		onSuccess
	}, props), {
		customRequest,
		data,
		multiple,
		action,
		accept,
		supportServerRender,
		prefixCls,
		disabled: mergedDisabled,
		beforeUpload: mergedBeforeUpload,
		onChange: void 0,
		hasControlInside
	});
	delete rcUploadProps.className;
	delete rcUploadProps.style;
	if (!children || mergedDisabled) delete rcUploadProps.id;
	const wrapperCls = `${prefixCls}-wrapper`;
	const [wrapCSSVar, hashId, cssVarCls] = style_default$1(prefixCls, wrapperCls);
	const [contextLocale] = useLocale_default("Upload", en_US_default.Upload);
	const { showRemoveIcon, showPreviewIcon, showDownloadIcon, removeIcon, previewIcon, downloadIcon, extra } = typeof showUploadList === "boolean" ? {} : showUploadList;
	const realShowRemoveIcon = typeof showRemoveIcon === "undefined" ? !mergedDisabled : showRemoveIcon;
	const renderUploadList = (button, buttonVisible) => {
		if (!showUploadList) return button;
		return /* @__PURE__ */ import_react.createElement(UploadList_default, {
			prefixCls,
			listType,
			items: mergedFileList,
			previewFile,
			onPreview,
			onDownload,
			onRemove: handleRemove,
			showRemoveIcon: realShowRemoveIcon,
			showPreviewIcon,
			showDownloadIcon,
			removeIcon,
			previewIcon,
			downloadIcon,
			iconRender,
			extra,
			locale: Object.assign(Object.assign({}, contextLocale), propLocale),
			isImageUrl: isImageUrl$1,
			progress,
			appendAction: button,
			appendActionVisible: buttonVisible,
			itemRender,
			disabled: mergedDisabled
		});
	};
	const mergedCls = (0, import_classnames$4.default)(wrapperCls, className, rootClassName, hashId, cssVarCls, ctxUpload === null || ctxUpload === void 0 ? void 0 : ctxUpload.className, {
		[`${prefixCls}-rtl`]: direction === "rtl",
		[`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
		[`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
	});
	const mergedStyle = Object.assign(Object.assign({}, ctxUpload === null || ctxUpload === void 0 ? void 0 : ctxUpload.style), style$1);
	if (type$2 === "drag") {
		const dragCls = (0, import_classnames$4.default)(hashId, prefixCls, `${prefixCls}-drag`, {
			[`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
			[`${prefixCls}-drag-hover`]: dragState === "dragover",
			[`${prefixCls}-disabled`]: mergedDisabled,
			[`${prefixCls}-rtl`]: direction === "rtl"
		});
		return wrapCSSVar(/* @__PURE__ */ import_react.createElement("span", {
			className: mergedCls,
			ref: wrapRef
		}, /* @__PURE__ */ import_react.createElement("div", {
			className: dragCls,
			style: mergedStyle,
			onDrop: onFileDrop,
			onDragOver: onFileDrop,
			onDragLeave: onFileDrop
		}, /* @__PURE__ */ import_react.createElement(es_default$1, Object.assign({}, rcUploadProps, {
			ref: upload$1,
			className: `${prefixCls}-btn`
		}), /* @__PURE__ */ import_react.createElement("div", { className: `${prefixCls}-drag-container` }, children))), renderUploadList()));
	}
	const uploadBtnCls = (0, import_classnames$4.default)(prefixCls, `${prefixCls}-select`, {
		[`${prefixCls}-disabled`]: mergedDisabled,
		[`${prefixCls}-hidden`]: !children
	});
	const uploadButton = /* @__PURE__ */ import_react.createElement("div", {
		className: uploadBtnCls,
		style: mergedStyle
	}, /* @__PURE__ */ import_react.createElement(es_default$1, Object.assign({}, rcUploadProps, { ref: upload$1 })));
	if (listType === "picture-card" || listType === "picture-circle") return wrapCSSVar(/* @__PURE__ */ import_react.createElement("span", {
		className: mergedCls,
		ref: wrapRef
	}, renderUploadList(uploadButton, !!children)));
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement("span", {
		className: mergedCls,
		ref: wrapRef
	}, uploadButton, renderUploadList()));
};
var Upload$1 = /* @__PURE__ */ import_react.forwardRef(InternalUpload);
Upload$1.displayName = "Upload";
var Upload_default = Upload$1;

//#endregion
//#region node_modules/antd/es/upload/Dragger.js
var __rest$1 = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
var Dragger = /* @__PURE__ */ import_react.forwardRef((_a, ref) => {
	var { style: style$1, height, hasControlInside = false } = _a, restProps = __rest$1(_a, [
		"style",
		"height",
		"hasControlInside"
	]);
	return /* @__PURE__ */ import_react.createElement(Upload_default, Object.assign({
		ref,
		hasControlInside
	}, restProps, {
		type: "drag",
		style: Object.assign(Object.assign({}, style$1), { height })
	}));
});
Dragger.displayName = "Dragger";
var Dragger_default = Dragger;

//#endregion
//#region node_modules/antd/es/upload/index.js
var Upload = Upload_default;
Upload.Dragger = Dragger_default;
Upload.LIST_IGNORE = LIST_IGNORE;
var upload_default = Upload;

//#endregion
//#region node_modules/@rc-component/mutate-observer/es/wrapper.js
var DomWrapper = /* @__PURE__ */ function(_React$Component) {
	_inherits(DomWrapper$3, _React$Component);
	var _super = _createSuper(DomWrapper$3);
	function DomWrapper$3() {
		_classCallCheck(this, DomWrapper$3);
		return _super.apply(this, arguments);
	}
	_createClass(DomWrapper$3, [{
		key: "render",
		value: function render$1() {
			return this.props.children;
		}
	}]);
	return DomWrapper$3;
}(import_react.Component);

//#endregion
//#region node_modules/@rc-component/mutate-observer/es/useMutateObserver.js
var defaultOptions = {
	subtree: true,
	childList: true,
	attributeFilter: ["style", "class"]
};
function useMutateObserver(nodeOrList, callback) {
	var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOptions;
	import_react.useEffect(function() {
		if (!canUseDom() || !nodeOrList) return;
		var instance;
		var nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];
		if ("MutationObserver" in window) {
			instance = new MutationObserver(callback);
			nodeList.forEach(function(element) {
				instance.observe(element, options);
			});
		}
		return function() {
			var _instance, _instance2;
			(_instance = instance) === null || _instance === void 0 || _instance.takeRecords();
			(_instance2 = instance) === null || _instance2 === void 0 || _instance2.disconnect();
		};
	}, [options, nodeOrList]);
}

//#endregion
//#region node_modules/antd/es/watermark/useClips.js
const FontGap = 3;
var prepareCanvas = (width, height, ratio = 1) => {
	const canvas = document.createElement("canvas");
	const ctx = canvas.getContext("2d");
	const realWidth = width * ratio;
	const realHeight = height * ratio;
	canvas.setAttribute("width", `${realWidth}px`);
	canvas.setAttribute("height", `${realHeight}px`);
	ctx.save();
	return [
		ctx,
		canvas,
		realWidth,
		realHeight
	];
};
var getRotatePos = (x, y, angle) => {
	const targetX = x * Math.cos(angle) - y * Math.sin(angle);
	const targetY = x * Math.sin(angle) + y * Math.cos(angle);
	return [targetX, targetY];
};
/**
* Get the clips of text content.
* This is a lazy hook function since SSR no need this
*/
var useClips = () => {
	const getClips = (content, rotate, ratio, width, height, font, gapX, gapY) => {
		const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);
		if (content instanceof HTMLImageElement) ctx.drawImage(content, 0, 0, contentWidth, contentHeight);
		else {
			const { color, fontSize, fontStyle, fontWeight, fontFamily, textAlign } = font;
			const mergedFontSize = Number(fontSize) * ratio;
			ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;
			ctx.fillStyle = color;
			ctx.textAlign = textAlign;
			ctx.textBaseline = "top";
			const contents = toList_default(content);
			contents === null || contents === void 0 || contents.forEach((item, index$2) => {
				ctx.fillText(item !== null && item !== void 0 ? item : "", contentWidth / 2, index$2 * (mergedFontSize + FontGap * ratio));
			});
		}
		const angle = Math.PI / 180 * Number(rotate);
		const maxSize = Math.max(width, height);
		const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);
		rCtx.translate(realMaxSize / 2, realMaxSize / 2);
		rCtx.rotate(angle);
		if (contentWidth > 0 && contentHeight > 0) rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);
		let left = 0;
		let right = 0;
		let top = 0;
		let bottom = 0;
		const halfWidth = contentWidth / 2;
		const halfHeight = contentHeight / 2;
		[
			[0 - halfWidth, 0 - halfHeight],
			[0 + halfWidth, 0 - halfHeight],
			[0 + halfWidth, 0 + halfHeight],
			[0 - halfWidth, 0 + halfHeight]
		].forEach(([x, y]) => {
			const [targetX, targetY] = getRotatePos(x, y, angle);
			left = Math.min(left, targetX);
			right = Math.max(right, targetX);
			top = Math.min(top, targetY);
			bottom = Math.max(bottom, targetY);
		});
		const cutLeft = left + realMaxSize / 2;
		const cutTop = top + realMaxSize / 2;
		const cutWidth = right - left;
		const cutHeight = bottom - top;
		const realGapX = gapX * ratio;
		const realGapY = gapY * ratio;
		const filledWidth = (cutWidth + realGapX) * 2;
		const filledHeight = cutHeight + realGapY;
		const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);
		const drawImg = (targetX = 0, targetY = 0) => {
			fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);
		};
		drawImg();
		drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);
		drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);
		return [
			fCanvas.toDataURL(),
			filledWidth / ratio,
			filledHeight / ratio
		];
	};
	return import_react.useCallback(getClips, []);
};
var useClips_default = useClips;

//#endregion
//#region node_modules/antd/es/watermark/useRafDebounce.js
/**
* Callback will only execute last one for each raf
*/
function useRafDebounce(callback) {
	const executeRef = import_react.useRef(false);
	const rafRef = import_react.useRef(null);
	const wrapperCallback = useEvent(callback);
	return () => {
		if (executeRef.current) return;
		executeRef.current = true;
		wrapperCallback();
		rafRef.current = raf_default(() => {
			executeRef.current = false;
		});
	};
}

//#endregion
//#region node_modules/antd/es/watermark/useSingletonCache.js
/**
* Singleton cache will only take latest `cacheParams` as key
* and return the result for callback matching.
*/
function useSingletonCache() {
	const cacheRef = import_react.useRef([null, null]);
	const getCache = (cacheKeys, callback) => {
		const filteredKeys = cacheKeys.map((item) => item instanceof HTMLElement || Number.isNaN(item) ? "" : item);
		if (!isEqual_default(cacheRef.current[0], filteredKeys)) cacheRef.current = [filteredKeys, callback()];
		return cacheRef.current[1];
	};
	return getCache;
}

//#endregion
//#region node_modules/antd/es/watermark/utils.js
/** converting camel-cased strings to be lowercase and link it with Separator */
function toLowercaseSeparator(key) {
	return key.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function getStyleStr(style$1) {
	return Object.keys(style$1).map((key) => `${toLowercaseSeparator(key)}: ${style$1[key]};`).join(" ");
}
/** Returns the ratio of the device's physical pixel resolution to the css pixel resolution */
function getPixelRatio() {
	return window.devicePixelRatio || 1;
}
/** Whether to re-render the watermark */
const reRendering = (mutation, isWatermarkEle) => {
	let flag = false;
	if (mutation.removedNodes.length) flag = Array.from(mutation.removedNodes).some((node$1) => isWatermarkEle(node$1));
	if (mutation.type === "attributes" && isWatermarkEle(mutation.target)) flag = true;
	return flag;
};

//#endregion
//#region node_modules/antd/es/watermark/useWatermark.js
var emphasizedStyle = { visibility: "visible !important" };
function useWatermark(markStyle) {
	const watermarkMap = import_react.useRef(/* @__PURE__ */ new Map());
	const appendWatermark = (base64Url, markWidth, container) => {
		if (container) {
			if (!watermarkMap.current.get(container)) {
				const newWatermarkEle = document.createElement("div");
				watermarkMap.current.set(container, newWatermarkEle);
			}
			const watermarkEle = watermarkMap.current.get(container);
			watermarkEle.setAttribute("style", getStyleStr(Object.assign(Object.assign(Object.assign({}, markStyle), {
				backgroundImage: `url('${base64Url}')`,
				backgroundSize: `${Math.floor(markWidth)}px`
			}), emphasizedStyle)));
			watermarkEle.removeAttribute("class");
			watermarkEle.removeAttribute("hidden");
			if (watermarkEle.parentElement !== container) container.append(watermarkEle);
		}
		return watermarkMap.current.get(container);
	};
	const removeWatermark = (container) => {
		const watermarkEle = watermarkMap.current.get(container);
		if (watermarkEle && container) container.removeChild(watermarkEle);
		watermarkMap.current.delete(container);
	};
	const isWatermarkEle = (ele) => Array.from(watermarkMap.current.values()).includes(ele);
	return [
		appendWatermark,
		removeWatermark,
		isWatermarkEle
	];
}

//#endregion
//#region node_modules/antd/es/watermark/index.js
var import_classnames$3 = /* @__PURE__ */ __toESM(require_classnames());
/**
* Only return `next` when size changed.
* This is only used for elements compare, not a shallow equal!
*/
function getSizeDiff(prev$1, next$1) {
	return prev$1.size === next$1.size ? prev$1 : next$1;
}
var DEFAULT_GAP_X = 100;
var DEFAULT_GAP_Y = 100;
var fixedStyle = {
	position: "relative",
	overflow: "hidden"
};
var Watermark = (props) => {
	var _a, _b;
	const { zIndex = 9, rotate = -22, width, height, image, content, font = {}, style: style$1, className, rootClassName, gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y], offset: offset$2, children, inherit = true } = props;
	const mergedStyle = Object.assign(Object.assign({}, fixedStyle), style$1);
	const [, token$1] = useToken();
	const { color = token$1.colorFill, fontSize = token$1.fontSizeLG, fontWeight = "normal", fontStyle = "normal", fontFamily = "sans-serif", textAlign = "center" } = font;
	const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;
	const gapXCenter = gapX / 2;
	const gapYCenter = gapY / 2;
	const offsetLeft = (_a = offset$2 === null || offset$2 === void 0 ? void 0 : offset$2[0]) !== null && _a !== void 0 ? _a : gapXCenter;
	const offsetTop = (_b = offset$2 === null || offset$2 === void 0 ? void 0 : offset$2[1]) !== null && _b !== void 0 ? _b : gapYCenter;
	const markStyle = import_react.useMemo(() => {
		const mergedMarkStyle = {
			zIndex,
			position: "absolute",
			left: 0,
			top: 0,
			width: "100%",
			height: "100%",
			pointerEvents: "none",
			backgroundRepeat: "repeat"
		};
		/** Calculate the style of the offset */
		let positionLeft = offsetLeft - gapXCenter;
		let positionTop = offsetTop - gapYCenter;
		if (positionLeft > 0) {
			mergedMarkStyle.left = `${positionLeft}px`;
			mergedMarkStyle.width = `calc(100% - ${positionLeft}px)`;
			positionLeft = 0;
		}
		if (positionTop > 0) {
			mergedMarkStyle.top = `${positionTop}px`;
			mergedMarkStyle.height = `calc(100% - ${positionTop}px)`;
			positionTop = 0;
		}
		mergedMarkStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;
		return mergedMarkStyle;
	}, [
		zIndex,
		offsetLeft,
		gapXCenter,
		offsetTop,
		gapYCenter
	]);
	const [container, setContainer] = import_react.useState();
	const [subElements, setSubElements] = import_react.useState(() => /* @__PURE__ */ new Set());
	const targetElements = import_react.useMemo(() => {
		const list = container ? [container] : [];
		return [].concat(list, _toConsumableArray(Array.from(subElements)));
	}, [container, subElements]);
	/**
	* Get the width and height of the watermark. The default values are as follows
	* Image: [120, 64]; Content: It's calculated by content;
	*/
	const getMarkSize = (ctx) => {
		let defaultWidth = 120;
		let defaultHeight = 64;
		if (!image && ctx.measureText) {
			ctx.font = `${Number(fontSize)}px ${fontFamily}`;
			const contents = toList_default(content);
			const sizes$1 = contents.map((item) => {
				const metrics = ctx.measureText(item);
				return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];
			});
			defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes$1.map((size) => size[0]))));
			defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes$1.map((size) => size[1])))) * contents.length + (contents.length - 1) * FontGap;
		}
		return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];
	};
	const getClips = useClips_default();
	const getClipsCache = useSingletonCache();
	const [watermarkInfo, setWatermarkInfo] = import_react.useState(null);
	const renderWatermark = () => {
		const ctx = document.createElement("canvas").getContext("2d");
		if (ctx) {
			const ratio = getPixelRatio();
			const [markWidth, markHeight] = getMarkSize(ctx);
			const drawCanvas = (drawContent) => {
				const params = [
					drawContent || "",
					rotate,
					ratio,
					markWidth,
					markHeight,
					{
						color,
						fontSize,
						fontStyle,
						fontWeight,
						fontFamily,
						textAlign
					},
					gapX,
					gapY
				];
				const [nextClips, clipWidth] = getClipsCache(params, () => getClips.apply(void 0, params));
				setWatermarkInfo([nextClips, clipWidth]);
			};
			if (image) {
				const img = new Image();
				img.onload = () => {
					drawCanvas(img);
				};
				img.onerror = () => {
					drawCanvas(content);
				};
				img.crossOrigin = "anonymous";
				img.referrerPolicy = "no-referrer";
				img.src = image;
			} else drawCanvas(content);
		}
	};
	const syncWatermark = useRafDebounce(renderWatermark);
	const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle);
	(0, import_react.useEffect)(() => {
		if (watermarkInfo) targetElements.forEach((holder) => {
			appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);
		});
	}, [watermarkInfo, targetElements]);
	const onMutate = useEvent((mutations) => {
		mutations.forEach((mutation) => {
			if (reRendering(mutation, isWatermarkEle)) syncWatermark();
			else if (mutation.target === container && mutation.attributeName === "style") {
				const keyStyles = Object.keys(fixedStyle);
				for (let i = 0; i < keyStyles.length; i += 1) {
					const key = keyStyles[i];
					const oriValue = mergedStyle[key];
					const currentValue = container.style[key];
					if (oriValue && oriValue !== currentValue) container.style[key] = oriValue;
				}
			}
		});
	});
	useMutateObserver(targetElements, onMutate);
	(0, import_react.useEffect)(syncWatermark, [
		rotate,
		zIndex,
		width,
		height,
		image,
		content,
		color,
		fontSize,
		fontWeight,
		fontStyle,
		fontFamily,
		textAlign,
		gapX,
		gapY,
		offsetLeft,
		offsetTop
	]);
	const watermarkContext = import_react.useMemo(() => ({
		add: (ele) => {
			setSubElements((prev$1) => {
				const clone = new Set(prev$1);
				clone.add(ele);
				return getSizeDiff(prev$1, clone);
			});
		},
		remove: (ele) => {
			removeWatermark(ele);
			setSubElements((prev$1) => {
				const clone = new Set(prev$1);
				clone.delete(ele);
				return getSizeDiff(prev$1, clone);
			});
		}
	}), []);
	const childNode = inherit ? /* @__PURE__ */ import_react.createElement(context_default.Provider, { value: watermarkContext }, children) : children;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref: setContainer,
		className: (0, import_classnames$3.default)(className, rootClassName),
		style: mergedStyle
	}, childNode);
};
Watermark.displayName = "Watermark";
var watermark_default = Watermark;

//#endregion
//#region node_modules/antd/es/splitter/Panel.js
var import_classnames$2 = /* @__PURE__ */ __toESM(require_classnames());
const InternalPanel = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	const { prefixCls, className, children, size, style: style$1 = {} } = props;
	const panelClassName = (0, import_classnames$2.default)(`${prefixCls}-panel`, { [`${prefixCls}-panel-hidden`]: size === 0 }, className);
	const hasSize = size !== void 0;
	return /* @__PURE__ */ import_react.createElement("div", {
		ref,
		className: panelClassName,
		style: Object.assign(Object.assign({}, style$1), {
			flexBasis: hasSize ? size : "auto",
			flexGrow: hasSize ? 0 : 1
		})
	}, children);
});
InternalPanel.displayName = "Panel";
var Panel = () => null;
var Panel_default = Panel;

//#endregion
//#region node_modules/antd/es/splitter/hooks/useItems.js
var __rest = void 0 && (void 0).__rest || function(s, e$2) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$2.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
};
function getCollapsible(collapsible) {
	if (collapsible && typeof collapsible === "object") return Object.assign(Object.assign({}, collapsible), { showCollapsibleIcon: collapsible.showCollapsibleIcon === void 0 ? "auto" : collapsible.showCollapsibleIcon });
	const mergedCollapsible = !!collapsible;
	return {
		start: mergedCollapsible,
		end: mergedCollapsible,
		showCollapsibleIcon: "auto"
	};
}
/**
* Convert `children` into `items`.
*/
function useItems(children) {
	return import_react.useMemo(() => toArray(children).filter((item) => /* @__PURE__ */ import_react.isValidElement(item)).map((node$1) => {
		const { props } = node$1;
		const { collapsible } = props, restProps = __rest(props, ["collapsible"]);
		return Object.assign(Object.assign({}, restProps), { collapsible: getCollapsible(collapsible) });
	}), [children]);
}
var useItems_default = useItems;

//#endregion
//#region node_modules/antd/es/splitter/hooks/useResizable.js
function getShowCollapsibleIcon(prev$1, next$1) {
	if (prev$1.collapsible && next$1.collapsible) {
		if (prev$1.showCollapsibleIcon === true || next$1.showCollapsibleIcon === true) return true;
		if (prev$1.showCollapsibleIcon === "auto" || next$1.showCollapsibleIcon === "auto") return "auto";
		return false;
	}
	if (prev$1.collapsible) return prev$1.showCollapsibleIcon;
	if (next$1.collapsible) return next$1.showCollapsibleIcon;
	return false;
}
function useResizable(items, pxSizes, isRTL) {
	return import_react.useMemo(() => {
		const resizeInfos = [];
		for (let i = 0; i < items.length - 1; i += 1) {
			const prevItem = items[i];
			const nextItem = items[i + 1];
			const prevSize = pxSizes[i];
			const nextSize = pxSizes[i + 1];
			const { resizable: prevResizable = true, min: prevMin, collapsible: prevCollapsible } = prevItem;
			const { resizable: nextResizable = true, min: nextMin, collapsible: nextCollapsible } = nextItem;
			const mergedResizable = prevResizable && nextResizable && (prevSize !== 0 || !prevMin) && (nextSize !== 0 || !nextMin);
			const prevEndCollapsible = !!prevCollapsible.end && prevSize > 0;
			const nextStartExpandable = !!nextCollapsible.start && nextSize === 0 && prevSize > 0;
			const startCollapsible = prevEndCollapsible || nextStartExpandable;
			const nextStartCollapsible = !!nextCollapsible.start && nextSize > 0;
			const prevEndExpandable = !!prevCollapsible.end && prevSize === 0 && nextSize > 0;
			const endCollapsible = nextStartCollapsible || prevEndExpandable;
			const showStartCollapsibleIcon = getShowCollapsibleIcon({
				collapsible: prevEndCollapsible,
				showCollapsibleIcon: prevCollapsible.showCollapsibleIcon
			}, {
				collapsible: nextStartExpandable,
				showCollapsibleIcon: nextCollapsible.showCollapsibleIcon
			});
			const showEndCollapsibleIcon = getShowCollapsibleIcon({
				collapsible: nextStartCollapsible,
				showCollapsibleIcon: nextCollapsible.showCollapsibleIcon
			}, {
				collapsible: prevEndExpandable,
				showCollapsibleIcon: prevCollapsible.showCollapsibleIcon
			});
			resizeInfos[i] = {
				resizable: mergedResizable,
				startCollapsible: !!(isRTL ? endCollapsible : startCollapsible),
				endCollapsible: !!(isRTL ? startCollapsible : endCollapsible),
				showStartCollapsibleIcon: isRTL ? showEndCollapsibleIcon : showStartCollapsibleIcon,
				showEndCollapsibleIcon: isRTL ? showStartCollapsibleIcon : showEndCollapsibleIcon
			};
		}
		return resizeInfos;
	}, [pxSizes, items]);
}

//#endregion
//#region node_modules/antd/es/splitter/hooks/sizeUtil.js
function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {
	let currentTotalPtg = 0;
	const undefinedIndexes = [];
	ptgSizes.forEach((size, index$2) => {
		if (size === void 0) undefinedIndexes.push(index$2);
		else currentTotalPtg += size;
	});
	const restPtg = 1 - currentTotalPtg;
	const undefinedCount = undefinedIndexes.length;
	if (restPtg < 0) {
		const scale = 1 / currentTotalPtg;
		return ptgSizes.map((size) => size === void 0 ? 0 : size * scale);
	}
	let sumMin = 0;
	let sumMax = 0;
	let limitMin = 0;
	let limitMax = 1;
	for (const index$2 of undefinedIndexes) {
		const min = minPtgSizes[index$2] || 0;
		const max = maxPtgSizes[index$2] || 1;
		sumMin += min;
		sumMax += max;
		limitMin = Math.max(limitMin, min);
		limitMax = Math.min(limitMax, max);
	}
	if (sumMin > 1 && sumMax < 1) {
		const avg = 1 / undefinedCount;
		return ptgSizes.map((size) => size === void 0 ? avg : size);
	}
	const restAvg = restPtg / undefinedCount;
	if (limitMin <= restAvg && restAvg <= limitMax) return ptgSizes.map((size) => size === void 0 ? restAvg : size);
	const result = _toConsumableArray(ptgSizes);
	let remain = restPtg - sumMin;
	for (let i = 0; i < undefinedCount; i += 1) {
		const index$2 = undefinedIndexes[i];
		const min = minPtgSizes[index$2] || 0;
		const max = maxPtgSizes[index$2] || 1;
		result[index$2] = min;
		const canAdd = max - min;
		const add = Math.min(canAdd, remain);
		result[index$2] += add;
		remain -= add;
	}
	return result;
}

//#endregion
//#region node_modules/antd/es/splitter/hooks/useSizes.js
function getPtg(str) {
	return Number(str.slice(0, -1)) / 100;
}
function isPtg(itemSize) {
	return typeof itemSize === "string" && itemSize.endsWith("%");
}
/**
* Save the size state.
* Align the size into flex percentage base.
*/
function useSizes(items, containerSize) {
	const propSizes = items.map((item) => item.size);
	const itemsCount = items.length;
	const mergedContainerSize = containerSize || 0;
	const ptg2px = (ptg) => ptg * mergedContainerSize;
	const [innerSizes, setInnerSizes] = import_react.useState(() => items.map((item) => item.defaultSize));
	const sizes$1 = import_react.useMemo(() => {
		var _a;
		const mergedSizes = [];
		for (let i = 0; i < itemsCount; i += 1) mergedSizes[i] = (_a = propSizes[i]) !== null && _a !== void 0 ? _a : innerSizes[i];
		return mergedSizes;
	}, [
		itemsCount,
		innerSizes,
		propSizes
	]);
	const postPercentMinSizes = import_react.useMemo(() => items.map((item) => {
		if (isPtg(item.min)) return getPtg(item.min);
		return (item.min || 0) / mergedContainerSize;
	}), [items, mergedContainerSize]);
	const postPercentMaxSizes = import_react.useMemo(() => items.map((item) => {
		if (isPtg(item.max)) return getPtg(item.max);
		return (item.max || mergedContainerSize) / mergedContainerSize;
	}), [items, mergedContainerSize]);
	const postPercentSizes = import_react.useMemo(() => {
		const ptgList = [];
		for (let i = 0; i < itemsCount; i += 1) {
			const itemSize = sizes$1[i];
			if (isPtg(itemSize)) ptgList[i] = getPtg(itemSize);
			else if (itemSize || itemSize === 0) {
				const num = Number(itemSize);
				if (!Number.isNaN(num)) ptgList[i] = num / mergedContainerSize;
			} else ptgList[i] = void 0;
		}
		return autoPtgSizes(ptgList, postPercentMinSizes, postPercentMaxSizes);
	}, [
		sizes$1,
		mergedContainerSize,
		postPercentMinSizes,
		postPercentMaxSizes
	]);
	const postPxSizes = import_react.useMemo(() => postPercentSizes.map(ptg2px), [postPercentSizes, mergedContainerSize]);
	return [
		import_react.useMemo(() => containerSize ? postPxSizes : sizes$1, [postPxSizes, containerSize]),
		postPxSizes,
		postPercentSizes,
		postPercentMinSizes,
		postPercentMaxSizes,
		setInnerSizes
	];
}

//#endregion
//#region node_modules/antd/es/splitter/hooks/useResize.js
/**
* Handle user drag resize logic.
*/
function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes, isRTL) {
	const limitSizes = items.map((item) => [item.min, item.max]);
	const mergedContainerSize = containerSize || 0;
	const ptg2px = (ptg) => ptg * mergedContainerSize;
	function getLimitSize(str, defaultLimit) {
		if (typeof str === "string") return ptg2px(getPtg(str));
		return str !== null && str !== void 0 ? str : defaultLimit;
	}
	const [cacheSizes, setCacheSizes] = import_react.useState([]);
	const cacheCollapsedSize = import_react.useRef([]);
	/**
	* When start drag, check the direct is `start` or `end`.
	* This will handle when 2 splitter bar are in the same position.
	*/
	const [movingIndex, setMovingIndex] = import_react.useState(null);
	const getPxSizes = () => percentSizes.map(ptg2px);
	const onOffsetStart = (index$2) => {
		setCacheSizes(getPxSizes());
		setMovingIndex({
			index: index$2,
			confirmed: false
		});
	};
	const onOffsetUpdate = (index$2, offset$2) => {
		var _a;
		let confirmedIndex = null;
		if ((!movingIndex || !movingIndex.confirmed) && offset$2 !== 0) {
			if (offset$2 > 0) {
				confirmedIndex = index$2;
				setMovingIndex({
					index: index$2,
					confirmed: true
				});
			} else for (let i = index$2; i >= 0; i -= 1) if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {
				confirmedIndex = i;
				setMovingIndex({
					index: i,
					confirmed: true
				});
				break;
			}
		}
		const mergedIndex = (_a = confirmedIndex !== null && confirmedIndex !== void 0 ? confirmedIndex : movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index) !== null && _a !== void 0 ? _a : index$2;
		const numSizes = _toConsumableArray(cacheSizes);
		const nextIndex = mergedIndex + 1;
		const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);
		const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);
		const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);
		const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);
		let mergedOffset = offset$2;
		if (numSizes[mergedIndex] + mergedOffset < startMinSize) mergedOffset = startMinSize - numSizes[mergedIndex];
		if (numSizes[nextIndex] - mergedOffset < endMinSize) mergedOffset = numSizes[nextIndex] - endMinSize;
		if (numSizes[mergedIndex] + mergedOffset > startMaxSize) mergedOffset = startMaxSize - numSizes[mergedIndex];
		if (numSizes[nextIndex] - mergedOffset > endMaxSize) mergedOffset = numSizes[nextIndex] - endMaxSize;
		numSizes[mergedIndex] += mergedOffset;
		numSizes[nextIndex] -= mergedOffset;
		updateSizes(numSizes);
		return numSizes;
	};
	const onOffsetEnd = () => {
		setMovingIndex(null);
	};
	const onCollapse = (index$2, type$2) => {
		const currentSizes = getPxSizes();
		const adjustedType = isRTL ? type$2 === "start" ? "end" : "start" : type$2;
		const currentIndex = adjustedType === "start" ? index$2 : index$2 + 1;
		const targetIndex = adjustedType === "start" ? index$2 + 1 : index$2;
		const currentSize = currentSizes[currentIndex];
		const targetSize = currentSizes[targetIndex];
		if (currentSize !== 0 && targetSize !== 0) {
			currentSizes[currentIndex] = 0;
			currentSizes[targetIndex] += currentSize;
			cacheCollapsedSize.current[index$2] = currentSize;
		} else {
			const totalSize = currentSize + targetSize;
			const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);
			const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);
			const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);
			const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);
			const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);
			const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);
			const halfOffset = targetSizeMin || (limitEnd - limitStart) / 2;
			const targetCacheCollapsedSize = cacheCollapsedSize.current[index$2];
			const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;
			if (targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin) {
				currentSizes[targetIndex] = targetCacheCollapsedSize;
				currentSizes[currentIndex] = currentCacheCollapsedSize;
			} else {
				currentSizes[currentIndex] -= halfOffset;
				currentSizes[targetIndex] += halfOffset;
			}
		}
		updateSizes(currentSizes);
		return currentSizes;
	};
	return [
		onOffsetStart,
		onOffsetUpdate,
		onOffsetEnd,
		onCollapse,
		movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index
	];
}

//#endregion
//#region node_modules/antd/es/splitter/SplitBar.js
var import_classnames$1 = /* @__PURE__ */ __toESM(require_classnames());
function getValidNumber(num) {
	return typeof num === "number" && !Number.isNaN(num) && Number.isFinite(num) ? Math.round(num) : 0;
}
var SplitBar = (props) => {
	const { prefixCls, vertical, index: index$2, active, ariaNow, ariaMin, ariaMax, resizable, startCollapsible, endCollapsible, onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, lazy, containerSize, showStartCollapsibleIcon, showEndCollapsibleIcon } = props;
	const splitBarPrefixCls = `${prefixCls}-bar`;
	const [startPos, setStartPos] = (0, import_react.useState)(null);
	const [constrainedOffset, setConstrainedOffset] = (0, import_react.useState)(0);
	const constrainedOffsetX = vertical ? 0 : constrainedOffset;
	const constrainedOffsetY = vertical ? constrainedOffset : 0;
	const onMouseDown = (e$2) => {
		if (resizable && e$2.currentTarget) {
			setStartPos([e$2.pageX, e$2.pageY]);
			onOffsetStart(index$2);
		}
	};
	const onTouchStart = (e$2) => {
		if (resizable && e$2.touches.length === 1) {
			const touch = e$2.touches[0];
			setStartPos([touch.pageX, touch.pageY]);
			onOffsetStart(index$2);
		}
	};
	const getConstrainedOffset = (rawOffset) => {
		const currentPos = containerSize * ariaNow / 100;
		const newPos = currentPos + rawOffset;
		const minAllowed = Math.max(0, containerSize * ariaMin / 100);
		const maxAllowed = Math.min(containerSize, containerSize * ariaMax / 100);
		return Math.max(minAllowed, Math.min(maxAllowed, newPos)) - currentPos;
	};
	const handleLazyMove = useEvent((offsetX, offsetY) => {
		const constrainedOffsetValue = getConstrainedOffset(vertical ? offsetY : offsetX);
		setConstrainedOffset(constrainedOffsetValue);
	});
	const handleLazyEnd = useEvent(() => {
		onOffsetUpdate(index$2, constrainedOffsetX, constrainedOffsetY, true);
		setConstrainedOffset(0);
		onOffsetEnd(true);
	});
	const getVisibilityClass = (mode) => {
		switch (mode) {
			case true: return `${splitBarPrefixCls}-collapse-bar-always-visible`;
			case false: return `${splitBarPrefixCls}-collapse-bar-always-hidden`;
			case "auto": return `${splitBarPrefixCls}-collapse-bar-hover-only`;
		}
	};
	useLayoutEffect_default(() => {
		if (!startPos) return;
		const onMouseMove = (e$2) => {
			const { pageX, pageY } = e$2;
			const offsetX = pageX - startPos[0];
			const offsetY = pageY - startPos[1];
			if (lazy) handleLazyMove(offsetX, offsetY);
			else onOffsetUpdate(index$2, offsetX, offsetY);
		};
		const onMouseUp = () => {
			if (lazy) handleLazyEnd();
			else onOffsetEnd();
			setStartPos(null);
		};
		const handleTouchMove = (e$2) => {
			if (e$2.touches.length === 1) {
				const touch = e$2.touches[0];
				const offsetX = touch.pageX - startPos[0];
				const offsetY = touch.pageY - startPos[1];
				if (lazy) handleLazyMove(offsetX, offsetY);
				else onOffsetUpdate(index$2, offsetX, offsetY);
			}
		};
		const handleTouchEnd = () => {
			if (lazy) handleLazyEnd();
			else onOffsetEnd();
			setStartPos(null);
		};
		const eventHandlerMap = {
			mousemove: onMouseMove,
			mouseup: onMouseUp,
			touchmove: handleTouchMove,
			touchend: handleTouchEnd
		};
		for (const [event, handler] of Object.entries(eventHandlerMap)) window.addEventListener(event, handler);
		return () => {
			for (const [event, handler] of Object.entries(eventHandlerMap)) window.removeEventListener(event, handler);
		};
	}, [
		startPos,
		index$2,
		lazy
	]);
	const transformStyle = { [`--${splitBarPrefixCls}-preview-offset`]: `${constrainedOffset}px` };
	const StartIcon = vertical ? UpOutlined_default : LeftOutlined_default;
	const EndIcon = vertical ? DownOutlined_default : RightOutlined_default;
	return /* @__PURE__ */ import_react.createElement("div", {
		className: splitBarPrefixCls,
		role: "separator",
		"aria-valuenow": getValidNumber(ariaNow),
		"aria-valuemin": getValidNumber(ariaMin),
		"aria-valuemax": getValidNumber(ariaMax)
	}, lazy && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$1.default)(`${splitBarPrefixCls}-preview`, { [`${splitBarPrefixCls}-preview-active`]: !!constrainedOffset }),
		style: transformStyle
	}), /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$1.default)(`${splitBarPrefixCls}-dragger`, {
			[`${splitBarPrefixCls}-dragger-disabled`]: !resizable,
			[`${splitBarPrefixCls}-dragger-active`]: active
		}),
		onMouseDown,
		onTouchStart
	}), startCollapsible && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$1.default)(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-start`, getVisibilityClass(showStartCollapsibleIcon)),
		onClick: () => onCollapse(index$2, "start")
	}, /* @__PURE__ */ import_react.createElement(StartIcon, { className: (0, import_classnames$1.default)(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-start`) })), endCollapsible && /* @__PURE__ */ import_react.createElement("div", {
		className: (0, import_classnames$1.default)(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-end`, getVisibilityClass(showEndCollapsibleIcon)),
		onClick: () => onCollapse(index$2, "end")
	}, /* @__PURE__ */ import_react.createElement(EndIcon, { className: (0, import_classnames$1.default)(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-end`) })));
};
var SplitBar_default = SplitBar;

//#endregion
//#region node_modules/antd/es/splitter/style/index.js
var genRtlStyle = (token$1) => {
	const { componentCls } = token$1;
	return {
		[`&-rtl${componentCls}-horizontal`]: { [`> ${componentCls}-bar`]: {
			[`${componentCls}-bar-collapse-previous`]: {
				insetInlineEnd: 0,
				insetInlineStart: "unset"
			},
			[`${componentCls}-bar-collapse-next`]: {
				insetInlineEnd: "unset",
				insetInlineStart: 0
			}
		} },
		[`&-rtl${componentCls}-vertical`]: { [`> ${componentCls}-bar`]: {
			[`${componentCls}-bar-collapse-previous`]: {
				insetInlineEnd: "50%",
				insetInlineStart: "unset"
			},
			[`${componentCls}-bar-collapse-next`]: {
				insetInlineEnd: "50%",
				insetInlineStart: "unset"
			}
		} }
	};
};
var centerStyle = {
	position: "absolute",
	top: "50%",
	left: {
		_skip_check_: true,
		value: "50%"
	},
	transform: "translate(-50%, -50%)"
};
var genSplitterStyle = (token$1) => {
	const { componentCls, colorFill, splitBarDraggableSize, splitBarSize, splitTriggerSize, controlItemBgHover, controlItemBgActive, controlItemBgActiveHover, prefixCls } = token$1;
	const splitBarCls = `${componentCls}-bar`;
	const splitMaskCls = `${componentCls}-mask`;
	const splitPanelCls = `${componentCls}-panel`;
	const halfTriggerSize = token$1.calc(splitTriggerSize).div(2).equal();
	const splitterBarPreviewOffsetVar = `${prefixCls}-bar-preview-offset`;
	const splitterBarPreviewStyle = {
		position: "absolute",
		background: token$1.colorPrimary,
		opacity: .2,
		pointerEvents: "none",
		transition: "none",
		zIndex: 1,
		display: "none"
	};
	return { [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token$1)), {
		display: "flex",
		width: "100%",
		height: "100%",
		alignItems: "stretch",
		[`> ${splitBarCls}`]: {
			flex: "none",
			position: "relative",
			userSelect: "none",
			[`${splitBarCls}-dragger`]: Object.assign(Object.assign({}, centerStyle), {
				zIndex: 1,
				"&::before": Object.assign({
					content: "\"\"",
					background: controlItemBgHover
				}, centerStyle),
				"&::after": Object.assign({
					content: "\"\"",
					background: colorFill
				}, centerStyle),
				[`&:hover:not(${splitBarCls}-dragger-active)`]: { "&::before": { background: controlItemBgActive } },
				"&-active": {
					zIndex: 2,
					"&::before": { background: controlItemBgActiveHover }
				},
				[`&-disabled${splitBarCls}-dragger`]: {
					zIndex: 0,
					"&, &:hover, &-active": {
						cursor: "default",
						"&::before": { background: controlItemBgHover }
					},
					"&::after": { display: "none" }
				}
			}),
			[`${splitBarCls}-collapse-bar`]: Object.assign(Object.assign({}, centerStyle), {
				zIndex: token$1.zIndexPopupBase,
				background: controlItemBgHover,
				fontSize: token$1.fontSizeSM,
				borderRadius: token$1.borderRadiusXS,
				color: token$1.colorText,
				cursor: "pointer",
				opacity: 0,
				display: "flex",
				alignItems: "center",
				justifyContent: "center",
				"&:hover": { background: controlItemBgActive },
				"&:active": { background: controlItemBgActiveHover }
			}),
			"&:hover, &:active": { [`${splitBarCls}-collapse-bar-hover-only`]: { opacity: 1 } },
			[`${splitBarCls}-collapse-bar-hover-only`]: { "@media(hover:none)": { opacity: 1 } },
			[`${splitBarCls}-collapse-bar-always-hidden`]: { display: "none" },
			[`${splitBarCls}-collapse-bar-always-visible`]: { opacity: 1 }
		},
		[splitMaskCls]: {
			position: "fixed",
			zIndex: token$1.zIndexPopupBase,
			inset: 0,
			"&-horizontal": { cursor: "col-resize" },
			"&-vertical": { cursor: "row-resize" }
		},
		"&-horizontal": {
			flexDirection: "row",
			[`> ${splitBarCls}`]: {
				width: 0,
				[`${splitBarCls}-preview`]: Object.assign(Object.assign({
					height: "100%",
					width: splitBarSize
				}, splitterBarPreviewStyle), { [`&${splitBarCls}-preview-active`]: {
					display: "block",
					transform: `translateX(var(--${splitterBarPreviewOffsetVar}))`
				} }),
				[`${splitBarCls}-dragger`]: {
					cursor: "col-resize",
					height: "100%",
					width: splitTriggerSize,
					"&::before": {
						height: "100%",
						width: splitBarSize
					},
					"&::after": {
						height: splitBarDraggableSize,
						width: splitBarSize
					}
				},
				[`${splitBarCls}-collapse-bar`]: {
					width: token$1.fontSizeSM,
					height: token$1.controlHeightSM,
					"&-start": {
						left: {
							_skip_check_: true,
							value: "auto"
						},
						right: {
							_skip_check_: true,
							value: halfTriggerSize
						},
						transform: "translateY(-50%)"
					},
					"&-end": {
						left: {
							_skip_check_: true,
							value: halfTriggerSize
						},
						right: {
							_skip_check_: true,
							value: "auto"
						},
						transform: "translateY(-50%)"
					}
				}
			}
		},
		"&-vertical": {
			flexDirection: "column",
			[`> ${splitBarCls}`]: {
				height: 0,
				[`${splitBarCls}-preview`]: Object.assign(Object.assign({
					height: splitBarSize,
					width: "100%"
				}, splitterBarPreviewStyle), { [`&${splitBarCls}-preview-active`]: {
					display: "block",
					transform: `translateY(var(--${splitterBarPreviewOffsetVar}))`
				} }),
				[`${splitBarCls}-dragger`]: {
					cursor: "row-resize",
					width: "100%",
					height: splitTriggerSize,
					"&::before": {
						width: "100%",
						height: splitBarSize
					},
					"&::after": {
						width: splitBarDraggableSize,
						height: splitBarSize
					}
				},
				[`${splitBarCls}-collapse-bar`]: {
					height: token$1.fontSizeSM,
					width: token$1.controlHeightSM,
					"&-start": {
						top: "auto",
						bottom: halfTriggerSize,
						transform: "translateX(-50%)"
					},
					"&-end": {
						top: halfTriggerSize,
						bottom: "auto",
						transform: "translateX(-50%)"
					}
				}
			}
		},
		[splitPanelCls]: {
			overflow: "auto",
			padding: "0 1px",
			scrollbarWidth: "thin",
			boxSizing: "border-box",
			"&-hidden": {
				padding: 0,
				overflow: "hidden"
			},
			[`&:has(${componentCls}:only-child)`]: { overflow: "hidden" }
		}
	}), genRtlStyle(token$1)) };
};
const prepareComponentToken = (token$1) => {
	var _a;
	const splitBarSize = token$1.splitBarSize || 2;
	const splitTriggerSize = token$1.splitTriggerSize || 6;
	const resizeSpinnerSize = token$1.resizeSpinnerSize || 20;
	const splitBarDraggableSize = (_a = token$1.splitBarDraggableSize) !== null && _a !== void 0 ? _a : resizeSpinnerSize;
	return {
		splitBarSize,
		splitTriggerSize,
		splitBarDraggableSize,
		resizeSpinnerSize
	};
};
var style_default = genStyleHooks("Splitter", genSplitterStyle, prepareComponentToken);

//#endregion
//#region node_modules/antd/es/splitter/Splitter.js
var import_classnames = /* @__PURE__ */ __toESM(require_classnames());
var Splitter$1 = (props) => {
	const { prefixCls: customizePrefixCls, className, style: style$1, layout = "horizontal", children, rootClassName, onResizeStart, onResize: onResize$1, onResizeEnd, lazy } = props;
	const { getPrefixCls, direction, className: contextClassName, style: contextStyle } = useComponentConfig("splitter");
	const prefixCls = getPrefixCls("splitter", customizePrefixCls);
	const rootCls = useCSSVarCls_default(prefixCls);
	const [wrapCSSVar, hashId, cssVarCls] = style_default(prefixCls, rootCls);
	const isVertical = layout === "vertical";
	const isRTL = direction === "rtl";
	const reverse = !isVertical && isRTL;
	const items = useItems_default(children);
	{
		const warning$4 = devUseWarning("Splitter");
		const existSize = items.some((item) => item.size !== void 0);
		const existUndefinedSize = items.some((item) => item.size === void 0);
		if (existSize && existUndefinedSize && !onResize$1) warning$4(false, "usage", "When part of `Splitter.Panel` has `size`, `onResize` is required or change `size` to `defaultSize`.");
	}
	const [containerSize, setContainerSize] = (0, import_react.useState)();
	const onContainerResize = (size) => {
		const { offsetWidth, offsetHeight } = size;
		const containerSize$1 = isVertical ? offsetHeight : offsetWidth;
		if (containerSize$1 === 0) return;
		setContainerSize(containerSize$1);
	};
	const [panelSizes, itemPxSizes, itemPtgSizes, itemPtgMinSizes, itemPtgMaxSizes, updateSizes] = useSizes(items, containerSize);
	const resizableInfos = useResizable(items, itemPxSizes, isRTL);
	const [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex] = useResize(items, resizableInfos, itemPtgSizes, containerSize, updateSizes, isRTL);
	const onInternalResizeStart = useEvent((index$2) => {
		onOffsetStart(index$2);
		onResizeStart === null || onResizeStart === void 0 || onResizeStart(itemPxSizes);
	});
	const onInternalResizeUpdate = useEvent((index$2, offset$2, lazyEnd) => {
		const nextSizes = onOffsetUpdate(index$2, offset$2);
		if (lazyEnd) onResizeEnd === null || onResizeEnd === void 0 || onResizeEnd(nextSizes);
		else onResize$1 === null || onResize$1 === void 0 || onResize$1(nextSizes);
	});
	const onInternalResizeEnd = useEvent((lazyEnd) => {
		onOffsetEnd();
		if (!lazyEnd) onResizeEnd === null || onResizeEnd === void 0 || onResizeEnd(itemPxSizes);
	});
	const onInternalCollapse = useEvent((index$2, type$2) => {
		const nextSizes = onCollapse(index$2, type$2);
		onResize$1 === null || onResize$1 === void 0 || onResize$1(nextSizes);
		onResizeEnd === null || onResizeEnd === void 0 || onResizeEnd(nextSizes);
	});
	const containerClassName = (0, import_classnames.default)(prefixCls, className, `${prefixCls}-${layout}`, { [`${prefixCls}-rtl`]: isRTL }, rootClassName, contextClassName, cssVarCls, rootCls, hashId);
	const maskCls = `${prefixCls}-mask`;
	const stackSizes = import_react.useMemo(() => {
		const mergedSizes = [];
		let stack = 0;
		for (let i = 0; i < items.length; i += 1) {
			stack += itemPtgSizes[i];
			mergedSizes.push(stack);
		}
		return mergedSizes;
	}, [itemPtgSizes]);
	const mergedStyle = Object.assign(Object.assign({}, contextStyle), style$1);
	return wrapCSSVar(/* @__PURE__ */ import_react.createElement(es_default, { onResize: onContainerResize }, /* @__PURE__ */ import_react.createElement("div", {
		style: mergedStyle,
		className: containerClassName
	}, items.map((item, idx) => {
		const panel = /* @__PURE__ */ import_react.createElement(InternalPanel, Object.assign({}, item, {
			prefixCls,
			size: panelSizes[idx]
		}));
		let splitBar = null;
		const resizableInfo = resizableInfos[idx];
		if (resizableInfo) {
			const ariaMinStart = (stackSizes[idx - 1] || 0) + itemPtgMinSizes[idx];
			const ariaMinEnd = (stackSizes[idx + 1] || 100) - itemPtgMaxSizes[idx + 1];
			const ariaMaxStart = (stackSizes[idx - 1] || 0) + itemPtgMaxSizes[idx];
			const ariaMaxEnd = (stackSizes[idx + 1] || 100) - itemPtgMinSizes[idx + 1];
			splitBar = /* @__PURE__ */ import_react.createElement(SplitBar_default, {
				lazy,
				index: idx,
				active: movingIndex === idx,
				prefixCls,
				vertical: isVertical,
				resizable: resizableInfo.resizable,
				ariaNow: stackSizes[idx] * 100,
				ariaMin: Math.max(ariaMinStart, ariaMinEnd) * 100,
				ariaMax: Math.min(ariaMaxStart, ariaMaxEnd) * 100,
				startCollapsible: resizableInfo.startCollapsible,
				endCollapsible: resizableInfo.endCollapsible,
				showStartCollapsibleIcon: resizableInfo.showStartCollapsibleIcon,
				showEndCollapsibleIcon: resizableInfo.showEndCollapsibleIcon,
				onOffsetStart: onInternalResizeStart,
				onOffsetUpdate: (index$2, offsetX, offsetY, lazyEnd) => {
					let offset$2 = isVertical ? offsetY : offsetX;
					if (reverse) offset$2 = -offset$2;
					onInternalResizeUpdate(index$2, offset$2, lazyEnd);
				},
				onOffsetEnd: onInternalResizeEnd,
				onCollapse: onInternalCollapse,
				containerSize: containerSize || 0
			});
		}
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, { key: `split-panel-${idx}` }, panel, splitBar);
	}), typeof movingIndex === "number" && /* @__PURE__ */ import_react.createElement("div", {
		"aria-hidden": true,
		className: (0, import_classnames.default)(maskCls, `${maskCls}-${layout}`)
	}))));
};
Splitter$1.displayName = "Splitter";
var Splitter_default = Splitter$1;

//#endregion
//#region node_modules/antd/es/splitter/index.js
var Splitter = Splitter_default;
Splitter.Panel = Panel_default;
var splitter_default = Splitter;

//#endregion
export { affix_default as Affix, alert_default as Alert, anchor_default as Anchor, app_default as App, auto_complete_default as AutoComplete, avatar_default as Avatar, back_top_default as BackTop, badge_default as Badge, breadcrumb_default as Breadcrumb, button_default as Button, calendar_default as Calendar, card_default as Card, carousel_default as Carousel, cascader_default as Cascader, checkbox_default as Checkbox, col_default as Col, collapse_default as Collapse, color_picker_default as ColorPicker, config_provider_default as ConfigProvider, date_picker_default as DatePicker, descriptions_default as Descriptions, divider_default as Divider, drawer_default as Drawer, dropdown_default as Dropdown, empty_default as Empty, flex_default as Flex, float_button_default as FloatButton, form_default as Form, grid_default as Grid, image_default as Image, input_default as Input, input_number_default as InputNumber, layout_default as Layout, list_default as List, mentions_default as Mentions, menu_default as Menu, modal_default as Modal, pagination_default as Pagination, popconfirm_default as Popconfirm, popover_default as Popover, progress_default as Progress, qr_code_default as QRCode, radio_default as Radio, rate_default as Rate, result_default as Result, row_default as Row, segmented_default as Segmented, select_default as Select, skeleton_default as Skeleton, slider_default as Slider, space_default as Space, spin_default as Spin, splitter_default as Splitter, statistic_default as Statistic, steps_default as Steps, switch_default as Switch, table_default as Table, tabs_default as Tabs, tag_default as Tag, time_picker_default as TimePicker, timeline_default as Timeline, tooltip_default as Tooltip, tour_default as Tour, transfer_default as Transfer, tree_default as Tree, tree_select_default as TreeSelect, typography_default as Typography, upload_default as Upload, watermark_default as Watermark, message_default as message, notification_default as notification, theme_default as theme, unstableSetRender, version_default as version };
//# sourceMappingURL=antd.js.map